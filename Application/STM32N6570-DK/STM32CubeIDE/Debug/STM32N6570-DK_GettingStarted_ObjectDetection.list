
STM32N6570-DK_GettingStarted_ObjectDetection.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34000400  34000400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001ca2c  34000750  34000750  00000750  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .gnu.sgstubs  00000020  3401d180  3401d180  0001d180  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00093d28  3401d1a0  3401d1a0  0001d1a0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .version      0000000c  340b0ec8  340b0ec8  000b0ec8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.extab    00000000  340b0ed4  340b0ed4  000b12cc  2**0
                  CONTENTS
  6 .ARM          00000008  340b0ed4  340b0ed4  000b0ed4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .preinit_array 00000000  340b0edc  340b12cc  000b12cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .init_array   00000004  340b0edc  340b0edc  000b0edc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .fini_array   00000004  340b0ee0  340b0ee0  000b0ee0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .data         000003e8  340b0ee4  340b0ee4  000b0ee4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .bss          0001dd6c  340b12d0  340b12d0  000b12cc  2**3
                  ALLOC
 12 .TxDecripSection 00000004  340cf03c  340cf03c  000b12cc  2**0
                  ALLOC
 13 .RxDecripSection 00000000  340cf040  340cf040  000b12cc  2**0
                  CONTENTS
 14 .RxArraySection 00000000  340cf040  340cf040  000b12cc  2**0
                  CONTENTS
 15 .TxArraySection 00000000  340cf040  340cf040  000b12cc  2**0
                  CONTENTS
 16 ._user_heap_stack 00004200  340cf040  340cf040  000b12cc  2**0
                  ALLOC
 17 .psram_section 00232800  91000000  91000000  000b2000  2**5
                  ALLOC
 18 .ARM.attributes 0000003a  00000000  00000000  000b12cc  2**0
                  CONTENTS, READONLY
 19 .debug_info   0008d0cc  00000000  00000000  000b1306  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_abbrev 0000c241  00000000  00000000  0013e3d2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_loclists 0003516e  00000000  00000000  0014a613  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_aranges 00003670  00000000  00000000  0017f788  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_rnglists 00004da3  00000000  00000000  00182df8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 24 .debug_macro  00096310  00000000  00000000  00187b9b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line   00066d9b  00000000  00000000  0021deab  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 26 .debug_str    003b6c0a  00000000  00000000  00284c46  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 27 .comment      00000043  00000000  00000000  0063b850  2**0
                  CONTENTS, READONLY
 28 .debug_frame  0000be18  00000000  00000000  0063b894  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 29 .debug_line_str 0000018b  00000000  00000000  006476ac  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

34000750 <__do_global_dtors_aux>:
34000750:	b510      	push	{r4, lr}
34000752:	4c05      	ldr	r4, [pc, #20]	@ (34000768 <__do_global_dtors_aux+0x18>)
34000754:	7823      	ldrb	r3, [r4, #0]
34000756:	b933      	cbnz	r3, 34000766 <__do_global_dtors_aux+0x16>
34000758:	4b04      	ldr	r3, [pc, #16]	@ (3400076c <__do_global_dtors_aux+0x1c>)
3400075a:	b113      	cbz	r3, 34000762 <__do_global_dtors_aux+0x12>
3400075c:	4804      	ldr	r0, [pc, #16]	@ (34000770 <__do_global_dtors_aux+0x20>)
3400075e:	f3af 8000 	nop.w
34000762:	2301      	movs	r3, #1
34000764:	7023      	strb	r3, [r4, #0]
34000766:	bd10      	pop	{r4, pc}
34000768:	340b12d0 	.word	0x340b12d0
3400076c:	00000000 	.word	0x00000000
34000770:	3401d164 	.word	0x3401d164

34000774 <frame_dummy>:
34000774:	b508      	push	{r3, lr}
34000776:	4b03      	ldr	r3, [pc, #12]	@ (34000784 <frame_dummy+0x10>)
34000778:	b11b      	cbz	r3, 34000782 <frame_dummy+0xe>
3400077a:	4903      	ldr	r1, [pc, #12]	@ (34000788 <frame_dummy+0x14>)
3400077c:	4803      	ldr	r0, [pc, #12]	@ (3400078c <frame_dummy+0x18>)
3400077e:	f3af 8000 	nop.w
34000782:	bd08      	pop	{r3, pc}
34000784:	00000000 	.word	0x00000000
34000788:	340b12d4 	.word	0x340b12d4
3400078c:	3401d164 	.word	0x3401d164

34000790 <vVjsiRnEsi>:
34000790:	ed90 6aad 	vldr	s12, [r0, #692]	@ 0x2b4
34000794:	b530      	push	{r4, r5, lr}
34000796:	ed2d 8b10 	vpush	{d8-d15}
3400079a:	ed90 7ba8 	vldr	d7, [r0, #672]	@ 0x2a0
3400079e:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
340007a2:	b087      	sub	sp, #28
340007a4:	ed8d 7b00 	vstr	d7, [sp]
340007a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340007ac:	ed90 7ba4 	vldr	d7, [r0, #656]	@ 0x290
340007b0:	4604      	mov	r4, r0
340007b2:	ed91 5a01 	vldr	s10, [r1, #4]
340007b6:	ed91 4a00 	vldr	s8, [r1]
340007ba:	ed91 fb02 	vldr	d15, [r1, #8]
340007be:	ed91 8b04 	vldr	d8, [r1, #16]
340007c2:	ed90 3b12 	vldr	d3, [r0, #72]	@ 0x48
340007c6:	ed90 dbaa 	vldr	d13, [r0, #680]	@ 0x2a8
340007ca:	ed90 bb16 	vldr	d11, [r0, #88]	@ 0x58
340007ce:	ed8d 7b04 	vstr	d7, [sp, #16]
340007d2:	ed90 eba6 	vldr	d14, [r0, #664]	@ 0x298
340007d6:	dc09      	bgt.n	340007ec <vVjsiRnEsi+0x5c>
340007d8:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
340007dc:	48d4      	ldr	r0, [pc, #848]	@ (34000b30 <vVjsiRnEsi+0x3a0>)
340007de:	4798      	blx	r3
340007e0:	f04f 30ff 	mov.w	r0, #4294967295
340007e4:	b007      	add	sp, #28
340007e6:	ecbd 8b10 	vpop	{d8-d15}
340007ea:	bd30      	pop	{r4, r5, pc}
340007ec:	eeb8 5b45 	vcvt.f64.u32	d5, s10
340007f0:	ed9f 7bc1 	vldr	d7, [pc, #772]	@ 34000af8 <vVjsiRnEsi+0x368>
340007f4:	eeb8 4b44 	vcvt.f64.u32	d4, s8
340007f8:	ee25 7b07 	vmul.f64	d7, d5, d7
340007fc:	eeb4 7bc4 	vcmpe.f64	d7, d4
34000800:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000804:	dd0f      	ble.n	34000826 <vVjsiRnEsi+0x96>
34000806:	ed90 7b1c 	vldr	d7, [r0, #112]	@ 0x70
3400080a:	ed9f 2bbd 	vldr	d2, [pc, #756]	@ 34000b00 <vVjsiRnEsi+0x370>
3400080e:	ee37 2b02 	vadd.f64	d2, d7, d2
34000812:	ed9f 7bbd 	vldr	d7, [pc, #756]	@ 34000b08 <vVjsiRnEsi+0x378>
34000816:	eeb4 2bc7 	vcmpe.f64	d2, d7
3400081a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400081e:	fe37 7b02 	vselgt.f64	d7, d7, d2
34000822:	ed80 7b1c 	vstr	d7, [r0, #112]	@ 0x70
34000826:	ed9f 7bba 	vldr	d7, [pc, #744]	@ 34000b10 <vVjsiRnEsi+0x380>
3400082a:	ee25 5b07 	vmul.f64	d5, d5, d7
3400082e:	eeb4 5bc4 	vcmpe.f64	d5, d4
34000832:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000836:	d510      	bpl.n	3400085a <vVjsiRnEsi+0xca>
34000838:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
3400083c:	ed9f 5bb0 	vldr	d5, [pc, #704]	@ 34000b00 <vVjsiRnEsi+0x370>
34000840:	ee37 7b45 	vsub.f64	d7, d7, d5
34000844:	ed9f 5bb4 	vldr	d5, [pc, #720]	@ 34000b18 <vVjsiRnEsi+0x388>
34000848:	eeb4 7bc5 	vcmpe.f64	d7, d5
3400084c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000850:	bf58      	it	pl
34000852:	eeb0 5b47 	vmovpl.f64	d5, d7
34000856:	ed84 5b1c 	vstr	d5, [r4, #112]	@ 0x70
3400085a:	ee83 9b0d 	vdiv.f64	d9, d3, d13
3400085e:	eebc 9bc9 	vcvt.u32.f64	s18, d9
34000862:	eeb8 9b49 	vcvt.f64.u32	d9, s18
34000866:	ee29 9b0d 	vmul.f64	d9, d9, d13
3400086a:	eefc 7bc9 	vcvt.u32.f64	s15, d9
3400086e:	f894 5050 	ldrb.w	r5, [r4, #80]	@ 0x50
34000872:	edcd 7a03 	vstr	s15, [sp, #12]
34000876:	2d01      	cmp	r5, #1
34000878:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
3400087c:	d152      	bne.n	34000924 <vVjsiRnEsi+0x194>
3400087e:	ed9f 7ba8 	vldr	d7, [pc, #672]	@ 34000b20 <vVjsiRnEsi+0x390>
34000882:	ee3f 5b48 	vsub.f64	d5, d15, d8
34000886:	ee85 cb07 	vdiv.f64	d12, d5, d7
3400088a:	ee3f 5b08 	vadd.f64	d5, d15, d8
3400088e:	ee85 ab07 	vdiv.f64	d10, d5, d7
34000892:	eeb0 7bcc 	vabs.f64	d7, d12
34000896:	eeb4 6bc7 	vcmpe.f64	d6, d7
3400089a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400089e:	eeb0 5bca 	vabs.f64	d5, d10
340008a2:	db0d      	blt.n	340008c0 <vVjsiRnEsi+0x130>
340008a4:	eeb4 6bc5 	vcmpe.f64	d6, d5
340008a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008ac:	db08      	blt.n	340008c0 <vVjsiRnEsi+0x130>
340008ae:	2300      	movs	r3, #0
340008b0:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
340008b4:	2300      	movs	r3, #0
340008b6:	eeb0 8b49 	vmov.f64	d8, d9
340008ba:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
340008be:	e049      	b.n	34000954 <vVjsiRnEsi+0x1c4>
340008c0:	eeb4 6bc5 	vcmpe.f64	d6, d5
340008c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008c8:	d50c      	bpl.n	340008e4 <vVjsiRnEsi+0x154>
340008ca:	ee8a 5b0c 	vdiv.f64	d5, d10, d12
340008ce:	ed94 6aae 	vldr	s12, [r4, #696]	@ 0x2b8
340008d2:	eeb0 5bc5 	vabs.f64	d5, d5
340008d6:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
340008da:	eeb4 5bc6 	vcmpe.f64	d5, d6
340008de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008e2:	dae7      	bge.n	340008b4 <vVjsiRnEsi+0x124>
340008e4:	2300      	movs	r3, #0
340008e6:	eef7 0bcb 	vcvt.f32.f64	s1, d11
340008ea:	eeb7 0bc7 	vcvt.f32.f64	s0, d7
340008ee:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
340008f2:	f01c f911 	bl	3401cb18 <powf>
340008f6:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
340008fa:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
340008fe:	eeb0 6bc8 	vabs.f64	d6, d8
34000902:	ee20 0b07 	vmul.f64	d0, d0, d7
34000906:	eeb0 7bcf 	vabs.f64	d7, d15
3400090a:	eeb4 7bc6 	vcmpe.f64	d7, d6
3400090e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000912:	dd6f      	ble.n	340009f4 <vVjsiRnEsi+0x264>
34000914:	eeb5 fbc0 	vcmpe.f64	d15, #0.0
34000918:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400091c:	d56f      	bpl.n	340009fe <vVjsiRnEsi+0x26e>
3400091e:	ee39 0b40 	vsub.f64	d0, d9, d0
34000922:	e06e      	b.n	34000a02 <vVjsiRnEsi+0x272>
34000924:	eeb0 5bcf 	vabs.f64	d5, d15
34000928:	eeb0 7bc8 	vabs.f64	d7, d8
3400092c:	eeb4 7bc5 	vcmpe.f64	d7, d5
34000930:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000934:	fe37 7b05 	vselgt.f64	d7, d7, d5
34000938:	eeb4 7bc6 	vcmpe.f64	d7, d6
3400093c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000940:	d853      	bhi.n	340009ea <vVjsiRnEsi+0x25a>
34000942:	ed9f ab79 	vldr	d10, [pc, #484]	@ 34000b28 <vVjsiRnEsi+0x398>
34000946:	2300      	movs	r3, #0
34000948:	eeb0 8b49 	vmov.f64	d8, d9
3400094c:	eeb0 cb4a 	vmov.f64	d12, d10
34000950:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34000954:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34000958:	bb2b      	cbnz	r3, 340009a6 <vVjsiRnEsi+0x216>
3400095a:	2210      	movs	r2, #16
3400095c:	f104 0188 	add.w	r1, r4, #136	@ 0x88
34000960:	f104 0080 	add.w	r0, r4, #128	@ 0x80
34000964:	f019 fbc4 	bl	3401a0f0 <memmove>
34000968:	2210      	movs	r2, #16
3400096a:	f104 01a0 	add.w	r1, r4, #160	@ 0xa0
3400096e:	f104 0098 	add.w	r0, r4, #152	@ 0x98
34000972:	f019 fbbd 	bl	3401a0f0 <memmove>
34000976:	e9d4 2330 	ldrd	r2, r3, [r4, #192]	@ 0xc0
3400097a:	ed84 9b24 	vstr	d9, [r4, #144]	@ 0x90
3400097e:	e9c4 232c 	strd	r2, r3, [r4, #176]	@ 0xb0
34000982:	e9d4 2332 	ldrd	r2, r3, [r4, #200]	@ 0xc8
34000986:	ed84 8b2a 	vstr	d8, [r4, #168]	@ 0xa8
3400098a:	e9c4 232e 	strd	r2, r3, [r4, #184]	@ 0xb8
3400098e:	e9d4 2334 	ldrd	r2, r3, [r4, #208]	@ 0xd0
34000992:	ed84 cb34 	vstr	d12, [r4, #208]	@ 0xd0
34000996:	e9c4 2330 	strd	r2, r3, [r4, #192]	@ 0xc0
3400099a:	e9d4 2336 	ldrd	r2, r3, [r4, #216]	@ 0xd8
3400099e:	ed84 ab36 	vstr	d10, [r4, #216]	@ 0xd8
340009a2:	e9c4 2332 	strd	r2, r3, [r4, #200]	@ 0xc8
340009a6:	eefc 7bc8 	vcvt.u32.f64	s15, d8
340009aa:	ee17 3a90 	vmov	r3, s15
340009ae:	ed94 7b1a 	vldr	d7, [r4, #104]	@ 0x68
340009b2:	9a03      	ldr	r2, [sp, #12]
340009b4:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
340009b8:	4293      	cmp	r3, r2
340009ba:	bf1c      	itt	ne
340009bc:	2301      	movne	r3, #1
340009be:	f884 3060 	strbne.w	r3, [r4, #96]	@ 0x60
340009c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340009c6:	f340 80b5 	ble.w	34000b34 <vVjsiRnEsi+0x3a4>
340009ca:	2301      	movs	r3, #1
340009cc:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
340009d0:	ed9d 7b00 	vldr	d7, [sp]
340009d4:	eeb4 bbc7 	vcmpe.f64	d11, d7
340009d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340009dc:	f140 80bd 	bpl.w	34000b5a <vVjsiRnEsi+0x3ca>
340009e0:	ed9d 7b04 	vldr	d7, [sp, #16]
340009e4:	ee3b eb07 	vadd.f64	d14, d11, d7
340009e8:	e0a9      	b.n	34000b3e <vVjsiRnEsi+0x3ae>
340009ea:	ed9f ab4f 	vldr	d10, [pc, #316]	@ 34000b28 <vVjsiRnEsi+0x398>
340009ee:	eeb0 cb4a 	vmov.f64	d12, d10
340009f2:	e777      	b.n	340008e4 <vVjsiRnEsi+0x154>
340009f4:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
340009f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340009fc:	d58f      	bpl.n	3400091e <vVjsiRnEsi+0x18e>
340009fe:	ee39 0b00 	vadd.f64	d0, d9, d0
34000a02:	ed94 7b3c 	vldr	d7, [r4, #240]	@ 0xf0
34000a06:	eeb4 7bc0 	vcmpe.f64	d7, d0
34000a0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a0e:	d42c      	bmi.n	34000a6a <vVjsiRnEsi+0x2da>
34000a10:	eeb0 7b40 	vmov.f64	d7, d0
34000a14:	ed94 6b3a 	vldr	d6, [r4, #232]	@ 0xe8
34000a18:	eeb4 6bc7 	vcmpe.f64	d6, d7
34000a1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a20:	dc26      	bgt.n	34000a70 <vVjsiRnEsi+0x2e0>
34000a22:	eeb0 6b47 	vmov.f64	d6, d7
34000a26:	ee86 8b0d 	vdiv.f64	d8, d6, d13
34000a2a:	eebc 8bc8 	vcvt.u32.f64	s16, d8
34000a2e:	eeb8 8b48 	vcvt.f64.u32	d8, s16
34000a32:	2d01      	cmp	r5, #1
34000a34:	ee2d 8b08 	vmul.f64	d8, d13, d8
34000a38:	d18c      	bne.n	34000954 <vVjsiRnEsi+0x1c4>
34000a3a:	f8b4 30e0 	ldrh.w	r3, [r4, #224]	@ 0xe0
34000a3e:	2b02      	cmp	r3, #2
34000a40:	d819      	bhi.n	34000a76 <vVjsiRnEsi+0x2e6>
34000a42:	eefc 7bc9 	vcvt.u32.f64	s15, d9
34000a46:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34000a4a:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
34000a4e:	ed82 7b20 	vstr	d7, [r2, #128]	@ 0x80
34000a52:	ed82 8b26 	vstr	d8, [r2, #152]	@ 0x98
34000a56:	eb04 1203 	add.w	r2, r4, r3, lsl #4
34000a5a:	3301      	adds	r3, #1
34000a5c:	ed82 cb2c 	vstr	d12, [r2, #176]	@ 0xb0
34000a60:	ed82 ab2e 	vstr	d10, [r2, #184]	@ 0xb8
34000a64:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34000a68:	e774      	b.n	34000954 <vVjsiRnEsi+0x1c4>
34000a6a:	eeb0 bb4e 	vmov.f64	d11, d14
34000a6e:	e7d1      	b.n	34000a14 <vVjsiRnEsi+0x284>
34000a70:	eeb0 bb4e 	vmov.f64	d11, d14
34000a74:	e7d7      	b.n	34000a26 <vVjsiRnEsi+0x296>
34000a76:	ed94 7b2a 	vldr	d7, [r4, #168]	@ 0xa8
34000a7a:	ed94 6aaf 	vldr	s12, [r4, #700]	@ 0x2bc
34000a7e:	ee38 7b47 	vsub.f64	d7, d8, d7
34000a82:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34000a86:	eeb0 7bc7 	vabs.f64	d7, d7
34000a8a:	eeb4 7bc6 	vcmpe.f64	d7, d6
34000a8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a92:	db28      	blt.n	34000ae6 <vVjsiRnEsi+0x356>
34000a94:	ed94 7b28 	vldr	d7, [r4, #160]	@ 0xa0
34000a98:	ee38 7b47 	vsub.f64	d7, d8, d7
34000a9c:	eeb0 7bc7 	vabs.f64	d7, d7
34000aa0:	eeb4 6bc7 	vcmpe.f64	d6, d7
34000aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000aa8:	dd1d      	ble.n	34000ae6 <vVjsiRnEsi+0x356>
34000aaa:	ed94 0b32 	vldr	d0, [r4, #200]	@ 0xc8
34000aae:	ed94 7b30 	vldr	d7, [r4, #192]	@ 0xc0
34000ab2:	ee3a 0b40 	vsub.f64	d0, d10, d0
34000ab6:	ee3c 7b47 	vsub.f64	d7, d12, d7
34000aba:	ee20 0b00 	vmul.f64	d0, d0, d0
34000abe:	eea7 0b07 	vfma.f64	d0, d7, d7
34000ac2:	f01b fc11 	bl	3401c2e8 <sqrt>
34000ac6:	ed94 7ab0 	vldr	s14, [r4, #704]	@ 0x2c0
34000aca:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000ace:	eeb4 0bc7 	vcmpe.f64	d0, d7
34000ad2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000ad6:	d506      	bpl.n	34000ae6 <vVjsiRnEsi+0x356>
34000ad8:	eefc 7bc9 	vcvt.u32.f64	s15, d9
34000adc:	f884 5078 	strb.w	r5, [r4, #120]	@ 0x78
34000ae0:	eeb8 8b67 	vcvt.f64.u32	d8, s15
34000ae4:	e736      	b.n	34000954 <vVjsiRnEsi+0x1c4>
34000ae6:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34000aea:	2b01      	cmp	r3, #1
34000aec:	f47f af32 	bne.w	34000954 <vVjsiRnEsi+0x1c4>
34000af0:	2300      	movs	r3, #0
34000af2:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34000af6:	e72d      	b.n	34000954 <vVjsiRnEsi+0x1c4>
34000af8:	9999999a 	.word	0x9999999a
34000afc:	3fa99999 	.word	0x3fa99999
34000b00:	47ae147b 	.word	0x47ae147b
34000b04:	3f847ae1 	.word	0x3f847ae1
34000b08:	33333334 	.word	0x33333334
34000b0c:	3fc33333 	.word	0x3fc33333
34000b10:	33333333 	.word	0x33333333
34000b14:	3fc33333 	.word	0x3fc33333
34000b18:	11111111 	.word	0x11111111
34000b1c:	3fb11111 	.word	0x3fb11111
34000b20:	667f3bcd 	.word	0x667f3bcd
34000b24:	3ff6a09e 	.word	0x3ff6a09e
	...
34000b30:	34021f45 	.word	0x34021f45
34000b34:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
34000b38:	2b00      	cmp	r3, #0
34000b3a:	f47f af49 	bne.w	340009d0 <vVjsiRnEsi+0x240>
34000b3e:	ee88 7b0d 	vdiv.f64	d7, d8, d13
34000b42:	eebc 7bc7 	vcvt.u32.f64	s14, d7
34000b46:	eeb8 7b47 	vcvt.f64.u32	d7, s14
34000b4a:	ee27 7b0d 	vmul.f64	d7, d7, d13
34000b4e:	ed84 eb16 	vstr	d14, [r4, #88]	@ 0x58
34000b52:	ed84 7b12 	vstr	d7, [r4, #72]	@ 0x48
34000b56:	2001      	movs	r0, #1
34000b58:	e644      	b.n	340007e4 <vVjsiRnEsi+0x54>
34000b5a:	ed9d eb00 	vldr	d14, [sp]
34000b5e:	e7ee      	b.n	34000b3e <vVjsiRnEsi+0x3ae>

34000b60 <RGqhTVOsSg>:
34000b60:	ed90 6b1a 	vldr	d6, [r0, #104]	@ 0x68
34000b64:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34000b68:	ed90 4b12 	vldr	d4, [r0, #72]	@ 0x48
34000b6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b70:	ed90 5baa 	vldr	d5, [r0, #680]	@ 0x2a8
34000b74:	eeb0 7b46 	vmov.f64	d7, d6
34000b78:	bfdf      	itttt	le
34000b7a:	ee84 7b05 	vdivle.f64	d7, d4, d5
34000b7e:	eebc 7bc7 	vcvtle.u32.f64	s14, d7
34000b82:	eeb8 7b47 	vcvtle.f64.u32	d7, s14
34000b86:	ee27 7b05 	vmulle.f64	d7, d7, d5
34000b8a:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
34000b8e:	ed90 5b3c 	vldr	d5, [r0, #240]	@ 0xf0
34000b92:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34000b96:	eeb4 4bc5 	vcmpe.f64	d4, d5
34000b9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b9e:	bfc8      	it	gt
34000ba0:	eeb7 7bc5 	vcvtgt.f32.f64	s14, d5
34000ba4:	ed90 5b3a 	vldr	d5, [r0, #232]	@ 0xe8
34000ba8:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34000bac:	eeb4 4bc5 	vcmpe.f64	d4, d5
34000bb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000bb4:	bf48      	it	mi
34000bb6:	eeb7 7bc5 	vcvtmi.f32.f64	s14, d5
34000bba:	eeb7 5ac7 	vcvt.f64.f32	d5, s14
34000bbe:	f8d0 3274 	ldr.w	r3, [r0, #628]	@ 0x274
34000bc2:	b530      	push	{r4, r5, lr}
34000bc4:	ed80 5b12 	vstr	d5, [r0, #72]	@ 0x48
34000bc8:	ed93 5a00 	vldr	s10, [r3]
34000bcc:	edd0 7aac 	vldr	s15, [r0, #688]	@ 0x2b0
34000bd0:	eeb4 5ac7 	vcmpe.f32	s10, s14
34000bd4:	eef1 5a67 	vneg.f32	s11, s15
34000bd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000bdc:	f04f 0100 	mov.w	r1, #0
34000be0:	f8b0 30f8 	ldrh.w	r3, [r0, #248]	@ 0xf8
34000be4:	fe75 7aa7 	vselgt.f32	s15, s11, s15
34000be8:	3b01      	subs	r3, #1
34000bea:	b28a      	uxth	r2, r1
34000bec:	4293      	cmp	r3, r2
34000bee:	d805      	bhi.n	34000bfc <RGqhTVOsSg+0x9c>
34000bf0:	2244      	movs	r2, #68	@ 0x44
34000bf2:	fb02 0303 	mla	r3, r2, r3, r0
34000bf6:	f503 7390 	add.w	r3, r3, #288	@ 0x120
34000bfa:	e011      	b.n	34000c20 <RGqhTVOsSg+0xc0>
34000bfc:	eb00 0482 	add.w	r4, r0, r2, lsl #2
34000c00:	edd4 5a44 	vldr	s11, [r4, #272]	@ 0x110
34000c04:	ee77 5aa5 	vadd.f32	s11, s15, s11
34000c08:	eef4 5ac7 	vcmpe.f32	s11, s14
34000c0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c10:	f101 0101 	add.w	r1, r1, #1
34000c14:	dbe9      	blt.n	34000bea <RGqhTVOsSg+0x8a>
34000c16:	2344      	movs	r3, #68	@ 0x44
34000c18:	fb03 0202 	mla	r2, r3, r2, r0
34000c1c:	f502 7390 	add.w	r3, r2, #288	@ 0x120
34000c20:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34000c24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c28:	f8c0 3274 	str.w	r3, [r0, #628]	@ 0x274
34000c2c:	dc05      	bgt.n	34000c3a <RGqhTVOsSg+0xda>
34000c2e:	ed93 7a00 	vldr	s14, [r3]
34000c32:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000c36:	ed80 7b12 	vstr	d7, [r0, #72]	@ 0x48
34000c3a:	685a      	ldr	r2, [r3, #4]
34000c3c:	f103 0138 	add.w	r1, r3, #56	@ 0x38
34000c40:	6042      	str	r2, [r0, #4]
34000c42:	689a      	ldr	r2, [r3, #8]
34000c44:	f103 0424 	add.w	r4, r3, #36	@ 0x24
34000c48:	6082      	str	r2, [r0, #8]
34000c4a:	68da      	ldr	r2, [r3, #12]
34000c4c:	60c2      	str	r2, [r0, #12]
34000c4e:	691a      	ldr	r2, [r3, #16]
34000c50:	6102      	str	r2, [r0, #16]
34000c52:	f100 0238 	add.w	r2, r0, #56	@ 0x38
34000c56:	695d      	ldr	r5, [r3, #20]
34000c58:	330c      	adds	r3, #12
34000c5a:	6145      	str	r5, [r0, #20]
34000c5c:	68dd      	ldr	r5, [r3, #12]
34000c5e:	300c      	adds	r0, #12
34000c60:	60c5      	str	r5, [r0, #12]
34000c62:	691d      	ldr	r5, [r3, #16]
34000c64:	42a3      	cmp	r3, r4
34000c66:	6105      	str	r5, [r0, #16]
34000c68:	f851 5b04 	ldr.w	r5, [r1], #4
34000c6c:	f842 5b04 	str.w	r5, [r2], #4
34000c70:	d1f1      	bne.n	34000c56 <RGqhTVOsSg+0xf6>
34000c72:	2001      	movs	r0, #1
34000c74:	bd30      	pop	{r4, r5, pc}

34000c76 <evision_api_awb_new>:
34000c76:	b510      	push	{r4, lr}
34000c78:	b090      	sub	sp, #64	@ 0x40
34000c7a:	b178      	cbz	r0, 34000c9c <evision_api_awb_new+0x26>
34000c7c:	2200      	movs	r2, #0
34000c7e:	4c08      	ldr	r4, [pc, #32]	@ (34000ca0 <evision_api_awb_new+0x2a>)
34000c80:	2140      	movs	r1, #64	@ 0x40
34000c82:	4b08      	ldr	r3, [pc, #32]	@ (34000ca4 <evision_api_awb_new+0x2e>)
34000c84:	7022      	strb	r2, [r4, #0]
34000c86:	f8c4 02c8 	str.w	r0, [r4, #712]	@ 0x2c8
34000c8a:	4a07      	ldr	r2, [pc, #28]	@ (34000ca8 <evision_api_awb_new+0x32>)
34000c8c:	4668      	mov	r0, sp
34000c8e:	f019 f8e5 	bl	34019e5c <sniprintf>
34000c92:	4668      	mov	r0, sp
34000c94:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000c98:	4798      	blx	r3
34000c9a:	4620      	mov	r0, r4
34000c9c:	b010      	add	sp, #64	@ 0x40
34000c9e:	bd10      	pop	{r4, pc}
34000ca0:	340b12f0 	.word	0x340b12f0
34000ca4:	340b0ec8 	.word	0x340b0ec8
34000ca8:	34021f85 	.word	0x34021f85

34000cac <evision_api_awb_delete>:
34000cac:	2800      	cmp	r0, #0
34000cae:	bf0c      	ite	eq
34000cb0:	f04f 30ff 	moveq.w	r0, #4294967295
34000cb4:	2001      	movne	r0, #1
34000cb6:	4770      	bx	lr

34000cb8 <evision_api_awb_set_profile>:
34000cb8:	b530      	push	{r4, r5, lr}
34000cba:	ed80 0a00 	vstr	s0, [r0]
34000cbe:	680c      	ldr	r4, [r1, #0]
34000cc0:	6044      	str	r4, [r0, #4]
34000cc2:	684c      	ldr	r4, [r1, #4]
34000cc4:	6084      	str	r4, [r0, #8]
34000cc6:	688c      	ldr	r4, [r1, #8]
34000cc8:	60c4      	str	r4, [r0, #12]
34000cca:	68c9      	ldr	r1, [r1, #12]
34000ccc:	f102 0424 	add.w	r4, r2, #36	@ 0x24
34000cd0:	6101      	str	r1, [r0, #16]
34000cd2:	f100 0138 	add.w	r1, r0, #56	@ 0x38
34000cd6:	6815      	ldr	r5, [r2, #0]
34000cd8:	320c      	adds	r2, #12
34000cda:	6145      	str	r5, [r0, #20]
34000cdc:	f852 5c08 	ldr.w	r5, [r2, #-8]
34000ce0:	300c      	adds	r0, #12
34000ce2:	60c5      	str	r5, [r0, #12]
34000ce4:	f852 5c04 	ldr.w	r5, [r2, #-4]
34000ce8:	42a2      	cmp	r2, r4
34000cea:	6105      	str	r5, [r0, #16]
34000cec:	f853 5b04 	ldr.w	r5, [r3], #4
34000cf0:	f841 5b04 	str.w	r5, [r1], #4
34000cf4:	d1ef      	bne.n	34000cd6 <evision_api_awb_set_profile+0x1e>
34000cf6:	bd30      	pop	{r4, r5, pc}

34000cf8 <evision_api_awb_init_profiles>:
34000cf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34000cfc:	ed2d 8b06 	vpush	{d8-d10}
34000d00:	460d      	mov	r5, r1
34000d02:	eeb0 9b40 	vmov.f64	d9, d0
34000d06:	eeb0 8b41 	vmov.f64	d8, d1
34000d0a:	461e      	mov	r6, r3
34000d0c:	4604      	mov	r4, r0
34000d0e:	b0c9      	sub	sp, #292	@ 0x124
34000d10:	2800      	cmp	r0, #0
34000d12:	f000 8185 	beq.w	34001020 <evision_api_awb_init_profiles+0x328>
34000d16:	ed9f abc6 	vldr	d10, [pc, #792]	@ 34001030 <evision_api_awb_init_profiles+0x338>
34000d1a:	ed80 ab12 	vstr	d10, [r0, #72]	@ 0x48
34000d1e:	2000      	movs	r0, #0
34000d20:	49c9      	ldr	r1, [pc, #804]	@ (34001048 <evision_api_awb_init_profiles+0x350>)
34000d22:	f04f 0800 	mov.w	r8, #0
34000d26:	e9c4 0116 	strd	r0, r1, [r4, #88]	@ 0x58
34000d2a:	e9c4 01a6 	strd	r0, r1, [r4, #664]	@ 0x298
34000d2e:	e9c4 01aa 	strd	r0, r1, [r4, #680]	@ 0x2a8
34000d32:	49c6      	ldr	r1, [pc, #792]	@ (3400104c <evision_api_awb_init_profiles+0x354>)
34000d34:	f8df 9348 	ldr.w	r9, [pc, #840]	@ 34001080 <evision_api_awb_init_profiles+0x388>
34000d38:	f8c4 12b0 	str.w	r1, [r4, #688]	@ 0x2b0
34000d3c:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
34000d40:	f8c4 12b4 	str.w	r1, [r4, #692]	@ 0x2b4
34000d44:	f04f 517c 	mov.w	r1, #1056964608	@ 0x3f000000
34000d48:	e9c4 891a 	strd	r8, r9, [r4, #104]	@ 0x68
34000d4c:	f20f 29e8 	addw	r9, pc, #744	@ 0x2e8
34000d50:	e9d9 8900 	ldrd	r8, r9, [r9]
34000d54:	e9c4 891c 	strd	r8, r9, [r4, #112]	@ 0x70
34000d58:	e9c4 89a4 	strd	r8, r9, [r4, #656]	@ 0x290
34000d5c:	f04f 0800 	mov.w	r8, #0
34000d60:	f8c4 12b8 	str.w	r1, [r4, #696]	@ 0x2b8
34000d64:	49ba      	ldr	r1, [pc, #744]	@ (34001050 <evision_api_awb_init_profiles+0x358>)
34000d66:	f8df 931c 	ldr.w	r9, [pc, #796]	@ 34001084 <evision_api_awb_init_profiles+0x38c>
34000d6a:	f8c4 12bc 	str.w	r1, [r4, #700]	@ 0x2bc
34000d6e:	f04f 517f 	mov.w	r1, #1069547520	@ 0x3fc00000
34000d72:	2300      	movs	r3, #0
34000d74:	e9c4 89a8 	strd	r8, r9, [r4, #672]	@ 0x2a0
34000d78:	2701      	movs	r7, #1
34000d7a:	f04f 0800 	mov.w	r8, #0
34000d7e:	f8c4 12c0 	str.w	r1, [r4, #704]	@ 0x2c0
34000d82:	1e69      	subs	r1, r5, #1
34000d84:	f8df 9300 	ldr.w	r9, [pc, #768]	@ 34001088 <evision_api_awb_init_profiles+0x390>
34000d88:	b288      	uxth	r0, r1
34000d8a:	2804      	cmp	r0, #4
34000d8c:	e9c4 89a0 	strd	r8, r9, [r4, #640]	@ 0x280
34000d90:	f20f 29ac 	addw	r9, pc, #684	@ 0x2ac
34000d94:	e9d9 8900 	ldrd	r8, r9, [r9]
34000d98:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34000d9c:	e9c4 89a2 	strd	r8, r9, [r4, #648]	@ 0x288
34000da0:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34000da4:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34000da8:	f8a4 7278 	strh.w	r7, [r4, #632]	@ 0x278
34000dac:	d914      	bls.n	34000dd8 <evision_api_awb_init_profiles+0xe0>
34000dae:	2305      	movs	r3, #5
34000db0:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000db4:	4aa7      	ldr	r2, [pc, #668]	@ (34001054 <evision_api_awb_init_profiles+0x35c>)
34000db6:	a808      	add	r0, sp, #32
34000db8:	f019 f850 	bl	34019e5c <sniprintf>
34000dbc:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000dc0:	a808      	add	r0, sp, #32
34000dc2:	4798      	blx	r3
34000dc4:	f884 7050 	strb.w	r7, [r4, #80]	@ 0x50
34000dc8:	4620      	mov	r0, r4
34000dca:	b049      	add	sp, #292	@ 0x124
34000dcc:	ecbd 8b06 	vpop	{d8-d10}
34000dd0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34000dd4:	f7ff bec4 	b.w	34000b60 <RGqhTVOsSg>
34000dd8:	ed96 7a00 	vldr	s14, [r6]
34000ddc:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000de0:	eeb4 0bc7 	vcmpe.f64	d0, d7
34000de4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000de8:	dd12      	ble.n	34000e10 <evision_api_awb_init_profiles+0x118>
34000dea:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000dee:	489a      	ldr	r0, [pc, #616]	@ (34001058 <evision_api_awb_init_profiles+0x360>)
34000df0:	4798      	blx	r3
34000df2:	ed96 7a00 	vldr	s14, [r6]
34000df6:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000dfa:	ed8d 9b00 	vstr	d9, [sp]
34000dfe:	ed8d 7b02 	vstr	d7, [sp, #8]
34000e02:	4a96      	ldr	r2, [pc, #600]	@ (3400105c <evision_api_awb_init_profiles+0x364>)
34000e04:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000e08:	a808      	add	r0, sp, #32
34000e0a:	f019 f827 	bl	34019e5c <sniprintf>
34000e0e:	e7d5      	b.n	34000dbc <evision_api_awb_init_profiles+0xc4>
34000e10:	f04f 0844 	mov.w	r8, #68	@ 0x44
34000e14:	fb08 f805 	mul.w	r8, r8, r5
34000e18:	eb06 0908 	add.w	r9, r6, r8
34000e1c:	ed19 7a11 	vldr	s14, [r9, #-68]	@ 0xffffffbc
34000e20:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000e24:	eeb4 1bc7 	vcmpe.f64	d1, d7
34000e28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e2c:	d445      	bmi.n	34000eba <evision_api_awb_init_profiles+0x1c2>
34000e2e:	46b3      	mov	fp, r6
34000e30:	4637      	mov	r7, r6
34000e32:	4699      	mov	r9, r3
34000e34:	4628      	mov	r0, r5
34000e36:	3801      	subs	r0, #1
34000e38:	d14d      	bne.n	34000ed6 <evision_api_awb_init_profiles+0x1de>
34000e3a:	4610      	mov	r0, r2
34000e3c:	4691      	mov	r9, r2
34000e3e:	2700      	movs	r7, #0
34000e40:	f1a5 0e02 	sub.w	lr, r5, #2
34000e44:	f101 0c01 	add.w	ip, r1, #1
34000e48:	f1bc 0c01 	subs.w	ip, ip, #1
34000e4c:	d175      	bne.n	34000f3a <evision_api_awb_init_profiles+0x242>
34000e4e:	ed84 9b3a 	vstr	d9, [r4, #232]	@ 0xe8
34000e52:	ed84 8b3c 	vstr	d8, [r4, #240]	@ 0xf0
34000e56:	f021 4140 	bic.w	r1, r1, #32####MQTT_PASS####5472	@ 0xc0000000
34000e5a:	f8a4 50f8 	strh.w	r5, [r4, #248]	@ 0xf8
34000e5e:	f504 7388 	add.w	r3, r4, #272	@ 0x110
34000e62:	3101      	adds	r1, #1
34000e64:	3901      	subs	r1, #1
34000e66:	f040 80bf 	bne.w	34000fe8 <evision_api_awb_init_profiles+0x2f0>
34000e6a:	2700      	movs	r7, #0
34000e6c:	f104 0afc 	add.w	sl, r4, #252	@ 0xfc
34000e70:	f504 7990 	add.w	r9, r4, #288	@ 0x120
34000e74:	eb06 0b07 	add.w	fp, r6, r7
34000e78:	eb09 0007 	add.w	r0, r9, r7
34000e7c:	2244      	movs	r2, #68	@ 0x44
34000e7e:	4659      	mov	r1, fp
34000e80:	f019 fbe7 	bl	3401a652 <memcpy>
34000e84:	3744      	adds	r7, #68	@ 0x44
34000e86:	f8db 3000 	ldr.w	r3, [fp]
34000e8a:	45b8      	cmp	r8, r7
34000e8c:	f84a 3b04 	str.w	r3, [sl], #4
34000e90:	d1f0      	bne.n	34000e74 <evision_api_awb_init_profiles+0x17c>
34000e92:	1e6b      	subs	r3, r5, #1
34000e94:	b29b      	uxth	r3, r3
34000e96:	2d00      	cmp	r5, #0
34000e98:	f103 0301 	add.w	r3, r3, #1
34000e9c:	bf14      	ite	ne
34000e9e:	461a      	movne	r2, r3
34000ea0:	2201      	moveq	r2, #1
34000ea2:	f8c4 9274 	str.w	r9, [r4, #628]	@ 0x274
34000ea6:	f504 71b2 	add.w	r1, r4, #356	@ 0x164
34000eaa:	3a01      	subs	r2, #1
34000eac:	f040 80a1 	bne.w	34000ff2 <evision_api_awb_init_profiles+0x2fa>
34000eb0:	2301      	movs	r3, #1
34000eb2:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34000eb6:	7023      	strb	r3, [r4, #0]
34000eb8:	e786      	b.n	34000dc8 <evision_api_awb_init_profiles+0xd0>
34000eba:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000ebe:	4868      	ldr	r0, [pc, #416]	@ (34001060 <evision_api_awb_init_profiles+0x368>)
34000ec0:	4798      	blx	r3
34000ec2:	ed99 7a00 	vldr	s14, [r9]
34000ec6:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000eca:	ed8d 8b00 	vstr	d8, [sp]
34000ece:	ed8d 7b02 	vstr	d7, [sp, #8]
34000ed2:	4a64      	ldr	r2, [pc, #400]	@ (34001064 <evision_api_awb_init_profiles+0x36c>)
34000ed4:	e796      	b.n	34000e04 <evision_api_awb_init_profiles+0x10c>
34000ed6:	46ba      	mov	sl, r7
34000ed8:	ed9a 7a00 	vldr	s14, [sl]
34000edc:	edda 7a11 	vldr	s15, [sl, #68]	@ 0x44
34000ee0:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000ee4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000ee8:	f109 0301 	add.w	r3, r9, #1
34000eec:	f107 0744 	add.w	r7, r7, #68	@ 0x44
34000ef0:	db21      	blt.n	34000f36 <evision_api_awb_init_profiles+0x23e>
34000ef2:	f8d4 22c8 	ldr.w	r2, [r4, #712]	@ 0x2c8
34000ef6:	485c      	ldr	r0, [pc, #368]	@ (34001068 <evision_api_awb_init_profiles+0x370>)
34000ef8:	9307      	str	r3, [sp, #28]
34000efa:	4790      	blx	r2
34000efc:	ed97 7a00 	vldr	s14, [r7]
34000f00:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000f04:	ed8d 7b04 	vstr	d7, [sp, #16]
34000f08:	9b07      	ldr	r3, [sp, #28]
34000f0a:	4a58      	ldr	r2, [pc, #352]	@ (3400106c <evision_api_awb_init_profiles+0x374>)
34000f0c:	9302      	str	r3, [sp, #8]
34000f0e:	ed9a 7a00 	vldr	s14, [sl]
34000f12:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000f16:	464b      	mov	r3, r9
34000f18:	ed8d 7b00 	vstr	d7, [sp]
34000f1c:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000f20:	a808      	add	r0, sp, #32
34000f22:	f018 ff9b 	bl	34019e5c <sniprintf>
34000f26:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000f2a:	a808      	add	r0, sp, #32
34000f2c:	4798      	blx	r3
34000f2e:	2301      	movs	r3, #1
34000f30:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34000f34:	e748      	b.n	34000dc8 <evision_api_awb_init_profiles+0xd0>
34000f36:	4699      	mov	r9, r3
34000f38:	e77d      	b.n	34000e36 <evision_api_awb_init_profiles+0x13e>
34000f3a:	45be      	cmp	lr, r7
34000f3c:	46ca      	mov	sl, r9
34000f3e:	f107 0201 	add.w	r2, r7, #1
34000f42:	ecf9 7a01 	vldmia	r9!, {s15}
34000f46:	d91c      	bls.n	34000f82 <evision_api_awb_init_profiles+0x28a>
34000f48:	ed99 7a00 	vldr	s14, [r9]
34000f4c:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000f50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000f54:	d815      	bhi.n	34000f82 <evision_api_awb_init_profiles+0x28a>
34000f56:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000f5a:	4845      	ldr	r0, [pc, #276]	@ (34001070 <evision_api_awb_init_profiles+0x378>)
34000f5c:	9207      	str	r2, [sp, #28]
34000f5e:	4798      	blx	r3
34000f60:	ed99 7a00 	vldr	s14, [r9]
34000f64:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000f68:	ed8d 7b04 	vstr	d7, [sp, #16]
34000f6c:	9a07      	ldr	r2, [sp, #28]
34000f6e:	463b      	mov	r3, r7
34000f70:	9202      	str	r2, [sp, #8]
34000f72:	ed9a 7a00 	vldr	s14, [sl]
34000f76:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000f7a:	4a3e      	ldr	r2, [pc, #248]	@ (34001074 <evision_api_awb_init_profiles+0x37c>)
34000f7c:	ed8d 7b00 	vstr	d7, [sp]
34000f80:	e7cc      	b.n	34000f1c <evision_api_awb_init_profiles+0x224>
34000f82:	465b      	mov	r3, fp
34000f84:	ed93 7a00 	vldr	s14, [r3]
34000f88:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000f8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000f90:	f10b 0b44 	add.w	fp, fp, #68	@ 0x44
34000f94:	da06      	bge.n	34000fa4 <evision_api_awb_init_profiles+0x2ac>
34000f96:	ed93 7a11 	vldr	s14, [r3, #68]	@ 0x44
34000f9a:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000f9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000fa2:	d81f      	bhi.n	34000fe4 <evision_api_awb_init_profiles+0x2ec>
34000fa4:	f8d4 22c8 	ldr.w	r2, [r4, #712]	@ 0x2c8
34000fa8:	4833      	ldr	r0, [pc, #204]	@ (34001078 <evision_api_awb_init_profiles+0x380>)
34000faa:	9307      	str	r3, [sp, #28]
34000fac:	4790      	blx	r2
34000fae:	ed9b 7a00 	vldr	s14, [fp]
34000fb2:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000fb6:	ed8d 7b04 	vstr	d7, [sp, #16]
34000fba:	9b07      	ldr	r3, [sp, #28]
34000fbc:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000fc0:	ed93 7a00 	vldr	s14, [r3]
34000fc4:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000fc8:	ed8d 7b02 	vstr	d7, [sp, #8]
34000fcc:	ed9a 7a00 	vldr	s14, [sl]
34000fd0:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000fd4:	463b      	mov	r3, r7
34000fd6:	ed8d 7b00 	vstr	d7, [sp]
34000fda:	4a28      	ldr	r2, [pc, #160]	@ (3400107c <evision_api_awb_init_profiles+0x384>)
34000fdc:	a808      	add	r0, sp, #32
34000fde:	f018 ff3d 	bl	34019e5c <sniprintf>
34000fe2:	e7a0      	b.n	34000f26 <evision_api_awb_init_profiles+0x22e>
34000fe4:	4617      	mov	r7, r2
34000fe6:	e72f      	b.n	34000e48 <evision_api_awb_init_profiles+0x150>
34000fe8:	f850 2b04 	ldr.w	r2, [r0], #4
34000fec:	f843 2b04 	str.w	r2, [r3], #4
34000ff0:	e738      	b.n	34000e64 <evision_api_awb_init_profiles+0x16c>
34000ff2:	f8d4 3274 	ldr.w	r3, [r4, #628]	@ 0x274
34000ff6:	ed91 6a00 	vldr	s12, [r1]
34000ffa:	ed93 7a00 	vldr	s14, [r3]
34000ffe:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34001002:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001006:	ee36 6b4a 	vsub.f64	d6, d6, d10
3400100a:	ee37 7b4a 	vsub.f64	d7, d7, d10
3400100e:	eeb4 6bc7 	vcmpe.f64	d6, d7
34001012:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001016:	bf48      	it	mi
34001018:	f8c4 1274 	strmi.w	r1, [r4, #628]	@ 0x274
3400101c:	3144      	adds	r1, #68	@ 0x44
3400101e:	e744      	b.n	34000eaa <evision_api_awb_init_profiles+0x1b2>
34001020:	f04f 30ff 	mov.w	r0, #4294967295
34001024:	b049      	add	sp, #292	@ 0x124
34001026:	ecbd 8b06 	vpop	{d8-d10}
3400102a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3400102e:	bf00      	nop
34001030:	00000000 	.word	0x00000000
34001034:	40b38800 	.word	0x40b38800
34001038:	9999999a 	.word	0x9999999a
3400103c:	3fb99999 	.word	0x3fb99999
34001040:	00000000 	.word	0x00000000
34001044:	406ea000 	.word	0x406ea000
34001048:	3ff00000 	.word	0x3ff00000
3400104c:	42480000 	.word	0x42480000
34001050:	432f0000 	.word	0x432f0000
34001054:	34021f95 	.word	0x34021f95
34001058:	34021fd9 	.word	0x34021fd9
3400105c:	34022060 	.word	0x34022060
34001060:	340220be 	.word	0x340220be
34001064:	34022146 	.word	0x34022146
34001068:	340221a3 	.word	0x340221a3
3400106c:	34022207 	.word	0x34022207
34001070:	3402225f 	.word	0x3402225f
34001074:	340222ce 	.word	0x340222ce
34001078:	34022338 	.word	0x34022338
3400107c:	3402238f 	.word	0x3402238f
34001080:	bff00000 	.word	0xbff00000
34001084:	40080000 	.word	0x40080000
34001088:	40240000 	.word	0x40240000

3400108c <evision_api_awb_run_average>:
3400108c:	b530      	push	{r4, r5, lr}
3400108e:	4605      	mov	r5, r0
34001090:	4614      	mov	r4, r2
34001092:	b08d      	sub	sp, #52	@ 0x34
34001094:	b952      	cbnz	r2, 340010ac <evision_api_awb_run_average+0x20>
34001096:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
3400109a:	481d      	ldr	r0, [pc, #116]	@ (34001110 <evision_api_awb_run_average+0x84>)
3400109c:	4798      	blx	r3
3400109e:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
340010a2:	481c      	ldr	r0, [pc, #112]	@ (34001114 <evision_api_awb_run_average+0x88>)
340010a4:	4798      	blx	r3
340010a6:	4620      	mov	r0, r4
340010a8:	b00d      	add	sp, #52	@ 0x34
340010aa:	bd30      	pop	{r4, r5, pc}
340010ac:	ed93 2b04 	vldr	d2, [r3, #16]
340010b0:	ed93 1b02 	vldr	d1, [r3, #8]
340010b4:	ed93 0b00 	vldr	d0, [r3]
340010b8:	aa0a      	add	r2, sp, #40	@ 0x28
340010ba:	a908      	add	r1, sp, #32
340010bc:	a806      	add	r0, sp, #24
340010be:	f000 f82f 	bl	34001120 <VGuzhuiVXN>
340010c2:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
340010c6:	e9cd 2302 	strd	r2, r3, [sp, #8]
340010ca:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	@ 0x28
340010ce:	e9cd 2304 	strd	r2, r3, [sp, #16]
340010d2:	2301      	movs	r3, #1
340010d4:	4298      	cmp	r0, r3
340010d6:	4604      	mov	r4, r0
340010d8:	e9cd 3300 	strd	r3, r3, [sp]
340010dc:	d1df      	bne.n	3400109e <evision_api_awb_run_average+0x12>
340010de:	4669      	mov	r1, sp
340010e0:	4628      	mov	r0, r5
340010e2:	f7ff fb55 	bl	34000790 <vVjsiRnEsi>
340010e6:	2801      	cmp	r0, #1
340010e8:	4604      	mov	r4, r0
340010ea:	d003      	beq.n	340010f4 <evision_api_awb_run_average+0x68>
340010ec:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
340010f0:	4809      	ldr	r0, [pc, #36]	@ (34001118 <evision_api_awb_run_average+0x8c>)
340010f2:	e7d7      	b.n	340010a4 <evision_api_awb_run_average+0x18>
340010f4:	f895 3060 	ldrb.w	r3, [r5, #96]	@ 0x60
340010f8:	2b01      	cmp	r3, #1
340010fa:	d1d4      	bne.n	340010a6 <evision_api_awb_run_average+0x1a>
340010fc:	4628      	mov	r0, r5
340010fe:	f7ff fd2f 	bl	34000b60 <RGqhTVOsSg>
34001102:	2801      	cmp	r0, #1
34001104:	4604      	mov	r4, r0
34001106:	d0ce      	beq.n	340010a6 <evision_api_awb_run_average+0x1a>
34001108:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
3400110c:	4803      	ldr	r0, [pc, #12]	@ (3400111c <evision_api_awb_run_average+0x90>)
3400110e:	e7c9      	b.n	340010a4 <evision_api_awb_run_average+0x18>
34001110:	34022415 	.word	0x34022415
34001114:	34022476 	.word	0x34022476
34001118:	3402249f 	.word	0x3402249f
3400111c:	340224d3 	.word	0x340224d3

34001120 <VGuzhuiVXN>:
34001120:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
34001124:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001128:	b51f      	push	{r0, r1, r2, r3, r4, lr}
3400112a:	eeb0 7b41 	vmov.f64	d7, d1
3400112e:	4613      	mov	r3, r2
34001130:	d409      	bmi.n	34001146 <VGuzhuiVXN+0x26>
34001132:	eeb5 1bc0 	vcmpe.f64	d1, #0.0
34001136:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400113a:	d404      	bmi.n	34001146 <VGuzhuiVXN+0x26>
3400113c:	eeb5 2bc0 	vcmpe.f64	d2, #0.0
34001140:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001144:	d50d      	bpl.n	34001162 <VGuzhuiVXN+0x42>
34001146:	ed8d 2b02 	vstr	d2, [sp, #8]
3400114a:	ed8d 7b00 	vstr	d7, [sp]
3400114e:	ec53 2b10 	vmov	r2, r3, d0
34001152:	4845      	ldr	r0, [pc, #276]	@ (34001268 <VGuzhuiVXN+0x148>)
34001154:	f018 fe12 	bl	34019d7c <iprintf>
34001158:	f04f 30ff 	mov.w	r0, #4294967295
3400115c:	b005      	add	sp, #20
3400115e:	f85d fb04 	ldr.w	pc, [sp], #4
34001162:	ed9f 6b33 	vldr	d6, [pc, #204]	@ 34001230 <VGuzhuiVXN+0x110>
34001166:	eeb4 0bc6 	vcmpe.f64	d0, d6
3400116a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400116e:	dc09      	bgt.n	34001184 <VGuzhuiVXN+0x64>
34001170:	eeb4 1bc6 	vcmpe.f64	d1, d6
34001174:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001178:	dc04      	bgt.n	34001184 <VGuzhuiVXN+0x64>
3400117a:	eeb4 2bc6 	vcmpe.f64	d2, d6
3400117e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001182:	dd07      	ble.n	34001194 <VGuzhuiVXN+0x74>
34001184:	ed8d 2b02 	vstr	d2, [sp, #8]
34001188:	ed8d 7b00 	vstr	d7, [sp]
3400118c:	ec53 2b10 	vmov	r2, r3, d0
34001190:	4836      	ldr	r0, [pc, #216]	@ (3400126c <VGuzhuiVXN+0x14c>)
34001192:	e7df      	b.n	34001154 <VGuzhuiVXN+0x34>
34001194:	b128      	cbz	r0, 340011a2 <VGuzhuiVXN+0x82>
34001196:	b181      	cbz	r1, 340011ba <VGuzhuiVXN+0x9a>
34001198:	b9aa      	cbnz	r2, 340011c6 <VGuzhuiVXN+0xa6>
3400119a:	4935      	ldr	r1, [pc, #212]	@ (34001270 <VGuzhuiVXN+0x150>)
3400119c:	4b35      	ldr	r3, [pc, #212]	@ (34001274 <VGuzhuiVXN+0x154>)
3400119e:	460a      	mov	r2, r1
340011a0:	e007      	b.n	340011b2 <VGuzhuiVXN+0x92>
340011a2:	b969      	cbnz	r1, 340011c0 <VGuzhuiVXN+0xa0>
340011a4:	4933      	ldr	r1, [pc, #204]	@ (34001274 <VGuzhuiVXN+0x154>)
340011a6:	460a      	mov	r2, r1
340011a8:	4832      	ldr	r0, [pc, #200]	@ (34001274 <VGuzhuiVXN+0x154>)
340011aa:	2b00      	cmp	r3, #0
340011ac:	4b30      	ldr	r3, [pc, #192]	@ (34001270 <VGuzhuiVXN+0x150>)
340011ae:	bf08      	it	eq
340011b0:	4603      	moveq	r3, r0
340011b2:	4831      	ldr	r0, [pc, #196]	@ (34001278 <VGuzhuiVXN+0x158>)
340011b4:	f018 fde2 	bl	34019d7c <iprintf>
340011b8:	e7ce      	b.n	34001158 <VGuzhuiVXN+0x38>
340011ba:	492d      	ldr	r1, [pc, #180]	@ (34001270 <VGuzhuiVXN+0x150>)
340011bc:	4a2d      	ldr	r2, [pc, #180]	@ (34001274 <VGuzhuiVXN+0x154>)
340011be:	e7f3      	b.n	340011a8 <VGuzhuiVXN+0x88>
340011c0:	492c      	ldr	r1, [pc, #176]	@ (34001274 <VGuzhuiVXN+0x154>)
340011c2:	4a2b      	ldr	r2, [pc, #172]	@ (34001270 <VGuzhuiVXN+0x150>)
340011c4:	e7f0      	b.n	340011a8 <VGuzhuiVXN+0x88>
340011c6:	ed9f 6b1c 	vldr	d6, [pc, #112]	@ 34001238 <VGuzhuiVXN+0x118>
340011ca:	ed9f 5b1d 	vldr	d5, [pc, #116]	@ 34001240 <VGuzhuiVXN+0x120>
340011ce:	ee21 6b06 	vmul.f64	d6, d1, d6
340011d2:	eeb3 4b00 	vmov.f64	d4, #48	@ 0x41800000  16.0
340011d6:	eea0 6b05 	vfma.f64	d6, d0, d5
340011da:	ed9f 5b1b 	vldr	d5, [pc, #108]	@ 34001248 <VGuzhuiVXN+0x128>
340011de:	eea2 6b04 	vfma.f64	d6, d2, d4
340011e2:	eea6 4b05 	vfma.f64	d4, d6, d5
340011e6:	ed9f 6b1a 	vldr	d6, [pc, #104]	@ 34001250 <VGuzhuiVXN+0x130>
340011ea:	ed80 4b00 	vstr	d4, [r0]
340011ee:	ee26 6b41 	vnmul.f64	d6, d6, d1
340011f2:	eebb 4b0a 	vmov.f64	d4, #186	@ 0xc1d00000 -26.0
340011f6:	ed9f 1b18 	vldr	d1, [pc, #96]	@ 34001258 <VGuzhuiVXN+0x138>
340011fa:	eea0 6b04 	vfma.f64	d6, d0, d4
340011fe:	ee21 1b47 	vnmul.f64	d1, d1, d7
34001202:	ed9f 4b17 	vldr	d4, [pc, #92]	@ 34001260 <VGuzhuiVXN+0x140>
34001206:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
3400120a:	eea0 1b04 	vfma.f64	d1, d0, d4
3400120e:	eea2 6b04 	vfma.f64	d6, d2, d4
34001212:	eea2 1b47 	vfms.f64	d1, d2, d7
34001216:	ee26 6b05 	vmul.f64	d6, d6, d5
3400121a:	ee21 1b05 	vmul.f64	d1, d1, d5
3400121e:	ed81 6b00 	vstr	d6, [r1]
34001222:	2001      	movs	r0, #1
34001224:	ed82 1b00 	vstr	d1, [r2]
34001228:	e798      	b.n	3400115c <VGuzhuiVXN+0x3c>
3400122a:	bf00      	nop
3400122c:	f3af 8000 	nop.w
34001230:	00000000 	.word	0x00000000
34001234:	406fe000 	.word	0x406fe000
34001238:	00000000 	.word	0x00000000
3400123c:	4063a000 	.word	0x4063a000
34001240:	00000000 	.word	0x00000000
34001244:	40478000 	.word	0x40478000
34001248:	00000000 	.word	0x00000000
3400124c:	3f700000 	.word	0x3f700000
34001250:	00000000 	.word	0x00000000
34001254:	40558000 	.word	0x40558000
34001258:	00000000 	.word	0x00000000
3400125c:	40598000 	.word	0x40598000
34001260:	00000000 	.word	0x00000000
34001264:	405c0000 	.word	0x405c0000
34001268:	34022510 	.word	0x34022510
3400126c:	3402254e 	.word	0x3402254e
34001270:	3402250a 	.word	0x3402250a
34001274:	34022508 	.word	0x34022508
34001278:	3402258e 	.word	0x3402258e
3400127c:	00000000 	.word	0x00000000

34001280 <GTePMGhCOh>:
34001280:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34001284:	4606      	mov	r6, r0
34001286:	4698      	mov	r8, r3
34001288:	6d73      	ldr	r3, [r6, #84]	@ 0x54
3400128a:	460f      	mov	r7, r1
3400128c:	4610      	mov	r0, r2
3400128e:	9906      	ldr	r1, [sp, #24]
34001290:	b923      	cbnz	r3, 3400129c <GTePMGhCOh+0x1c>
34001292:	f8c8 7000 	str.w	r7, [r8]
34001296:	6008      	str	r0, [r1, #0]
34001298:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3400129c:	4d20      	ldr	r5, [pc, #128]	@ (34001320 <GTePMGhCOh+0xa0>)
3400129e:	005b      	lsls	r3, r3, #1
340012a0:	fbb5 f5f3 	udiv	r5, r5, r3
340012a4:	4295      	cmp	r5, r2
340012a6:	d2f4      	bcs.n	34001292 <GTePMGhCOh+0x12>
340012a8:	fbb2 f4f5 	udiv	r4, r2, r5
340012ac:	ee07 2a90 	vmov	s15, r2
340012b0:	fb04 5205 	mla	r2, r4, r5, r5
340012b4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
340012b8:	ee07 2a90 	vmov	s15, r2
340012bc:	eddf 6a19 	vldr	s13, [pc, #100]	@ 34001324 <GTePMGhCOh+0xa4>
340012c0:	eef8 7a67 	vcvt.f32.u32	s15, s15
340012c4:	ee67 7aa6 	vmul.f32	s15, s15, s13
340012c8:	eeb4 7ae7 	vcmpe.f32	s14, s15
340012cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340012d0:	d5df      	bpl.n	34001292 <GTePMGhCOh+0x12>
340012d2:	1b52      	subs	r2, r2, r5
340012d4:	600a      	str	r2, [r1, #0]
340012d6:	3201      	adds	r2, #1
340012d8:	ee07 2a90 	vmov	s15, r2
340012dc:	eef8 7a67 	vcvt.f32.u32	s15, s15
340012e0:	ee87 0a27 	vdiv.f32	s0, s14, s15
340012e4:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
340012e8:	f01a ffca 	bl	3401c280 <log10>
340012ec:	ed9f 7b0a 	vldr	d7, [pc, #40]	@ 34001318 <GTePMGhCOh+0x98>
340012f0:	ee20 0b07 	vmul.f64	d0, d0, d7
340012f4:	eebc 0bc0 	vcvt.u32.f64	s0, d0
340012f8:	ee10 3a10 	vmov	r3, s0
340012fc:	443b      	add	r3, r7
340012fe:	461f      	mov	r7, r3
34001300:	f8c8 3000 	str.w	r3, [r8]
34001304:	6cf3      	ldr	r3, [r6, #76]	@ 0x4c
34001306:	42bb      	cmp	r3, r7
34001308:	bf94      	ite	ls
3400130a:	f8c8 3000 	strls.w	r3, [r8]
3400130e:	f8c8 7000 	strhi.w	r7, [r8]
34001312:	e7c1      	b.n	34001298 <GTePMGhCOh+0x18>
34001314:	f3af 8000 	nop.w
34001318:	00000000 	.word	0x00000000
3400131c:	40d38800 	.word	0x40d38800
34001320:	000f4240 	.word	0x000f4240
34001324:	3f733333 	.word	0x3f733333

34001328 <jHlPSTIzmc>:
34001328:	ee07 1a90 	vmov	s15, r1
3400132c:	ed9f 7a28 	vldr	s14, [pc, #160]	@ 340013d0 <jHlPSTIzmc+0xa8>
34001330:	eef8 7a67 	vcvt.f32.u32	s15, s15
34001334:	b570      	push	{r4, r5, r6, lr}
34001336:	ee87 1a87 	vdiv.f32	s2, s15, s14
3400133a:	ed2d 8b02 	vpush	{d8}
3400133e:	ee08 2a10 	vmov	s16, r2
34001342:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
34001346:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3400134a:	4605      	mov	r5, r0
3400134c:	461c      	mov	r4, r3
3400134e:	9e06      	ldr	r6, [sp, #24]
34001350:	f01b f89e 	bl	3401c490 <pow>
34001354:	eeb8 7b48 	vcvt.f64.u32	d7, s16
34001358:	ee27 7b00 	vmul.f64	d7, d7, d0
3400135c:	eefc 7bc7 	vcvt.u32.f64	s15, d7
34001360:	ee17 2a90 	vmov	r2, s15
34001364:	6c69      	ldr	r1, [r5, #68]	@ 0x44
34001366:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3400136a:	4291      	cmp	r1, r2
3400136c:	d916      	bls.n	3400139c <jHlPSTIzmc+0x74>
3400136e:	2300      	movs	r3, #0
34001370:	6023      	str	r3, [r4, #0]
34001372:	edc6 7a00 	vstr	s15, [r6]
34001376:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
34001378:	eddf 6a16 	vldr	s13, [pc, #88]	@ 340013d4 <jHlPSTIzmc+0xac>
3400137c:	ee07 3a90 	vmov	s15, r3
34001380:	eef8 7a67 	vcvt.f32.u32	s15, s15
34001384:	ee67 7aa6 	vmul.f32	s15, s15, s13
34001388:	eeb4 7a67 	vcmp.f32	s14, s15
3400138c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001390:	bfc8      	it	gt
34001392:	461a      	movgt	r2, r3
34001394:	6032      	str	r2, [r6, #0]
34001396:	ecbd 8b02 	vpop	{d8}
3400139a:	bd70      	pop	{r4, r5, r6, pc}
3400139c:	ee07 1a90 	vmov	s15, r1
340013a0:	eef8 7a67 	vcvt.f32.u32	s15, s15
340013a4:	ee87 0a27 	vdiv.f32	s0, s14, s15
340013a8:	6031      	str	r1, [r6, #0]
340013aa:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
340013ae:	f01a ff67 	bl	3401c280 <log10>
340013b2:	ed9f 7b05 	vldr	d7, [pc, #20]	@ 340013c8 <jHlPSTIzmc+0xa0>
340013b6:	ee20 0b07 	vmul.f64	d0, d0, d7
340013ba:	eebc 0bc0 	vcvt.u32.f64	s0, d0
340013be:	ed84 0a00 	vstr	s0, [r4]
340013c2:	e7e8      	b.n	34001396 <jHlPSTIzmc+0x6e>
340013c4:	f3af 8000 	nop.w
340013c8:	00000000 	.word	0x00000000
340013cc:	40d38800 	.word	0x40d38800
340013d0:	469c4000 	.word	0x469c4000
340013d4:	3f7ae148 	.word	0x3f7ae148

340013d8 <evision_api_st_ae_new>:
340013d8:	b510      	push	{r4, lr}
340013da:	b090      	sub	sp, #64	@ 0x40
340013dc:	b168      	cbz	r0, 340013fa <evision_api_st_ae_new+0x22>
340013de:	2200      	movs	r2, #0
340013e0:	4c07      	ldr	r4, [pc, #28]	@ (34001400 <evision_api_st_ae_new+0x28>)
340013e2:	2140      	movs	r1, #64	@ 0x40
340013e4:	4b07      	ldr	r3, [pc, #28]	@ (34001404 <evision_api_st_ae_new+0x2c>)
340013e6:	7022      	strb	r2, [r4, #0]
340013e8:	65a0      	str	r0, [r4, #88]	@ 0x58
340013ea:	4a07      	ldr	r2, [pc, #28]	@ (34001408 <evision_api_st_ae_new+0x30>)
340013ec:	4668      	mov	r0, sp
340013ee:	f018 fd35 	bl	34019e5c <sniprintf>
340013f2:	4668      	mov	r0, sp
340013f4:	6da3      	ldr	r3, [r4, #88]	@ 0x58
340013f6:	4798      	blx	r3
340013f8:	4620      	mov	r0, r4
340013fa:	b010      	add	sp, #64	@ 0x40
340013fc:	bd10      	pop	{r4, pc}
340013fe:	bf00      	nop
34001400:	340b15c0 	.word	0x340b15c0
34001404:	340b0ece 	.word	0x340b0ece
34001408:	340225d8 	.word	0x340225d8

3400140c <evision_api_st_ae_delete>:
3400140c:	2800      	cmp	r0, #0
3400140e:	bf0c      	ite	eq
34001410:	f04f 30ff 	moveq.w	r0, #4294967295
34001414:	2001      	movne	r0, #1
34001416:	4770      	bx	lr

34001418 <BnNqZEfmZx>:
34001418:	2238      	movs	r2, #56	@ 0x38
3400141a:	230a      	movs	r3, #10
3400141c:	b530      	push	{r4, r5, lr}
3400141e:	e9c0 2304 	strd	r2, r3, [r0, #16]
34001422:	2264      	movs	r2, #100	@ 0x64
34001424:	232d      	movs	r3, #45	@ 0x2d
34001426:	2178      	movs	r1, #120	@ 0x78
34001428:	e9c0 2306 	strd	r2, r3, [r0, #24]
3400142c:	f240 53dc 	movw	r3, #1500	@ 0x5dc
34001430:	f241 7470 	movw	r4, #6000	@ 0x1770
34001434:	e9c0 1308 	strd	r1, r3, [r0, #32]
34001438:	f642 63e0 	movw	r3, #12000	@ 0x2ee0
3400143c:	e9c0 430a 	strd	r4, r3, [r0, #40]	@ 0x28
34001440:	a50b      	add	r5, pc, #44	@ (adr r5, 34001470 <BnNqZEfmZx+0x58>)
34001442:	e9d5 4500 	ldrd	r4, r5, [r5]
34001446:	2305      	movs	r3, #5
34001448:	f248 01e8 	movw	r1, #33000	@ 0x80e8
3400144c:	6503      	str	r3, [r0, #80]	@ 0x50
3400144e:	2300      	movs	r3, #0
34001450:	e9c0 3110 	strd	r3, r1, [r0, #64]	@ 0x40
34001454:	2101      	movs	r1, #1
34001456:	e9c0 450c 	strd	r4, r5, [r0, #48]	@ 0x30
3400145a:	a507      	add	r5, pc, #28	@ (adr r5, 34001478 <BnNqZEfmZx+0x60>)
3400145c:	e9d5 4500 	ldrd	r4, r5, [r5]
34001460:	e9c0 1212 	strd	r1, r2, [r0, #72]	@ 0x48
34001464:	e9c0 450e 	strd	r4, r5, [r0, #56]	@ 0x38
34001468:	6543      	str	r3, [r0, #84]	@ 0x54
3400146a:	bd30      	pop	{r4, r5, pc}
3400146c:	f3af 8000 	nop.w
34001470:	40000000 	.word	0x40000000
34001474:	3f947ae1 	.word	0x3f947ae1
34001478:	e0000000 	.word	0xe0000000
3400147c:	3f70624d 	.word	0x3f70624d

34001480 <evision_api_st_ae_init>:
34001480:	b510      	push	{r4, lr}
34001482:	4604      	mov	r4, r0
34001484:	b120      	cbz	r0, 34001490 <evision_api_st_ae_init+0x10>
34001486:	f7ff ffc7 	bl	34001418 <BnNqZEfmZx>
3400148a:	2001      	movs	r0, #1
3400148c:	7020      	strb	r0, [r4, #0]
3400148e:	bd10      	pop	{r4, pc}
34001490:	f04f 30ff 	mov.w	r0, #4294967295
34001494:	e7fb      	b.n	3400148e <evision_api_st_ae_init+0xe>

34001496 <evision_api_st_ae_process>:
34001496:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400149a:	460f      	mov	r7, r1
3400149c:	4615      	mov	r5, r2
3400149e:	4698      	mov	r8, r3
340014a0:	4604      	mov	r4, r0
340014a2:	b089      	sub	sp, #36	@ 0x24
340014a4:	2800      	cmp	r0, #0
340014a6:	f000 813b 	beq.w	34001720 <evision_api_st_ae_process+0x28a>
340014aa:	7803      	ldrb	r3, [r0, #0]
340014ac:	2b01      	cmp	r3, #1
340014ae:	d11c      	bne.n	340014ea <evision_api_st_ae_process+0x54>
340014b0:	2302      	movs	r3, #2
340014b2:	7003      	strb	r3, [r0, #0]
340014b4:	f8d4 9054 	ldr.w	r9, [r4, #84]	@ 0x54
340014b8:	f1b9 0f00 	cmp.w	r9, #0
340014bc:	d019      	beq.n	340014f2 <evision_api_st_ae_process+0x5c>
340014be:	4b9c      	ldr	r3, [pc, #624]	@ (34001730 <evision_api_st_ae_process+0x29a>)
340014c0:	ea4f 0249 	mov.w	r2, r9, lsl #1
340014c4:	fbb3 f3f2 	udiv	r3, r3, r2
340014c8:	6ca6      	ldr	r6, [r4, #72]	@ 0x48
340014ca:	42be      	cmp	r6, r7
340014cc:	d213      	bcs.n	340014f6 <evision_api_st_ae_process+0x60>
340014ce:	6c62      	ldr	r2, [r4, #68]	@ 0x44
340014d0:	42aa      	cmp	r2, r5
340014d2:	d910      	bls.n	340014f6 <evision_api_st_ae_process+0x60>
340014d4:	fbb5 f2f3 	udiv	r2, r5, r3
340014d8:	fb03 5312 	mls	r3, r3, r2, r5
340014dc:	b15b      	cbz	r3, 340014f6 <evision_api_st_ae_process+0x60>
340014de:	e9c4 5601 	strd	r5, r6, [r4, #4]
340014e2:	2001      	movs	r0, #1
340014e4:	b009      	add	sp, #36	@ 0x24
340014e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340014ea:	2b02      	cmp	r3, #2
340014ec:	d0e2      	beq.n	340014b4 <evision_api_st_ae_process+0x1e>
340014ee:	2000      	movs	r0, #0
340014f0:	e7f8      	b.n	340014e4 <evision_api_st_ae_process+0x4e>
340014f2:	2301      	movs	r3, #1
340014f4:	e7e8      	b.n	340014c8 <evision_api_st_ae_process+0x32>
340014f6:	f10d 0a14 	add.w	sl, sp, #20
340014fa:	4639      	mov	r1, r7
340014fc:	ab04      	add	r3, sp, #16
340014fe:	462a      	mov	r2, r5
34001500:	4620      	mov	r0, r4
34001502:	f8cd a000 	str.w	sl, [sp]
34001506:	f7ff ff0f 	bl	34001328 <jHlPSTIzmc>
3400150a:	e9dd b104 	ldrd	fp, r1, [sp, #16]
3400150e:	f8d4 c010 	ldr.w	ip, [r4, #16]
34001512:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
34001516:	ee07 ca90 	vmov	s15, ip
3400151a:	eeb8 6a67 	vcvt.f32.u32	s12, s15
3400151e:	ee07 8a90 	vmov	s15, r8
34001522:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34001526:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
3400152a:	ee37 7b05 	vadd.f64	d7, d7, d5
3400152e:	ee86 0b07 	vdiv.f64	d0, d6, d7
34001532:	6d23      	ldr	r3, [r4, #80]	@ 0x50
34001534:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
34001538:	4598      	cmp	r8, r3
3400153a:	d30e      	bcc.n	3400155a <evision_api_st_ae_process+0xc4>
3400153c:	ebac 0008 	sub.w	r0, ip, r8
34001540:	69e3      	ldr	r3, [r4, #28]
34001542:	ea80 72e0 	eor.w	r2, r0, r0, asr #31
34001546:	eba2 72e0 	sub.w	r2, r2, r0, asr #31
3400154a:	429a      	cmp	r2, r3
3400154c:	d959      	bls.n	34001602 <evision_api_st_ae_process+0x16c>
3400154e:	6a23      	ldr	r3, [r4, #32]
34001550:	429a      	cmp	r2, r3
34001552:	bf2c      	ite	cs
34001554:	6ae3      	ldrcs	r3, [r4, #44]	@ 0x2c
34001556:	6aa3      	ldrcc	r3, [r4, #40]	@ 0x28
34001558:	e054      	b.n	34001604 <evision_api_st_ae_process+0x16e>
3400155a:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
3400155e:	eeb4 0ae7 	vcmpe.f32	s0, s15
34001562:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001566:	d4e9      	bmi.n	3400153c <evision_api_st_ae_process+0xa6>
34001568:	6c62      	ldr	r2, [r4, #68]	@ 0x44
3400156a:	4291      	cmp	r1, r2
3400156c:	d22b      	bcs.n	340015c6 <evision_api_st_ae_process+0x130>
3400156e:	2901      	cmp	r1, #1
34001570:	460b      	mov	r3, r1
34001572:	bf38      	it	cc
34001574:	2301      	movcc	r3, #1
34001576:	ee07 3a90 	vmov	s15, r3
3400157a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3400157e:	ee67 7a80 	vmul.f32	s15, s15, s0
34001582:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34001586:	ee17 3a90 	vmov	r3, s15
3400158a:	4293      	cmp	r3, r2
3400158c:	dc0e      	bgt.n	340015ac <evision_api_st_ae_process+0x116>
3400158e:	edc4 7a01 	vstr	s15, [r4, #4]
34001592:	ab07      	add	r3, sp, #28
34001594:	9300      	str	r3, [sp, #0]
34001596:	4620      	mov	r0, r4
34001598:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
3400159c:	ab06      	add	r3, sp, #24
3400159e:	f7ff fe6f 	bl	34001280 <GTePMGhCOh>
340015a2:	9b06      	ldr	r3, [sp, #24]
340015a4:	60a3      	str	r3, [r4, #8]
340015a6:	9b07      	ldr	r3, [sp, #28]
340015a8:	6063      	str	r3, [r4, #4]
340015aa:	e79a      	b.n	340014e2 <evision_api_st_ae_process+0x4c>
340015ac:	ee07 2a90 	vmov	s15, r2
340015b0:	eef8 6ae7 	vcvt.f32.s32	s13, s15
340015b4:	ee07 1a90 	vmov	s15, r1
340015b8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
340015bc:	eec6 7a87 	vdiv.f32	s15, s13, s14
340015c0:	ee80 0a27 	vdiv.f32	s0, s0, s15
340015c4:	6062      	str	r2, [r4, #4]
340015c6:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
340015ca:	eeb4 0ae7 	vcmpe.f32	s0, s15
340015ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340015d2:	ddde      	ble.n	34001592 <evision_api_st_ae_process+0xfc>
340015d4:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
340015d8:	f01a fe52 	bl	3401c280 <log10>
340015dc:	eeb3 7b04 	vmov.f64	d7, #52	@ 0x41a00000  20.0
340015e0:	ee20 0b07 	vmul.f64	d0, d0, d7
340015e4:	ed9f 7b50 	vldr	d7, [pc, #320]	@ 34001728 <evision_api_st_ae_process+0x292>
340015e8:	ee20 0b07 	vmul.f64	d0, d0, d7
340015ec:	eebd 0bc0 	vcvt.s32.f64	s0, d0
340015f0:	ee10 3a10 	vmov	r3, s0
340015f4:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
340015f6:	445b      	add	r3, fp
340015f8:	4293      	cmp	r3, r2
340015fa:	bfd4      	ite	le
340015fc:	60a3      	strle	r3, [r4, #8]
340015fe:	60a2      	strgt	r2, [r4, #8]
34001600:	e7c7      	b.n	34001592 <evision_api_st_ae_process+0xfc>
34001602:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34001604:	f8d4 e014 	ldr.w	lr, [r4, #20]
34001608:	69a2      	ldr	r2, [r4, #24]
3400160a:	9303      	str	r3, [sp, #12]
3400160c:	eb0e 030c 	add.w	r3, lr, ip
34001610:	4543      	cmp	r3, r8
34001612:	fb00 f202 	mul.w	r2, r0, r2
34001616:	d24c      	bcs.n	340016b2 <evision_api_st_ae_process+0x21c>
34001618:	eddd 7a03 	vldr	s15, [sp, #12]
3400161c:	ed9f 7a45 	vldr	s14, [pc, #276]	@ 34001734 <evision_api_st_ae_process+0x29e>
34001620:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34001624:	ee67 7a87 	vmul.f32	s15, s15, s14
34001628:	ee07 2a10 	vmov	s14, r2
3400162c:	eef1 6a67 	vneg.f32	s13, s15
34001630:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34001634:	eeb4 7ae6 	vcmpe.f32	s14, s13
34001638:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400163c:	d504      	bpl.n	34001648 <evision_api_st_ae_process+0x1b2>
3400163e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34001642:	ee17 3a90 	vmov	r3, s15
34001646:	425a      	negs	r2, r3
34001648:	2a00      	cmp	r2, #0
3400164a:	d057      	beq.n	340016fc <evision_api_st_ae_process+0x266>
3400164c:	455e      	cmp	r6, fp
3400164e:	d14a      	bne.n	340016e6 <evision_api_st_ae_process+0x250>
34001650:	6c65      	ldr	r5, [r4, #68]	@ 0x44
34001652:	42a9      	cmp	r1, r5
34001654:	d336      	bcc.n	340016c4 <evision_api_st_ae_process+0x22e>
34001656:	2a00      	cmp	r2, #0
34001658:	da45      	bge.n	340016e6 <evision_api_st_ae_process+0x250>
3400165a:	fb01 0000 	mla	r0, r1, r0, r0
3400165e:	ee07 0a90 	vmov	s15, r0
34001662:	eeb8 6be7 	vcvt.f64.s32	d6, s15
34001666:	ee07 1a90 	vmov	s15, r1
3400166a:	ed94 5b0e 	vldr	d5, [r4, #56]	@ 0x38
3400166e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34001672:	eea6 7b05 	vfma.f64	d7, d6, d5
34001676:	eebd 7bc7 	vcvt.s32.f64	s14, d7
3400167a:	ee17 2a10 	vmov	r2, s14
3400167e:	6c23      	ldr	r3, [r4, #64]	@ 0x40
34001680:	f8c4 b008 	str.w	fp, [r4, #8]
34001684:	429a      	cmp	r2, r3
34001686:	bfb8      	it	lt
34001688:	461a      	movlt	r2, r3
3400168a:	42aa      	cmp	r2, r5
3400168c:	bfd4      	ite	le
3400168e:	6062      	strle	r2, [r4, #4]
34001690:	6065      	strgt	r5, [r4, #4]
34001692:	4620      	mov	r0, r4
34001694:	f8cd a000 	str.w	sl, [sp]
34001698:	ab04      	add	r3, sp, #16
3400169a:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
3400169e:	f7ff fdef 	bl	34001280 <GTePMGhCOh>
340016a2:	9b04      	ldr	r3, [sp, #16]
340016a4:	9d05      	ldr	r5, [sp, #20]
340016a6:	60a3      	str	r3, [r4, #8]
340016a8:	4b23      	ldr	r3, [pc, #140]	@ (34001738 <evision_api_st_ae_process+0x2a2>)
340016aa:	6065      	str	r5, [r4, #4]
340016ac:	f8c3 9060 	str.w	r9, [r3, #96]	@ 0x60
340016b0:	e717      	b.n	340014e2 <evision_api_st_ae_process+0x4c>
340016b2:	ebac 0c0e 	sub.w	ip, ip, lr
340016b6:	45c4      	cmp	ip, r8
340016b8:	dd20      	ble.n	340016fc <evision_api_st_ae_process+0x266>
340016ba:	9b03      	ldr	r3, [sp, #12]
340016bc:	429a      	cmp	r2, r3
340016be:	bfa8      	it	ge
340016c0:	461a      	movge	r2, r3
340016c2:	e7c1      	b.n	34001648 <evision_api_st_ae_process+0x1b2>
340016c4:	2a00      	cmp	r2, #0
340016c6:	dbc8      	blt.n	3400165a <evision_api_st_ae_process+0x1c4>
340016c8:	fb01 0000 	mla	r0, r1, r0, r0
340016cc:	ee07 0a90 	vmov	s15, r0
340016d0:	eeb8 6be7 	vcvt.f64.s32	d6, s15
340016d4:	ee07 1a90 	vmov	s15, r1
340016d8:	ed94 5b0c 	vldr	d5, [r4, #48]	@ 0x30
340016dc:	eeb8 7be7 	vcvt.f64.s32	d7, s15
340016e0:	eea5 7b06 	vfma.f64	d7, d5, d6
340016e4:	e7c7      	b.n	34001676 <evision_api_st_ae_process+0x1e0>
340016e6:	4493      	add	fp, r2
340016e8:	455e      	cmp	r6, fp
340016ea:	dc04      	bgt.n	340016f6 <evision_api_st_ae_process+0x260>
340016ec:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
340016ee:	465e      	mov	r6, fp
340016f0:	459b      	cmp	fp, r3
340016f2:	bfa8      	it	ge
340016f4:	461e      	movge	r6, r3
340016f6:	e9c4 1601 	strd	r1, r6, [r4, #4]
340016fa:	e7ca      	b.n	34001692 <evision_api_st_ae_process+0x1fc>
340016fc:	4b0e      	ldr	r3, [pc, #56]	@ (34001738 <evision_api_st_ae_process+0x2a2>)
340016fe:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34001700:	4599      	cmp	r9, r3
34001702:	d00b      	beq.n	3400171c <evision_api_st_ae_process+0x286>
34001704:	462a      	mov	r2, r5
34001706:	4639      	mov	r1, r7
34001708:	4620      	mov	r0, r4
3400170a:	f8cd a000 	str.w	sl, [sp]
3400170e:	ab04      	add	r3, sp, #16
34001710:	f1b9 0f00 	cmp.w	r9, #0
34001714:	d1c3      	bne.n	3400169e <evision_api_st_ae_process+0x208>
34001716:	f7ff fe07 	bl	34001328 <jHlPSTIzmc>
3400171a:	e7c2      	b.n	340016a2 <evision_api_st_ae_process+0x20c>
3400171c:	60a7      	str	r7, [r4, #8]
3400171e:	e7c3      	b.n	340016a8 <evision_api_st_ae_process+0x212>
34001720:	f04f 30ff 	mov.w	r0, #4294967295
34001724:	e6de      	b.n	340014e4 <evision_api_st_ae_process+0x4e>
34001726:	bf00      	nop
34001728:	00000000 	.word	0x00000000
3400172c:	408f4000 	.word	0x408f4000
34001730:	000f4240 	.word	0x000f4240
34001734:	3f59999a 	.word	0x3f59999a
34001738:	340b15c0 	.word	0x340b15c0

3400173c <strlen>:
3400173c:	4603      	mov	r3, r0
3400173e:	f813 2b01 	ldrb.w	r2, [r3], #1
34001742:	2a00      	cmp	r2, #0
34001744:	d1fb      	bne.n	3400173e <strlen+0x2>
34001746:	1a18      	subs	r0, r3, r0
34001748:	3801      	subs	r0, #1
3400174a:	4770      	bx	lr

3400174c <__aeabi_ldivmod>:
3400174c:	b97b      	cbnz	r3, 3400176e <__aeabi_ldivmod+0x22>
3400174e:	b972      	cbnz	r2, 3400176e <__aeabi_ldivmod+0x22>
34001750:	2900      	cmp	r1, #0
34001752:	bfbe      	ittt	lt
34001754:	2000      	movlt	r0, #0
34001756:	f04f 4100 	movlt.w	r1, #2147483648	@ 0x80000000
3400175a:	e006      	blt.n	3400176a <__aeabi_ldivmod+0x1e>
3400175c:	bf08      	it	eq
3400175e:	2800      	cmpeq	r0, #0
34001760:	bf1c      	itt	ne
34001762:	f06f 4100 	mvnne.w	r1, #2147483648	@ 0x80000000
34001766:	f04f 30ff 	movne.w	r0, #4294967295
3400176a:	f000 b9fb 	b.w	34001b64 <__aeabi_idiv0>
3400176e:	f1ad 0c08 	sub.w	ip, sp, #8
34001772:	e96d ce04 	strd	ip, lr, [sp, #-16]!
34001776:	2900      	cmp	r1, #0
34001778:	db09      	blt.n	3400178e <__aeabi_ldivmod+0x42>
3400177a:	2b00      	cmp	r3, #0
3400177c:	db1a      	blt.n	340017b4 <__aeabi_ldivmod+0x68>
3400177e:	f000 f84d 	bl	3400181c <__udivmoddi4>
34001782:	f8dd e004 	ldr.w	lr, [sp, #4]
34001786:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
3400178a:	b004      	add	sp, #16
3400178c:	4770      	bx	lr
3400178e:	4240      	negs	r0, r0
34001790:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
34001794:	2b00      	cmp	r3, #0
34001796:	db1b      	blt.n	340017d0 <__aeabi_ldivmod+0x84>
34001798:	f000 f840 	bl	3400181c <__udivmoddi4>
3400179c:	f8dd e004 	ldr.w	lr, [sp, #4]
340017a0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340017a4:	b004      	add	sp, #16
340017a6:	4240      	negs	r0, r0
340017a8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
340017ac:	4252      	negs	r2, r2
340017ae:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340017b2:	4770      	bx	lr
340017b4:	4252      	negs	r2, r2
340017b6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340017ba:	f000 f82f 	bl	3400181c <__udivmoddi4>
340017be:	f8dd e004 	ldr.w	lr, [sp, #4]
340017c2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340017c6:	b004      	add	sp, #16
340017c8:	4240      	negs	r0, r0
340017ca:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
340017ce:	4770      	bx	lr
340017d0:	4252      	negs	r2, r2
340017d2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340017d6:	f000 f821 	bl	3400181c <__udivmoddi4>
340017da:	f8dd e004 	ldr.w	lr, [sp, #4]
340017de:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340017e2:	b004      	add	sp, #16
340017e4:	4252      	negs	r2, r2
340017e6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340017ea:	4770      	bx	lr

340017ec <__aeabi_uldivmod>:
340017ec:	b953      	cbnz	r3, 34001804 <__aeabi_uldivmod+0x18>
340017ee:	b94a      	cbnz	r2, 34001804 <__aeabi_uldivmod+0x18>
340017f0:	2900      	cmp	r1, #0
340017f2:	bf08      	it	eq
340017f4:	2800      	cmpeq	r0, #0
340017f6:	bf1c      	itt	ne
340017f8:	f04f 31ff 	movne.w	r1, #4294967295
340017fc:	f04f 30ff 	movne.w	r0, #4294967295
34001800:	f000 b9b0 	b.w	34001b64 <__aeabi_idiv0>
34001804:	f1ad 0c08 	sub.w	ip, sp, #8
34001808:	e96d ce04 	strd	ip, lr, [sp, #-16]!
3400180c:	f000 f806 	bl	3400181c <__udivmoddi4>
34001810:	f8dd e004 	ldr.w	lr, [sp, #4]
34001814:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001818:	b004      	add	sp, #16
3400181a:	4770      	bx	lr

3400181c <__udivmoddi4>:
3400181c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34001820:	9d09      	ldr	r5, [sp, #36]	@ 0x24
34001822:	4688      	mov	r8, r1
34001824:	4604      	mov	r4, r0
34001826:	468e      	mov	lr, r1
34001828:	2b00      	cmp	r3, #0
3400182a:	d14a      	bne.n	340018c2 <__udivmoddi4+0xa6>
3400182c:	428a      	cmp	r2, r1
3400182e:	4617      	mov	r7, r2
34001830:	d95f      	bls.n	340018f2 <__udivmoddi4+0xd6>
34001832:	fab2 f682 	clz	r6, r2
34001836:	b14e      	cbz	r6, 3400184c <__udivmoddi4+0x30>
34001838:	f1c6 0320 	rsb	r3, r6, #32
3400183c:	fa01 fe06 	lsl.w	lr, r1, r6
34001840:	40b7      	lsls	r7, r6
34001842:	40b4      	lsls	r4, r6
34001844:	fa20 f303 	lsr.w	r3, r0, r3
34001848:	ea43 0e0e 	orr.w	lr, r3, lr
3400184c:	ea4f 4817 	mov.w	r8, r7, lsr #16
34001850:	fa1f fc87 	uxth.w	ip, r7
34001854:	0c23      	lsrs	r3, r4, #16
34001856:	fbbe f1f8 	udiv	r1, lr, r8
3400185a:	fb08 ee11 	mls	lr, r8, r1, lr
3400185e:	fb01 f20c 	mul.w	r2, r1, ip
34001862:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
34001866:	429a      	cmp	r2, r3
34001868:	d907      	bls.n	3400187a <__udivmoddi4+0x5e>
3400186a:	18fb      	adds	r3, r7, r3
3400186c:	f101 30ff 	add.w	r0, r1, #4294967295
34001870:	d202      	bcs.n	34001878 <__udivmoddi4+0x5c>
34001872:	429a      	cmp	r2, r3
34001874:	f200 8154 	bhi.w	34001b20 <__udivmoddi4+0x304>
34001878:	4601      	mov	r1, r0
3400187a:	1a9b      	subs	r3, r3, r2
3400187c:	b2a2      	uxth	r2, r4
3400187e:	fbb3 f0f8 	udiv	r0, r3, r8
34001882:	fb08 3310 	mls	r3, r8, r0, r3
34001886:	fb00 fc0c 	mul.w	ip, r0, ip
3400188a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
3400188e:	4594      	cmp	ip, r2
34001890:	d90b      	bls.n	340018aa <__udivmoddi4+0x8e>
34001892:	18ba      	adds	r2, r7, r2
34001894:	f100 33ff 	add.w	r3, r0, #4294967295
34001898:	bf2c      	ite	cs
3400189a:	2401      	movcs	r4, #1
3400189c:	2400      	movcc	r4, #0
3400189e:	4594      	cmp	ip, r2
340018a0:	d902      	bls.n	340018a8 <__udivmoddi4+0x8c>
340018a2:	2c00      	cmp	r4, #0
340018a4:	f000 813f 	beq.w	34001b26 <__udivmoddi4+0x30a>
340018a8:	4618      	mov	r0, r3
340018aa:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
340018ae:	eba2 020c 	sub.w	r2, r2, ip
340018b2:	2100      	movs	r1, #0
340018b4:	b11d      	cbz	r5, 340018be <__udivmoddi4+0xa2>
340018b6:	40f2      	lsrs	r2, r6
340018b8:	2300      	movs	r3, #0
340018ba:	e9c5 2300 	strd	r2, r3, [r5]
340018be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340018c2:	428b      	cmp	r3, r1
340018c4:	d905      	bls.n	340018d2 <__udivmoddi4+0xb6>
340018c6:	b10d      	cbz	r5, 340018cc <__udivmoddi4+0xb0>
340018c8:	e9c5 0100 	strd	r0, r1, [r5]
340018cc:	2100      	movs	r1, #0
340018ce:	4608      	mov	r0, r1
340018d0:	e7f5      	b.n	340018be <__udivmoddi4+0xa2>
340018d2:	fab3 f183 	clz	r1, r3
340018d6:	2900      	cmp	r1, #0
340018d8:	d14e      	bne.n	34001978 <__udivmoddi4+0x15c>
340018da:	4543      	cmp	r3, r8
340018dc:	f0c0 8112 	bcc.w	34001b04 <__udivmoddi4+0x2e8>
340018e0:	4282      	cmp	r2, r0
340018e2:	f240 810f 	bls.w	34001b04 <__udivmoddi4+0x2e8>
340018e6:	4608      	mov	r0, r1
340018e8:	2d00      	cmp	r5, #0
340018ea:	d0e8      	beq.n	340018be <__udivmoddi4+0xa2>
340018ec:	e9c5 4e00 	strd	r4, lr, [r5]
340018f0:	e7e5      	b.n	340018be <__udivmoddi4+0xa2>
340018f2:	2a00      	cmp	r2, #0
340018f4:	f000 80ac 	beq.w	34001a50 <__udivmoddi4+0x234>
340018f8:	fab2 f682 	clz	r6, r2
340018fc:	2e00      	cmp	r6, #0
340018fe:	f040 80bb 	bne.w	34001a78 <__udivmoddi4+0x25c>
34001902:	1a8b      	subs	r3, r1, r2
34001904:	ea4f 4e12 	mov.w	lr, r2, lsr #16
34001908:	b2bc      	uxth	r4, r7
3400190a:	2101      	movs	r1, #1
3400190c:	0c02      	lsrs	r2, r0, #16
3400190e:	b280      	uxth	r0, r0
34001910:	fbb3 fcfe 	udiv	ip, r3, lr
34001914:	fb0e 331c 	mls	r3, lr, ip, r3
34001918:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
3400191c:	fb04 f20c 	mul.w	r2, r4, ip
34001920:	429a      	cmp	r2, r3
34001922:	d90e      	bls.n	34001942 <__udivmoddi4+0x126>
34001924:	18fb      	adds	r3, r7, r3
34001926:	f10c 38ff 	add.w	r8, ip, #4294967295
3400192a:	bf2c      	ite	cs
3400192c:	f04f 0901 	movcs.w	r9, #1
34001930:	f04f 0900 	movcc.w	r9, #0
34001934:	429a      	cmp	r2, r3
34001936:	d903      	bls.n	34001940 <__udivmoddi4+0x124>
34001938:	f1b9 0f00 	cmp.w	r9, #0
3400193c:	f000 80ec 	beq.w	34001b18 <__udivmoddi4+0x2fc>
34001940:	46c4      	mov	ip, r8
34001942:	1a9b      	subs	r3, r3, r2
34001944:	fbb3 f8fe 	udiv	r8, r3, lr
34001948:	fb0e 3318 	mls	r3, lr, r8, r3
3400194c:	fb04 f408 	mul.w	r4, r4, r8
34001950:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
34001954:	4294      	cmp	r4, r2
34001956:	d90b      	bls.n	34001970 <__udivmoddi4+0x154>
34001958:	18ba      	adds	r2, r7, r2
3400195a:	f108 33ff 	add.w	r3, r8, #4294967295
3400195e:	bf2c      	ite	cs
34001960:	2001      	movcs	r0, #1
34001962:	2000      	movcc	r0, #0
34001964:	4294      	cmp	r4, r2
34001966:	d902      	bls.n	3400196e <__udivmoddi4+0x152>
34001968:	2800      	cmp	r0, #0
3400196a:	f000 80d1 	beq.w	34001b10 <__udivmoddi4+0x2f4>
3400196e:	4698      	mov	r8, r3
34001970:	1b12      	subs	r2, r2, r4
34001972:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
34001976:	e79d      	b.n	340018b4 <__udivmoddi4+0x98>
34001978:	f1c1 0620 	rsb	r6, r1, #32
3400197c:	408b      	lsls	r3, r1
3400197e:	fa08 f401 	lsl.w	r4, r8, r1
34001982:	fa00 f901 	lsl.w	r9, r0, r1
34001986:	fa22 f706 	lsr.w	r7, r2, r6
3400198a:	fa28 f806 	lsr.w	r8, r8, r6
3400198e:	408a      	lsls	r2, r1
34001990:	431f      	orrs	r7, r3
34001992:	fa20 f306 	lsr.w	r3, r0, r6
34001996:	0c38      	lsrs	r0, r7, #16
34001998:	4323      	orrs	r3, r4
3400199a:	fa1f fc87 	uxth.w	ip, r7
3400199e:	0c1c      	lsrs	r4, r3, #16
340019a0:	fbb8 fef0 	udiv	lr, r8, r0
340019a4:	fb00 881e 	mls	r8, r0, lr, r8
340019a8:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
340019ac:	fb0e f80c 	mul.w	r8, lr, ip
340019b0:	45a0      	cmp	r8, r4
340019b2:	d90e      	bls.n	340019d2 <__udivmoddi4+0x1b6>
340019b4:	193c      	adds	r4, r7, r4
340019b6:	f10e 3aff 	add.w	sl, lr, #4294967295
340019ba:	bf2c      	ite	cs
340019bc:	f04f 0b01 	movcs.w	fp, #1
340019c0:	f04f 0b00 	movcc.w	fp, #0
340019c4:	45a0      	cmp	r8, r4
340019c6:	d903      	bls.n	340019d0 <__udivmoddi4+0x1b4>
340019c8:	f1bb 0f00 	cmp.w	fp, #0
340019cc:	f000 80b8 	beq.w	34001b40 <__udivmoddi4+0x324>
340019d0:	46d6      	mov	lr, sl
340019d2:	eba4 0408 	sub.w	r4, r4, r8
340019d6:	fa1f f883 	uxth.w	r8, r3
340019da:	fbb4 f3f0 	udiv	r3, r4, r0
340019de:	fb00 4413 	mls	r4, r0, r3, r4
340019e2:	fb03 fc0c 	mul.w	ip, r3, ip
340019e6:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
340019ea:	45a4      	cmp	ip, r4
340019ec:	d90e      	bls.n	34001a0c <__udivmoddi4+0x1f0>
340019ee:	193c      	adds	r4, r7, r4
340019f0:	f103 30ff 	add.w	r0, r3, #4294967295
340019f4:	bf2c      	ite	cs
340019f6:	f04f 0801 	movcs.w	r8, #1
340019fa:	f04f 0800 	movcc.w	r8, #0
340019fe:	45a4      	cmp	ip, r4
34001a00:	d903      	bls.n	34001a0a <__udivmoddi4+0x1ee>
34001a02:	f1b8 0f00 	cmp.w	r8, #0
34001a06:	f000 809f 	beq.w	34001b48 <__udivmoddi4+0x32c>
34001a0a:	4603      	mov	r3, r0
34001a0c:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
34001a10:	eba4 040c 	sub.w	r4, r4, ip
34001a14:	fba0 ec02 	umull	lr, ip, r0, r2
34001a18:	4564      	cmp	r4, ip
34001a1a:	4673      	mov	r3, lr
34001a1c:	46e0      	mov	r8, ip
34001a1e:	d302      	bcc.n	34001a26 <__udivmoddi4+0x20a>
34001a20:	d107      	bne.n	34001a32 <__udivmoddi4+0x216>
34001a22:	45f1      	cmp	r9, lr
34001a24:	d205      	bcs.n	34001a32 <__udivmoddi4+0x216>
34001a26:	ebbe 0302 	subs.w	r3, lr, r2
34001a2a:	eb6c 0c07 	sbc.w	ip, ip, r7
34001a2e:	3801      	subs	r0, #1
34001a30:	46e0      	mov	r8, ip
34001a32:	b15d      	cbz	r5, 34001a4c <__udivmoddi4+0x230>
34001a34:	ebb9 0203 	subs.w	r2, r9, r3
34001a38:	eb64 0408 	sbc.w	r4, r4, r8
34001a3c:	fa04 f606 	lsl.w	r6, r4, r6
34001a40:	fa22 f301 	lsr.w	r3, r2, r1
34001a44:	40cc      	lsrs	r4, r1
34001a46:	431e      	orrs	r6, r3
34001a48:	e9c5 6400 	strd	r6, r4, [r5]
34001a4c:	2100      	movs	r1, #0
34001a4e:	e736      	b.n	340018be <__udivmoddi4+0xa2>
34001a50:	fbb1 fcf2 	udiv	ip, r1, r2
34001a54:	0c01      	lsrs	r1, r0, #16
34001a56:	4614      	mov	r4, r2
34001a58:	b280      	uxth	r0, r0
34001a5a:	4696      	mov	lr, r2
34001a5c:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34001a60:	2620      	movs	r6, #32
34001a62:	4690      	mov	r8, r2
34001a64:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
34001a68:	4610      	mov	r0, r2
34001a6a:	fbb1 f1f2 	udiv	r1, r1, r2
34001a6e:	eba3 0308 	sub.w	r3, r3, r8
34001a72:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
34001a76:	e74b      	b.n	34001910 <__udivmoddi4+0xf4>
34001a78:	40b7      	lsls	r7, r6
34001a7a:	f1c6 0320 	rsb	r3, r6, #32
34001a7e:	fa01 f206 	lsl.w	r2, r1, r6
34001a82:	fa21 f803 	lsr.w	r8, r1, r3
34001a86:	ea4f 4e17 	mov.w	lr, r7, lsr #16
34001a8a:	fa20 f303 	lsr.w	r3, r0, r3
34001a8e:	b2bc      	uxth	r4, r7
34001a90:	40b0      	lsls	r0, r6
34001a92:	4313      	orrs	r3, r2
34001a94:	0c02      	lsrs	r2, r0, #16
34001a96:	0c19      	lsrs	r1, r3, #16
34001a98:	b280      	uxth	r0, r0
34001a9a:	fbb8 f9fe 	udiv	r9, r8, lr
34001a9e:	fb0e 8819 	mls	r8, lr, r9, r8
34001aa2:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34001aa6:	fb09 f804 	mul.w	r8, r9, r4
34001aaa:	4588      	cmp	r8, r1
34001aac:	d951      	bls.n	34001b52 <__udivmoddi4+0x336>
34001aae:	1879      	adds	r1, r7, r1
34001ab0:	f109 3cff 	add.w	ip, r9, #4294967295
34001ab4:	bf2c      	ite	cs
34001ab6:	f04f 0a01 	movcs.w	sl, #1
34001aba:	f04f 0a00 	movcc.w	sl, #0
34001abe:	4588      	cmp	r8, r1
34001ac0:	d902      	bls.n	34001ac8 <__udivmoddi4+0x2ac>
34001ac2:	f1ba 0f00 	cmp.w	sl, #0
34001ac6:	d031      	beq.n	34001b2c <__udivmoddi4+0x310>
34001ac8:	eba1 0108 	sub.w	r1, r1, r8
34001acc:	fbb1 f9fe 	udiv	r9, r1, lr
34001ad0:	fb09 f804 	mul.w	r8, r9, r4
34001ad4:	fb0e 1119 	mls	r1, lr, r9, r1
34001ad8:	b29b      	uxth	r3, r3
34001ada:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34001ade:	4543      	cmp	r3, r8
34001ae0:	d235      	bcs.n	34001b4e <__udivmoddi4+0x332>
34001ae2:	18fb      	adds	r3, r7, r3
34001ae4:	f109 31ff 	add.w	r1, r9, #4294967295
34001ae8:	bf2c      	ite	cs
34001aea:	f04f 0a01 	movcs.w	sl, #1
34001aee:	f04f 0a00 	movcc.w	sl, #0
34001af2:	4543      	cmp	r3, r8
34001af4:	d2bb      	bcs.n	34001a6e <__udivmoddi4+0x252>
34001af6:	f1ba 0f00 	cmp.w	sl, #0
34001afa:	d1b8      	bne.n	34001a6e <__udivmoddi4+0x252>
34001afc:	f1a9 0102 	sub.w	r1, r9, #2
34001b00:	443b      	add	r3, r7
34001b02:	e7b4      	b.n	34001a6e <__udivmoddi4+0x252>
34001b04:	1a84      	subs	r4, r0, r2
34001b06:	eb68 0203 	sbc.w	r2, r8, r3
34001b0a:	2001      	movs	r0, #1
34001b0c:	4696      	mov	lr, r2
34001b0e:	e6eb      	b.n	340018e8 <__udivmoddi4+0xcc>
34001b10:	443a      	add	r2, r7
34001b12:	f1a8 0802 	sub.w	r8, r8, #2
34001b16:	e72b      	b.n	34001970 <__udivmoddi4+0x154>
34001b18:	f1ac 0c02 	sub.w	ip, ip, #2
34001b1c:	443b      	add	r3, r7
34001b1e:	e710      	b.n	34001942 <__udivmoddi4+0x126>
34001b20:	3902      	subs	r1, #2
34001b22:	443b      	add	r3, r7
34001b24:	e6a9      	b.n	3400187a <__udivmoddi4+0x5e>
34001b26:	443a      	add	r2, r7
34001b28:	3802      	subs	r0, #2
34001b2a:	e6be      	b.n	340018aa <__udivmoddi4+0x8e>
34001b2c:	eba7 0808 	sub.w	r8, r7, r8
34001b30:	f1a9 0c02 	sub.w	ip, r9, #2
34001b34:	4441      	add	r1, r8
34001b36:	fbb1 f9fe 	udiv	r9, r1, lr
34001b3a:	fb09 f804 	mul.w	r8, r9, r4
34001b3e:	e7c9      	b.n	34001ad4 <__udivmoddi4+0x2b8>
34001b40:	f1ae 0e02 	sub.w	lr, lr, #2
34001b44:	443c      	add	r4, r7
34001b46:	e744      	b.n	340019d2 <__udivmoddi4+0x1b6>
34001b48:	3b02      	subs	r3, #2
34001b4a:	443c      	add	r4, r7
34001b4c:	e75e      	b.n	34001a0c <__udivmoddi4+0x1f0>
34001b4e:	4649      	mov	r1, r9
34001b50:	e78d      	b.n	34001a6e <__udivmoddi4+0x252>
34001b52:	eba1 0108 	sub.w	r1, r1, r8
34001b56:	46cc      	mov	ip, r9
34001b58:	fbb1 f9fe 	udiv	r9, r1, lr
34001b5c:	fb09 f804 	mul.w	r8, r9, r4
34001b60:	e7b8      	b.n	34001ad4 <__udivmoddi4+0x2b8>
34001b62:	bf00      	nop

34001b64 <__aeabi_idiv0>:
34001b64:	4770      	bx	lr
34001b66:	bf00      	nop

34001b68 <CameraPipeline_Init>:
* @param lcd_bg_width display width
* @param lcd_bg_height display height
* @param pitch_nn output pitch computed by the CMW
*/
void CameraPipeline_Init(uint32_t *lcd_bg_width, uint32_t *lcd_bg_height, uint32_t *pitch_nn)
{
34001b68:	b5f0      	push	{r4, r5, r6, r7, lr}
  int ret;
  CMW_CameraInit_t cam_conf;

  cam_conf.width = CAMERA_WIDTH;
  cam_conf.height = CAMERA_HEIGHT;
  cam_conf.fps = CAMERA_FPS;
34001b6a:	231e      	movs	r3, #30
{
34001b6c:	460e      	mov	r6, r1
  cam_conf.width = CAMERA_WIDTH;
34001b6e:	2100      	movs	r1, #0
{
34001b70:	b093      	sub	sp, #76	@ 0x4c
34001b72:	4607      	mov	r7, r0
  cam_conf.pixel_format = 0; /* Default; Not implemented yet */
  cam_conf.anti_flicker = 0;
  cam_conf.mirror_flip = CAMERA_FLIP;

  ret = CMW_CAMERA_Init(&cam_conf, NULL);
34001b74:	a801      	add	r0, sp, #4
  cam_conf.height = CAMERA_HEIGHT;
34001b76:	e9cd 1101 	strd	r1, r1, [sp, #4]
  cam_conf.pixel_format = 0; /* Default; Not implemented yet */
34001b7a:	e9cd 3103 	strd	r3, r1, [sp, #12]
  cam_conf.mirror_flip = CAMERA_FLIP;
34001b7e:	e9cd 1105 	strd	r1, r1, [sp, #20]
{
34001b82:	4615      	mov	r5, r2
  ret = CMW_CAMERA_Init(&cam_conf, NULL);
34001b84:	f00e ff06 	bl	34010994 <CMW_CAMERA_Init>
  assert(ret == CMW_ERROR_NONE);
34001b88:	4601      	mov	r1, r0
34001b8a:	b128      	cbz	r0, 34001b98 <CameraPipeline_Init+0x30>
34001b8c:	2186      	movs	r1, #134	@ 0x86
34001b8e:	4b21      	ldr	r3, [pc, #132]	@ (34001c14 <CameraPipeline_Init+0xac>)
34001b90:	4a21      	ldr	r2, [pc, #132]	@ (34001c18 <CameraPipeline_Init+0xb0>)
  assert(ret == HAL_OK);
34001b92:	4822      	ldr	r0, [pc, #136]	@ (34001c1c <CameraPipeline_Init+0xb4>)
34001b94:	f017 f962 	bl	34018e5c <__assert_func>
  DCMIPP_PipeInitDisplay(&cam_conf, lcd_bg_width, lcd_bg_height);
34001b98:	9c02      	ldr	r4, [sp, #8]
  CMW_DCMIPP_Conf_t dcmipp_conf = {0};
34001b9a:	221c      	movs	r2, #28
34001b9c:	a80b      	add	r0, sp, #44	@ 0x2c
34001b9e:	f018 fac1 	bl	3401a124 <memset>
  lcd_bg_height = (camConf->height <= SCREEN_HEIGHT) ? camConf->height : SCREEN_HEIGHT;
34001ba2:	f5b4 7ff0 	cmp.w	r4, #480	@ 0x1e0
34001ba6:	bf28      	it	cs
34001ba8:	f44f 74f0 	movcs.w	r4, #480	@ 0x1e0
  *bg_width = lcd_bg_width;
34001bac:	f44f 7248 	mov.w	r2, #800	@ 0x320
  dcmipp_conf.output_height = lcd_bg_height;
34001bb0:	e9cd 2407 	strd	r2, r4, [sp, #28]
  *bg_width = lcd_bg_width;
34001bb4:	603a      	str	r2, [r7, #0]
  *bg_height = lcd_bg_height;
34001bb6:	6034      	str	r4, [r6, #0]
  dcmipp_conf.output_bpp = 2;
34001bb8:	2401      	movs	r4, #1
34001bba:	2602      	movs	r6, #2
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE1, &dcmipp_conf, &pitch);
34001bbc:	466a      	mov	r2, sp
34001bbe:	4620      	mov	r0, r4
34001bc0:	a907      	add	r1, sp, #28
  dcmipp_conf.output_bpp = 2;
34001bc2:	e9cd 4609 	strd	r4, r6, [sp, #36]	@ 0x24
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE1, &dcmipp_conf, &pitch);
34001bc6:	f00e fd9f 	bl	34010708 <CMW_CAMERA_SetPipeConfig>
  assert(ret == HAL_OK);
34001bca:	b118      	cbz	r0, 34001bd4 <CameraPipeline_Init+0x6c>
34001bcc:	2151      	movs	r1, #81	@ 0x51
34001bce:	4b14      	ldr	r3, [pc, #80]	@ (34001c20 <CameraPipeline_Init+0xb8>)
34001bd0:	4a14      	ldr	r2, [pc, #80]	@ (34001c24 <CameraPipeline_Init+0xbc>)
34001bd2:	e7de      	b.n	34001b92 <CameraPipeline_Init+0x2a>
  assert(dcmipp_conf.output_width * dcmipp_conf.output_bpp == pitch);
34001bd4:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
34001bd6:	9b07      	ldr	r3, [sp, #28]
34001bd8:	4353      	muls	r3, r2
34001bda:	9a00      	ldr	r2, [sp, #0]
34001bdc:	4293      	cmp	r3, r2
34001bde:	d003      	beq.n	34001be8 <CameraPipeline_Init+0x80>
34001be0:	2152      	movs	r1, #82	@ 0x52
34001be2:	4b11      	ldr	r3, [pc, #68]	@ (34001c28 <CameraPipeline_Init+0xc0>)
34001be4:	4a0f      	ldr	r2, [pc, #60]	@ (34001c24 <CameraPipeline_Init+0xbc>)
34001be6:	e7d4      	b.n	34001b92 <CameraPipeline_Init+0x2a>
  dcmipp_conf.output_width = NN_WIDTH;
34001be8:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
  dcmipp_conf.output_height = NN_HEIGHT;
34001bec:	e9cd 3307 	strd	r3, r3, [sp, #28]
  dcmipp_conf.output_bpp = NN_BPP;
34001bf0:	2303      	movs	r3, #3
  dcmipp_conf.enable_gamma_conversion = GAMMA_CONVERSION;
34001bf2:	e9cd 400b 	strd	r4, r0, [sp, #44]	@ 0x2c
  dcmipp_conf.output_format = DCMIPP_PIXEL_PACKER_FORMAT_RGB888_YUV444_1;
34001bf6:	9009      	str	r0, [sp, #36]	@ 0x24
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &dcmipp_conf, pitch);
34001bf8:	462a      	mov	r2, r5
34001bfa:	4630      	mov	r0, r6
34001bfc:	a907      	add	r1, sp, #28
  dcmipp_conf.output_bpp = NN_BPP;
34001bfe:	930a      	str	r3, [sp, #40]	@ 0x28
  dcmipp_conf.mode = aspect_ratio;
34001c00:	940d      	str	r4, [sp, #52]	@ 0x34
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &dcmipp_conf, pitch);
34001c02:	f00e fd81 	bl	34010708 <CMW_CAMERA_SetPipeConfig>
  assert(ret == HAL_OK);
34001c06:	b118      	cbz	r0, 34001c10 <CameraPipeline_Init+0xa8>
34001c08:	2170      	movs	r1, #112	@ 0x70
34001c0a:	4b05      	ldr	r3, [pc, #20]	@ (34001c20 <CameraPipeline_Init+0xb8>)
34001c0c:	4a07      	ldr	r2, [pc, #28]	@ (34001c2c <CameraPipeline_Init+0xc4>)
34001c0e:	e7c0      	b.n	34001b92 <CameraPipeline_Init+0x2a>
  DCMIPP_PipeInitNn(pitch_nn);
}
34001c10:	b013      	add	sp, #76	@ 0x4c
34001c12:	bdf0      	pop	{r4, r5, r6, r7, pc}
34001c14:	3401d3d4 	.word	0x3401d3d4
34001c18:	34022e6c 	.word	0x34022e6c
34001c1c:	3401d3ea 	.word	0x3401d3ea
34001c20:	3401d49b 	.word	0x3401d49b
34001c24:	34022e55 	.word	0x34022e55
34001c28:	3401d4a9 	.word	0x3401d4a9
34001c2c:	34022e43 	.word	0x34022e43

34001c30 <CameraPipeline_DisplayPipe_Start>:
  ret = CMW_CAMERA_DeInit();
  assert(ret == CMW_ERROR_NONE);
}

void CameraPipeline_DisplayPipe_Start(uint8_t *display_pipe_dst, uint32_t cam_mode)
{
34001c30:	460a      	mov	r2, r1
34001c32:	b508      	push	{r3, lr}
  int ret;
  ret = CMW_CAMERA_Start(DCMIPP_PIPE1, display_pipe_dst, cam_mode);
34001c34:	4601      	mov	r1, r0
34001c36:	2001      	movs	r0, #1
34001c38:	f00e fe28 	bl	3401088c <CMW_CAMERA_Start>
  assert(ret == CMW_ERROR_NONE);
34001c3c:	b128      	cbz	r0, 34001c4a <CameraPipeline_DisplayPipe_Start+0x1a>
34001c3e:	2196      	movs	r1, #150	@ 0x96
34001c40:	4b02      	ldr	r3, [pc, #8]	@ (34001c4c <CameraPipeline_DisplayPipe_Start+0x1c>)
34001c42:	4a03      	ldr	r2, [pc, #12]	@ (34001c50 <CameraPipeline_DisplayPipe_Start+0x20>)
34001c44:	4803      	ldr	r0, [pc, #12]	@ (34001c54 <CameraPipeline_DisplayPipe_Start+0x24>)
34001c46:	f017 f909 	bl	34018e5c <__assert_func>
}
34001c4a:	bd08      	pop	{r3, pc}
34001c4c:	3401d3d4 	.word	0x3401d3d4
34001c50:	34022e22 	.word	0x34022e22
34001c54:	3401d3ea 	.word	0x3401d3ea

34001c58 <CameraPipeline_NNPipe_Start>:

void CameraPipeline_NNPipe_Start(uint8_t *nn_pipe_dst, uint32_t cam_mode)
{
34001c58:	460a      	mov	r2, r1
34001c5a:	b508      	push	{r3, lr}
  int ret;

  ret = CMW_CAMERA_Start(DCMIPP_PIPE2, nn_pipe_dst, cam_mode);
34001c5c:	4601      	mov	r1, r0
34001c5e:	2002      	movs	r0, #2
34001c60:	f00e fe14 	bl	3401088c <CMW_CAMERA_Start>
  assert(ret == CMW_ERROR_NONE);
34001c64:	b128      	cbz	r0, 34001c72 <CameraPipeline_NNPipe_Start+0x1a>
34001c66:	219e      	movs	r1, #158	@ 0x9e
34001c68:	4b02      	ldr	r3, [pc, #8]	@ (34001c74 <CameraPipeline_NNPipe_Start+0x1c>)
34001c6a:	4a03      	ldr	r2, [pc, #12]	@ (34001c78 <CameraPipeline_NNPipe_Start+0x20>)
34001c6c:	4803      	ldr	r0, [pc, #12]	@ (34001c7c <CameraPipeline_NNPipe_Start+0x24>)
34001c6e:	f017 f8f5 	bl	34018e5c <__assert_func>
}
34001c72:	bd08      	pop	{r3, pc}
34001c74:	3401d3d4 	.word	0x3401d3d4
34001c78:	34022e06 	.word	0x34022e06
34001c7c:	3401d3ea 	.word	0x3401d3ea

34001c80 <CameraPipeline_IspUpdate>:
  ret = CMW_CAMERA_Suspend(DCMIPP_PIPE1);
  assert(ret == CMW_ERROR_NONE);
}

void CameraPipeline_IspUpdate(void)
{
34001c80:	b508      	push	{r3, lr}
  int ret = CMW_ERROR_NONE;
  ret = CMW_CAMERA_Run();
34001c82:	f00e fee9 	bl	34010a58 <CMW_CAMERA_Run>
  assert(ret == CMW_ERROR_NONE);
34001c86:	b128      	cbz	r0, 34001c94 <CameraPipeline_IspUpdate+0x14>
34001c88:	21ac      	movs	r1, #172	@ 0xac
34001c8a:	4b03      	ldr	r3, [pc, #12]	@ (34001c98 <CameraPipeline_IspUpdate+0x18>)
34001c8c:	4a03      	ldr	r2, [pc, #12]	@ (34001c9c <CameraPipeline_IspUpdate+0x1c>)
34001c8e:	4804      	ldr	r0, [pc, #16]	@ (34001ca0 <CameraPipeline_IspUpdate+0x20>)
34001c90:	f017 f8e4 	bl	34018e5c <__assert_func>
}
34001c94:	bd08      	pop	{r3, pc}
34001c96:	bf00      	nop
34001c98:	3401d3d4 	.word	0x3401d3d4
34001c9c:	34022ded 	.word	0x34022ded
34001ca0:	3401d3ea 	.word	0x3401d3ea

34001ca4 <CMW_CAMERA_PIPE_FrameEventCallback>:
  * @param  hdcmipp pointer to the DCMIPP handle
  * @retval None
  */
int CMW_CAMERA_PIPE_FrameEventCallback(uint32_t pipe)
{
  switch (pipe)
34001ca4:	2802      	cmp	r0, #2
  {
    case DCMIPP_PIPE2 :
      cameraFrameReceived++;
34001ca6:	bf08      	it	eq
34001ca8:	4a03      	ldreq	r2, [pc, #12]	@ (34001cb8 <CMW_CAMERA_PIPE_FrameEventCallback+0x14>)
      break;
  }
  return 0;
}
34001caa:	f04f 0000 	mov.w	r0, #0
      cameraFrameReceived++;
34001cae:	bf02      	ittt	eq
34001cb0:	6813      	ldreq	r3, [r2, #0]
34001cb2:	3301      	addeq	r3, #1
34001cb4:	6013      	streq	r3, [r2, #0]
}
34001cb6:	4770      	bx	lr
34001cb8:	340cd15c 	.word	0x340cd15c

34001cbc <Fuse_Programming>:
/**
  * @brief  Check specific fuse configuration and update it if needed.
  * @retval None
  */
void Fuse_Programming(void)
{
34001cbc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint32_t fuse_id, bit_mask, data;

  BSEC_HandleTypeDef sBsecHandler;

  sBsecHandler.Instance = BSEC;
34001cbe:	4b15      	ldr	r3, [pc, #84]	@ (34001d14 <Fuse_Programming+0x58>)

  /* Read current value of fuse */
  fuse_id = BSEC_FUSE_ADDRESS;
  if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
34001cc0:	217c      	movs	r1, #124	@ 0x7c
34001cc2:	aa01      	add	r2, sp, #4
34001cc4:	a802      	add	r0, sp, #8
  sBsecHandler.Instance = BSEC;
34001cc6:	9302      	str	r3, [sp, #8]
  if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
34001cc8:	f003 f932 	bl	34004f30 <HAL_BSEC_OTP_Read>
34001ccc:	4603      	mov	r3, r0
34001cce:	b9e0      	cbnz	r0, 34001d0a <Fuse_Programming+0x4e>
  {
    /* Check if bit has already been set */
    bit_mask = BSEC_FUSE_MASK;
    if ((data & bit_mask) != bit_mask)
34001cd0:	9a01      	ldr	r2, [sp, #4]
34001cd2:	f402 31c0 	and.w	r1, r2, #98304	@ 0x18000
34001cd6:	f5b1 3fc0 	cmp.w	r1, #98304	@ 0x18000
34001cda:	d017      	beq.n	34001d0c <Fuse_Programming+0x50>
    {
      data |= bit_mask;
34001cdc:	f442 32c0 	orr.w	r2, r2, #98304	@ 0x18000
      /* Bitwise programming of lower bits */
      if (HAL_BSEC_OTP_Program(&sBsecHandler, fuse_id, data, HAL_BSEC_NORMAL_PROG) == HAL_OK)
34001ce0:	217c      	movs	r1, #124	@ 0x7c
34001ce2:	a802      	add	r0, sp, #8
      data |= bit_mask;
34001ce4:	9201      	str	r2, [sp, #4]
      if (HAL_BSEC_OTP_Program(&sBsecHandler, fuse_id, data, HAL_BSEC_NORMAL_PROG) == HAL_OK)
34001ce6:	f003 f93f 	bl	34004f68 <HAL_BSEC_OTP_Program>
34001cea:	b968      	cbnz	r0, 34001d08 <Fuse_Programming+0x4c>
      {
        /* Read lower bits to verify the correct programming */
        if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
34001cec:	217c      	movs	r1, #124	@ 0x7c
34001cee:	aa01      	add	r2, sp, #4
34001cf0:	a802      	add	r0, sp, #8
34001cf2:	f003 f91d 	bl	34004f30 <HAL_BSEC_OTP_Read>
34001cf6:	b930      	cbnz	r0, 34001d06 <Fuse_Programming+0x4a>
        {
          if ((data & bit_mask) != bit_mask)
34001cf8:	9b01      	ldr	r3, [sp, #4]
34001cfa:	f403 33c0 	and.w	r3, r3, #98304	@ 0x18000
34001cfe:	f5b3 3fc0 	cmp.w	r3, #98304	@ 0x18000
34001d02:	d003      	beq.n	34001d0c <Fuse_Programming+0x50>
34001d04:	e7fe      	b.n	34001d04 <Fuse_Programming+0x48>
34001d06:	e7fe      	b.n	34001d06 <Fuse_Programming+0x4a>
34001d08:	e7fe      	b.n	34001d08 <Fuse_Programming+0x4c>
34001d0a:	e7fe      	b.n	34001d0a <Fuse_Programming+0x4e>
  else
  {
    /* Error  : Fuse read unsuccessful */
    ErrorHandler();
  }
}
34001d0c:	b005      	add	sp, #20
34001d0e:	f85d fb04 	ldr.w	pc, [sp], #4
34001d12:	bf00      	nop
34001d14:	56009000 	.word	0x56009000

34001d18 <PersonCounter_Init>:
/**
 * @brief Initialise le compteur de personnes
 */
void PersonCounter_Init(void)
{
  memset(&counter_status, 0, sizeof(PersonCounter_Status_t));
34001d18:	2300      	movs	r3, #0
{
34001d1a:	b510      	push	{r4, lr}
  memset(&counter_status, 0, sizeof(PersonCounter_Status_t));
34001d1c:	4c03      	ldr	r4, [pc, #12]	@ (34001d2c <PersonCounter_Init+0x14>)
34001d1e:	e9c4 3300 	strd	r3, r3, [r4]
34001d22:	60a3      	str	r3, [r4, #8]
  counter_status.last_update_time = HAL_GetTick();
34001d24:	f003 f8aa 	bl	34004e7c <HAL_GetTick>
34001d28:	60a0      	str	r0, [r4, #8]
}
34001d2a:	bd10      	pop	{r4, pc}
34001d2c:	340b1624 	.word	0x340b1624

34001d30 <PersonCounter_Update>:
 * @brief Met  jour le compteur avec les rsultats de dtection
 * @param pp_output Pointeur vers les rsultats du post-processing
 * @return Nombre de personnes dtectes
 */
uint32_t PersonCounter_Update(od_pp_out_t *pp_output)
{
34001d30:	b538      	push	{r3, r4, r5, lr}
  if (pp_output == NULL)
  {
    return 0;
34001d32:	4604      	mov	r4, r0
  if (pp_output == NULL)
34001d34:	b1a0      	cbz	r0, 34001d60 <PersonCounter_Update+0x30>
  }

  uint32_t person_count = 0;
  od_pp_outBuffer_t *rois = pp_output->pOutBuff;
  uint32_t nb_rois = pp_output->nb_detect;
34001d36:	e9d0 2100 	ldrd	r2, r1, [r0]
34001d3a:	2318      	movs	r3, #24
  uint32_t person_count = 0;
34001d3c:	2400      	movs	r4, #0
34001d3e:	fb03 2301 	mla	r3, r3, r1, r2
34001d42:	480b      	ldr	r0, [pc, #44]	@ (34001d70 <PersonCounter_Update+0x40>)
34001d44:	1a9b      	subs	r3, r3, r2
34001d46:	08db      	lsrs	r3, r3, #3
34001d48:	4343      	muls	r3, r0
34001d4a:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
34001d4e:	3301      	adds	r3, #1

  /* Compter le nombre de personnes dtectes */
  for (uint32_t i = 0; i < nb_rois; i++)
34001d50:	3b01      	subs	r3, #1
34001d52:	d107      	bne.n	34001d64 <PersonCounter_Update+0x34>
      person_count++;
    }
  }

  /* Mise  jour du statut */
  counter_status.person_count = person_count;
34001d54:	4d07      	ldr	r5, [pc, #28]	@ (34001d74 <PersonCounter_Update+0x44>)
  counter_status.total_objects = nb_rois;
34001d56:	e9c5 4100 	strd	r4, r1, [r5]
  counter_status.last_update_time = HAL_GetTick();
34001d5a:	f003 f88f 	bl	34004e7c <HAL_GetTick>
34001d5e:	60a8      	str	r0, [r5, #8]

  return person_count;
}
34001d60:	4620      	mov	r0, r4
34001d62:	bd38      	pop	{r3, r4, r5, pc}
    if (rois[i].class_index == PERSON_CLASS_INDEX)
34001d64:	6950      	ldr	r0, [r2, #20]
34001d66:	3218      	adds	r2, #24
      person_count++;
34001d68:	2800      	cmp	r0, #0
34001d6a:	ea54 9414 			@ <UNDEFINED> instruction: 0xea549414
  for (uint32_t i = 0; i < nb_rois; i++)
34001d6e:	e7ef      	b.n	34001d50 <PersonCounter_Update+0x20>
34001d70:	0aaaaaab 	.word	0x0aaaaaab
34001d74:	340b1624 	.word	0x340b1624

34001d78 <app_postprocess_init>:
                                            AI_OD_ST_YOLOX_PP_L_GRID_WIDTH * AI_OD_ST_YOLOX_PP_L_GRID_HEIGHT +
                                            AI_OD_ST_YOLOX_PP_M_GRID_WIDTH * AI_OD_ST_YOLOX_PP_M_GRID_HEIGHT +
                                            AI_OD_ST_YOLOX_PP_S_GRID_WIDTH * AI_OD_ST_YOLOX_PP_S_GRID_HEIGHT)];

int32_t app_postprocess_init(void *params_postprocess, NN_Instance_TypeDef *NN_Instance)
{
34001d78:	b510      	push	{r4, lr}
34001d7a:	4604      	mov	r4, r0
    return nn_instance->network->output_getter(num);
  }

  static inline const LL_Buffer_InfoTypeDef *LL_ATON_Output_Buffers_Info(const NN_Instance_TypeDef *nn_instance)
  {
    assert((nn_instance != NULL) && (nn_instance->network != NULL) &&
34001d7c:	b119      	cbz	r1, 34001d86 <app_postprocess_init+0xe>
34001d7e:	680b      	ldr	r3, [r1, #0]
34001d80:	b10b      	cbz	r3, 34001d86 <app_postprocess_init+0xe>
34001d82:	6a1b      	ldr	r3, [r3, #32]
34001d84:	b933      	cbnz	r3, 34001d94 <app_postprocess_init+0x1c>
34001d86:	f240 1123 	movw	r1, #291	@ 0x123
34001d8a:	4b1e      	ldr	r3, [pc, #120]	@ (34001e04 <app_postprocess_init+0x8c>)
34001d8c:	4a1e      	ldr	r2, [pc, #120]	@ (34001e08 <app_postprocess_init+0x90>)
34001d8e:	481f      	ldr	r0, [pc, #124]	@ (34001e0c <app_postprocess_init+0x94>)
34001d90:	f017 f864 	bl	34018e5c <__assert_func>
           (nn_instance->network->output_buffers_info != NULL));
    return nn_instance->network->output_buffers_info();
34001d94:	4798      	blx	r3
  int32_t error = AI_OD_POSTPROCESS_ERROR_NO;
  od_st_yolox_pp_static_param_t *params = (od_st_yolox_pp_static_param_t *) params_postprocess;
  const LL_Buffer_InfoTypeDef *buffers_info = LL_ATON_Output_Buffers_Info(NN_Instance);
  params->raw_s_scale = *(buffers_info[0].scale);
34001d96:	6b03      	ldr	r3, [r0, #48]	@ 0x30
  params->raw_l_scale = *(buffers_info[1].scale);
  params->raw_l_zero_point = *(buffers_info[1].offset);
  params->raw_m_scale = *(buffers_info[2].scale);
  params->raw_m_zero_point = *(buffers_info[2].offset);
  params->nb_classes = AI_OD_ST_YOLOX_PP_NB_CLASSES;
  params->nb_anchors = AI_OD_ST_YOLOX_PP_NB_ANCHORS;
34001d98:	2201      	movs	r2, #1
  params->raw_s_scale = *(buffers_info[0].scale);
34001d9a:	681b      	ldr	r3, [r3, #0]
34001d9c:	64a3      	str	r3, [r4, #72]	@ 0x48
  params->raw_s_zero_point = *(buffers_info[0].offset);
34001d9e:	6b43      	ldr	r3, [r0, #52]	@ 0x34
34001da0:	881b      	ldrh	r3, [r3, #0]
34001da2:	f884 304e 	strb.w	r3, [r4, #78]	@ 0x4e
  params->raw_l_scale = *(buffers_info[1].scale);
34001da6:	6e83      	ldr	r3, [r0, #104]	@ 0x68
34001da8:	681b      	ldr	r3, [r3, #0]
34001daa:	6423      	str	r3, [r4, #64]	@ 0x40
  params->raw_l_zero_point = *(buffers_info[1].offset);
34001dac:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
34001dae:	881b      	ldrh	r3, [r3, #0]
34001db0:	f884 304c 	strb.w	r3, [r4, #76]	@ 0x4c
  params->raw_m_scale = *(buffers_info[2].scale);
34001db4:	f8d0 30a0 	ldr.w	r3, [r0, #160]	@ 0xa0
34001db8:	681b      	ldr	r3, [r3, #0]
34001dba:	6463      	str	r3, [r4, #68]	@ 0x44
  params->raw_m_zero_point = *(buffers_info[2].offset);
34001dbc:	f8d0 30a4 	ldr.w	r3, [r0, #164]	@ 0xa4
  params->pAnchors_M = AI_OD_ST_YOLOX_PP_M_ANCHORS;
  params->pAnchors_S = AI_OD_ST_YOLOX_PP_S_ANCHORS;
  params->max_boxes_limit = AI_OD_ST_YOLOX_PP_MAX_BOXES_LIMIT;
  params->conf_threshold = AI_OD_ST_YOLOX_PP_CONF_THRESHOLD;
  params->iou_threshold = AI_OD_ST_YOLOX_PP_IOU_THRESHOLD;
  error = od_st_yolox_pp_reset(params);
34001dc0:	4620      	mov	r0, r4
  params->raw_m_zero_point = *(buffers_info[2].offset);
34001dc2:	881b      	ldrh	r3, [r3, #0]
34001dc4:	f884 304d 	strb.w	r3, [r4, #77]	@ 0x4d
  params->nb_anchors = AI_OD_ST_YOLOX_PP_NB_ANCHORS;
34001dc8:	2303      	movs	r3, #3
34001dca:	e9c4 2300 	strd	r2, r3, [r4]
  params->grid_width_L = AI_OD_ST_YOLOX_PP_L_GRID_WIDTH;
34001dce:	233c      	movs	r3, #60	@ 0x3c
  params->grid_height_L = AI_OD_ST_YOLOX_PP_L_GRID_HEIGHT;
34001dd0:	e9c4 3302 	strd	r3, r3, [r4, #8]
  params->grid_width_M = AI_OD_ST_YOLOX_PP_M_GRID_WIDTH;
34001dd4:	231e      	movs	r3, #30
  params->grid_height_M = AI_OD_ST_YOLOX_PP_M_GRID_HEIGHT;
34001dd6:	e9c4 3304 	strd	r3, r3, [r4, #16]
  params->grid_width_S = AI_OD_ST_YOLOX_PP_S_GRID_WIDTH;
34001dda:	230f      	movs	r3, #15
  params->grid_height_S = AI_OD_ST_YOLOX_PP_S_GRID_HEIGHT;
34001ddc:	e9c4 3306 	strd	r3, r3, [r4, #24]
  params->pAnchors_L = AI_OD_ST_YOLOX_PP_L_ANCHORS;
34001de0:	4b0b      	ldr	r3, [pc, #44]	@ (34001e10 <app_postprocess_init+0x98>)
34001de2:	6323      	str	r3, [r4, #48]	@ 0x30
  params->pAnchors_M = AI_OD_ST_YOLOX_PP_M_ANCHORS;
34001de4:	4b0b      	ldr	r3, [pc, #44]	@ (34001e14 <app_postprocess_init+0x9c>)
34001de6:	6363      	str	r3, [r4, #52]	@ 0x34
  params->pAnchors_S = AI_OD_ST_YOLOX_PP_S_ANCHORS;
34001de8:	4b0b      	ldr	r3, [pc, #44]	@ (34001e18 <app_postprocess_init+0xa0>)
34001dea:	63a3      	str	r3, [r4, #56]	@ 0x38
  params->max_boxes_limit = AI_OD_ST_YOLOX_PP_MAX_BOXES_LIMIT;
34001dec:	2364      	movs	r3, #100	@ 0x64
34001dee:	6263      	str	r3, [r4, #36]	@ 0x24
  params->conf_threshold = AI_OD_ST_YOLOX_PP_CONF_THRESHOLD;
34001df0:	4b0a      	ldr	r3, [pc, #40]	@ (34001e1c <app_postprocess_init+0xa4>)
34001df2:	62a3      	str	r3, [r4, #40]	@ 0x28
  params->iou_threshold = AI_OD_ST_YOLOX_PP_IOU_THRESHOLD;
34001df4:	f04f 537c 	mov.w	r3, #1056964608	@ 0x3f000000
34001df8:	62e3      	str	r3, [r4, #44]	@ 0x2c
  return error;
}
34001dfa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  error = od_st_yolox_pp_reset(params);
34001dfe:	f014 b905 	b.w	3401600c <od_st_yolox_pp_reset>
34001e02:	bf00      	nop
34001e04:	3401d4e4 	.word	0x3401d4e4
34001e08:	34022e94 	.word	0x34022e94
34001e0c:	3401d553 	.word	0x3401d553
34001e10:	34022ee0 	.word	0x34022ee0
34001e14:	34022ec8 	.word	0x34022ec8
34001e18:	34022eb0 	.word	0x34022eb0
34001e1c:	3f19999a 	.word	0x3f19999a

34001e20 <app_postprocess_run>:

int32_t app_postprocess_run(void *pInput[], int nb_input, void *pOutput, void *pInput_param)
{
34001e20:	b51f      	push	{r0, r1, r2, r3, r4, lr}
34001e22:	460c      	mov	r4, r1
  assert(nb_input == 3);
34001e24:	2c03      	cmp	r4, #3
{
34001e26:	4611      	mov	r1, r2
34001e28:	461a      	mov	r2, r3
  assert(nb_input == 3);
34001e2a:	d005      	beq.n	34001e38 <app_postprocess_run+0x18>
34001e2c:	213e      	movs	r1, #62	@ 0x3e
34001e2e:	4b0a      	ldr	r3, [pc, #40]	@ (34001e58 <app_postprocess_run+0x38>)
34001e30:	4a0a      	ldr	r2, [pc, #40]	@ (34001e5c <app_postprocess_run+0x3c>)
34001e32:	480b      	ldr	r0, [pc, #44]	@ (34001e60 <app_postprocess_run+0x40>)
34001e34:	f017 f812 	bl	34018e5c <__assert_func>
  int32_t error = AI_OD_POSTPROCESS_ERROR_NO;
  ((od_st_yolox_pp_static_param_t *) pInput_param)->nb_detect = 0;
34001e38:	2300      	movs	r3, #0
34001e3a:	63d3      	str	r3, [r2, #60]	@ 0x3c
  od_pp_out_t *pObjDetOutput = (od_pp_out_t *) pOutput;
  pObjDetOutput->pOutBuff = out_detections;
34001e3c:	4b09      	ldr	r3, [pc, #36]	@ (34001e64 <app_postprocess_run+0x44>)
34001e3e:	600b      	str	r3, [r1, #0]
  od_st_yolox_pp_in_t pp_input = {
34001e40:	6843      	ldr	r3, [r0, #4]
34001e42:	9301      	str	r3, [sp, #4]
34001e44:	6883      	ldr	r3, [r0, #8]
34001e46:	9302      	str	r3, [sp, #8]
34001e48:	6803      	ldr	r3, [r0, #0]
      .pRaw_detections_S = (float32_t *) pInput[0],
      .pRaw_detections_L = (float32_t *) pInput[1],
      .pRaw_detections_M = (float32_t *) pInput[2],
  };
  error = od_st_yolox_pp_process_int8(&pp_input, pObjDetOutput,
34001e4a:	a801      	add	r0, sp, #4
  od_st_yolox_pp_in_t pp_input = {
34001e4c:	9303      	str	r3, [sp, #12]
  error = od_st_yolox_pp_process_int8(&pp_input, pObjDetOutput,
34001e4e:	f014 f8e1 	bl	34016014 <od_st_yolox_pp_process_int8>
                                 (od_st_yolox_pp_static_param_t *) pInput_param);
  return error;
}
34001e52:	b004      	add	sp, #16
34001e54:	bd10      	pop	{r4, pc}
34001e56:	bf00      	nop
34001e58:	3401d598 	.word	0x3401d598
34001e5c:	34022e80 	.word	0x34022e80
34001e60:	3401d5a6 	.word	0x3401d5a6
34001e64:	340b1630 	.word	0x340b1630

34001e68 <Delay_Us>:
/* Dlai bloquant en microsecondes utilisant DWT */
/* Note: SystemCoreClock est 800MHz. DWT cyccnt incrmente  cette vitesse. */
static void Delay_Us(uint32_t us)
{
    uint32_t start = DWT->CYCCNT;
    uint32_t cycles = us * (SystemCoreClock / 1000000);
34001e68:	4b06      	ldr	r3, [pc, #24]	@ (34001e84 <Delay_Us+0x1c>)
34001e6a:	4a07      	ldr	r2, [pc, #28]	@ (34001e88 <Delay_Us+0x20>)
34001e6c:	681b      	ldr	r3, [r3, #0]
    uint32_t start = DWT->CYCCNT;
34001e6e:	4907      	ldr	r1, [pc, #28]	@ (34001e8c <Delay_Us+0x24>)
    uint32_t cycles = us * (SystemCoreClock / 1000000);
34001e70:	fbb3 f3f2 	udiv	r3, r3, r2
34001e74:	4343      	muls	r3, r0
{
34001e76:	b510      	push	{r4, lr}
    uint32_t start = DWT->CYCCNT;
34001e78:	684c      	ldr	r4, [r1, #4]
    
    while ((DWT->CYCCNT - start) < cycles);
34001e7a:	684a      	ldr	r2, [r1, #4]
34001e7c:	1b12      	subs	r2, r2, r4
34001e7e:	429a      	cmp	r2, r3
34001e80:	d3fb      	bcc.n	34001e7a <Delay_Us+0x12>
}
34001e82:	bd10      	pop	{r4, pc}
34001e84:	340b0f2c 	.word	0x340b0f2c
34001e88:	000f4240 	.word	0x000f4240
34001e8c:	e0001000 	.word	0xe0001000

34001e90 <SoftSerial_Init>:

void SoftSerial_Init(void)
{
34001e90:	b5f0      	push	{r4, r5, r6, r7, lr}
  * @retval None
  */
__STATIC_INLINE void LL_AHB4_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34001e92:	2401      	movs	r4, #1
    GPIO_InitTypeDef GPIO_InitStruct = {0};
34001e94:	2500      	movs	r5, #0
34001e96:	4b1b      	ldr	r3, [pc, #108]	@ (34001f04 <SoftSerial_Init+0x74>)
{
34001e98:	b089      	sub	sp, #36	@ 0x24
    GPIO_InitTypeDef GPIO_InitStruct = {0};
34001e9a:	9507      	str	r5, [sp, #28]
34001e9c:	f8c3 4a5c 	str.w	r4, [r3, #2652]	@ 0xa5c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB4ENR);
34001ea0:	f8d3 225c 	ldr.w	r2, [r3, #604]	@ 0x25c
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    DWT->CYCCNT = 0;
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;

    /* Configure TX (PG2 / D11) */
    GPIO_InitStruct.Pin = SS_TX_PIN;
34001ea4:	2704      	movs	r7, #4
34001ea6:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
34001ea8:	9a02      	ldr	r2, [sp, #8]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34001eaa:	2240      	movs	r2, #64	@ 0x40
34001eac:	f8c3 2a5c 	str.w	r2, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34001eb0:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
34001eb4:	4a14      	ldr	r2, [pc, #80]	@ (34001f08 <SoftSerial_Init+0x78>)
34001eb6:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34001eb8:	9b01      	ldr	r3, [sp, #4]
34001eba:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(SS_TX_PORT, &GPIO_InitStruct);
34001ebe:	4e13      	ldr	r6, [pc, #76]	@ (34001f0c <SoftSerial_Init+0x7c>)
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
34001ec0:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
34001ec4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
    DWT->CYCCNT = 0;
34001ec8:	4b11      	ldr	r3, [pc, #68]	@ (34001f10 <SoftSerial_Init+0x80>)
    HAL_GPIO_Init(SS_TX_PORT, &GPIO_InitStruct);
34001eca:	4630      	mov	r0, r6
    DWT->CYCCNT = 0;
34001ecc:	605d      	str	r5, [r3, #4]
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
34001ece:	681a      	ldr	r2, [r3, #0]
    HAL_GPIO_Init(SS_TX_PORT, &GPIO_InitStruct);
34001ed0:	a903      	add	r1, sp, #12
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
34001ed2:	4322      	orrs	r2, r4
34001ed4:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
34001ed6:	2302      	movs	r3, #2
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34001ed8:	e9cd 7403 	strd	r7, r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
34001edc:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34001ede:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(SS_TX_PORT, &GPIO_InitStruct);
34001ee0:	f005 fede 	bl	34007ca0 <HAL_GPIO_Init>
    
    /* Idle State High */
    TX_HIGH();
34001ee4:	4622      	mov	r2, r4
34001ee6:	4639      	mov	r1, r7
34001ee8:	4630      	mov	r0, r6
34001eea:	f006 fa1f 	bl	3400832c <HAL_GPIO_WritePin>

    /* Configure RX (PA3 / D10) */
    GPIO_InitStruct.Pin = SS_RX_PIN;
34001eee:	2308      	movs	r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(SS_RX_PORT, &GPIO_InitStruct);
34001ef0:	4808      	ldr	r0, [pc, #32]	@ (34001f14 <SoftSerial_Init+0x84>)
34001ef2:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
34001ef4:	e9cd 3503 	strd	r3, r5, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
34001ef8:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(SS_RX_PORT, &GPIO_InitStruct);
34001efa:	f005 fed1 	bl	34007ca0 <HAL_GPIO_Init>
}
34001efe:	b009      	add	sp, #36	@ 0x24
34001f00:	bdf0      	pop	{r4, r5, r6, r7, pc}
34001f02:	bf00      	nop
34001f04:	56028000 	.word	0x56028000
34001f08:	e000ed00 	.word	0xe000ed00
34001f0c:	56021800 	.word	0x56021800
34001f10:	e0001000 	.word	0xe0001000
34001f14:	56020000 	.word	0x56020000

34001f18 <SoftSerial_WriteByte>:

void SoftSerial_WriteByte(uint8_t byte)
{
34001f18:	b570      	push	{r4, r5, r6, lr}
    /* Start Bit (Low) */
    TX_LOW();
34001f1a:	2200      	movs	r2, #0
34001f1c:	2104      	movs	r1, #4
{
34001f1e:	4604      	mov	r4, r0
    TX_LOW();
34001f20:	4810      	ldr	r0, [pc, #64]	@ (34001f64 <SoftSerial_WriteByte+0x4c>)
34001f22:	f006 fa03 	bl	3400832c <HAL_GPIO_WritePin>
    Delay_Us(BIT_DELAY_US);
34001f26:	2068      	movs	r0, #104	@ 0x68
34001f28:	f7ff ff9e 	bl	34001e68 <Delay_Us>
34001f2c:	2508      	movs	r5, #8
    
    /* Data Bits (LSB first) */
    for (int i = 0; i < 8; i++)
    {
        if (byte & 1) TX_HIGH();
        else          TX_LOW();
34001f2e:	4e0d      	ldr	r6, [pc, #52]	@ (34001f64 <SoftSerial_WriteByte+0x4c>)
        if (byte & 1) TX_HIGH();
34001f30:	f014 0201 	ands.w	r2, r4, #1
34001f34:	bf18      	it	ne
34001f36:	2201      	movne	r2, #1
        else          TX_LOW();
34001f38:	2104      	movs	r1, #4
34001f3a:	4630      	mov	r0, r6
34001f3c:	f006 f9f6 	bl	3400832c <HAL_GPIO_WritePin>
        
        Delay_Us(BIT_DELAY_US);
34001f40:	2068      	movs	r0, #104	@ 0x68
34001f42:	f7ff ff91 	bl	34001e68 <Delay_Us>
    for (int i = 0; i < 8; i++)
34001f46:	3d01      	subs	r5, #1
        byte >>= 1;
34001f48:	ea4f 0454 	mov.w	r4, r4, lsr #1
    for (int i = 0; i < 8; i++)
34001f4c:	d1f0      	bne.n	34001f30 <SoftSerial_WriteByte+0x18>
    }
    
    /* Stop Bit (High) */
    TX_HIGH();
34001f4e:	4805      	ldr	r0, [pc, #20]	@ (34001f64 <SoftSerial_WriteByte+0x4c>)
34001f50:	2201      	movs	r2, #1
34001f52:	2104      	movs	r1, #4
34001f54:	f006 f9ea 	bl	3400832c <HAL_GPIO_WritePin>
    Delay_Us(BIT_DELAY_US);
}
34001f58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Delay_Us(BIT_DELAY_US);
34001f5c:	2068      	movs	r0, #104	@ 0x68
34001f5e:	f7ff bf83 	b.w	34001e68 <Delay_Us>
34001f62:	bf00      	nop
34001f64:	56021800 	.word	0x56021800

34001f68 <SoftSerial_Print>:

void SoftSerial_Print(const char* str)
{
34001f68:	b510      	push	{r4, lr}
34001f6a:	1e44      	subs	r4, r0, #1
    while (*str)
34001f6c:	f814 0f01 	ldrb.w	r0, [r4, #1]!
34001f70:	b900      	cbnz	r0, 34001f74 <SoftSerial_Print+0xc>
    {
        SoftSerial_WriteByte((uint8_t)*str++);
    }
}
34001f72:	bd10      	pop	{r4, pc}
        SoftSerial_WriteByte((uint8_t)*str++);
34001f74:	f7ff ffd0 	bl	34001f18 <SoftSerial_WriteByte>
34001f78:	e7f8      	b.n	34001f6c <SoftSerial_Print+0x4>
	...

34001f7c <Log_Status>:
/* Private variables */
static uint8_t wifi_connected = 1; /* Assumed managed by ESP8266 */

/* Helper pour afficher sur LCD et Srie */
static void Log_Status(const char* fmt, ...)
{
34001f7c:	b40f      	push	{r0, r1, r2, r3}
34001f7e:	b510      	push	{r4, lr}
34001f80:	b094      	sub	sp, #80	@ 0x50
34001f82:	ab16      	add	r3, sp, #88	@ 0x58
34001f84:	f853 2b04 	ldr.w	r2, [r3], #4
    char buf[64];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buf, sizeof(buf), fmt, args);
34001f88:	ac04      	add	r4, sp, #16
34001f8a:	2140      	movs	r1, #64	@ 0x40
34001f8c:	4620      	mov	r0, r4
    va_start(args, fmt);
34001f8e:	9303      	str	r3, [sp, #12]
    vsnprintf(buf, sizeof(buf), fmt, args);
34001f90:	f018 f80c 	bl	34019fac <vsniprintf>
    va_end(args);
    
    printf("%s\r\n", buf);
34001f94:	4621      	mov	r1, r4
34001f96:	4811      	ldr	r0, [pc, #68]	@ (34001fdc <Log_Status+0x60>)
34001f98:	f017 fef0 	bl	34019d7c <iprintf>
    
    /* Affichage en bas de l'cran */
    UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLACK);
34001f9c:	f04f 407f 	mov.w	r0, #4278190080	@ 0xff000000
34001fa0:	f013 fb38 	bl	34015614 <UTIL_LCD_SetBackColor>
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_YELLOW);
34001fa4:	f06f 00ff 	mvn.w	r0, #255	@ 0xff
34001fa8:	f013 fb2c 	bl	34015604 <UTIL_LCD_SetTextColor>
    UTIL_LCDEx_PrintfAt(0, 440, CENTER_MODE, "                    "); /* Clear line */
34001fac:	2201      	movs	r2, #1
34001fae:	f44f 71dc 	mov.w	r1, #440	@ 0x1b8
34001fb2:	2000      	movs	r0, #0
34001fb4:	4b0a      	ldr	r3, [pc, #40]	@ (34001fe0 <Log_Status+0x64>)
34001fb6:	f000 ffcf 	bl	34002f58 <UTIL_LCDEx_PrintfAt>
    UTIL_LCDEx_PrintfAt(0, 440, CENTER_MODE, "%s", buf);
34001fba:	2201      	movs	r2, #1
34001fbc:	f44f 71dc 	mov.w	r1, #440	@ 0x1b8
34001fc0:	4b08      	ldr	r3, [pc, #32]	@ (34001fe4 <Log_Status+0x68>)
34001fc2:	2000      	movs	r0, #0
34001fc4:	9400      	str	r4, [sp, #0]
34001fc6:	f000 ffc7 	bl	34002f58 <UTIL_LCDEx_PrintfAt>
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
34001fca:	f04f 30ff 	mov.w	r0, #4294967295
34001fce:	f013 fb19 	bl	34015604 <UTIL_LCD_SetTextColor>
}
34001fd2:	b014      	add	sp, #80	@ 0x50
34001fd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34001fd8:	b004      	add	sp, #16
34001fda:	4770      	bx	lr
34001fdc:	3401d66b 	.word	0x3401d66b
34001fe0:	3401d670 	.word	0x3401d670
34001fe4:	34021f92 	.word	0x34021f92

34001fe8 <WiFi_Init>:

/**
 * @brief Initialise le module de communication
 */
void WiFi_Init(void)
{
34001fe8:	b508      	push	{r3, lr}
    /* Init Software Serial (D10/D11) @ 9600 baud */
    SoftSerial_Init();
34001fea:	f7ff ff51 	bl	34001e90 <SoftSerial_Init>

    /* Dlai pour laisser le module ESP8266 dmarrer */
    HAL_Delay(2000);
34001fee:	f44f 60fa 	mov.w	r0, #2000	@ 0x7d0
34001ff2:	f002 ff49 	bl	34004e88 <HAL_Delay>

    Log_Status("ESP Link Ready");
}
34001ff6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Log_Status("ESP Link Ready");
34001ffa:	4801      	ldr	r0, [pc, #4]	@ (34002000 <WiFi_Init+0x18>)
34001ffc:	f7ff bfbe 	b.w	34001f7c <Log_Status>
34002000:	3401d685 	.word	0x3401d685

34002004 <MQTT_Publish_PersonCount>:
/**
 * @brief Envoie le nombre de personnes  l'ESP8266
 * Protocole: "COUNT:<n>\n"
 */
void MQTT_Publish_PersonCount(uint32_t count)
{
34002004:	b570      	push	{r4, r5, r6, lr}
    static uint32_t last_published_count = 0xFFFFFFFF;
    static uint32_t last_publish_time = 0;
    const uint32_t HEARTBEAT_DELAY = 10000; /* 10 secondes heartbeat */

    /* Publier si le compte a chang OU si le dlai heartbeat est dpass */
    if (count != last_published_count || (HAL_GetTick() - last_publish_time > HEARTBEAT_DELAY))
34002006:	4e11      	ldr	r6, [pc, #68]	@ (3400204c <MQTT_Publish_PersonCount+0x48>)
{
34002008:	4604      	mov	r4, r0
    if (count != last_published_count || (HAL_GetTick() - last_publish_time > HEARTBEAT_DELAY))
3400200a:	6833      	ldr	r3, [r6, #0]
3400200c:	4d10      	ldr	r5, [pc, #64]	@ (34002050 <MQTT_Publish_PersonCount+0x4c>)
3400200e:	4283      	cmp	r3, r0
{
34002010:	b088      	sub	sp, #32
    if (count != last_published_count || (HAL_GetTick() - last_publish_time > HEARTBEAT_DELAY))
34002012:	d012      	beq.n	3400203a <MQTT_Publish_PersonCount+0x36>
    {
        char msg[32];
        /* Format simple que l'ESP8266 va parser */
        snprintf(msg, sizeof(msg), "COUNT:%lu\n", count);
34002014:	4623      	mov	r3, r4
34002016:	4a0f      	ldr	r2, [pc, #60]	@ (34002054 <MQTT_Publish_PersonCount+0x50>)
34002018:	2120      	movs	r1, #32
3400201a:	4668      	mov	r0, sp
3400201c:	f017 ff1e 	bl	34019e5c <sniprintf>
        
        /* Envoi via Software Serial */
        SoftSerial_Print(msg);
34002020:	4668      	mov	r0, sp
34002022:	f7ff ffa1 	bl	34001f68 <SoftSerial_Print>
        
        Log_Status("Sent: %lu", count);
34002026:	4621      	mov	r1, r4
34002028:	480b      	ldr	r0, [pc, #44]	@ (34002058 <MQTT_Publish_PersonCount+0x54>)
3400202a:	f7ff ffa7 	bl	34001f7c <Log_Status>
        
        last_published_count = count;
3400202e:	6034      	str	r4, [r6, #0]
        last_publish_time = HAL_GetTick();
34002030:	f002 ff24 	bl	34004e7c <HAL_GetTick>
34002034:	6028      	str	r0, [r5, #0]
    }
}
34002036:	b008      	add	sp, #32
34002038:	bd70      	pop	{r4, r5, r6, pc}
    if (count != last_published_count || (HAL_GetTick() - last_publish_time > HEARTBEAT_DELAY))
3400203a:	f002 ff1f 	bl	34004e7c <HAL_GetTick>
3400203e:	682b      	ldr	r3, [r5, #0]
34002040:	1ac0      	subs	r0, r0, r3
34002042:	f242 7310 	movw	r3, #10000	@ 0x2710
34002046:	4298      	cmp	r0, r3
34002048:	d8e4      	bhi.n	34002014 <MQTT_Publish_PersonCount+0x10>
3400204a:	e7f4      	b.n	34002036 <MQTT_Publish_PersonCount+0x32>
3400204c:	340b0ee4 	.word	0x340b0ee4
34002050:	340cd128 	.word	0x340cd128
34002054:	3401d694 	.word	0x3401d694
34002058:	3401d69f 	.word	0x3401d69f

3400205c <img_crop>:
#include <assert.h>

void img_crop(uint8_t *src_image, uint8_t *dst_img, const uint32_t src_stride,
              const uint16_t dst_width, const uint16_t height,
              const uint16_t dst_bpp)
{
3400205c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34002060:	460d      	mov	r5, r1
  const uint8_t *pIn = src_image;
  uint8_t *pOut = dst_img;
  const uint32_t dst_line_size = (dst_width * dst_bpp);
34002062:	4604      	mov	r4, r0

  /* Copy line per line */
  for (uint32_t i = 0; i < height; i++)
34002064:	2700      	movs	r7, #0
{
34002066:	4690      	mov	r8, r2
  const uint32_t dst_line_size = (dst_width * dst_bpp);
34002068:	f8bd 2024 	ldrh.w	r2, [sp, #36]	@ 0x24
{
3400206c:	f8bd 9020 	ldrh.w	r9, [sp, #32]
  const uint32_t dst_line_size = (dst_width * dst_bpp);
34002070:	fb02 f603 	mul.w	r6, r2, r3
  for (uint32_t i = 0; i < height; i++)
34002074:	45b9      	cmp	r9, r7
34002076:	d801      	bhi.n	3400207c <img_crop+0x20>
  {
    memcpy(pOut, pIn + (i * src_stride), dst_line_size);
    pOut += dst_line_size;
  }
34002078:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    memcpy(pOut, pIn + (i * src_stride), dst_line_size);
3400207c:	4621      	mov	r1, r4
3400207e:	4628      	mov	r0, r5
34002080:	4632      	mov	r2, r6
34002082:	f018 fae6 	bl	3401a652 <memcpy>
    pOut += dst_line_size;
34002086:	4435      	add	r5, r6
  for (uint32_t i = 0; i < height; i++)
34002088:	3701      	adds	r7, #1
3400208a:	4444      	add	r4, r8
3400208c:	e7f2      	b.n	34002074 <img_crop+0x18>
	...

34002090 <LL_MEM_EnableClock>:
  WRITE_REG(RCC->MEMENSR, Memories);
34002090:	4b04      	ldr	r3, [pc, #16]	@ (340020a4 <LL_MEM_EnableClock+0x14>)
{
34002092:	b082      	sub	sp, #8
  WRITE_REG(RCC->MEMENSR, Memories);
34002094:	f8c3 0a4c 	str.w	r0, [r3, #2636]	@ 0xa4c
  tmpreg = READ_REG(RCC->MEMENR);
34002098:	f8d3 324c 	ldr.w	r3, [r3, #588]	@ 0x24c
3400209c:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400209e:	9b01      	ldr	r3, [sp, #4]
}
340020a0:	b002      	add	sp, #8
340020a2:	4770      	bx	lr
340020a4:	56028000 	.word	0x56028000

340020a8 <LL_MEM_EnableClockLowPower>:
  WRITE_REG(RCC->MEMLPENSR, Memories);
340020a8:	4b04      	ldr	r3, [pc, #16]	@ (340020bc <LL_MEM_EnableClockLowPower+0x14>)
{
340020aa:	b082      	sub	sp, #8
  WRITE_REG(RCC->MEMLPENSR, Memories);
340020ac:	f8c3 0a8c 	str.w	r0, [r3, #2700]	@ 0xa8c
  tmpreg = READ_REG(RCC->MEMLPENR);
340020b0:	f8d3 328c 	ldr.w	r3, [r3, #652]	@ 0x28c
340020b4:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
340020b6:	9b01      	ldr	r3, [sp, #4]
}
340020b8:	b002      	add	sp, #8
340020ba:	4770      	bx	lr
340020bc:	56028000 	.word	0x56028000

340020c0 <LL_AHB5_GRP1_EnableClockLowPower>:
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5LPENSR, Periphs);
340020c0:	4b04      	ldr	r3, [pc, #16]	@ (340020d4 <LL_AHB5_GRP1_EnableClockLowPower+0x14>)
{
340020c2:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB5LPENSR, Periphs);
340020c4:	f8c3 0aa0 	str.w	r0, [r3, #2720]	@ 0xaa0
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5LPENR);
340020c8:	f8d3 32a0 	ldr.w	r3, [r3, #672]	@ 0x2a0
340020cc:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
340020ce:	9b01      	ldr	r3, [sp, #4]
}
340020d0:	b002      	add	sp, #8
340020d2:	4770      	bx	lr
340020d4:	56028000 	.word	0x56028000

340020d8 <Hardware_init>:
  }
}


static void Hardware_init(void)
{
340020d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  /* Power on ICACHE */
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_ICACTIVE_Msk;
340020dc:	4a64      	ldr	r2, [pc, #400]	@ (34002270 <Hardware_init+0x198>)
{
340020de:	f5ad 7d24 	sub.w	sp, sp, #656	@ 0x290
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_ICACTIVE_Msk;
340020e2:	6813      	ldr	r3, [r2, #0]
340020e4:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
340020e8:	6013      	str	r3, [r2, #0]
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_IC1
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetCpuClkSource(uint32_t Source)
{
  MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, Source);
340020ea:	4b62      	ldr	r3, [pc, #392]	@ (34002274 <Hardware_init+0x19c>)
340020ec:	6a1a      	ldr	r2, [r3, #32]
340020ee:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
340020f2:	621a      	str	r2, [r3, #32]
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_IC2_IC6_IC11
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSysClkSource(uint32_t Source)
{
  MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, Source);
340020f4:	6a1a      	ldr	r2, [r3, #32]
340020f6:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
340020fa:	621a      	str	r2, [r3, #32]

  /* Set back system and CPU clock source to HSI */
  __HAL_RCC_CPUCLK_CONFIG(RCC_CPUCLKSOURCE_HSI);
  __HAL_RCC_SYSCLK_CONFIG(RCC_SYSCLKSOURCE_HSI);

  HAL_Init();
340020fc:	f002 fea0 	bl	34004e40 <HAL_Init>
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34002100:	4b5d      	ldr	r3, [pc, #372]	@ (34002278 <Hardware_init+0x1a0>)
34002102:	695a      	ldr	r2, [r3, #20]
34002104:	f412 3200 	ands.w	r2, r2, #131072	@ 0x20000
34002108:	d111      	bne.n	3400212e <Hardware_init+0x56>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
3400210a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3400210e:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
34002112:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
34002116:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3400211a:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
3400211e:	695a      	ldr	r2, [r3, #20]
34002120:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
34002124:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
34002126:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3400212a:	f3bf 8f6f 	isb	sy

  SCB_EnableICache();

#if defined(USE_DCACHE)
  /* Power on DCACHE */
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_DCACTIVE_Msk;
3400212e:	4a50      	ldr	r2, [pc, #320]	@ (34002270 <Hardware_init+0x198>)
34002130:	6813      	ldr	r3, [r2, #0]
34002132:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
34002136:	6013      	str	r3, [r2, #0]
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
34002138:	f5a2 4273 	sub.w	r2, r2, #62208	@ 0xf300
3400213c:	6953      	ldr	r3, [r2, #20]
3400213e:	f413 3380 	ands.w	r3, r3, #65536	@ 0x10000
34002142:	d128      	bne.n	34002196 <Hardware_init+0xbe>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
34002144:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34002148:	f3bf 8f4f 	dsb	sy
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
3400214c:	f643 74e0 	movw	r4, #16352	@ 0x3fe0
    ccsidr = SCB->CCSIDR;
34002150:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
34002154:	f3c3 00c9 	ubfx	r0, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
34002158:	f3c3 334e 	ubfx	r3, r3, #13, #15
3400215c:	015b      	lsls	r3, r3, #5
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
3400215e:	f100 0e01 	add.w	lr, r0, #1
34002162:	4601      	mov	r1, r0
34002164:	f04e e001 	dls	lr, lr
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34002168:	ea03 0604 	and.w	r6, r3, r4
3400216c:	ea46 7581 	orr.w	r5, r6, r1, lsl #30
34002170:	f8c2 5260 	str.w	r5, [r2, #608]	@ 0x260
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
34002174:	3901      	subs	r1, #1
34002176:	f00f c807 	le	lr, 3400216c <Hardware_init+0x94>
    } while(sets-- != 0U);
3400217a:	3b20      	subs	r3, #32
3400217c:	f113 0f20 	cmn.w	r3, #32
34002180:	d1ed      	bne.n	3400215e <Hardware_init+0x86>
34002182:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
34002186:	6953      	ldr	r3, [r2, #20]
34002188:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3400218c:	6153      	str	r3, [r2, #20]
3400218e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34002192:	f3bf 8f6f 	isb	sy
  return ret;
}

static void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
34002196:	2240      	movs	r2, #64	@ 0x40
34002198:	2100      	movs	r1, #0
3400219a:	a80a      	add	r0, sp, #40	@ 0x28
3400219c:	f017 ffc2 	bl	3401a124 <memset>
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
340021a0:	2298      	movs	r2, #152	@ 0x98
340021a2:	2100      	movs	r1, #0
340021a4:	a81a      	add	r0, sp, #104	@ 0x68
340021a6:	f017 ffbd 	bl	3401a124 <memset>
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
340021aa:	f44f 72c8 	mov.w	r2, #400	@ 0x190
340021ae:	2100      	movs	r1, #0
340021b0:	a840      	add	r0, sp, #256	@ 0x100
340021b2:	f017 ffb7 	bl	3401a124 <memset>

  /* Ensure VDDCORE=0.9V before increasing the system frequency */
  BSP_SMPS_Init(SMPS_VOLTAGE_OVERDRIVE);
340021b6:	2001      	movs	r0, #1
340021b8:	f001 fab4 	bl	34003724 <BSP_SMPS_Init>
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL1.PLLM = 2;
  RCC_OscInitStruct.PLL1.PLLN = 25;
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
  RCC_OscInitStruct.PLL1.PLLP1 = 1;
340021bc:	2601      	movs	r6, #1
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
340021be:	2300      	movs	r3, #0
  RCC_OscInitStruct.PLL1.PLLN = 25;
340021c0:	2219      	movs	r2, #25
  /* PLL2 = 64 x 125 / 8 = 1000MHz */
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL2.PLLM = 8;
  RCC_OscInitStruct.PLL2.PLLFractional = 0;
  RCC_OscInitStruct.PLL2.PLLN = 125;
340021c2:	217d      	movs	r1, #125	@ 0x7d
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
340021c4:	2502      	movs	r5, #2
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
340021c6:	e9cd 3227 	strd	r3, r2, [sp, #156]	@ 0x9c
  RCC_OscInitStruct.PLL2.PLLP1 = 1;
340021ca:	e9cd 162f 	strd	r1, r6, [sp, #188]	@ 0xbc
  RCC_OscInitStruct.PLL2.PLLM = 8;
340021ce:	2208      	movs	r2, #8

  /* PLL3 = (64 x 225 / 8) / (1 * 2) = 900MHz */
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL3.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL3.PLLM = 8;
  RCC_OscInitStruct.PLL3.PLLN = 225;
340021d0:	21e1      	movs	r1, #225	@ 0xe1
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
340021d2:	e9cd 5324 	strd	r5, r3, [sp, #144]	@ 0x90
  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
340021d6:	e9cd 532b 	strd	r5, r3, [sp, #172]	@ 0xac
  RCC_OscInitStruct.PLL2.PLLFractional = 0;
340021da:	e9cd 232d 	strd	r2, r3, [sp, #180]	@ 0xb4
  RCC_OscInitStruct.PLL3.PLLM = 8;
340021de:	e9cd 3233 	strd	r3, r2, [sp, #204]	@ 0xcc
  RCC_OscInitStruct.PLL3.PLLFractional = 0;
340021e2:	e9cd 3135 	strd	r3, r1, [sp, #212]	@ 0xd4
  RCC_OscInitStruct.PLL3.PLLP1 = 1;
  RCC_OscInitStruct.PLL3.PLLP2 = 2;

  /* PLL4 = (64 x 225 / 8) / (6 * 6) = 50 MHz */
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL4.PLLSource = RCC_PLLSOURCE_HSI;
340021e6:	e9cd 5339 	strd	r5, r3, [sp, #228]	@ 0xe4
  RCC_OscInitStruct.PLL4.PLLM = 8;
  RCC_OscInitStruct.PLL4.PLLFractional = 0;
340021ea:	e9cd 233b 	strd	r2, r3, [sp, #236]	@ 0xec
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
340021ee:	931a      	str	r3, [sp, #104]	@ 0x68
  RCC_OscInitStruct.PLL4.PLLN = 225;
  RCC_OscInitStruct.PLL4.PLLP1 = 6;
340021f0:	2306      	movs	r3, #6
  RCC_OscInitStruct.PLL4.PLLP2 = 6;

  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
340021f2:	a81a      	add	r0, sp, #104	@ 0x68
  RCC_OscInitStruct.PLL1.PLLP2 = 1;
340021f4:	e9cd 6629 	strd	r6, r6, [sp, #164]	@ 0xa4
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
340021f8:	e9cd 6531 	strd	r6, r5, [sp, #196]	@ 0xc4
  RCC_OscInitStruct.PLL3.PLLP2 = 2;
340021fc:	e9cd 6537 	strd	r6, r5, [sp, #220]	@ 0xdc
  RCC_OscInitStruct.PLL4.PLLP2 = 6;
34002200:	e9cd 333e 	strd	r3, r3, [sp, #248]	@ 0xf8
  RCC_OscInitStruct.PLL1.PLLM = 2;
34002204:	9526      	str	r5, [sp, #152]	@ 0x98
  RCC_OscInitStruct.PLL4.PLLN = 225;
34002206:	913d      	str	r1, [sp, #244]	@ 0xf4
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34002208:	f007 fcd0 	bl	34009bac <HAL_RCC_OscConfig>
3400220c:	b100      	cbz	r0, 34002210 <Hardware_init+0x138>
  {
    while(1);
3400220e:	e7fe      	b.n	3400220e <Hardware_init+0x136>
                                 RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 |
                                 RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_PCLK4 |
                                 RCC_CLOCKTYPE_PCLK5);

  /* CPU CLock (sysa_ck) = ic1_ck = PLL1 output/ic1_divider = 800 MHz */
  RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
34002210:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
34002214:	277f      	movs	r7, #127	@ 0x7f
34002216:	e9cd 730a 	strd	r7, r3, [sp, #40]	@ 0x28
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
3400221a:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
3400221e:	930c      	str	r3, [sp, #48]	@ 0x30
  /* AXI Clock (sysb_ck) = ic2_ck = PLL1 output/ic2_divider = 400 MHz */
  RCC_ClkInitStruct.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 2;

  /* NPU Clock (sysc_ck) = ic6_ck = PLL2 output/ic6_divider = 1000 MHz */
  RCC_ClkInitStruct.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL2;
34002220:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
  RCC_ClkInitStruct.IC6Selection.ClockDivider = 1;
34002224:	e9cd 3616 	strd	r3, r6, [sp, #88]	@ 0x58

  /* AXISRAM3/4/5/6 Clock (sysd_ck) = ic11_ck = PLL3 output/ic11_divider = 900 MHz */
  RCC_ClkInitStruct.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL3;
34002228:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
  RCC_ClkInitStruct.IC11Selection.ClockDivider = 1;
3400222c:	e9cd 3618 	strd	r3, r6, [sp, #96]	@ 0x60

  /* HCLK = sysb_ck / HCLK divider = 200 MHz */
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
34002230:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
  RCC_ClkInitStruct.IC1Selection.ClockDivider = 1;
34002234:	e9cd 0612 	strd	r0, r6, [sp, #72]	@ 0x48
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 2;
34002238:	e9cd 0514 	strd	r0, r5, [sp, #80]	@ 0x50

  /* PCLKx = HCLK / PCLKx divider = 200 MHz */
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
3400223c:	e9cd 300d 	strd	r3, r0, [sp, #52]	@ 0x34
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
34002240:	e9cd 000f 	strd	r0, r0, [sp, #60]	@ 0x3c
  RCC_ClkInitStruct.APB5CLKDivider = RCC_APB5_DIV1;
34002244:	9011      	str	r0, [sp, #68]	@ 0x44

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34002246:	a80a      	add	r0, sp, #40	@ 0x28
34002248:	f008 f8ac 	bl	3400a3a4 <HAL_RCC_ClockConfig>
3400224c:	b100      	cbz	r0, 34002250 <Hardware_init+0x178>
  {
    while(1);
3400224e:	e7fe      	b.n	3400224e <Hardware_init+0x176>

  RCC_PeriphCLKInitStruct.PeriphClockSelection = 0;

  /* XSPI1 kernel clock (ck_ker_xspi1) = HCLK = 200MHz */
  RCC_PeriphCLKInitStruct.PeriphClockSelection |= RCC_PERIPHCLK_XSPI1;
  RCC_PeriphCLKInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34002250:	4b0a      	ldr	r3, [pc, #40]	@ (3400227c <Hardware_init+0x1a4>)

  /* XSPI2 kernel clock (ck_ker_xspi1) = HCLK =  200MHz */
  RCC_PeriphCLKInitStruct.PeriphClockSelection |= RCC_PERIPHCLK_XSPI2;
34002252:	2200      	movs	r2, #0
  RCC_PeriphCLKInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34002254:	936b      	str	r3, [sp, #428]	@ 0x1ac
  RCC_PeriphCLKInitStruct.PeriphClockSelection |= RCC_PERIPHCLK_XSPI2;
34002256:	f44f 0340 	mov.w	r3, #12582912	@ 0xc00000
3400225a:	e9cd 2340 	strd	r2, r3, [sp, #256]	@ 0x100
  RCC_PeriphCLKInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
3400225e:	4b08      	ldr	r3, [pc, #32]	@ (34002280 <Hardware_init+0x1a8>)

  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34002260:	a840      	add	r0, sp, #256	@ 0x100
  RCC_PeriphCLKInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
34002262:	936c      	str	r3, [sp, #432]	@ 0x1b0
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34002264:	f008 fc18 	bl	3400aa98 <HAL_RCCEx_PeriphCLKConfig>
34002268:	4604      	mov	r4, r0
3400226a:	b158      	cbz	r0, 34002284 <Hardware_init+0x1ac>
  {
    while (1);
3400226c:	e7fe      	b.n	3400226c <Hardware_init+0x194>
3400226e:	bf00      	nop
34002270:	e001e000 	.word	0xe001e000
34002274:	56028000 	.word	0x56028000
34002278:	e000ed00 	.word	0xe000ed00
3400227c:	03000014 	.word	0x03000014
34002280:	03000414 	.word	0x03000414
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34002284:	2210      	movs	r2, #16
34002286:	4bae      	ldr	r3, [pc, #696]	@ (34002540 <Hardware_init+0x468>)
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
34002288:	48ae      	ldr	r0, [pc, #696]	@ (34002544 <Hardware_init+0x46c>)
3400228a:	f8c3 2a5c 	str.w	r2, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
3400228e:	f8d3 125c 	ldr.w	r1, [r3, #604]	@ 0x25c
34002292:	9103      	str	r1, [sp, #12]
  (void)tmpreg;
34002294:	9903      	ldr	r1, [sp, #12]
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB2ENSR, Periphs);
34002296:	f8c3 2a6c 	str.w	r2, [r3, #2668]	@ 0xa6c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB2ENR);
3400229a:	f8d3 326c 	ldr.w	r3, [r3, #620]	@ 0x26c
3400229e:	a91a      	add	r1, sp, #104	@ 0x68
340022a0:	9302      	str	r3, [sp, #8]
  (void)tmpreg;
340022a2:	9b02      	ldr	r3, [sp, #8]
  GPIO_InitStruct.Pin = GPIO_PIN_5 | GPIO_PIN_6;
340022a4:	2360      	movs	r3, #96	@ 0x60
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
340022a6:	e9cd 351a 	strd	r3, r5, [sp, #104]	@ 0x68
  GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
340022aa:	2307      	movs	r3, #7
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
340022ac:	e9cd 651c 	strd	r6, r5, [sp, #112]	@ 0x70
  GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
340022b0:	931e      	str	r3, [sp, #120]	@ 0x78
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
340022b2:	f005 fcf5 	bl	34007ca0 <HAL_GPIO_Init>
  hcom_uart[0].Init.BaudRate = 115200;
340022b6:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
  hcom_uart[0].Instance = USART1;  /* COM1 = hcom_uart[0] */
340022ba:	48a3      	ldr	r0, [pc, #652]	@ (34002548 <Hardware_init+0x470>)
  hcom_uart[0].Init.BaudRate = 115200;
340022bc:	4da3      	ldr	r5, [pc, #652]	@ (3400254c <Hardware_init+0x474>)
  hcom_uart[0].Init.StopBits = UART_STOPBITS_1;
340022be:	e9c0 4402 	strd	r4, r4, [r0, #8]
  hcom_uart[0].Init.BaudRate = 115200;
340022c2:	e9c0 5300 	strd	r5, r3, [r0]
  hcom_uart[0].Init.Mode = UART_MODE_TX_RX;
340022c6:	230c      	movs	r3, #12
  hcom_uart[0].Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
340022c8:	e9c0 4407 	strd	r4, r4, [r0, #28]
  hcom_uart[0].Init.HwFlowCtl = UART_HWCONTROL_NONE;
340022cc:	e9c0 3405 	strd	r3, r4, [r0, #20]
  hcom_uart[0].AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
340022d0:	e9c0 4409 	strd	r4, r4, [r0, #36]	@ 0x24
  hcom_uart[0].Init.Parity = UART_PARITY_NONE;
340022d4:	6104      	str	r4, [r0, #16]
  uart_status = HAL_UART_Init(&hcom_uart[0]);
340022d6:	f016 fcd1 	bl	34018c7c <HAL_UART_Init>
340022da:	4604      	mov	r4, r0
  HAL_Delay(100);
340022dc:	2064      	movs	r0, #100	@ 0x64
340022de:	f002 fdd3 	bl	34004e88 <HAL_Delay>
  const char test_msg[] = "\r\n\r\n=== UART TEST ===\r\n";
340022e2:	4b9b      	ldr	r3, [pc, #620]	@ (34002550 <Hardware_init+0x478>)
340022e4:	ad40      	add	r5, sp, #256	@ 0x100
340022e6:	f103 0618 	add.w	r6, r3, #24
340022ea:	462a      	mov	r2, r5
340022ec:	6818      	ldr	r0, [r3, #0]
340022ee:	6859      	ldr	r1, [r3, #4]
340022f0:	3308      	adds	r3, #8
340022f2:	c203      	stmia	r2!, {r0, r1}
340022f4:	42b3      	cmp	r3, r6
340022f6:	4615      	mov	r5, r2
340022f8:	d1f7      	bne.n	340022ea <Hardware_init+0x212>
  for (int i = 0; i < sizeof(test_msg)-1; i++)
340022fa:	2100      	movs	r1, #0
    while (!(USART1->ISR & USART_ISR_TXE_TXFNF));
340022fc:	4a93      	ldr	r2, [pc, #588]	@ (3400254c <Hardware_init+0x474>)
340022fe:	ab40      	add	r3, sp, #256	@ 0x100
34002300:	69d0      	ldr	r0, [r2, #28]
34002302:	0600      	lsls	r0, r0, #24
34002304:	d5fc      	bpl.n	34002300 <Hardware_init+0x228>
    USART1->TDR = test_msg[i];
34002306:	f813 0b01 	ldrb.w	r0, [r3], #1
  for (int i = 0; i < sizeof(test_msg)-1; i++)
3400230a:	3101      	adds	r1, #1
3400230c:	2917      	cmp	r1, #23
    USART1->TDR = test_msg[i];
3400230e:	6290      	str	r0, [r2, #40]	@ 0x28
  for (int i = 0; i < sizeof(test_msg)-1; i++)
34002310:	d1f6      	bne.n	34002300 <Hardware_init+0x228>
  while (!(USART1->ISR & USART_ISR_TC));
34002312:	69d3      	ldr	r3, [r2, #28]
34002314:	065b      	lsls	r3, r3, #25
34002316:	d5fc      	bpl.n	34002312 <Hardware_init+0x23a>
  if (uart_status == HAL_OK)
34002318:	2c00      	cmp	r4, #0
3400231a:	f040 80fc 	bne.w	34002516 <Hardware_init+0x43e>
    const char ok_msg[] = "UART HAL: OK\r\n";
3400231e:	4b8d      	ldr	r3, [pc, #564]	@ (34002554 <Hardware_init+0x47c>)
34002320:	aa0a      	add	r2, sp, #40	@ 0x28
34002322:	f103 0508 	add.w	r5, r3, #8
34002326:	4614      	mov	r4, r2
34002328:	6818      	ldr	r0, [r3, #0]
3400232a:	6859      	ldr	r1, [r3, #4]
3400232c:	3308      	adds	r3, #8
3400232e:	c403      	stmia	r4!, {r0, r1}
34002330:	42ab      	cmp	r3, r5
34002332:	4622      	mov	r2, r4
34002334:	d1f7      	bne.n	34002326 <Hardware_init+0x24e>
34002336:	6818      	ldr	r0, [r3, #0]
34002338:	8899      	ldrh	r1, [r3, #4]
3400233a:	799b      	ldrb	r3, [r3, #6]
    HAL_UART_Transmit(&hcom_uart[0], (uint8_t*)ok_msg, sizeof(ok_msg)-1, 1000);
3400233c:	220e      	movs	r2, #14
    const char ok_msg[] = "UART HAL: OK\r\n";
3400233e:	71a3      	strb	r3, [r4, #6]
    HAL_UART_Transmit(&hcom_uart[0], (uint8_t*)ok_msg, sizeof(ok_msg)-1, 1000);
34002340:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
    const char ok_msg[] = "UART HAL: OK\r\n";
34002344:	6020      	str	r0, [r4, #0]
34002346:	80a1      	strh	r1, [r4, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34002348:	f04f 4700 	mov.w	r7, #2147483648	@ 0x80000000
  WRITE_REG(RCC->AHB2ENSR, Periphs);
3400234c:	f44f 5980 	mov.w	r9, #4096	@ 0x1000
  RAMCFG_HandleTypeDef hramcfg = {0};
34002350:	2500      	movs	r5, #0
    HAL_UART_Transmit(&hcom_uart[0], (uint8_t*)err_msg, sizeof(err_msg)-1, 1000);
34002352:	a90a      	add	r1, sp, #40	@ 0x28
34002354:	487c      	ldr	r0, [pc, #496]	@ (34002548 <Hardware_init+0x470>)
34002356:	f016 fbdf 	bl	34018b18 <HAL_UART_Transmit>
  printf("========================================\r\n");
3400235a:	487f      	ldr	r0, [pc, #508]	@ (34002558 <Hardware_init+0x480>)
3400235c:	f017 fd76 	bl	34019e4c <puts>
  printf("  STM32N6570-DK - Object Detection\r\n");
34002360:	487e      	ldr	r0, [pc, #504]	@ (3400255c <Hardware_init+0x484>)
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34002362:	4c77      	ldr	r4, [pc, #476]	@ (34002540 <Hardware_init+0x468>)
34002364:	f017 fd72 	bl	34019e4c <puts>
  printf("  UART Console : OK via printf\r\n");
34002368:	487d      	ldr	r0, [pc, #500]	@ (34002560 <Hardware_init+0x488>)
3400236a:	f017 fd6f 	bl	34019e4c <puts>
  printf("========================================\r\n");
3400236e:	487a      	ldr	r0, [pc, #488]	@ (34002558 <Hardware_init+0x480>)
34002370:	f017 fd6c 	bl	34019e4c <puts>
34002374:	f8c4 7a60 	str.w	r7, [r4, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34002378:	f8d4 3260 	ldr.w	r3, [r4, #608]	@ 0x260
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
3400237c:	f8df a214 	ldr.w	sl, [pc, #532]	@ 34002594 <Hardware_init+0x4bc>
  tmpreg = READ_REG(RCC->AHB5ENR);
34002380:	9305      	str	r3, [sp, #20]
  (void)tmpreg;
34002382:	9b05      	ldr	r3, [sp, #20]
  __HAL_RCC_AXISRAM3_MEM_CLK_ENABLE();
34002384:	2001      	movs	r0, #1
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34002386:	f8c4 7a20 	str.w	r7, [r4, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
3400238a:	f8ca 7220 	str.w	r7, [sl, #544]	@ 0x220
3400238e:	f7ff fe7f 	bl	34002090 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM4_MEM_CLK_ENABLE();
34002392:	2002      	movs	r0, #2
34002394:	f7ff fe7c 	bl	34002090 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM5_MEM_CLK_ENABLE();
34002398:	2004      	movs	r0, #4
3400239a:	f7ff fe79 	bl	34002090 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM6_MEM_CLK_ENABLE();
3400239e:	2008      	movs	r0, #8
340023a0:	f7ff fe76 	bl	34002090 <LL_MEM_EnableClock>
  WRITE_REG(RCC->AHB2ENSR, Periphs);
340023a4:	f8c4 9a54 	str.w	r9, [r4, #2644]	@ 0xa54
  tmpreg = READ_REG(RCC->AHB2ENR);
340023a8:	f8d4 3254 	ldr.w	r3, [r4, #596]	@ 0x254
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
340023ac:	a80a      	add	r0, sp, #40	@ 0x28
340023ae:	9304      	str	r3, [sp, #16]
  (void)tmpreg;
340023b0:	9b04      	ldr	r3, [sp, #16]
  hramcfg.Instance =  RAMCFG_SRAM3_AXI;
340023b2:	4b6c      	ldr	r3, [pc, #432]	@ (34002564 <Hardware_init+0x48c>)
  RAMCFG_HandleTypeDef hramcfg = {0};
340023b4:	e9cd 550b 	strd	r5, r5, [sp, #44]	@ 0x2c
  hramcfg.Instance =  RAMCFG_SRAM3_AXI;
340023b8:	930a      	str	r3, [sp, #40]	@ 0x28
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
340023ba:	f007 f993 	bl	340096e4 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM4_AXI;
340023be:	4b6a      	ldr	r3, [pc, #424]	@ (34002568 <Hardware_init+0x490>)
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
340023c0:	a80a      	add	r0, sp, #40	@ 0x28
  hramcfg.Instance =  RAMCFG_SRAM4_AXI;
340023c2:	930a      	str	r3, [sp, #40]	@ 0x28
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
340023c4:	f007 f98e 	bl	340096e4 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM5_AXI;
340023c8:	4b68      	ldr	r3, [pc, #416]	@ (3400256c <Hardware_init+0x494>)
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
340023ca:	a80a      	add	r0, sp, #40	@ 0x28
  hramcfg.Instance =  RAMCFG_SRAM5_AXI;
340023cc:	930a      	str	r3, [sp, #40]	@ 0x28
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
340023ce:	f007 f989 	bl	340096e4 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM6_AXI;
340023d2:	4b67      	ldr	r3, [pc, #412]	@ (34002570 <Hardware_init+0x498>)
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
340023d4:	a80a      	add	r0, sp, #40	@ 0x28
  hramcfg.Instance =  RAMCFG_SRAM6_AXI;
340023d6:	930a      	str	r3, [sp, #40]	@ 0x28
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
340023d8:	f007 f984 	bl	340096e4 <HAL_RAMCFG_EnableAXISRAM>
  Fuse_Programming();
340023dc:	f7ff fc6e 	bl	34001cbc <Fuse_Programming>
  npu_cache_init();
340023e0:	f000 fda6 	bl	34002f30 <npu_cache_init>
  npu_cache_enable();
340023e4:	f000 fdae 	bl	34002f44 <npu_cache_enable>
  BSP_XSPI_RAM_Init(0);
340023e8:	4628      	mov	r0, r5
340023ea:	f002 fa31 	bl	34004850 <BSP_XSPI_RAM_Init>
  BSP_XSPI_RAM_EnableMemoryMappedMode(0);
340023ee:	4628      	mov	r0, r5
340023f0:	f002 fb52 	bl	34004a98 <BSP_XSPI_RAM_EnableMemoryMappedMode>
  NOR_Init.InterfaceMode = BSP_XSPI_NOR_OPI_MODE;
340023f4:	f240 1301 	movw	r3, #257	@ 0x101
  WRITE_REG(RCC->AHB3ENSR, Periphs);
340023f8:	f44f 7800 	mov.w	r8, #512	@ 0x200
  BSP_XSPI_NOR_Init(0, &NOR_Init);
340023fc:	a901      	add	r1, sp, #4
340023fe:	4628      	mov	r0, r5
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34002400:	2602      	movs	r6, #2
  NOR_Init.InterfaceMode = BSP_XSPI_NOR_OPI_MODE;
34002402:	f8ad 3004 	strh.w	r3, [sp, #4]
  BSP_XSPI_NOR_Init(0, &NOR_Init);
34002406:	f002 f8dd 	bl	340045c4 <BSP_XSPI_NOR_Init>
  BSP_XSPI_NOR_EnableMemoryMappedMode(0);
3400240a:	4628      	mov	r0, r5
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
3400240c:	2503      	movs	r5, #3
  BSP_XSPI_NOR_EnableMemoryMappedMode(0);
3400240e:	f002 f847 	bl	340044a0 <BSP_XSPI_NOR_EnableMemoryMappedMode>
34002412:	f8c4 8a58 	str.w	r8, [r4, #2648]	@ 0xa58
  tmpreg = READ_REG(RCC->AHB3ENR);
34002416:	f8d4 3258 	ldr.w	r3, [r4, #600]	@ 0x258
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_NPU, &RIMC_master);
3400241a:	a90a      	add	r1, sp, #40	@ 0x28
3400241c:	9306      	str	r3, [sp, #24]
3400241e:	2001      	movs	r0, #1
  (void)tmpreg;
34002420:	9b06      	ldr	r3, [sp, #24]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34002422:	e9cd 650a 	strd	r6, r5, [sp, #40]	@ 0x28
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_NPU, &RIMC_master);
34002426:	f00d f965 	bl	3400f6f4 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DMA2D, &RIMC_master);
3400242a:	a90a      	add	r1, sp, #40	@ 0x28
3400242c:	2008      	movs	r0, #8
3400242e:	f00d f961 	bl	3400f6f4 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34002432:	a90a      	add	r1, sp, #40	@ 0x28
34002434:	2009      	movs	r0, #9
34002436:	f00d f95d 	bl	3400f6f4 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1 , &RIMC_master);
3400243a:	a90a      	add	r1, sp, #40	@ 0x28
3400243c:	200a      	movs	r0, #10
3400243e:	f00d f959 	bl	3400f6f4 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC2 , &RIMC_master);
34002442:	a90a      	add	r1, sp, #40	@ 0x28
34002444:	200b      	movs	r0, #11
34002446:	f00d f955 	bl	3400f6f4 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_NPU , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
3400244a:	4629      	mov	r1, r5
3400244c:	4849      	ldr	r0, [pc, #292]	@ (34002574 <Hardware_init+0x49c>)
3400244e:	f00d f9a7 	bl	3400f7a0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DMA2D , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34002452:	4629      	mov	r1, r5
34002454:	4848      	ldr	r0, [pc, #288]	@ (34002578 <Hardware_init+0x4a0>)
34002456:	f00d f9a3 	bl	3400f7a0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_CSI    , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
3400245a:	4629      	mov	r1, r5
3400245c:	4847      	ldr	r0, [pc, #284]	@ (3400257c <Hardware_init+0x4a4>)
3400245e:	f00d f99f 	bl	3400f7a0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DCMIPP , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34002462:	4629      	mov	r1, r5
34002464:	4846      	ldr	r0, [pc, #280]	@ (34002580 <Hardware_init+0x4a8>)
34002466:	f00d f99b 	bl	3400f7a0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDC   , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
3400246a:	4629      	mov	r1, r5
3400246c:	4845      	ldr	r0, [pc, #276]	@ (34002584 <Hardware_init+0x4ac>)
3400246e:	f00d f997 	bl	3400f7a0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL1 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34002472:	4629      	mov	r1, r5
34002474:	4844      	ldr	r0, [pc, #272]	@ (34002588 <Hardware_init+0x4b0>)
34002476:	f00d f993 	bl	3400f7a0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL2 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
3400247a:	4629      	mov	r1, r5
3400247c:	4843      	ldr	r0, [pc, #268]	@ (3400258c <Hardware_init+0x4b4>)
3400247e:	f00d f98f 	bl	3400f7a0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  WRITE_REG(RCC->AHB3ENSR, Periphs);
34002482:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34002486:	f8c4 3a58 	str.w	r3, [r4, #2648]	@ 0xa58
  tmpreg = READ_REG(RCC->AHB3ENR);
3400248a:	f8d4 2258 	ldr.w	r2, [r4, #600]	@ 0x258
  __HAL_RCC_XSPI1_CLK_SLEEP_ENABLE();    /* For display frame buffer */
3400248e:	2020      	movs	r0, #32
34002490:	9207      	str	r2, [sp, #28]
  (void)tmpreg;
34002492:	9a07      	ldr	r2, [sp, #28]
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34002494:	2204      	movs	r2, #4
  WRITE_REG(RCC->AHB3RSTSR, Periphs);
34002496:	f8c4 3a18 	str.w	r3, [r4, #2584]	@ 0xa18
  WRITE_REG(RCC->AHB3RSTCR, Periphs);
3400249a:	f8ca 3218 	str.w	r3, [sl, #536]	@ 0x218
3400249e:	f7ff fe0f 	bl	340020c0 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_XSPI2_CLK_SLEEP_ENABLE();    /* For NN weights */
340024a2:	4648      	mov	r0, r9
340024a4:	f7ff fe0c 	bl	340020c0 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_NPU_CLK_SLEEP_ENABLE();      /* For NN inference */
340024a8:	4638      	mov	r0, r7
340024aa:	f7ff fe09 	bl	340020c0 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_CACHEAXI_CLK_SLEEP_ENABLE(); /* For NN inference */
340024ae:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
340024b2:	f7ff fe05 	bl	340020c0 <LL_AHB5_GRP1_EnableClockLowPower>
  WRITE_REG(RCC->APB5LPENSR, Periphs);
340024b6:	f8c4 6abc 	str.w	r6, [r4, #2748]	@ 0xabc
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5LPENR);
340024ba:	f8d4 32bc 	ldr.w	r3, [r4, #700]	@ 0x2bc
  __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE();    /* For display */
340024be:	4630      	mov	r0, r6
340024c0:	930a      	str	r3, [sp, #40]	@ 0x28
  (void)tmpreg;
340024c2:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
340024c4:	f7ff fdfc 	bl	340020c0 <LL_AHB5_GRP1_EnableClockLowPower>
  WRITE_REG(RCC->APB5LPENSR, Periphs);
340024c8:	f8c4 2abc 	str.w	r2, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
340024cc:	f8d4 32bc 	ldr.w	r3, [r4, #700]	@ 0x2bc
  __HAL_RCC_FLEXRAM_MEM_CLK_SLEEP_ENABLE();
340024d0:	4640      	mov	r0, r8
340024d2:	9309      	str	r3, [sp, #36]	@ 0x24
  (void)tmpreg;
340024d4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  WRITE_REG(RCC->APB5LPENSR, Periphs);
340024d6:	2340      	movs	r3, #64	@ 0x40
340024d8:	f8c4 3abc 	str.w	r3, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
340024dc:	f8d4 32bc 	ldr.w	r3, [r4, #700]	@ 0x2bc
340024e0:	9308      	str	r3, [sp, #32]
  (void)tmpreg;
340024e2:	9b08      	ldr	r3, [sp, #32]
340024e4:	f7ff fde0 	bl	340020a8 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM1_MEM_CLK_SLEEP_ENABLE();
340024e8:	2080      	movs	r0, #128	@ 0x80
340024ea:	f7ff fddd 	bl	340020a8 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM2_MEM_CLK_SLEEP_ENABLE();
340024ee:	f44f 7080 	mov.w	r0, #256	@ 0x100
340024f2:	f7ff fdd9 	bl	340020a8 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM3_MEM_CLK_SLEEP_ENABLE();
340024f6:	2001      	movs	r0, #1
340024f8:	f7ff fdd6 	bl	340020a8 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM4_MEM_CLK_SLEEP_ENABLE();
340024fc:	4630      	mov	r0, r6
340024fe:	f7ff fdd3 	bl	340020a8 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM5_MEM_CLK_SLEEP_ENABLE();
34002502:	4610      	mov	r0, r2
34002504:	f7ff fdd0 	bl	340020a8 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM6_MEM_CLK_SLEEP_ENABLE(); 
34002508:	2008      	movs	r0, #8
3400250a:	f7ff fdcd 	bl	340020a8 <LL_MEM_EnableClockLowPower>
}
3400250e:	f50d 7d24 	add.w	sp, sp, #656	@ 0x290
34002512:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    const char err_msg[] = "UART HAL: ERREUR\r\n";
34002516:	4b1e      	ldr	r3, [pc, #120]	@ (34002590 <Hardware_init+0x4b8>)
34002518:	aa0a      	add	r2, sp, #40	@ 0x28
3400251a:	f103 0510 	add.w	r5, r3, #16
3400251e:	4614      	mov	r4, r2
34002520:	6818      	ldr	r0, [r3, #0]
34002522:	6859      	ldr	r1, [r3, #4]
34002524:	3308      	adds	r3, #8
34002526:	c403      	stmia	r4!, {r0, r1}
34002528:	42ab      	cmp	r3, r5
3400252a:	4622      	mov	r2, r4
3400252c:	d1f7      	bne.n	3400251e <Hardware_init+0x446>
3400252e:	8819      	ldrh	r1, [r3, #0]
34002530:	789b      	ldrb	r3, [r3, #2]
    HAL_UART_Transmit(&hcom_uart[0], (uint8_t*)err_msg, sizeof(err_msg)-1, 1000);
34002532:	2212      	movs	r2, #18
    const char err_msg[] = "UART HAL: ERREUR\r\n";
34002534:	70a3      	strb	r3, [r4, #2]
34002536:	8021      	strh	r1, [r4, #0]
    HAL_UART_Transmit(&hcom_uart[0], (uint8_t*)err_msg, sizeof(err_msg)-1, 1000);
34002538:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
3400253c:	e704      	b.n	34002348 <Hardware_init+0x270>
3400253e:	bf00      	nop
34002540:	56028000 	.word	0x56028000
34002544:	56021000 	.word	0x56021000
34002548:	340cd200 	.word	0x340cd200
3400254c:	52001000 	.word	0x52001000
34002550:	3401d717 	.word	0x3401d717
34002554:	3401d72f 	.word	0x3401d72f
34002558:	3401d6a9 	.word	0x3401d6a9
3400255c:	3401d6d3 	.word	0x3401d6d3
34002560:	3401d6f7 	.word	0x3401d6f7
34002564:	52023100 	.word	0x52023100
34002568:	52023180 	.word	0x52023180
3400256c:	52023200 	.word	0x52023200
34002570:	52023280 	.word	0x52023280
34002574:	3000000a 	.word	0x3000000a
34002578:	30000005 	.word	0x30000005
3400257c:	2000001c 	.word	0x2000001c
34002580:	2000001d 	.word	0x2000001d
34002584:	30000006 	.word	0x30000006
34002588:	30000007 	.word	0x30000007
3400258c:	30000008 	.word	0x30000008
34002590:	3401d73e 	.word	0x3401d73e
34002594:	56029000 	.word	0x56029000

34002598 <main>:
{
34002598:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t pitch_nn = 0;
3400259c:	2400      	movs	r4, #0
{
3400259e:	b093      	sub	sp, #76	@ 0x4c
  Hardware_init();
340025a0:	f7ff fd9a 	bl	340020d8 <Hardware_init>
  }

  static inline const LL_Buffer_InfoTypeDef *LL_ATON_Input_Buffers_Info(const NN_Instance_TypeDef *nn_instance)
  {
    assert((nn_instance != NULL) && (nn_instance->network != NULL) &&
340025a4:	4dab      	ldr	r5, [pc, #684]	@ (34002854 <main+0x2bc>)
  PersonCounter_Init();
340025a6:	f7ff fbb7 	bl	34001d18 <PersonCounter_Init>
  float32_t *nn_out[MAX_NUMBER_OUTPUT] = {0};
340025aa:	2214      	movs	r2, #20
340025ac:	4621      	mov	r1, r4
340025ae:	a808      	add	r0, sp, #32
  uint32_t pitch_nn = 0;
340025b0:	9407      	str	r4, [sp, #28]
  float32_t *nn_out[MAX_NUMBER_OUTPUT] = {0};
340025b2:	f017 fdb7 	bl	3401a124 <memset>
  int32_t nn_out_len[MAX_NUMBER_OUTPUT] = {0};
340025b6:	2214      	movs	r2, #20
340025b8:	4621      	mov	r1, r4
340025ba:	a80d      	add	r0, sp, #52	@ 0x34
340025bc:	f017 fdb2 	bl	3401a124 <memset>
340025c0:	682b      	ldr	r3, [r5, #0]
340025c2:	b10b      	cbz	r3, 340025c8 <main+0x30>
340025c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340025c6:	b933      	cbnz	r3, 340025d6 <main+0x3e>
340025c8:	f44f 7195 	mov.w	r1, #298	@ 0x12a
340025cc:	4ba2      	ldr	r3, [pc, #648]	@ (34002858 <main+0x2c0>)
340025ce:	4aa3      	ldr	r2, [pc, #652]	@ (3400285c <main+0x2c4>)
    assert((nn_instance != NULL) && (nn_instance->network != NULL) &&
340025d0:	48a3      	ldr	r0, [pc, #652]	@ (34002860 <main+0x2c8>)
340025d2:	f016 fc43 	bl	34018e5c <__assert_func>
           (nn_instance->network->input_buffers_info != NULL));
    return nn_instance->network->input_buffers_info();
340025d6:	4798      	blx	r3
    assert((nn_instance != NULL) && (nn_instance->network != NULL) &&
340025d8:	682b      	ldr	r3, [r5, #0]
    return nn_instance->network->input_buffers_info();
340025da:	4604      	mov	r4, r0
    assert((nn_instance != NULL) && (nn_instance->network != NULL) &&
340025dc:	b10b      	cbz	r3, 340025e2 <main+0x4a>
340025de:	6a1b      	ldr	r3, [r3, #32]
340025e0:	b923      	cbnz	r3, 340025ec <main+0x54>
340025e2:	f240 1123 	movw	r1, #291	@ 0x123
340025e6:	4b9f      	ldr	r3, [pc, #636]	@ (34002864 <main+0x2cc>)
340025e8:	4a9f      	ldr	r2, [pc, #636]	@ (34002868 <main+0x2d0>)
340025ea:	e7f1      	b.n	340025d0 <main+0x38>
    return nn_instance->network->output_buffers_info();
340025ec:	4798      	blx	r3
340025ee:	6861      	ldr	r1, [r4, #4]
340025f0:	4602      	mov	r2, r0
    return eb->blob_address;
  }

  static inline unsigned char *LL_Buffer_addr_base(const LL_Buffer_InfoTypeDef *buf)
  {
    if (buf->is_user_allocated)
340025f2:	7d20      	ldrb	r0, [r4, #20]
    {
      unsigned char **tmp = (unsigned char **)buf->addr_base.p;
      return *tmp;
    }
    return buf->addr_base.p;
340025f4:	460b      	mov	r3, r1
    if (buf->is_user_allocated)
340025f6:	b100      	cbz	r0, 340025fa <main+0x62>
      return *tmp;
340025f8:	680b      	ldr	r3, [r1, #0]
  int number_output = 0;
340025fa:	f04f 0800 	mov.w	r8, #0
340025fe:	2038      	movs	r0, #56	@ 0x38
  }

  static inline unsigned char *LL_Buffer_addr_start(const LL_Buffer_InfoTypeDef *buf)
  {
    return LL_Buffer_addr_base(buf) + buf->offset_start;
34002600:	68a5      	ldr	r5, [r4, #8]
  nn_in = (uint8_t *) LL_Buffer_addr_start(&nn_in_info[0]);
34002602:	499a      	ldr	r1, [pc, #616]	@ (3400286c <main+0x2d4>)
34002604:	442b      	add	r3, r5
34002606:	600b      	str	r3, [r1, #0]
  while (nn_out_info[*number_output].name != NULL)
34002608:	fb00 f308 	mul.w	r3, r0, r8
3400260c:	58d1      	ldr	r1, [r2, r3]
3400260e:	2900      	cmp	r1, #0
34002610:	f040 80d8 	bne.w	340027c4 <main+0x22c>
  assert(*number_output <= MAX_NUMBER_OUTPUT);
34002614:	f1b8 0f05 	cmp.w	r8, #5
34002618:	f300 80d7 	bgt.w	340027ca <main+0x232>
3400261c:	4894      	ldr	r0, [pc, #592]	@ (34002870 <main+0x2d8>)
3400261e:	08db      	lsrs	r3, r3, #3
34002620:	4343      	muls	r3, r0
34002622:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
34002626:	a908      	add	r1, sp, #32
34002628:	ae0d      	add	r6, sp, #52	@ 0x34
3400262a:	3301      	adds	r3, #1
  for (int i = 0; i < *number_output; i++)
3400262c:	3b01      	subs	r3, #1
3400262e:	f040 80d2 	bne.w	340027d6 <main+0x23e>
    return LL_Buffer_addr_base(buf) + buf->offset_limit;
  }

  static inline uint32_t LL_Buffer_len(const LL_Buffer_InfoTypeDef *buf)
  {
    return buf->offset_end - buf->offset_start;
34002632:	68e3      	ldr	r3, [r4, #12]
  CameraPipeline_Init(&lcd_bg_area.XSize, &lcd_bg_area.YSize, &pitch_nn);
34002634:	4c8f      	ldr	r4, [pc, #572]	@ (34002874 <main+0x2dc>)
34002636:	1b5b      	subs	r3, r3, r5
34002638:	9302      	str	r3, [sp, #8]
  LL_ATON_RT_RuntimeInit();
3400263a:	f015 fd15 	bl	34018068 <LL_ATON_RT_RuntimeInit>
  LL_ATON_RT_Init_Network(&NN_Instance_Default);
3400263e:	4885      	ldr	r0, [pc, #532]	@ (34002854 <main+0x2bc>)
34002640:	f015 fcc6 	bl	34017fd0 <LL_ATON_RT_Init_Network>
  app_postprocess_init(&pp_params, &NN_Instance_Default);
34002644:	4983      	ldr	r1, [pc, #524]	@ (34002854 <main+0x2bc>)
34002646:	488c      	ldr	r0, [pc, #560]	@ (34002878 <main+0x2e0>)
34002648:	f7ff fb96 	bl	34001d78 <app_postprocess_init>
  CameraPipeline_Init(&lcd_bg_area.XSize, &lcd_bg_area.YSize, &pitch_nn);
3400264c:	4621      	mov	r1, r4
3400264e:	aa07      	add	r2, sp, #28
34002650:	1f20      	subs	r0, r4, #4
34002652:	f7ff fa89 	bl	34001b68 <CameraPipeline_Init>
  BSP_LCD_Init(0, LCD_ORIENTATION_LANDSCAPE);
34002656:	2101      	movs	r1, #1
34002658:	2000      	movs	r0, #0
3400265a:	f001 fe2f 	bl	340042bc <BSP_LCD_Init>
  LayerConfig.X0          = lcd_bg_area.X0;
3400265e:	f1a4 030c 	sub.w	r3, r4, #12
34002662:	f854 0c0c 	ldr.w	r0, [r4, #-12]
  LayerConfig.Y0          = lcd_bg_area.Y0;
34002666:	6859      	ldr	r1, [r3, #4]
  LayerConfig.X0          = lcd_bg_area.X0;
34002668:	4c84      	ldr	r4, [pc, #528]	@ (3400287c <main+0x2e4>)
  LayerConfig.X1          = lcd_bg_area.X0 + lcd_bg_area.XSize;
3400266a:	689a      	ldr	r2, [r3, #8]
  LayerConfig.Y1          = lcd_bg_area.Y0 + lcd_bg_area.YSize;
3400266c:	68db      	ldr	r3, [r3, #12]
  LayerConfig.Y0          = lcd_bg_area.Y0;
3400266e:	60a1      	str	r1, [r4, #8]
  LayerConfig.Y1          = lcd_bg_area.Y0 + lcd_bg_area.YSize;
34002670:	440b      	add	r3, r1
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_1, &LayerConfig);
34002672:	2100      	movs	r1, #0
  LayerConfig.Y1          = lcd_bg_area.Y0 + lcd_bg_area.YSize;
34002674:	60e3      	str	r3, [r4, #12]
  LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_RGB565;
34002676:	2302      	movs	r3, #2
  LayerConfig.Address     = (uint32_t) lcd_bg_buffer;
34002678:	4d81      	ldr	r5, [pc, #516]	@ (34002880 <main+0x2e8>)
  LayerConfig.X1          = lcd_bg_area.X0 + lcd_bg_area.XSize;
3400267a:	4402      	add	r2, r0
  LayerConfig.X0          = lcd_bg_area.X0;
3400267c:	6020      	str	r0, [r4, #0]
  LayerConfig.X1          = lcd_bg_area.X0 + lcd_bg_area.XSize;
3400267e:	6062      	str	r2, [r4, #4]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_1, &LayerConfig);
34002680:	4608      	mov	r0, r1
34002682:	4622      	mov	r2, r4
  LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_RGB565;
34002684:	6123      	str	r3, [r4, #16]
  LayerConfig.Address     = (uint32_t) lcd_bg_buffer;
34002686:	6165      	str	r5, [r4, #20]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_1, &LayerConfig);
34002688:	f001 fe24 	bl	340042d4 <BSP_LCD_ConfigLayer>
  LayerConfig.X0 = lcd_fg_area.X0;
3400268c:	4b7d      	ldr	r3, [pc, #500]	@ (34002884 <main+0x2ec>)
      CameraPipeline_NNPipe_Start(dcmipp_out_nn, CMW_MODE_SNAPSHOT);
3400268e:	f8df a23c 	ldr.w	sl, [pc, #572]	@ 340028cc <main+0x334>
  LayerConfig.X0 = lcd_fg_area.X0;
34002692:	6818      	ldr	r0, [r3, #0]
  LayerConfig.Y0 = lcd_fg_area.Y0;
34002694:	6859      	ldr	r1, [r3, #4]
  LayerConfig.X1 = lcd_fg_area.X0 + lcd_fg_area.XSize;
34002696:	689a      	ldr	r2, [r3, #8]
  LayerConfig.Y1 = lcd_fg_area.Y0 + lcd_fg_area.YSize;
34002698:	68db      	ldr	r3, [r3, #12]
  LayerConfig.X1 = lcd_fg_area.X0 + lcd_fg_area.XSize;
3400269a:	4402      	add	r2, r0
  LayerConfig.Y1 = lcd_fg_area.Y0 + lcd_fg_area.YSize;
3400269c:	440b      	add	r3, r1
3400269e:	60e3      	str	r3, [r4, #12]
  LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
340026a0:	2304      	movs	r3, #4
340026a2:	6123      	str	r3, [r4, #16]
  LayerConfig.Address = (uint32_t) lcd_fg_buffer; /* External XSPI1 PSRAM */
340026a4:	4b78      	ldr	r3, [pc, #480]	@ (34002888 <main+0x2f0>)
  LayerConfig.X0 = lcd_fg_area.X0;
340026a6:	6020      	str	r0, [r4, #0]
  LayerConfig.Y0 = lcd_fg_area.Y0;
340026a8:	60a1      	str	r1, [r4, #8]
  LayerConfig.X1 = lcd_fg_area.X0 + lcd_fg_area.XSize;
340026aa:	6062      	str	r2, [r4, #4]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_2, &LayerConfig);
340026ac:	2101      	movs	r1, #1
340026ae:	4622      	mov	r2, r4
340026b0:	2000      	movs	r0, #0
  LayerConfig.Address = (uint32_t) lcd_fg_buffer; /* External XSPI1 PSRAM */
340026b2:	6163      	str	r3, [r4, #20]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_2, &LayerConfig);
340026b4:	f001 fe0e 	bl	340042d4 <BSP_LCD_ConfigLayer>
  UTIL_LCD_SetFuncDriver(&LCD_Driver);
340026b8:	4874      	ldr	r0, [pc, #464]	@ (3400288c <main+0x2f4>)
340026ba:	f012 ff49 	bl	34015550 <UTIL_LCD_SetFuncDriver>
  UTIL_LCD_SetLayer(LTDC_LAYER_2);
340026be:	2001      	movs	r0, #1
340026c0:	f012 ff7a 	bl	340155b8 <UTIL_LCD_SetLayer>
  UTIL_LCD_Clear(0x00000000);
340026c4:	2000      	movs	r0, #0
340026c6:	f013 f9d9 	bl	34015a7c <UTIL_LCD_Clear>
  UTIL_LCD_SetFont(&Font20);
340026ca:	4871      	ldr	r0, [pc, #452]	@ (34002890 <main+0x2f8>)
340026cc:	f012 ffaa 	bl	34015624 <UTIL_LCD_SetFont>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
340026d0:	f04f 30ff 	mov.w	r0, #4294967295
340026d4:	f012 ff96 	bl	34015604 <UTIL_LCD_SetTextColor>
  memset(lcd_bg_buffer, 0, sizeof(lcd_bg_buffer));
340026d8:	2100      	movs	r1, #0
340026da:	4a6e      	ldr	r2, [pc, #440]	@ (34002894 <main+0x2fc>)
340026dc:	4628      	mov	r0, r5
340026de:	f017 fd21 	bl	3401a124 <memset>
  printf("Initialisation WiFi (SoftSerial D10/D11)...\r\n");
340026e2:	486d      	ldr	r0, [pc, #436]	@ (34002898 <main+0x300>)
340026e4:	f017 fbb2 	bl	34019e4c <puts>
  WiFi_Init();
340026e8:	f7ff fc7e 	bl	34001fe8 <WiFi_Init>
  CameraPipeline_DisplayPipe_Start(lcd_bg_buffer, CMW_MODE_CONTINUOUS);
340026ec:	2100      	movs	r1, #0
340026ee:	4628      	mov	r0, r5
340026f0:	f7ff fa9e 	bl	34001c30 <CameraPipeline_DisplayPipe_Start>
    CameraPipeline_IspUpdate();
340026f4:	f7ff fac4 	bl	34001c80 <CameraPipeline_IspUpdate>
    if (pitch_nn != (NN_WIDTH * NN_BPP))
340026f8:	9b07      	ldr	r3, [sp, #28]
      CameraPipeline_NNPipe_Start(dcmipp_out_nn, CMW_MODE_SNAPSHOT);
340026fa:	2104      	movs	r1, #4
    if (pitch_nn != (NN_WIDTH * NN_BPP))
340026fc:	f5b3 6fb4 	cmp.w	r3, #1440	@ 0x5a0
      CameraPipeline_NNPipe_Start(nn_in, CMW_MODE_SNAPSHOT);
34002700:	bf0a      	itet	eq
34002702:	4b5a      	ldreq	r3, [pc, #360]	@ (3400286c <main+0x2d4>)
      CameraPipeline_NNPipe_Start(dcmipp_out_nn, CMW_MODE_SNAPSHOT);
34002704:	f8da 0000 	ldrne.w	r0, [sl]
      CameraPipeline_NNPipe_Start(nn_in, CMW_MODE_SNAPSHOT);
34002708:	6818      	ldreq	r0, [r3, #0]
3400270a:	f7ff faa5 	bl	34001c58 <CameraPipeline_NNPipe_Start>
    while (cameraFrameReceived == 0) {};
3400270e:	4b63      	ldr	r3, [pc, #396]	@ (3400289c <main+0x304>)
34002710:	681a      	ldr	r2, [r3, #0]
34002712:	2a00      	cmp	r2, #0
34002714:	d0fc      	beq.n	34002710 <main+0x178>
    cameraFrameReceived = 0;
34002716:	2200      	movs	r2, #0
34002718:	601a      	str	r2, [r3, #0]
    if (pitch_nn != (NN_WIDTH * NN_BPP))
3400271a:	9b07      	ldr	r3, [sp, #28]
3400271c:	f5b3 6fb4 	cmp.w	r3, #1440	@ 0x5a0
34002720:	d046      	beq.n	340027b0 <main+0x218>
*/
__STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) {
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002722:	f8da 1000 	ldr.w	r1, [sl]
34002726:	f001 021f 	and.w	r2, r1, #31
  __ASM volatile ("dsb 0xF":::"memory");
3400272a:	f3bf 8f4f 	dsb	sy
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;

      __DSB();

      do {
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
3400272e:	1cd3      	adds	r3, r2, #3
34002730:	3a1c      	subs	r2, #28
34002732:	095b      	lsrs	r3, r3, #5
34002734:	3220      	adds	r2, #32
34002736:	f103 0e01 	add.w	lr, r3, #1
3400273a:	bfd8      	it	le
3400273c:	f04f 0e01 	movle.w	lr, #1
34002740:	f04e e001 	dls	lr, lr
34002744:	4856      	ldr	r0, [pc, #344]	@ (340028a0 <main+0x308>)
34002746:	f8c0 125c 	str.w	r1, [r0, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
3400274a:	3120      	adds	r1, #32
        op_size -= __SCB_DCACHE_LINE_SIZE;
      } while ( op_size > 0 );
3400274c:	f00f c805 	le	lr, 34002746 <main+0x1ae>
34002750:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34002754:	f3bf 8f6f 	isb	sy
      img_crop(dcmipp_out_nn, nn_in, pitch_nn, NN_WIDTH, NN_HEIGHT, NN_BPP);
34002758:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
3400275c:	2203      	movs	r2, #3
3400275e:	e9cd 3200 	strd	r3, r2, [sp]
34002762:	4c42      	ldr	r4, [pc, #264]	@ (3400286c <main+0x2d4>)
34002764:	9a07      	ldr	r2, [sp, #28]
34002766:	6821      	ldr	r1, [r4, #0]
34002768:	f8da 0000 	ldr.w	r0, [sl]
3400276c:	f7ff fc76 	bl	3400205c <img_crop>
  \param[in]   dsize   size of memory block (in number of bytes)
*/
__STATIC_FORCEINLINE void SCB_CleanInvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) {
34002770:	9a02      	ldr	r2, [sp, #8]
      SCB_CleanInvalidateDCache_by_Addr(nn_in, nn_in_len);
34002772:	6823      	ldr	r3, [r4, #0]
34002774:	2a00      	cmp	r2, #0
34002776:	dd1b      	ble.n	340027b0 <main+0x218>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002778:	f003 011f 	and.w	r1, r3, #31
3400277c:	4411      	add	r1, r2
  __ASM volatile ("dsb 0xF":::"memory");
3400277e:	f3bf 8f4f 	dsb	sy

      do {
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
        op_addr +=          __SCB_DCACHE_LINE_SIZE;
        op_size -=          __SCB_DCACHE_LINE_SIZE;
      } while ( op_size > 0 );
34002782:	43da      	mvns	r2, r3
34002784:	185c      	adds	r4, r3, r1
34002786:	4422      	add	r2, r4
34002788:	3920      	subs	r1, #32
3400278a:	0952      	lsrs	r2, r2, #5
3400278c:	3120      	adds	r1, #32
3400278e:	f102 0e01 	add.w	lr, r2, #1
34002792:	bfd8      	it	le
34002794:	f04f 0e01 	movle.w	lr, #1
34002798:	f04e e001 	dls	lr, lr
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
3400279c:	4840      	ldr	r0, [pc, #256]	@ (340028a0 <main+0x308>)
3400279e:	f8c0 3270 	str.w	r3, [r0, #624]	@ 0x270
        op_addr +=          __SCB_DCACHE_LINE_SIZE;
340027a2:	3320      	adds	r3, #32
      } while ( op_size > 0 );
340027a4:	f00f c805 	le	lr, 3400279e <main+0x206>
340027a8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340027ac:	f3bf 8f6f 	isb	sy
    ts[0] = HAL_GetTick();
340027b0:	f002 fb64 	bl	34004e7c <HAL_GetTick>
340027b4:	4605      	mov	r5, r0
    ll_aton_rt_ret = LL_ATON_RT_RunEpochBlock(&NN_Instance_Default);
340027b6:	4827      	ldr	r0, [pc, #156]	@ (34002854 <main+0x2bc>)
340027b8:	f015 fca0 	bl	340180fc <LL_ATON_RT_RunEpochBlock>
    if (ll_aton_rt_ret == LL_ATON_RT_WFE)
340027bc:	2801      	cmp	r0, #1
340027be:	d119      	bne.n	340027f4 <main+0x25c>
      LL_ATON_OSAL_WFE();
340027c0:	bf20      	wfe
  } while (ll_aton_rt_ret != LL_ATON_RT_DONE);
340027c2:	e7f8      	b.n	340027b6 <main+0x21e>
    (*number_output)++;
340027c4:	f108 0801 	add.w	r8, r8, #1
340027c8:	e71e      	b.n	34002608 <main+0x70>
  assert(*number_output <= MAX_NUMBER_OUTPUT);
340027ca:	f240 1185 	movw	r1, #389	@ 0x185
340027ce:	4b35      	ldr	r3, [pc, #212]	@ (340028a4 <main+0x30c>)
340027d0:	4a35      	ldr	r2, [pc, #212]	@ (340028a8 <main+0x310>)
  assert(ret == HAL_OK);
340027d2:	4836      	ldr	r0, [pc, #216]	@ (340028ac <main+0x314>)
340027d4:	e6fd      	b.n	340025d2 <main+0x3a>
    if (buf->is_user_allocated)
340027d6:	7d17      	ldrb	r7, [r2, #20]
      unsigned char **tmp = (unsigned char **)buf->addr_base.p;
340027d8:	6850      	ldr	r0, [r2, #4]
    if (buf->is_user_allocated)
340027da:	b107      	cbz	r7, 340027de <main+0x246>
      return *tmp;
340027dc:	6800      	ldr	r0, [r0, #0]
    return LL_Buffer_addr_base(buf) + buf->offset_start;
340027de:	6897      	ldr	r7, [r2, #8]
340027e0:	3238      	adds	r2, #56	@ 0x38
340027e2:	4438      	add	r0, r7
    nn_out[i] = (float32_t *) LL_Buffer_addr_start(&nn_out_info[i]);
340027e4:	f841 0b04 	str.w	r0, [r1], #4
    return buf->offset_end - buf->offset_start;
340027e8:	f852 0c2c 	ldr.w	r0, [r2, #-44]
340027ec:	1bc0      	subs	r0, r0, r7
    nn_out_len[i] = LL_Buffer_len(&nn_out_info[i]);
340027ee:	f846 0b04 	str.w	r0, [r6], #4
  for (int i = 0; i < *number_output; i++)
340027f2:	e71b      	b.n	3400262c <main+0x94>
  } while (ll_aton_rt_ret != LL_ATON_RT_DONE);
340027f4:	2802      	cmp	r0, #2
340027f6:	d1de      	bne.n	340027b6 <main+0x21e>
  LL_ATON_RT_Reset_Network(&NN_Instance_Default);
340027f8:	4816      	ldr	r0, [pc, #88]	@ (34002854 <main+0x2bc>)
340027fa:	f015 fc2b 	bl	34018054 <LL_ATON_RT_Reset_Network>
    ts[1] = HAL_GetTick();
340027fe:	f002 fb3d 	bl	34004e7c <HAL_GetTick>
    int32_t ret = app_postprocess_run((void **) nn_out, number_output, &pp_output, &pp_params);
34002802:	4c2b      	ldr	r4, [pc, #172]	@ (340028b0 <main+0x318>)
    ts[1] = HAL_GetTick();
34002804:	4606      	mov	r6, r0
    int32_t ret = app_postprocess_run((void **) nn_out, number_output, &pp_output, &pp_params);
34002806:	4622      	mov	r2, r4
34002808:	4641      	mov	r1, r8
3400280a:	4b1b      	ldr	r3, [pc, #108]	@ (34002878 <main+0x2e0>)
3400280c:	a808      	add	r0, sp, #32
3400280e:	f7ff fb07 	bl	34001e20 <app_postprocess_run>
    assert(ret == 0);
34002812:	4607      	mov	r7, r0
34002814:	b118      	cbz	r0, 3400281e <main+0x286>
34002816:	21e5      	movs	r1, #229	@ 0xe5
34002818:	4b26      	ldr	r3, [pc, #152]	@ (340028b4 <main+0x31c>)
3400281a:	4a27      	ldr	r2, [pc, #156]	@ (340028b8 <main+0x320>)
3400281c:	e7d9      	b.n	340027d2 <main+0x23a>
    uint32_t person_count = PersonCounter_Update(&pp_output);
3400281e:	4620      	mov	r0, r4
34002820:	f7ff fa86 	bl	34001d30 <PersonCounter_Update>
    MQTT_Publish_PersonCount(person_count);
34002824:	f7ff fbee 	bl	34002004 <MQTT_Publish_PersonCount>
    Display_NetworkOutput(&pp_output, ts[1] - ts[0]);
34002828:	1b73      	subs	r3, r6, r5
3400282a:	9304      	str	r3, [sp, #16]
  uint32_t nb_rois = p_postprocess->nb_detect;
3400282c:	e9d4 5300 	ldrd	r5, r3, [r4]
34002830:	9303      	str	r3, [sp, #12]
  ret = HAL_LTDC_SetAddress_NoReload(&hlcd_ltdc, (uint32_t) lcd_fg_buffer[lcd_fg_buffer_rd_idx], LTDC_LAYER_2);
34002832:	4b22      	ldr	r3, [pc, #136]	@ (340028bc <main+0x324>)
34002834:	4817      	ldr	r0, [pc, #92]	@ (34002894 <main+0x2fc>)
34002836:	6819      	ldr	r1, [r3, #0]
34002838:	4b13      	ldr	r3, [pc, #76]	@ (34002888 <main+0x2f0>)
3400283a:	2201      	movs	r2, #1
3400283c:	fb00 3101 	mla	r1, r0, r1, r3
34002840:	481f      	ldr	r0, [pc, #124]	@ (340028c0 <main+0x328>)
34002842:	f006 febd 	bl	340095c0 <HAL_LTDC_SetAddress_NoReload>
  assert(ret == HAL_OK);
34002846:	2800      	cmp	r0, #0
34002848:	d042      	beq.n	340028d0 <main+0x338>
3400284a:	f240 11fd 	movw	r1, #509	@ 0x1fd
3400284e:	4b1d      	ldr	r3, [pc, #116]	@ (340028c4 <main+0x32c>)
34002850:	4a1d      	ldr	r2, [pc, #116]	@ (340028c8 <main+0x330>)
34002852:	e7be      	b.n	340027d2 <main+0x23a>
34002854:	340b0efc 	.word	0x340b0efc
34002858:	3401d751 	.word	0x3401d751
3400285c:	34022f2a 	.word	0x34022f2a
34002860:	3401d553 	.word	0x3401d553
34002864:	3401d4e4 	.word	0x3401d4e4
34002868:	34022f0e 	.word	0x34022f0e
3400286c:	340cd158 	.word	0x340cd158
34002870:	16db6db7 	.word	0x16db6db7
34002874:	340cd1bc 	.word	0x340cd1bc
34002878:	340cd160 	.word	0x340cd160
3400287c:	340cd140 	.word	0x340cd140
34002880:	91177000 	.word	0x91177000
34002884:	340b0ee8 	.word	0x340b0ee8
34002888:	91000000 	.word	0x91000000
3400288c:	340a6d84 	.word	0x340a6d84
34002890:	340b103c 	.word	0x340b103c
34002894:	000bb800 	.word	0x000bb800
34002898:	3401d886 	.word	0x3401d886
3400289c:	340cd15c 	.word	0x340cd15c
340028a0:	e000ed00 	.word	0xe000ed00
340028a4:	3401d7bf 	.word	0x3401d7bf
340028a8:	34022f45 	.word	0x34022f45
340028ac:	3401d7e3 	.word	0x3401d7e3
340028b0:	340cd138 	.word	0x340cd138
340028b4:	3401d8b3 	.word	0x3401d8b3
340028b8:	34022f58 	.word	0x34022f58
340028bc:	340cd130 	.word	0x340cd130
340028c0:	340cdda4 	.word	0x340cdda4
340028c4:	3401d49b 	.word	0x3401d49b
340028c8:	34022ef8 	.word	0x34022ef8
340028cc:	340cd134 	.word	0x340cd134
  UTIL_LCD_FillRect(lcd_fg_area.X0, lcd_fg_area.Y0, lcd_fg_area.XSize, lcd_fg_area.YSize, 0x00000000); /* Clear previous boxes */
340028d0:	489b      	ldr	r0, [pc, #620]	@ (34002b40 <main+0x5a8>)
340028d2:	9700      	str	r7, [sp, #0]
340028d4:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
340028d8:	e9d0 0100 	ldrd	r0, r1, [r0]
340028dc:	f013 f892 	bl	34015a04 <UTIL_LCD_FillRect>
  for (int32_t i = 0; i < nb_rois; i++)
340028e0:	46bb      	mov	fp, r7
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
340028e2:	f8df 92a8 	ldr.w	r9, [pc, #680]	@ 34002b8c <main+0x5f4>
  for (int32_t i = 0; i < nb_rois; i++)
340028e6:	9b03      	ldr	r3, [sp, #12]
340028e8:	455b      	cmp	r3, fp
340028ea:	d17a      	bne.n	340029e2 <main+0x44a>
  UTIL_LCD_SetBackColor(0x40000000);
340028ec:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
340028f0:	f012 fe90 	bl	34015614 <UTIL_LCD_SetBackColor>
  UTIL_LCDEx_PrintfAt(0, LINE(2), CENTER_MODE, "Objects %u", nb_rois);
340028f4:	f012 fe9e 	bl	34015634 <UTIL_LCD_GetFont>
340028f8:	2201      	movs	r2, #1
340028fa:	88c1      	ldrh	r1, [r0, #6]
340028fc:	9b03      	ldr	r3, [sp, #12]
340028fe:	4091      	lsls	r1, r2
34002900:	2000      	movs	r0, #0
34002902:	9300      	str	r3, [sp, #0]
34002904:	4b8f      	ldr	r3, [pc, #572]	@ (34002b44 <main+0x5ac>)
34002906:	f000 fb27 	bl	34002f58 <UTIL_LCDEx_PrintfAt>
  UTIL_LCDEx_PrintfAt(0, LINE(20), CENTER_MODE, "Inference: %ums", inference_ms);
3400290a:	f012 fe93 	bl	34015634 <UTIL_LCD_GetFont>
3400290e:	88c1      	ldrh	r1, [r0, #6]
34002910:	2014      	movs	r0, #20
34002912:	9b04      	ldr	r3, [sp, #16]
34002914:	4341      	muls	r1, r0
34002916:	2201      	movs	r2, #1
34002918:	2000      	movs	r0, #0
3400291a:	9300      	str	r3, [sp, #0]
  if (t0 == 0)
3400291c:	4c8a      	ldr	r4, [pc, #552]	@ (34002b48 <main+0x5b0>)
  UTIL_LCDEx_PrintfAt(0, LINE(20), CENTER_MODE, "Inference: %ums", inference_ms);
3400291e:	4b8b      	ldr	r3, [pc, #556]	@ (34002b4c <main+0x5b4>)
34002920:	f000 fb1a 	bl	34002f58 <UTIL_LCDEx_PrintfAt>
  UTIL_LCD_SetBackColor(0);
34002924:	2000      	movs	r0, #0
34002926:	f012 fe75 	bl	34015614 <UTIL_LCD_SetBackColor>
  if (t0 == 0)
3400292a:	6823      	ldr	r3, [r4, #0]
3400292c:	b913      	cbnz	r3, 34002934 <main+0x39c>
    t0 = HAL_GetTick();
3400292e:	f002 faa5 	bl	34004e7c <HAL_GetTick>
34002932:	6020      	str	r0, [r4, #0]
  if (HAL_GetTick() - t0 < 4000)
34002934:	f002 faa2 	bl	34004e7c <HAL_GetTick>
34002938:	6823      	ldr	r3, [r4, #0]
3400293a:	1ac0      	subs	r0, r0, r3
3400293c:	f5b0 6f7a 	cmp.w	r0, #4000	@ 0xfa0
34002940:	d22c      	bcs.n	3400299c <main+0x404>
    UTIL_LCD_FillRGBRect(300, 100, (uint8_t *) stlogo, 200, 107);
34002942:	236b      	movs	r3, #107	@ 0x6b
34002944:	2164      	movs	r1, #100	@ 0x64
34002946:	4a82      	ldr	r2, [pc, #520]	@ (34002b50 <main+0x5b8>)
34002948:	f44f 7096 	mov.w	r0, #300	@ 0x12c
3400294c:	9300      	str	r3, [sp, #0]
3400294e:	23c8      	movs	r3, #200	@ 0xc8
34002950:	f012 fe78 	bl	34015644 <UTIL_LCD_FillRGBRect>
    UTIL_LCD_SetBackColor(0x40000000);
34002954:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34002958:	f012 fe5c 	bl	34015614 <UTIL_LCD_SetBackColor>
    UTIL_LCDEx_PrintfAt(0, LINE(16), CENTER_MODE, "Object detection");
3400295c:	f012 fe6a 	bl	34015634 <UTIL_LCD_GetFont>
34002960:	88c1      	ldrh	r1, [r0, #6]
34002962:	2201      	movs	r2, #1
34002964:	4b7b      	ldr	r3, [pc, #492]	@ (34002b54 <main+0x5bc>)
34002966:	0109      	lsls	r1, r1, #4
34002968:	2000      	movs	r0, #0
3400296a:	f000 faf5 	bl	34002f58 <UTIL_LCDEx_PrintfAt>
    UTIL_LCDEx_PrintfAt(0, LINE(17), CENTER_MODE, WELCOME_MSG_1);
3400296e:	f012 fe61 	bl	34015634 <UTIL_LCD_GetFont>
34002972:	88c1      	ldrh	r1, [r0, #6]
34002974:	2201      	movs	r2, #1
34002976:	4b78      	ldr	r3, [pc, #480]	@ (34002b58 <main+0x5c0>)
34002978:	eb01 1101 	add.w	r1, r1, r1, lsl #4
3400297c:	2000      	movs	r0, #0
3400297e:	f000 faeb 	bl	34002f58 <UTIL_LCDEx_PrintfAt>
    UTIL_LCDEx_PrintfAt(0, LINE(18), CENTER_MODE, WELCOME_MSG_2);
34002982:	f012 fe57 	bl	34015634 <UTIL_LCD_GetFont>
34002986:	88c1      	ldrh	r1, [r0, #6]
34002988:	2012      	movs	r0, #18
3400298a:	2201      	movs	r2, #1
3400298c:	4341      	muls	r1, r0
3400298e:	4b73      	ldr	r3, [pc, #460]	@ (34002b5c <main+0x5c4>)
34002990:	2000      	movs	r0, #0
34002992:	f000 fae1 	bl	34002f58 <UTIL_LCDEx_PrintfAt>
    UTIL_LCD_SetBackColor(0);
34002996:	2000      	movs	r0, #0
34002998:	f012 fe3c 	bl	34015614 <UTIL_LCD_SetBackColor>
  SCB_CleanDCache_by_Addr(lcd_fg_buffer[lcd_fg_buffer_rd_idx], LCD_FG_FRAMEBUFFER_SIZE);
3400299c:	4c70      	ldr	r4, [pc, #448]	@ (34002b60 <main+0x5c8>)
3400299e:	4971      	ldr	r1, [pc, #452]	@ (34002b64 <main+0x5cc>)
340029a0:	6822      	ldr	r2, [r4, #0]
340029a2:	4b71      	ldr	r3, [pc, #452]	@ (34002b68 <main+0x5d0>)
340029a4:	fb01 3302 	mla	r3, r1, r2, r3
  __ASM volatile ("dsb 0xF":::"memory");
340029a8:	f3bf 8f4f 	dsb	sy
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340029ac:	f645 5ec0 	movw	lr, #24000	@ 0x5dc0
340029b0:	f04e e001 	dls	lr, lr
340029b4:	4a6d      	ldr	r2, [pc, #436]	@ (34002b6c <main+0x5d4>)
340029b6:	f8c2 3268 	str.w	r3, [r2, #616]	@ 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
340029ba:	3320      	adds	r3, #32
      } while ( op_size > 0 );
340029bc:	f00f c805 	le	lr, 340029b6 <main+0x41e>
340029c0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340029c4:	f3bf 8f6f 	isb	sy
  ret = HAL_LTDC_ReloadLayer(&hlcd_ltdc, LTDC_RELOAD_VERTICAL_BLANKING, LTDC_LAYER_2);
340029c8:	2201      	movs	r2, #1
340029ca:	2102      	movs	r1, #2
340029cc:	4868      	ldr	r0, [pc, #416]	@ (34002b70 <main+0x5d8>)
340029ce:	f006 fdcf 	bl	34009570 <HAL_LTDC_ReloadLayer>
  assert(ret == HAL_OK);
340029d2:	2800      	cmp	r0, #0
340029d4:	f000 8086 	beq.w	34002ae4 <main+0x54c>
340029d8:	f240 211a 	movw	r1, #538	@ 0x21a
340029dc:	4b65      	ldr	r3, [pc, #404]	@ (34002b74 <main+0x5dc>)
340029de:	4a66      	ldr	r2, [pc, #408]	@ (34002b78 <main+0x5e0>)
340029e0:	e6f7      	b.n	340027d2 <main+0x23a>
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
340029e2:	edd5 6a02 	vldr	s13, [r5, #8]
340029e6:	edd5 7a00 	vldr	s15, [r5]
340029ea:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
340029ee:	ed99 7a02 	vldr	s14, [r9, #8]
340029f2:	eee6 7ac6 	vfms.f32	s15, s13, s12
340029f6:	eef8 5a47 	vcvt.f32.u32	s11, s14
340029fa:	ee67 7aa5 	vmul.f32	s15, s15, s11
340029fe:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    uint32_t y0 = (uint32_t) ((rois[i].y_center - rois[i].height / 2) * ((float32_t) lcd_bg_area.YSize));
34002a02:	ed95 7a01 	vldr	s14, [r5, #4]
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
34002a06:	ee17 4a90 	vmov	r4, s15
    uint32_t y0 = (uint32_t) ((rois[i].y_center - rois[i].height / 2) * ((float32_t) lcd_bg_area.YSize));
34002a0a:	edd5 7a03 	vldr	s15, [r5, #12]
34002a0e:	eea7 7ac6 	vfms.f32	s14, s15, s12
34002a12:	ed99 6a03 	vldr	s12, [r9, #12]
34002a16:	eeb8 6a46 	vcvt.f32.u32	s12, s12
34002a1a:	ee27 7a06 	vmul.f32	s14, s14, s12
    uint32_t width = (uint32_t) (rois[i].width * ((float32_t) lcd_bg_area.XSize));
34002a1e:	ee66 6aa5 	vmul.f32	s13, s13, s11
    uint32_t y0 = (uint32_t) ((rois[i].y_center - rois[i].height / 2) * ((float32_t) lcd_bg_area.YSize));
34002a22:	eebc 7ac7 	vcvt.u32.f32	s14, s14
34002a26:	ee17 1a10 	vmov	r1, s14
    uint32_t width = (uint32_t) (rois[i].width * ((float32_t) lcd_bg_area.XSize));
34002a2a:	eebc 7ae6 	vcvt.u32.f32	s14, s13
    uint32_t height = (uint32_t) (rois[i].height * ((float32_t) lcd_bg_area.YSize));
34002a2e:	ee67 7a86 	vmul.f32	s15, s15, s12
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
34002a32:	f8d9 0000 	ldr.w	r0, [r9]
    x0 = x0 < lcd_bg_area.X0 + lcd_bg_area.XSize ? x0 : lcd_bg_area.X0 + lcd_bg_area.XSize - 1;
34002a36:	f8d9 3008 	ldr.w	r3, [r9, #8]
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
34002a3a:	4404      	add	r4, r0
    x0 = x0 < lcd_bg_area.X0 + lcd_bg_area.XSize ? x0 : lcd_bg_area.X0 + lcd_bg_area.XSize - 1;
34002a3c:	4418      	add	r0, r3
34002a3e:	f100 3eff 	add.w	lr, r0, #4294967295
34002a42:	4284      	cmp	r4, r0
    uint32_t width = (uint32_t) (rois[i].width * ((float32_t) lcd_bg_area.XSize));
34002a44:	ee17 6a10 	vmov	r6, s14
    x0 = x0 < lcd_bg_area.X0 + lcd_bg_area.XSize ? x0 : lcd_bg_area.X0 + lcd_bg_area.XSize - 1;
34002a48:	bf28      	it	cs
34002a4a:	4674      	movcs	r4, lr
    uint32_t height = (uint32_t) (rois[i].height * ((float32_t) lcd_bg_area.YSize));
34002a4c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    y0 = y0 < lcd_bg_area.Y0 + lcd_bg_area.YSize ? y0 : lcd_bg_area.Y0 + lcd_bg_area.YSize  - 1;
34002a50:	f8d9 300c 	ldr.w	r3, [r9, #12]
34002a54:	f8d9 2004 	ldr.w	r2, [r9, #4]
    width = ((x0 + width) < lcd_bg_area.X0 + lcd_bg_area.XSize) ? width : (lcd_bg_area.X0 + lcd_bg_area.XSize - x0 - 1);
34002a58:	ebae 0e04 	sub.w	lr, lr, r4
    y0 = y0 < lcd_bg_area.Y0 + lcd_bg_area.YSize ? y0 : lcd_bg_area.Y0 + lcd_bg_area.YSize  - 1;
34002a5c:	441a      	add	r2, r3
34002a5e:	4291      	cmp	r1, r2
34002a60:	f102 3cff 	add.w	ip, r2, #4294967295
    width = ((x0 + width) < lcd_bg_area.X0 + lcd_bg_area.XSize) ? width : (lcd_bg_area.X0 + lcd_bg_area.XSize - x0 - 1);
34002a64:	eb06 0304 	add.w	r3, r6, r4
    y0 = y0 < lcd_bg_area.Y0 + lcd_bg_area.YSize ? y0 : lcd_bg_area.Y0 + lcd_bg_area.YSize  - 1;
34002a68:	bf28      	it	cs
34002a6a:	4661      	movcs	r1, ip
    width = ((x0 + width) < lcd_bg_area.X0 + lcd_bg_area.XSize) ? width : (lcd_bg_area.X0 + lcd_bg_area.XSize - x0 - 1);
34002a6c:	4298      	cmp	r0, r3
    height = ((y0 + height) < lcd_bg_area.Y0 + lcd_bg_area.YSize) ? height : (lcd_bg_area.Y0 + lcd_bg_area.YSize - y0 - 1);
34002a6e:	ee17 3a90 	vmov	r3, s15
34002a72:	eb03 0001 	add.w	r0, r3, r1
    width = ((x0 + width) < lcd_bg_area.X0 + lcd_bg_area.XSize) ? width : (lcd_bg_area.X0 + lcd_bg_area.XSize - x0 - 1);
34002a76:	bf98      	it	ls
34002a78:	4676      	movls	r6, lr
    height = ((y0 + height) < lcd_bg_area.Y0 + lcd_bg_area.YSize) ? height : (lcd_bg_area.Y0 + lcd_bg_area.YSize - y0 - 1);
34002a7a:	4282      	cmp	r2, r0
    UTIL_LCD_DrawRect(x0, y0, width, height, colors[rois[i].class_index % NUMBER_COLORS]);
34002a7c:	f04f 000a 	mov.w	r0, #10
34002a80:	696a      	ldr	r2, [r5, #20]
34002a82:	4b3e      	ldr	r3, [pc, #248]	@ (34002b7c <main+0x5e4>)
34002a84:	fb92 fef0 	sdiv	lr, r2, r0
34002a88:	fb00 221e 	mls	r2, r0, lr, r2
34002a8c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    height = ((y0 + height) < lcd_bg_area.Y0 + lcd_bg_area.YSize) ? height : (lcd_bg_area.Y0 + lcd_bg_area.YSize - y0 - 1);
34002a90:	ebac 0c01 	sub.w	ip, ip, r1
    UTIL_LCD_DrawRect(x0, y0, width, height, colors[rois[i].class_index % NUMBER_COLORS]);
34002a94:	ee17 3a90 	vmov	r3, s15
34002a98:	4620      	mov	r0, r4
34002a9a:	bf98      	it	ls
34002a9c:	4663      	movls	r3, ip
34002a9e:	9200      	str	r2, [sp, #0]
34002aa0:	4632      	mov	r2, r6
34002aa2:	9105      	str	r1, [sp, #20]
34002aa4:	f012 ff8c 	bl	340159c0 <UTIL_LCD_DrawRect>
    UTIL_LCDEx_PrintfAt(x0, y0, LEFT_MODE, classes_table[rois[i].class_index]);
34002aa8:	696a      	ldr	r2, [r5, #20]
34002aaa:	4b35      	ldr	r3, [pc, #212]	@ (34002b80 <main+0x5e8>)
34002aac:	4620      	mov	r0, r4
34002aae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34002ab2:	9905      	ldr	r1, [sp, #20]
34002ab4:	2203      	movs	r2, #3
34002ab6:	f000 fa4f 	bl	34002f58 <UTIL_LCDEx_PrintfAt>
    UTIL_LCDEx_PrintfAt(-x0-width, y0, RIGHT_MODE, "%.0f%%", rois[i].conf*100.0f);
34002aba:	ed95 7a04 	vldr	s14, [r5, #16]
34002abe:	eddf 7a31 	vldr	s15, [pc, #196]	@ 34002b84 <main+0x5ec>
34002ac2:	ee27 7a27 	vmul.f32	s14, s14, s15
34002ac6:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34002aca:	19a0      	adds	r0, r4, r6
34002acc:	ed8d 7b00 	vstr	d7, [sp]
34002ad0:	2202      	movs	r2, #2
34002ad2:	4b2d      	ldr	r3, [pc, #180]	@ (34002b88 <main+0x5f0>)
34002ad4:	9905      	ldr	r1, [sp, #20]
34002ad6:	4240      	negs	r0, r0
34002ad8:	f000 fa3e 	bl	34002f58 <UTIL_LCDEx_PrintfAt>
  for (int32_t i = 0; i < nb_rois; i++)
34002adc:	f10b 0b01 	add.w	fp, fp, #1
34002ae0:	3518      	adds	r5, #24
34002ae2:	e700      	b.n	340028e6 <main+0x34e>
  lcd_fg_buffer_rd_idx = 1 - lcd_fg_buffer_rd_idx;
34002ae4:	6823      	ldr	r3, [r4, #0]
}
34002ae6:	a90d      	add	r1, sp, #52	@ 0x34
  lcd_fg_buffer_rd_idx = 1 - lcd_fg_buffer_rd_idx;
34002ae8:	f1c3 0301 	rsb	r3, r3, #1
34002aec:	6023      	str	r3, [r4, #0]
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002aee:	4c1f      	ldr	r4, [pc, #124]	@ (34002b6c <main+0x5d4>)
      float32_t *tmp = nn_out[i];
34002af0:	a808      	add	r0, sp, #32
    for (int i = 0; i < number_output; i++)
34002af2:	4547      	cmp	r7, r8
34002af4:	f43f adfe 	beq.w	340026f4 <main+0x15c>
      SCB_InvalidateDCache_by_Addr(tmp, nn_out_len[i]);
34002af8:	f851 2b04 	ldr.w	r2, [r1], #4
    if ( dsize > 0 ) {
34002afc:	2a00      	cmp	r2, #0
34002afe:	dd1c      	ble.n	34002b3a <main+0x5a2>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002b00:	f850 3027 	ldr.w	r3, [r0, r7, lsl #2]
34002b04:	f003 051f 	and.w	r5, r3, #31
34002b08:	4415      	add	r5, r2
  __ASM volatile ("dsb 0xF":::"memory");
34002b0a:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
34002b0e:	43da      	mvns	r2, r3
34002b10:	195e      	adds	r6, r3, r5
34002b12:	4432      	add	r2, r6
34002b14:	3d20      	subs	r5, #32
34002b16:	0952      	lsrs	r2, r2, #5
34002b18:	3520      	adds	r5, #32
34002b1a:	f102 0e01 	add.w	lr, r2, #1
34002b1e:	bfd8      	it	le
34002b20:	f04f 0e01 	movle.w	lr, #1
34002b24:	f04e e001 	dls	lr, lr
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002b28:	f8c4 325c 	str.w	r3, [r4, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
34002b2c:	3320      	adds	r3, #32
      } while ( op_size > 0 );
34002b2e:	f00f c805 	le	lr, 34002b28 <main+0x590>
34002b32:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34002b36:	f3bf 8f6f 	isb	sy
    for (int i = 0; i < number_output; i++)
34002b3a:	3701      	adds	r7, #1
34002b3c:	e7d9      	b.n	34002af2 <main+0x55a>
34002b3e:	bf00      	nop
34002b40:	340b0ee8 	.word	0x340b0ee8
34002b44:	3401d8c3 	.word	0x3401d8c3
34002b48:	340cd12c 	.word	0x340cd12c
34002b4c:	3401d8ce 	.word	0x3401d8ce
34002b50:	34022f88 	.word	0x34022f88
34002b54:	3401d8de 	.word	0x3401d8de
34002b58:	3401d8ef 	.word	0x3401d8ef
34002b5c:	3401d91c 	.word	0x3401d91c
34002b60:	340cd130 	.word	0x340cd130
34002b64:	000bb800 	.word	0x000bb800
34002b68:	91000000 	.word	0x91000000
34002b6c:	e000ed00 	.word	0xe000ed00
34002b70:	340cdda4 	.word	0x340cdda4
34002b74:	3401d49b 	.word	0x3401d49b
34002b78:	34022ef8 	.word	0x34022ef8
34002b7c:	34022f60 	.word	0x34022f60
34002b80:	340b0ef8 	.word	0x340b0ef8
34002b84:	42c80000 	.word	0x42c80000
34002b88:	3401d8bc 	.word	0x3401d8bc
34002b8c:	340cd1b0 	.word	0x340cd1b0

34002b90 <IAC_IRQHandler>:
  while (1)
34002b90:	e7fe      	b.n	34002b90 <IAC_IRQHandler>

34002b92 <MX_DCMIPP_ClockConfig>:
{
34002b92:	b500      	push	{lr}
34002b94:	b0e5      	sub	sp, #404	@ 0x194
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
34002b96:	f44f 72c8 	mov.w	r2, #400	@ 0x190
34002b9a:	2100      	movs	r1, #0
34002b9c:	4668      	mov	r0, sp
34002b9e:	f017 fac1 	bl	3401a124 <memset>
  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_DCMIPP;
34002ba2:	2300      	movs	r3, #0
34002ba4:	2210      	movs	r2, #16
34002ba6:	e9cd 2300 	strd	r2, r3, [sp]
  RCC_PeriphCLKInitStruct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_IC17;
34002baa:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC17].ClockDivider = 3;
34002bae:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
  RCC_PeriphCLKInitStruct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_IC17;
34002bb2:	9332      	str	r3, [sp, #200]	@ 0xc8
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC17].ClockDivider = 3;
34002bb4:	2303      	movs	r3, #3
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
34002bb6:	4668      	mov	r0, sp
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC17].ClockDivider = 3;
34002bb8:	e9cd 1322 	strd	r1, r3, [sp, #136]	@ 0x88
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
34002bbc:	f007 ff6c 	bl	3400aa98 <HAL_RCCEx_PeriphCLKConfig>
  if (ret)
34002bc0:	b948      	cbnz	r0, 34002bd6 <MX_DCMIPP_ClockConfig+0x44>
  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CSI;
34002bc2:	2300      	movs	r3, #0
34002bc4:	2208      	movs	r2, #8
34002bc6:	e9cd 2300 	strd	r2, r3, [sp]
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC18].ClockDivider = 40;
34002bca:	2328      	movs	r3, #40	@ 0x28
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC18].ClockSelection = RCC_ICCLKSOURCE_PLL1;
34002bcc:	9024      	str	r0, [sp, #144]	@ 0x90
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
34002bce:	4668      	mov	r0, sp
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC18].ClockDivider = 40;
34002bd0:	9325      	str	r3, [sp, #148]	@ 0x94
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
34002bd2:	f007 ff61 	bl	3400aa98 <HAL_RCCEx_PeriphCLKConfig>
}
34002bd6:	b065      	add	sp, #404	@ 0x194
34002bd8:	f85d fb04 	ldr.w	pc, [sp], #4

34002bdc <HAL_CACHEAXI_MspInit>:
  }
}

void HAL_CACHEAXI_MspInit(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34002bdc:	b507      	push	{r0, r1, r2, lr}
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34002bde:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
  __HAL_RCC_CACHEAXIRAM_MEM_CLK_ENABLE();
34002be2:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34002be6:	f7ff fa53 	bl	34002090 <LL_MEM_EnableClock>
34002bea:	4b08      	ldr	r3, [pc, #32]	@ (34002c0c <HAL_CACHEAXI_MspInit+0x30>)
34002bec:	f8c3 2a60 	str.w	r2, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34002bf0:	f8d3 1260 	ldr.w	r1, [r3, #608]	@ 0x260
34002bf4:	9101      	str	r1, [sp, #4]
  (void)tmpreg;
34002bf6:	9901      	ldr	r1, [sp, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34002bf8:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34002bfc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34002c00:	f8c3 2220 	str.w	r2, [r3, #544]	@ 0x220
  __HAL_RCC_CACHEAXI_CLK_ENABLE();
  __HAL_RCC_CACHEAXI_FORCE_RESET();
  __HAL_RCC_CACHEAXI_RELEASE_RESET();
}
34002c04:	b003      	add	sp, #12
34002c06:	f85d fb04 	ldr.w	pc, [sp], #4
34002c0a:	bf00      	nop
34002c0c:	56028000 	.word	0x56028000

34002c10 <assert_failed>:
  */
void assert_failed(uint8_t* file, uint32_t line)
{
  UNUSED(file);
  UNUSED(line);
  __BKPT(0);
34002c10:	be00      	bkpt	0x0000
  while (1)
34002c12:	e7fe      	b.n	34002c12 <assert_failed+0x2>

34002c14 <mcu_cache_invalidate_range>:
  }
  return 0;
}

int mcu_cache_invalidate_range(uint32_t start_addr, uint32_t end_addr)
{
34002c14:	b530      	push	{r4, r5, lr}

#include "stm32n6xx_hal.h"

__STATIC_FORCEINLINE int mcu_cache_enabled(void) {
#if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
   if (SCB->CCR & SCB_CCR_DC_Msk) return 1;  /* return `1` if DCache is enabled */
34002c16:	4d13      	ldr	r5, [pc, #76]	@ (34002c64 <mcu_cache_invalidate_range+0x50>)
34002c18:	696b      	ldr	r3, [r5, #20]
34002c1a:	03db      	lsls	r3, r3, #15
34002c1c:	d51f      	bpl.n	34002c5e <mcu_cache_invalidate_range+0x4a>
  if(mcu_cache_enabled()) {
    SCB_InvalidateDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
34002c1e:	1a0a      	subs	r2, r1, r0
    if ( dsize > 0 ) {
34002c20:	2a00      	cmp	r2, #0
34002c22:	dd1c      	ble.n	34002c5e <mcu_cache_invalidate_range+0x4a>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002c24:	f000 031f 	and.w	r3, r0, #31
34002c28:	441a      	add	r2, r3
  __ASM volatile ("dsb 0xF":::"memory");
34002c2a:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
34002c2e:	1884      	adds	r4, r0, r2
34002c30:	43c2      	mvns	r2, r0
34002c32:	1a1b      	subs	r3, r3, r0
34002c34:	440b      	add	r3, r1
34002c36:	4422      	add	r2, r4
34002c38:	3b20      	subs	r3, #32
34002c3a:	0952      	lsrs	r2, r2, #5
34002c3c:	3320      	adds	r3, #32
34002c3e:	f102 0e01 	add.w	lr, r2, #1
34002c42:	bfd8      	it	le
34002c44:	f04f 0e01 	movle.w	lr, #1
34002c48:	f04e e001 	dls	lr, lr
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002c4c:	f8c5 025c 	str.w	r0, [r5, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
34002c50:	3020      	adds	r0, #32
      } while ( op_size > 0 );
34002c52:	f00f c805 	le	lr, 34002c4c <mcu_cache_invalidate_range+0x38>
34002c56:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34002c5a:	f3bf 8f6f 	isb	sy
  }
  return 0;
}
34002c5e:	2000      	movs	r0, #0
34002c60:	bd30      	pop	{r4, r5, pc}
34002c62:	bf00      	nop
34002c64:	e000ed00 	.word	0xe000ed00

34002c68 <mcu_cache_clean_range>:

int mcu_cache_clean_range(uint32_t start_addr, uint32_t end_addr) {
34002c68:	b530      	push	{r4, r5, lr}
34002c6a:	4d13      	ldr	r5, [pc, #76]	@ (34002cb8 <mcu_cache_clean_range+0x50>)
34002c6c:	696b      	ldr	r3, [r5, #20]
34002c6e:	03db      	lsls	r3, r3, #15
34002c70:	d51f      	bpl.n	34002cb2 <mcu_cache_clean_range+0x4a>
  if(mcu_cache_enabled()) {
    SCB_CleanDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
34002c72:	1a0a      	subs	r2, r1, r0
    if ( dsize > 0 ) {
34002c74:	2a00      	cmp	r2, #0
34002c76:	dd1c      	ble.n	34002cb2 <mcu_cache_clean_range+0x4a>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002c78:	f000 031f 	and.w	r3, r0, #31
34002c7c:	441a      	add	r2, r3
  __ASM volatile ("dsb 0xF":::"memory");
34002c7e:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
34002c82:	1884      	adds	r4, r0, r2
34002c84:	43c2      	mvns	r2, r0
34002c86:	1a1b      	subs	r3, r3, r0
34002c88:	440b      	add	r3, r1
34002c8a:	4422      	add	r2, r4
34002c8c:	3b20      	subs	r3, #32
34002c8e:	0952      	lsrs	r2, r2, #5
34002c90:	3320      	adds	r3, #32
34002c92:	f102 0e01 	add.w	lr, r2, #1
34002c96:	bfd8      	it	le
34002c98:	f04f 0e01 	movle.w	lr, #1
34002c9c:	f04e e001 	dls	lr, lr
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002ca0:	f8c5 0268 	str.w	r0, [r5, #616]	@ 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
34002ca4:	3020      	adds	r0, #32
      } while ( op_size > 0 );
34002ca6:	f00f c805 	le	lr, 34002ca0 <mcu_cache_clean_range+0x38>
34002caa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34002cae:	f3bf 8f6f 	isb	sy
  }
  return 0;
}
34002cb2:	2000      	movs	r0, #0
34002cb4:	bd30      	pop	{r4, r5, pc}
34002cb6:	bf00      	nop
34002cb8:	e000ed00 	.word	0xe000ed00

34002cbc <mcu_cache_clean_invalidate_range>:
 int mcu_cache_clean_invalidate_range(uint32_t start_addr, uint32_t end_addr) {
34002cbc:	b530      	push	{r4, r5, lr}
34002cbe:	4d13      	ldr	r5, [pc, #76]	@ (34002d0c <mcu_cache_clean_invalidate_range+0x50>)
34002cc0:	696b      	ldr	r3, [r5, #20]
34002cc2:	03db      	lsls	r3, r3, #15
34002cc4:	d51f      	bpl.n	34002d06 <mcu_cache_clean_invalidate_range+0x4a>
  if(mcu_cache_enabled()) {
    SCB_CleanInvalidateDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
34002cc6:	1a0a      	subs	r2, r1, r0
    if ( dsize > 0 ) {
34002cc8:	2a00      	cmp	r2, #0
34002cca:	dd1c      	ble.n	34002d06 <mcu_cache_clean_invalidate_range+0x4a>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002ccc:	f000 031f 	and.w	r3, r0, #31
34002cd0:	441a      	add	r2, r3
  __ASM volatile ("dsb 0xF":::"memory");
34002cd2:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
34002cd6:	1884      	adds	r4, r0, r2
34002cd8:	43c2      	mvns	r2, r0
34002cda:	1a1b      	subs	r3, r3, r0
34002cdc:	440b      	add	r3, r1
34002cde:	4422      	add	r2, r4
34002ce0:	3b20      	subs	r3, #32
34002ce2:	0952      	lsrs	r2, r2, #5
34002ce4:	3320      	adds	r3, #32
34002ce6:	f102 0e01 	add.w	lr, r2, #1
34002cea:	bfd8      	it	le
34002cec:	f04f 0e01 	movle.w	lr, #1
34002cf0:	f04e e001 	dls	lr, lr
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002cf4:	f8c5 0270 	str.w	r0, [r5, #624]	@ 0x270
        op_addr +=          __SCB_DCACHE_LINE_SIZE;
34002cf8:	3020      	adds	r0, #32
      } while ( op_size > 0 );
34002cfa:	f00f c805 	le	lr, 34002cf4 <mcu_cache_clean_invalidate_range+0x38>
34002cfe:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34002d02:	f3bf 8f6f 	isb	sy
  }
  return 0;
}
34002d06:	2000      	movs	r0, #0
34002d08:	bd30      	pop	{r4, r5, pc}
34002d0a:	bf00      	nop
34002d0c:	e000ed00 	.word	0xe000ed00

34002d10 <_ec_blob_cache_start_func_196>:
   *       cache (e.g. using a DMA) and should be called BEFORE the buffer gets filled
   */
  static inline void LL_ATON_Cache_MCU_Invalidate_Range(uintptr_t virtual_addr, uint32_t size)
  {
    LL_ATON_OSAL_LOCK_MCU_CACHE();
    mcu_cache_invalidate_range(virtual_addr, virtual_addr + size);
34002d10:	4901      	ldr	r1, [pc, #4]	@ (34002d18 <_ec_blob_cache_start_func_196+0x8>)
34002d12:	4802      	ldr	r0, [pc, #8]	@ (34002d1c <_ec_blob_cache_start_func_196+0xc>)
34002d14:	f7ff bf7e 	b.w	34002c14 <mcu_cache_invalidate_range>
34002d18:	342fb5c0 	.word	0x342fb5c0
34002d1c:	342fa5e0 	.word	0x342fa5e0

34002d20 <_ec_blob_cache_start_func_191>:
34002d20:	4901      	ldr	r1, [pc, #4]	@ (34002d28 <_ec_blob_cache_start_func_191+0x8>)
34002d22:	4802      	ldr	r0, [pc, #8]	@ (34002d2c <_ec_blob_cache_start_func_191+0xc>)
34002d24:	f7ff bf76 	b.w	34002c14 <mcu_cache_invalidate_range>
34002d28:	342d1900 	.word	0x342d1900
34002d2c:	342ceec0 	.word	0x342ceec0

34002d30 <_ec_blob_cache_start_func_138>:


// Epoch Controller Blob (name='_ec_blob_Default_138') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_138') start function
static void _ec_blob_cache_start_func_138(const void *epoch_block) {
34002d30:	b508      	push	{r3, lr}
34002d32:	4907      	ldr	r1, [pc, #28]	@ (34002d50 <_ec_blob_cache_start_func_138+0x20>)
34002d34:	4807      	ldr	r0, [pc, #28]	@ (34002d54 <_ec_blob_cache_start_func_138+0x24>)
34002d36:	f7ff ff6d 	bl	34002c14 <mcu_cache_invalidate_range>
34002d3a:	4907      	ldr	r1, [pc, #28]	@ (34002d58 <_ec_blob_cache_start_func_138+0x28>)
34002d3c:	4807      	ldr	r0, [pc, #28]	@ (34002d5c <_ec_blob_cache_start_func_138+0x2c>)
34002d3e:	f7ff ff69 	bl	34002c14 <mcu_cache_invalidate_range>
  /*     memory pool: 2 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x34270000UL + 399584))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x34270000UL + 410400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x34270000UL + 399584))) /* Equivalent hex address = 0x342d18e0UL */, 10816);

};
34002d42:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
34002d46:	4906      	ldr	r1, [pc, #24]	@ (34002d60 <_ec_blob_cache_start_func_138+0x30>)
34002d48:	4806      	ldr	r0, [pc, #24]	@ (34002d64 <_ec_blob_cache_start_func_138+0x34>)
34002d4a:	f7ff bf63 	b.w	34002c14 <mcu_cache_invalidate_range>
34002d4e:	bf00      	nop
34002d50:	3434d6e0 	.word	0x3434d6e0
34002d54:	34349780 	.word	0x34349780
34002d58:	342ceec0 	.word	0x342ceec0
34002d5c:	342c4600 	.word	0x342c4600
34002d60:	342d4320 	.word	0x342d4320
34002d64:	342d18e0 	.word	0x342d18e0

34002d68 <_ec_blob_cache_start_func_119>:
34002d68:	4901      	ldr	r1, [pc, #4]	@ (34002d70 <_ec_blob_cache_start_func_119+0x8>)
34002d6a:	4802      	ldr	r0, [pc, #8]	@ (34002d74 <_ec_blob_cache_start_func_119+0xc>)
34002d6c:	f7ff bf52 	b.w	34002c14 <mcu_cache_invalidate_range>
34002d70:	34318400 	.word	0x34318400
34002d74:	342e0000 	.word	0x342e0000

34002d78 <_ec_blob_cache_start_func_1>:
34002d78:	4901      	ldr	r1, [pc, #4]	@ (34002d80 <_ec_blob_cache_start_func_1+0x8>)
34002d7a:	4802      	ldr	r0, [pc, #8]	@ (34002d84 <_ec_blob_cache_start_func_1+0xc>)
34002d7c:	f7ff bf4a 	b.w	34002c14 <mcu_cache_invalidate_range>
34002d80:	34334600 	.word	0x34334600
34002d84:	34318400 	.word	0x34318400

34002d88 <LL_ATON_End_EpochBlock_220>:


/* scheduling epoch=220  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_220(const void *epoch_block)
{
34002d88:	b537      	push	{r0, r1, r2, r4, r5, lr}
34002d8a:	4d0d      	ldr	r5, [pc, #52]	@ (34002dc0 <LL_ATON_End_EpochBlock_220+0x38>)
34002d8c:	4c0d      	ldr	r4, [pc, #52]	@ (34002dc4 <LL_ATON_End_EpochBlock_220+0x3c>)
34002d8e:	4629      	mov	r1, r5
34002d90:	4620      	mov	r0, r4
34002d92:	f7ff ff3f 	bl	34002c14 <mcu_cache_invalidate_range>
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 64800))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 68864))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 64800))) /* Equivalent hex address = 0x342efd20UL */, 4064);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);
34002d96:	2100      	movs	r1, #0
34002d98:	4608      	mov	r0, r1
34002d9a:	f013 fedd 	bl	34016b58 <LL_Switch_Init>
    {
      .name = NULL,
    }
  };

  LL_ATON_LIB_Concat(Concat_780_tensor_info_in_220, 3, Concat_780_tensor_info_out_220, 1, 4, 5);
34002d9e:	2304      	movs	r3, #4
34002da0:	2205      	movs	r2, #5
34002da2:	2103      	movs	r1, #3
34002da4:	e9cd 3200 	strd	r3, r2, [sp]
34002da8:	4807      	ldr	r0, [pc, #28]	@ (34002dc8 <LL_ATON_End_EpochBlock_220+0x40>)
34002daa:	2301      	movs	r3, #1
34002dac:	4a07      	ldr	r2, [pc, #28]	@ (34002dcc <LL_ATON_End_EpochBlock_220+0x44>)
34002dae:	f014 fd13 	bl	340177d8 <LL_ATON_LIB_Concat>
    mcu_cache_clean_range(virtual_addr, virtual_addr + size);
34002db2:	4629      	mov	r1, r5
34002db4:	4620      	mov	r0, r4
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 64800))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 68864))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 64800))) /* Equivalent hex address = 0x342efd20UL */, 4064);

}
34002db6:	b003      	add	sp, #12
34002db8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34002dbc:	f7ff bf54 	b.w	34002c68 <mcu_cache_clean_range>
34002dc0:	342f0d00 	.word	0x342f0d00
34002dc4:	342efd20 	.word	0x342efd20
34002dc8:	34033010 	.word	0x34033010
34002dcc:	34032fa0 	.word	0x34032fa0

34002dd0 <LL_ATON_End_EpochBlock_195>:
{
34002dd0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    mcu_cache_invalidate_range(virtual_addr, virtual_addr + size);
34002dd2:	4d0d      	ldr	r5, [pc, #52]	@ (34002e08 <LL_ATON_End_EpochBlock_195+0x38>)
34002dd4:	4c0d      	ldr	r4, [pc, #52]	@ (34002e0c <LL_ATON_End_EpochBlock_195+0x3c>)
34002dd6:	4629      	mov	r1, r5
34002dd8:	4620      	mov	r0, r4
34002dda:	f7ff ff1b 	bl	34002c14 <mcu_cache_invalidate_range>
  LL_Switch_Init(NULL, 0);
34002dde:	2100      	movs	r1, #0
34002de0:	4608      	mov	r0, r1
34002de2:	f013 feb9 	bl	34016b58 <LL_Switch_Init>
  LL_ATON_LIB_Concat(Concat_884_tensor_info_in_195, 3, Concat_884_tensor_info_out_195, 1, 9, 0);
34002de6:	2309      	movs	r3, #9
34002de8:	2200      	movs	r2, #0
34002dea:	2103      	movs	r1, #3
34002dec:	e9cd 3200 	strd	r3, r2, [sp]
34002df0:	4807      	ldr	r0, [pc, #28]	@ (34002e10 <LL_ATON_End_EpochBlock_195+0x40>)
34002df2:	2301      	movs	r3, #1
34002df4:	4a07      	ldr	r2, [pc, #28]	@ (34002e14 <LL_ATON_End_EpochBlock_195+0x44>)
34002df6:	f014 fcef 	bl	340177d8 <LL_ATON_LIB_Concat>
    mcu_cache_clean_range(virtual_addr, virtual_addr + size);
34002dfa:	4629      	mov	r1, r5
34002dfc:	4620      	mov	r0, r4
}
34002dfe:	b003      	add	sp, #12
34002e00:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34002e04:	f7ff bf30 	b.w	34002c68 <mcu_cache_clean_range>
34002e08:	342efd20 	.word	0x342efd20
34002e0c:	342e0000 	.word	0x342e0000
34002e10:	34032e40 	.word	0x34032e40
34002e14:	34032dd0 	.word	0x34032dd0

34002e18 <LL_ATON_End_EpochBlock_190>:
{
34002e18:	b537      	push	{r0, r1, r2, r4, r5, lr}
    mcu_cache_invalidate_range(virtual_addr, virtual_addr + size);
34002e1a:	4d0d      	ldr	r5, [pc, #52]	@ (34002e50 <LL_ATON_End_EpochBlock_190+0x38>)
34002e1c:	4c0d      	ldr	r4, [pc, #52]	@ (34002e54 <LL_ATON_End_EpochBlock_190+0x3c>)
34002e1e:	4629      	mov	r1, r5
34002e20:	4620      	mov	r0, r4
34002e22:	f7ff fef7 	bl	34002c14 <mcu_cache_invalidate_range>
  LL_Switch_Init(NULL, 0);
34002e26:	2100      	movs	r1, #0
34002e28:	4608      	mov	r0, r1
34002e2a:	f013 fe95 	bl	34016b58 <LL_Switch_Init>
  LL_ATON_LIB_Concat(Concat_832_tensor_info_in_190, 3, Concat_832_tensor_info_out_190, 1, 8, 9);
34002e2e:	2308      	movs	r3, #8
34002e30:	2209      	movs	r2, #9
34002e32:	2103      	movs	r1, #3
34002e34:	e9cd 3200 	strd	r3, r2, [sp]
34002e38:	4807      	ldr	r0, [pc, #28]	@ (34002e58 <LL_ATON_End_EpochBlock_190+0x40>)
34002e3a:	2301      	movs	r3, #1
34002e3c:	4a07      	ldr	r2, [pc, #28]	@ (34002e5c <LL_ATON_End_EpochBlock_190+0x44>)
34002e3e:	f014 fccb 	bl	340177d8 <LL_ATON_LIB_Concat>
    mcu_cache_clean_range(virtual_addr, virtual_addr + size);
34002e42:	4629      	mov	r1, r5
34002e44:	4620      	mov	r0, r4
}
34002e46:	b003      	add	sp, #12
34002e48:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34002e4c:	f7ff bf0c 	b.w	34002c68 <mcu_cache_clean_range>
34002e50:	3431c360 	.word	0x3431c360
34002e54:	34318400 	.word	0x34318400
34002e58:	34032c70 	.word	0x34032c70
34002e5c:	34032c00 	.word	0x34032c00

34002e60 <LL_ATON_End_EpochBlock_137>:
{
34002e60:	b530      	push	{r4, r5, lr}
    mcu_cache_invalidate_range(virtual_addr, virtual_addr + size);
34002e62:	4d0e      	ldr	r5, [pc, #56]	@ (34002e9c <LL_ATON_End_EpochBlock_137+0x3c>)
34002e64:	4c0e      	ldr	r4, [pc, #56]	@ (34002ea0 <LL_ATON_End_EpochBlock_137+0x40>)
34002e66:	b085      	sub	sp, #20
34002e68:	4629      	mov	r1, r5
34002e6a:	4620      	mov	r0, r4
34002e6c:	f7ff fed2 	bl	34002c14 <mcu_cache_invalidate_range>
  LL_Switch_Init(NULL, 0);
34002e70:	2100      	movs	r1, #0
34002e72:	4608      	mov	r0, r1
34002e74:	f013 fe70 	bl	34016b58 <LL_Switch_Init>
  LL_ATON_LIB_DMA_DepthToSpace(Resize_553_resize_NN_to_expansion_dts_1803_tensor_info_in_137, 1, Resize_553_resize_NN_to_expansion_dts_1803_tensor_info_out_137, 2, 2, 4, 5);
34002e78:	2304      	movs	r3, #4
34002e7a:	2205      	movs	r2, #5
34002e7c:	e9cd 3201 	strd	r3, r2, [sp, #4]
34002e80:	2302      	movs	r3, #2
34002e82:	2101      	movs	r1, #1
34002e84:	4a07      	ldr	r2, [pc, #28]	@ (34002ea4 <LL_ATON_End_EpochBlock_137+0x44>)
34002e86:	9300      	str	r3, [sp, #0]
34002e88:	4807      	ldr	r0, [pc, #28]	@ (34002ea8 <LL_ATON_End_EpochBlock_137+0x48>)
34002e8a:	f014 fc97 	bl	340177bc <LL_ATON_LIB_DMA_DepthToSpace>
    mcu_cache_clean_range(virtual_addr, virtual_addr + size);
34002e8e:	4629      	mov	r1, r5
34002e90:	4620      	mov	r0, r4
}
34002e92:	b005      	add	sp, #20
34002e94:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34002e98:	f7ff bee6 	b.w	34002c68 <mcu_cache_clean_range>
34002e9c:	34138400 	.word	0x34138400
34002ea0:	34100000 	.word	0x34100000
34002ea4:	34032aa0 	.word	0x34032aa0
34002ea8:	34032b10 	.word	0x34032b10

34002eac <LL_ATON_End_EpochBlock_118>:
{
34002eac:	b530      	push	{r4, r5, lr}
    mcu_cache_invalidate_range(virtual_addr, virtual_addr + size);
34002eae:	4d0e      	ldr	r5, [pc, #56]	@ (34002ee8 <LL_ATON_End_EpochBlock_118+0x3c>)
34002eb0:	4c0e      	ldr	r4, [pc, #56]	@ (34002eec <LL_ATON_End_EpochBlock_118+0x40>)
34002eb2:	b085      	sub	sp, #20
34002eb4:	4629      	mov	r1, r5
34002eb6:	4620      	mov	r0, r4
34002eb8:	f7ff feac 	bl	34002c14 <mcu_cache_invalidate_range>
  LL_Switch_Init(NULL, 0);
34002ebc:	2100      	movs	r1, #0
34002ebe:	4608      	mov	r0, r1
34002ec0:	f013 fe4a 	bl	34016b58 <LL_Switch_Init>
  LL_ATON_LIB_DMA_DepthToSpace(Resize_495_resize_NN_to_expansion_dts_1799_tensor_info_in_118, 1, Resize_495_resize_NN_to_expansion_dts_1799_tensor_info_out_118, 2, 2, 2, 3);
34002ec4:	2302      	movs	r3, #2
34002ec6:	2203      	movs	r2, #3
34002ec8:	2101      	movs	r1, #1
34002eca:	e9cd 3201 	strd	r3, r2, [sp, #4]
34002ece:	9300      	str	r3, [sp, #0]
34002ed0:	4a07      	ldr	r2, [pc, #28]	@ (34002ef0 <LL_ATON_End_EpochBlock_118+0x44>)
34002ed2:	4808      	ldr	r0, [pc, #32]	@ (34002ef4 <LL_ATON_End_EpochBlock_118+0x48>)
34002ed4:	f014 fc72 	bl	340177bc <LL_ATON_LIB_DMA_DepthToSpace>
    mcu_cache_clean_range(virtual_addr, virtual_addr + size);
34002ed8:	4629      	mov	r1, r5
34002eda:	4620      	mov	r0, r4
}
34002edc:	b005      	add	sp, #20
34002ede:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34002ee2:	f7ff bec1 	b.w	34002c68 <mcu_cache_clean_range>
34002ee6:	bf00      	nop
34002ee8:	342fc200 	.word	0x342fc200
34002eec:	342e0000 	.word	0x342e0000
34002ef0:	34032970 	.word	0x34032970
34002ef4:	340329e0 	.word	0x340329e0

34002ef8 <LL_ATON_Set_User_Input_Buffer_Default>:
}
34002ef8:	2003      	movs	r0, #3
34002efa:	4770      	bx	lr

34002efc <LL_ATON_Get_User_Input_Buffer_Default>:
}
34002efc:	2000      	movs	r0, #0
34002efe:	4770      	bx	lr

34002f00 <LL_ATON_Set_User_Output_Buffer_Default>:
LL_ATON_User_IO_Result_t LL_ATON_Set_User_Output_Buffer_Default(uint32_t num, void* buffer, uint32_t size)
34002f00:	2003      	movs	r0, #3
34002f02:	4770      	bx	lr

34002f04 <LL_ATON_Get_User_Output_Buffer_Default>:
void *LL_ATON_Get_User_Output_Buffer_Default(uint32_t num)
34002f04:	2000      	movs	r0, #0
34002f06:	4770      	bx	lr

34002f08 <LL_ATON_EC_Network_Init_Default>:

// this function MUST be called ONLY ONCE once for initializing the network
bool LL_ATON_EC_Network_Init_Default(void)
{
  return true;
}
34002f08:	2001      	movs	r0, #1
34002f0a:	4770      	bx	lr

34002f0c <LL_ATON_EC_Inference_Init_Default>:

// this function should be called before each inference
bool LL_ATON_EC_Inference_Init_Default(void)
34002f0c:	2001      	movs	r0, #1
34002f0e:	4770      	bx	lr

34002f10 <LL_ATON_EpochBlockItems_Default>:
    },
  };


  return ll_atonn_rt_epoch_block_array;
}
34002f10:	4800      	ldr	r0, [pc, #0]	@ (34002f14 <LL_ATON_EpochBlockItems_Default+0x4>)
34002f12:	4770      	bx	lr
34002f14:	340330f0 	.word	0x340330f0

34002f18 <LL_ATON_Input_Buffers_Info_Default>:
      .name = NULL,
    }
  };

  return buff_info;
}
34002f18:	4800      	ldr	r0, [pc, #0]	@ (34002f1c <LL_ATON_Input_Buffers_Info_Default+0x4>)
34002f1a:	4770      	bx	lr
34002f1c:	340328b0 	.word	0x340328b0

34002f20 <LL_ATON_Output_Buffers_Info_Default>:
      .name = NULL,
    }
  };

  return buff_info;
}
34002f20:	4800      	ldr	r0, [pc, #0]	@ (34002f24 <LL_ATON_Output_Buffers_Info_Default+0x4>)
34002f22:	4770      	bx	lr
34002f24:	340327a8 	.word	0x340327a8

34002f28 <LL_ATON_Internal_Buffers_Info_Default>:
      .name = NULL,
    }
  };

  return buff_info;
}
34002f28:	4800      	ldr	r0, [pc, #0]	@ (34002f2c <LL_ATON_Internal_Buffers_Info_Default+0x4>)
34002f2a:	4770      	bx	lr
34002f2c:	3402e440 	.word	0x3402e440

34002f30 <npu_cache_init>:

static CACHEAXI_HandleTypeDef hcacheaxi_s;

void npu_cache_init(void)
{
  hcacheaxi_s.Instance = CACHEAXI;
34002f30:	4802      	ldr	r0, [pc, #8]	@ (34002f3c <npu_cache_init+0xc>)
34002f32:	4b03      	ldr	r3, [pc, #12]	@ (34002f40 <npu_cache_init+0x10>)
34002f34:	6003      	str	r3, [r0, #0]
  HAL_CACHEAXI_Init(&hcacheaxi_s);      // Side effect: cacheaxi should be enabled (but one should call npu_enable_cache to be sure)
34002f36:	f002 b8ab 	b.w	34005090 <HAL_CACHEAXI_Init>
34002f3a:	bf00      	nop
34002f3c:	340cd1c0 	.word	0x340cd1c0
34002f40:	580dfc00 	.word	0x580dfc00

34002f44 <npu_cache_enable>:
}

void npu_cache_enable(void)
{
34002f44:	b510      	push	{r4, lr}
  HAL_StatusTypeDef status;
  // Enable is wrapped in a loop because most of times, the first call returns
  //    HAL_BUSY, resulting in a cache not enabled.
  do
  {
    status = HAL_CACHEAXI_Enable(&hcacheaxi_s);
34002f46:	4c03      	ldr	r4, [pc, #12]	@ (34002f54 <npu_cache_enable+0x10>)
34002f48:	4620      	mov	r0, r4
34002f4a:	f002 f86d 	bl	34005028 <HAL_CACHEAXI_Enable>
  } while (status == HAL_BUSY);
34002f4e:	2802      	cmp	r0, #2
34002f50:	d0fa      	beq.n	34002f48 <npu_cache_enable+0x4>
}
34002f52:	bd10      	pop	{r4, pc}
34002f54:	340cd1c0 	.word	0x340cd1c0

34002f58 <UTIL_LCDEx_PrintfAt>:
  UTIL_LCD_DisplayStringAtLine(line, (uint8_t *) buffer);
  va_end(args);
}

void UTIL_LCDEx_PrintfAt(uint32_t x_pos, uint32_t y_pos, Text_AlignModeTypdef mode, const char * format, ...)
{
34002f58:	b408      	push	{r3}
34002f5a:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
34002f5c:	4604      	mov	r4, r0
34002f5e:	460d      	mov	r5, r1
34002f60:	4616      	mov	r6, r2
34002f62:	ab07      	add	r3, sp, #28
  static char buffer[N_PRINTABLE_CHARS + 1];
  va_list args;
  va_start(args, format);
  vsnprintf(buffer, N_PRINTABLE_CHARS + 1, format, args);
34002f64:	4f09      	ldr	r7, [pc, #36]	@ (34002f8c <UTIL_LCDEx_PrintfAt+0x34>)
{
34002f66:	f853 2b04 	ldr.w	r2, [r3], #4
  vsnprintf(buffer, N_PRINTABLE_CHARS + 1, format, args);
34002f6a:	2130      	movs	r1, #48	@ 0x30
34002f6c:	4638      	mov	r0, r7
  va_start(args, format);
34002f6e:	9301      	str	r3, [sp, #4]
  vsnprintf(buffer, N_PRINTABLE_CHARS + 1, format, args);
34002f70:	f017 f81c 	bl	34019fac <vsniprintf>
  UTIL_LCD_DisplayStringAt(x_pos, y_pos, (uint8_t *) buffer, mode);
34002f74:	4633      	mov	r3, r6
34002f76:	463a      	mov	r2, r7
34002f78:	4629      	mov	r1, r5
34002f7a:	4620      	mov	r0, r4
34002f7c:	f012 fcd6 	bl	3401592c <UTIL_LCD_DisplayStringAt>
  va_end(args);
}
34002f80:	b002      	add	sp, #8
34002f82:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34002f86:	b001      	add	sp, #4
34002f88:	4770      	bx	lr
34002f8a:	bf00      	nop
34002f8c:	340cd1cc 	.word	0x340cd1cc

34002f90 <NMI_Handler>:
/**
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
34002f90:	4770      	bx	lr

34002f92 <HardFault_Handler>:
  * @retval None
  */
void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
34002f92:	e7fe      	b.n	34002f92 <HardFault_Handler>

34002f94 <MemManage_Handler>:
  * @retval None
  */
void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
34002f94:	e7fe      	b.n	34002f94 <MemManage_Handler>

34002f96 <BusFault_Handler>:
  * @retval None
  */
void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
34002f96:	e7fe      	b.n	34002f96 <BusFault_Handler>

34002f98 <UsageFault_Handler>:
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
34002f98:	e7fe      	b.n	34002f98 <UsageFault_Handler>

34002f9a <SecureFault_Handler>:
  * @retval None
  */
void SecureFault_Handler(void)
{
  /* Go to infinite loop when Secure Fault exception occurs */
  while (1)
34002f9a:	e7fe      	b.n	34002f9a <SecureFault_Handler>

34002f9c <SVC_Handler>:
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
}
34002f9c:	4770      	bx	lr

34002f9e <DebugMon_Handler>:
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
  while (1)
34002f9e:	e7fe      	b.n	34002f9e <DebugMon_Handler>

34002fa0 <PendSV_Handler>:
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
  while (1)
34002fa0:	e7fe      	b.n	34002fa0 <PendSV_Handler>

34002fa2 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
34002fa2:	f001 bf5f 	b.w	34004e64 <HAL_IncTick>

34002fa6 <CSI_IRQHandler>:
/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
/*  available peripheral interrupt handler's name please refer to the startup */
/*  file (startup_stm32n6xx.s).                                               */
/******************************************************************************/
void CSI_IRQHandler(void)
{
34002fa6:	b508      	push	{r3, lr}
  DCMIPP_HandleTypeDef *hcamera_dcmipp = CMW_CAMERA_GetDCMIPPHandle();
34002fa8:	f00d fbaa 	bl	34010700 <CMW_CAMERA_GetDCMIPPHandle>
  HAL_DCMIPP_CSI_IRQHandler(hcamera_dcmipp);
}
34002fac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_DCMIPP_CSI_IRQHandler(hcamera_dcmipp);
34002fb0:	f002 be1c 	b.w	34005bec <HAL_DCMIPP_CSI_IRQHandler>

34002fb4 <DCMIPP_IRQHandler>:

void DCMIPP_IRQHandler(void)
{
34002fb4:	b508      	push	{r3, lr}
  DCMIPP_HandleTypeDef *hcamera_dcmipp = CMW_CAMERA_GetDCMIPPHandle();
34002fb6:	f00d fba3 	bl	34010700 <CMW_CAMERA_GetDCMIPPHandle>
  HAL_DCMIPP_IRQHandler(hcamera_dcmipp);
34002fba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_DCMIPP_IRQHandler(hcamera_dcmipp);
34002fbe:	f002 bcdf 	b.w	34005980 <HAL_DCMIPP_IRQHandler>

34002fc2 <_getpid>:
}

int _getpid(void)
{
  return 1;
}
34002fc2:	2001      	movs	r0, #1
34002fc4:	4770      	bx	lr

34002fc6 <_kill>:

int _kill(int pid, int sig)
{
34002fc6:	b508      	push	{r3, lr}
  (void)pid;
  (void)sig;
  errno = EINVAL;
34002fc8:	f017 fb00 	bl	3401a5cc <__errno>
34002fcc:	2316      	movs	r3, #22
34002fce:	6003      	str	r3, [r0, #0]
  return -1;
}
34002fd0:	f04f 30ff 	mov.w	r0, #4294967295
34002fd4:	bd08      	pop	{r3, pc}

34002fd6 <_exit>:

void _exit (int status)
{
34002fd6:	b508      	push	{r3, lr}
  errno = EINVAL;
34002fd8:	f017 faf8 	bl	3401a5cc <__errno>
34002fdc:	2316      	movs	r3, #22
34002fde:	6003      	str	r3, [r0, #0]
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
34002fe0:	e7fe      	b.n	34002fe0 <_exit+0xa>

34002fe2 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
34002fe2:	b570      	push	{r4, r5, r6, lr}
34002fe4:	460d      	mov	r5, r1
34002fe6:	4614      	mov	r4, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
34002fe8:	460e      	mov	r6, r1
34002fea:	1b73      	subs	r3, r6, r5
34002fec:	429c      	cmp	r4, r3
34002fee:	dc01      	bgt.n	34002ff4 <_read+0x12>
  {
    *ptr++ = __io_getchar();
  }

  return len;
}
34002ff0:	4620      	mov	r0, r4
34002ff2:	bd70      	pop	{r4, r5, r6, pc}
    *ptr++ = __io_getchar();
34002ff4:	f3af 8000 	nop.w
34002ff8:	f806 0b01 	strb.w	r0, [r6], #1
  for (DataIdx = 0; DataIdx < len; DataIdx++)
34002ffc:	e7f5      	b.n	34002fea <_read+0x8>

34002ffe <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
34002ffe:	b570      	push	{r4, r5, r6, lr}
34003000:	460d      	mov	r5, r1
34003002:	4614      	mov	r4, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
34003004:	460e      	mov	r6, r1
34003006:	1b73      	subs	r3, r6, r5
34003008:	429c      	cmp	r4, r3
3400300a:	dc01      	bgt.n	34003010 <_write+0x12>
  {
    __io_putchar(*ptr++);
  }
  return len;
}
3400300c:	4620      	mov	r0, r4
3400300e:	bd70      	pop	{r4, r5, r6, pc}
    __io_putchar(*ptr++);
34003010:	f816 0b01 	ldrb.w	r0, [r6], #1
34003014:	f000 fba4 	bl	34003760 <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
34003018:	e7f5      	b.n	34003006 <_write+0x8>

3400301a <_close>:

int _close(int file)
{
  (void)file;
  return -1;
}
3400301a:	f04f 30ff 	mov.w	r0, #4294967295
3400301e:	4770      	bx	lr

34003020 <_fstat>:


int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
34003020:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  return 0;
}
34003024:	2000      	movs	r0, #0
  st->st_mode = S_IFCHR;
34003026:	604b      	str	r3, [r1, #4]
}
34003028:	4770      	bx	lr

3400302a <_isatty>:

int _isatty(int file)
{
  (void)file;
  return 1;
}
3400302a:	2001      	movs	r0, #1
3400302c:	4770      	bx	lr

3400302e <_lseek>:
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}
3400302e:	2000      	movs	r0, #0
34003030:	4770      	bx	lr

34003032 <APS256XX_EnableMemoryMappedMode>:
  * @param  BurstType Type of burst used for the access
  * @retval Memory status
  */
int32_t APS256XX_EnableMemoryMappedMode(XSPI_HandleTypeDef *Ctx, uint32_t ReadLatencyCode, uint32_t WriteLatencyCode,
                                        uint32_t IOMode, uint32_t BurstType)
{
34003032:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34003036:	b098      	sub	sp, #96	@ 0x60
34003038:	4605      	mov	r5, r0
3400303a:	4617      	mov	r7, r2
3400303c:	460e      	mov	r6, r1
  XSPI_RegularCmdTypeDef   sCommand = {0};
3400303e:	223c      	movs	r2, #60	@ 0x3c
34003040:	2100      	movs	r1, #0
34003042:	a806      	add	r0, sp, #24
{
34003044:	4698      	mov	r8, r3
34003046:	9c1e      	ldr	r4, [sp, #120]	@ 0x78
  XSPI_RegularCmdTypeDef   sCommand = {0};
34003048:	f017 f86c 	bl	3401a124 <memset>
  XSPI_MemoryMappedTypeDef sMemMappedCfg = {0};
3400304c:	2210      	movs	r2, #16
3400304e:	2100      	movs	r1, #0
34003050:	a801      	add	r0, sp, #4
34003052:	f017 f867 	bl	3401a124 <memset>

  /* Initialize the write command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_WRITE_CFG;
34003056:	2302      	movs	r3, #2
34003058:	9305      	str	r3, [sp, #20]
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
3400305a:	2304      	movs	r3, #4
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
3400305c:	2c00      	cmp	r4, #0
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
3400305e:	9308      	str	r3, [sp, #32]
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
34003060:	bf14      	ite	ne
34003062:	2380      	movne	r3, #128	@ 0x80
34003064:	23a0      	moveq	r3, #160	@ 0xa0
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
34003066:	f44f 6180 	mov.w	r1, #1024	@ 0x400
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
3400306a:	9307      	str	r3, [sp, #28]
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
3400306c:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34003070:	e9cd 130c 	strd	r1, r3, [sp, #48]	@ 0x30
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
34003074:	f44f 6300 	mov.w	r3, #2048	@ 0x800
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
  sCommand.DataMode            = ((IOMode == 0U) ? HAL_XSPI_DATA_8_LINES : HAL_XSPI_DATA_16_LINES);
34003078:	f1b8 0f00 	cmp.w	r8, #0
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
3400307c:	930e      	str	r3, [sp, #56]	@ 0x38
  sCommand.DataMode            = ((IOMode == 0U) ? HAL_XSPI_DATA_8_LINES : HAL_XSPI_DATA_16_LINES);
3400307e:	bf14      	ite	ne
34003080:	f04f 63a0 	movne.w	r3, #83886080	@ 0x5000000
34003084:	f04f 6380 	moveq.w	r3, #67108864	@ 0x4000000
34003088:	9313      	str	r3, [sp, #76]	@ 0x4c
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
3400308a:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
3400308e:	9315      	str	r3, [sp, #84]	@ 0x54
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
  sCommand.DQSMode             = HAL_XSPI_DQS_ENABLE;
34003090:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
34003094:	3f01      	subs	r7, #1
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003096:	f241 3288 	movw	r2, #5000	@ 0x1388
3400309a:	4628      	mov	r0, r5
3400309c:	a905      	add	r1, sp, #20
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
3400309e:	9716      	str	r7, [sp, #88]	@ 0x58
  sCommand.DQSMode             = HAL_XSPI_DQS_ENABLE;
340030a0:	9317      	str	r3, [sp, #92]	@ 0x5c
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340030a2:	f00c fe7f 	bl	3400fda4 <HAL_XSPI_Command>
340030a6:	b120      	cbz	r0, 340030b2 <APS256XX_EnableMemoryMappedMode+0x80>
  {
    return APS256XX_ERROR;
340030a8:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return APS256XX_ERROR;
  }

  return APS256XX_OK;
}
340030ac:	b018      	add	sp, #96	@ 0x60
340030ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  sCommand.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
340030b2:	2301      	movs	r3, #1
340030b4:	9305      	str	r3, [sp, #20]
  sCommand.Instruction   = ((BurstType == 0U) ? APS256XX_READ_LINEAR_BURST_CMD : APS256XX_READ_CMD);
340030b6:	fab4 f384 	clz	r3, r4
340030ba:	095b      	lsrs	r3, r3, #5
340030bc:	015b      	lsls	r3, r3, #5
  sCommand.DummyCycles   = (ReadLatencyCode - 1U);
340030be:	3e01      	subs	r6, #1
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340030c0:	f241 3288 	movw	r2, #5000	@ 0x1388
340030c4:	4628      	mov	r0, r5
340030c6:	a905      	add	r1, sp, #20
  sCommand.Instruction   = ((BurstType == 0U) ? APS256XX_READ_LINEAR_BURST_CMD : APS256XX_READ_CMD);
340030c8:	9307      	str	r3, [sp, #28]
  sCommand.DummyCycles   = (ReadLatencyCode - 1U);
340030ca:	9616      	str	r6, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340030cc:	f00c fe6a 	bl	3400fda4 <HAL_XSPI_Command>
340030d0:	2800      	cmp	r0, #0
340030d2:	d1e9      	bne.n	340030a8 <APS256XX_EnableMemoryMappedMode+0x76>
  sMemMappedCfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
340030d4:	9001      	str	r0, [sp, #4]
  if (HAL_XSPI_MemoryMapped(Ctx, &sMemMappedCfg) != HAL_OK)
340030d6:	a901      	add	r1, sp, #4
340030d8:	4628      	mov	r0, r5
340030da:	f00d f891 	bl	34010200 <HAL_XSPI_MemoryMapped>
340030de:	3800      	subs	r0, #0
340030e0:	bf18      	it	ne
340030e2:	2001      	movne	r0, #1
340030e4:	4240      	negs	r0, r0
340030e6:	e7e1      	b.n	340030ac <APS256XX_EnableMemoryMappedMode+0x7a>

340030e8 <APS256XX_WriteReg>:
  * @param  Address Register address
  * @param  Value Value to write to register
  * @retval error status
  */
int32_t APS256XX_WriteReg(XSPI_HandleTypeDef *Ctx, uint32_t Address, uint8_t Value)
{
340030e8:	b530      	push	{r4, r5, lr}
340030ea:	b097      	sub	sp, #92	@ 0x5c
340030ec:	460d      	mov	r5, r1
340030ee:	4604      	mov	r4, r0
  XSPI_RegularCmdTypeDef sCommand = {0};
340030f0:	2100      	movs	r1, #0
{
340030f2:	f88d 2007 	strb.w	r2, [sp, #7]
  XSPI_RegularCmdTypeDef sCommand = {0};
340030f6:	a803      	add	r0, sp, #12
340030f8:	224c      	movs	r2, #76	@ 0x4c
340030fa:	f017 f813 	bl	3401a124 <memset>
  /* Initialize the write register command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_COMMON_CFG;
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
  sCommand.Instruction         = APS256XX_WRITE_REG_CMD;
340030fe:	23c0      	movs	r3, #192	@ 0xc0
34003100:	2204      	movs	r2, #4
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
34003102:	f44f 6180 	mov.w	r1, #1024	@ 0x400
  sCommand.Instruction         = APS256XX_WRITE_REG_CMD;
34003106:	e9cd 3205 	strd	r3, r2, [sp, #20]
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
3400310a:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
3400310e:	e9cd 130a 	strd	r1, r3, [sp, #40]	@ 0x28
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
34003112:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34003116:	930c      	str	r3, [sp, #48]	@ 0x30
  sCommand.Address             = Address;
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
  sCommand.DataMode            = HAL_XSPI_DATA_8_LINES;
34003118:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  sCommand.Address             = Address;
3400311c:	9509      	str	r5, [sp, #36]	@ 0x24
  sCommand.DataMode            = HAL_XSPI_DATA_8_LINES;
3400311e:	9311      	str	r3, [sp, #68]	@ 0x44
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
  sCommand.DataLength          = 2;
34003120:	f04f 6500 	mov.w	r5, #134217728	@ 0x8000000
34003124:	2302      	movs	r3, #2
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Configure the command */
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003126:	f241 3288 	movw	r2, #5000	@ 0x1388
3400312a:	4620      	mov	r0, r4
3400312c:	a903      	add	r1, sp, #12
  sCommand.DataLength          = 2;
3400312e:	e9cd 3512 	strd	r3, r5, [sp, #72]	@ 0x48
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003132:	f00c fe37 	bl	3400fda4 <HAL_XSPI_Command>
34003136:	b960      	cbnz	r0, 34003152 <APS256XX_WriteReg+0x6a>
  {
    return APS256XX_ERROR;
  }

  /* Transmission of the data */
  if (HAL_XSPI_Transmit(Ctx, (uint8_t *)(&Value), HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003138:	f241 3288 	movw	r2, #5000	@ 0x1388
3400313c:	4620      	mov	r0, r4
3400313e:	f10d 0107 	add.w	r1, sp, #7
34003142:	f00c ff47 	bl	3400ffd4 <HAL_XSPI_Transmit>
34003146:	3800      	subs	r0, #0
34003148:	bf18      	it	ne
3400314a:	2001      	movne	r0, #1
3400314c:	4240      	negs	r0, r0
  {
    return APS256XX_ERROR;
  }

  return APS256XX_OK;
}
3400314e:	b017      	add	sp, #92	@ 0x5c
34003150:	bd30      	pop	{r4, r5, pc}
    return APS256XX_ERROR;
34003152:	f04f 30ff 	mov.w	r0, #4294967295
34003156:	e7fa      	b.n	3400314e <APS256XX_WriteReg+0x66>

34003158 <MX66UW1G45G_GetFlashInfo>:
  */
int32_t MX66UW1G45G_GetFlashInfo(MX66UW1G45G_Info_t *pInfo)
{
  /* Configure the structure with the memory configuration */
  pInfo->FlashSize = MX66UW1G45G_FLASH_SIZE;
  pInfo->EraseSectorSize = MX66UW1G45G_BLOCK_64K;
34003158:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
3400315c:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
34003160:	e9c0 2300 	strd	r2, r3, [r0]
  pInfo->EraseSectorsNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_64K);
  pInfo->EraseSubSectorSize = MX66UW1G45G_BLOCK_4K;
34003164:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34003168:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400316c:	e9c0 3202 	strd	r3, r2, [r0, #8]
  pInfo->EraseSubSectorNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
34003170:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  pInfo->EraseSubSector1Size = MX66UW1G45G_BLOCK_4K;
  pInfo->EraseSubSector1Number = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
  pInfo->ProgPageSize = MX66UW1G45G_PAGE_SIZE;
  pInfo->ProgPagesNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_PAGE_SIZE);
34003174:	f44f 7180 	mov.w	r1, #256	@ 0x100
  pInfo->EraseSubSector1Size = MX66UW1G45G_BLOCK_4K;
34003178:	e9c0 3204 	strd	r3, r2, [r0, #16]
  pInfo->EraseSubSector1Number = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
3400317c:	6183      	str	r3, [r0, #24]
  pInfo->ProgPagesNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_PAGE_SIZE);
3400317e:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
34003182:	e9c0 1307 	strd	r1, r3, [r0, #28]

  return MX66UW1G45G_OK;
};
34003186:	2000      	movs	r0, #0
34003188:	4770      	bx	lr

3400318a <MX66UW1G45G_AutoPollingMemReady>:
  * @param  Rate Transfer rate
  * @retval error status
  */
int32_t MX66UW1G45G_AutoPollingMemReady(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                        MX66UW1G45G_Transfer_t Rate)
{
3400318a:	b570      	push	{r4, r5, r6, lr}
3400318c:	460d      	mov	r5, r1
3400318e:	b098      	sub	sp, #96	@ 0x60
  XSPI_RegularCmdTypeDef s_command = {0};
34003190:	2100      	movs	r1, #0
{
34003192:	4606      	mov	r6, r0
34003194:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34003196:	a805      	add	r0, sp, #20
34003198:	224c      	movs	r2, #76	@ 0x4c
3400319a:	f016 ffc3 	bl	3401a124 <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
3400319e:	2214      	movs	r2, #20
340031a0:	2100      	movs	r1, #0
340031a2:	4668      	mov	r0, sp
340031a4:	f016 ffbe 	bl	3401a124 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
340031a8:	b92d      	cbnz	r5, 340031b6 <MX66UW1G45G_AutoPollingMemReady+0x2c>
340031aa:	2c01      	cmp	r4, #1
340031ac:	d14d      	bne.n	3400324a <MX66UW1G45G_AutoPollingMemReady+0xc0>
  {
    return MX66UW1G45G_ERROR;
340031ae:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
340031b2:	b018      	add	sp, #96	@ 0x60
340031b4:	bd70      	pop	{r4, r5, r6, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
340031b6:	2204      	movs	r2, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
340031b8:	f104 3cff 	add.w	ip, r4, #4294967295
340031bc:	f1dc 0300 	rsbs	r3, ip, #0
340031c0:	eb43 030c 	adc.w	r3, r3, ip
340031c4:	00db      	lsls	r3, r3, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
340031c6:	9208      	str	r2, [sp, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
340031c8:	930a      	str	r3, [sp, #40]	@ 0x28
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
340031ca:	2d00      	cmp	r5, #0
340031cc:	d040      	beq.n	34003250 <MX66UW1G45G_AutoPollingMemReady+0xc6>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
340031ce:	2310      	movs	r3, #16
340031d0:	f240 52fa 	movw	r2, #1530	@ 0x5fa
340031d4:	9309      	str	r3, [sp, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
340031d6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
340031da:	1e60      	subs	r0, r4, #1
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
340031dc:	930c      	str	r3, [sp, #48]	@ 0x30
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
340031de:	4243      	negs	r3, r0
340031e0:	4143      	adcs	r3, r0
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
340031e2:	9207      	str	r2, [sp, #28]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
340031e4:	02da      	lsls	r2, r3, #11
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
340031e6:	920e      	str	r2, [sp, #56]	@ 0x38
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
340031e8:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340031ec:	2d00      	cmp	r5, #0
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
340031ee:	920d      	str	r2, [sp, #52]	@ 0x34
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340031f0:	bf14      	ite	ne
340031f2:	f04f 6280 	movne.w	r2, #67108864	@ 0x4000000
340031f6:	f04f 7280 	moveq.w	r2, #16777216	@ 0x1000000
                              : HAL_XSPI_DATA_DTR_DISABLE;
340031fa:	ea4f 63c3 	mov.w	r3, r3, lsl #27
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340031fe:	9213      	str	r2, [sp, #76]	@ 0x4c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34003200:	9315      	str	r3, [sp, #84]	@ 0x54
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34003202:	d02d      	beq.n	34003260 <MX66UW1G45G_AutoPollingMemReady+0xd6>
34003204:	2c01      	cmp	r4, #1
34003206:	d126      	bne.n	34003256 <MX66UW1G45G_AutoPollingMemReady+0xcc>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34003208:	2305      	movs	r3, #5
3400320a:	9316      	str	r3, [sp, #88]	@ 0x58
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
3400320c:	2202      	movs	r2, #2
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
3400320e:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34003212:	9317      	str	r3, [sp, #92]	@ 0x5c
  s_config.MatchMask = MX66UW1G45G_SR_WIP;
34003214:	2301      	movs	r3, #1
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34003216:	2110      	movs	r1, #16
  s_config.MatchMask = MX66UW1G45G_SR_WIP;
34003218:	9301      	str	r3, [sp, #4]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
3400321a:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
3400321e:	9214      	str	r2, [sp, #80]	@ 0x50
34003220:	e9cd 3103 	strd	r3, r1, [sp, #12]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003224:	f241 3288 	movw	r2, #5000	@ 0x1388
34003228:	4630      	mov	r0, r6
3400322a:	a905      	add	r1, sp, #20
3400322c:	f00c fdba 	bl	3400fda4 <HAL_XSPI_Command>
34003230:	2800      	cmp	r0, #0
34003232:	d1bc      	bne.n	340031ae <MX66UW1G45G_AutoPollingMemReady+0x24>
  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003234:	f241 3288 	movw	r2, #5000	@ 0x1388
34003238:	4669      	mov	r1, sp
3400323a:	4630      	mov	r0, r6
3400323c:	f00c ff64 	bl	34010108 <HAL_XSPI_AutoPolling>
34003240:	3800      	subs	r0, #0
34003242:	bf18      	it	ne
34003244:	2001      	movne	r0, #1
34003246:	4240      	negs	r0, r0
34003248:	e7b3      	b.n	340031b2 <MX66UW1G45G_AutoPollingMemReady+0x28>
3400324a:	2201      	movs	r2, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
3400324c:	462b      	mov	r3, r5
3400324e:	e7ba      	b.n	340031c6 <MX66UW1G45G_AutoPollingMemReady+0x3c>
34003250:	2205      	movs	r2, #5
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34003252:	462b      	mov	r3, r5
34003254:	e7c1      	b.n	340031da <MX66UW1G45G_AutoPollingMemReady+0x50>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34003256:	2304      	movs	r3, #4
34003258:	9316      	str	r3, [sp, #88]	@ 0x58
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
3400325a:	2201      	movs	r2, #1
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
3400325c:	2300      	movs	r3, #0
3400325e:	e7d8      	b.n	34003212 <MX66UW1G45G_AutoPollingMemReady+0x88>
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34003260:	2c01      	cmp	r4, #1
34003262:	d1fa      	bne.n	3400325a <MX66UW1G45G_AutoPollingMemReady+0xd0>
34003264:	e7d2      	b.n	3400320c <MX66UW1G45G_AutoPollingMemReady+0x82>

34003266 <MX66UW1G45G_EnableSTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableSTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                              MX66UW1G45G_AddressWidth_t AddressWidth)
{
34003266:	b570      	push	{r4, r5, r6, lr}
34003268:	460c      	mov	r4, r1
3400326a:	b098      	sub	sp, #96	@ 0x60
  XSPI_RegularCmdTypeDef s_command = {0};
3400326c:	2100      	movs	r1, #0
{
3400326e:	4606      	mov	r6, r0
34003270:	4615      	mov	r5, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34003272:	a805      	add	r0, sp, #20
34003274:	224c      	movs	r2, #76	@ 0x4c
34003276:	f016 ff55 	bl	3401a124 <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
3400327a:	2210      	movs	r2, #16
3400327c:	2100      	movs	r1, #0
3400327e:	a801      	add	r0, sp, #4
34003280:	f016 ff50 	bl	3401a124 <memset>

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX66UW1G45G_OPI_MODE) && (AddressWidth == MX66UW1G45G_3BYTES_SIZE))
34003284:	2c01      	cmp	r4, #1
34003286:	d144      	bne.n	34003312 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xac>
34003288:	b91d      	cbnz	r5, 34003292 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x2c>
  {
    return MX66UW1G45G_ERROR;
3400328a:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
3400328e:	b018      	add	sp, #96	@ 0x60
34003290:	bd70      	pop	{r4, r5, r6, pc}
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34003292:	9405      	str	r4, [sp, #20]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34003294:	2204      	movs	r2, #4
34003296:	2310      	movs	r3, #16
34003298:	e9cd 2308 	strd	r2, r3, [sp, #32]
3400329c:	f64e 4213 	movw	r2, #60435	@ 0xec13
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
340032a0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
                               : HAL_XSPI_ADDRESS_32_BITS;
340032a4:	2d00      	cmp	r5, #0
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
340032a6:	930c      	str	r3, [sp, #48]	@ 0x30
                               : HAL_XSPI_ADDRESS_32_BITS;
340032a8:	bf14      	ite	ne
340032aa:	f44f 5340 	movne.w	r3, #12288	@ 0x3000
340032ae:	f44f 5300 	moveq.w	r3, #8192	@ 0x2000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340032b2:	2c00      	cmp	r4, #0
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
340032b4:	9207      	str	r2, [sp, #28]
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340032b6:	bf0c      	ite	eq
340032b8:	f04f 7280 	moveq.w	r2, #16777216	@ 0x1000000
340032bc:	f04f 6280 	movne.w	r2, #67108864	@ 0x4000000
  s_command.AddressWidth = (AddressWidth == MX66UW1G45G_3BYTES_SIZE)
340032c0:	930d      	str	r3, [sp, #52]	@ 0x34
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340032c2:	bf0c      	ite	eq
340032c4:	2308      	moveq	r3, #8
340032c6:	230a      	movne	r3, #10
340032c8:	9213      	str	r2, [sp, #76]	@ 0x4c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340032ca:	4630      	mov	r0, r6
340032cc:	f241 3288 	movw	r2, #5000	@ 0x1388
340032d0:	a905      	add	r1, sp, #20
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE) ? DUMMY_CYCLES_READ : DUMMY_CYCLES_READ_OCTAL;
340032d2:	9316      	str	r3, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340032d4:	f00c fd66 	bl	3400fda4 <HAL_XSPI_Command>
340032d8:	2800      	cmp	r0, #0
340032da:	d1d6      	bne.n	3400328a <MX66UW1G45G_EnableSTRMemoryMappedMode+0x24>
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
340032dc:	2302      	movs	r3, #2
340032de:	9305      	str	r3, [sp, #20]
                              : MX66UW1G45G_OCTA_PAGE_PROG_CMD;
340032e0:	bb1c      	cbnz	r4, 3400332a <MX66UW1G45G_EnableSTRMemoryMappedMode+0xc4>
340032e2:	2d00      	cmp	r5, #0
340032e4:	bf18      	it	ne
340032e6:	2312      	movne	r3, #18
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
340032e8:	9307      	str	r3, [sp, #28]
  s_command.DummyCycles = 0U;
340032ea:	2300      	movs	r3, #0
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340032ec:	f241 3288 	movw	r2, #5000	@ 0x1388
340032f0:	4630      	mov	r0, r6
340032f2:	a905      	add	r1, sp, #20
  s_command.DummyCycles = 0U;
340032f4:	9316      	str	r3, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340032f6:	f00c fd55 	bl	3400fda4 <HAL_XSPI_Command>
340032fa:	2800      	cmp	r0, #0
340032fc:	d1c5      	bne.n	3400328a <MX66UW1G45G_EnableSTRMemoryMappedMode+0x24>
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
340032fe:	9001      	str	r0, [sp, #4]
  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
34003300:	a901      	add	r1, sp, #4
34003302:	4630      	mov	r0, r6
34003304:	f00c ff7c 	bl	34010200 <HAL_XSPI_MemoryMapped>
34003308:	3800      	subs	r0, #0
3400330a:	bf18      	it	ne
3400330c:	2001      	movne	r0, #1
3400330e:	4240      	negs	r0, r0
34003310:	e7bd      	b.n	3400328e <MX66UW1G45G_EnableSTRMemoryMappedMode+0x28>
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34003312:	2301      	movs	r3, #1
34003314:	9305      	str	r3, [sp, #20]
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34003316:	2c00      	cmp	r4, #0
34003318:	d1bc      	bne.n	34003294 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x2e>
                              : MX66UW1G45G_OCTA_READ_CMD;
3400331a:	2d00      	cmp	r5, #0
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
3400331c:	9308      	str	r3, [sp, #32]
                              : MX66UW1G45G_OCTA_READ_CMD;
3400331e:	bf14      	ite	ne
34003320:	220c      	movne	r2, #12
34003322:	220b      	moveq	r2, #11
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34003324:	f44f 7380 	mov.w	r3, #256	@ 0x100
34003328:	e7bc      	b.n	340032a4 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x3e>
                              : MX66UW1G45G_OCTA_PAGE_PROG_CMD;
3400332a:	f241 23ed 	movw	r3, #4845	@ 0x12ed
3400332e:	e7db      	b.n	340032e8 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x82>

34003330 <MX66UW1G45G_EnableDTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @note   Only OPI mode support DTR transfer rate
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableDTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode)
{
34003330:	b530      	push	{r4, r5, lr}
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Mode);

  XSPI_RegularCmdTypeDef s_command = {0};
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
34003332:	2510      	movs	r5, #16
{
34003334:	b099      	sub	sp, #100	@ 0x64
34003336:	4604      	mov	r4, r0
  XSPI_RegularCmdTypeDef s_command = {0};
34003338:	223c      	movs	r2, #60	@ 0x3c
3400333a:	2100      	movs	r1, #0
3400333c:	a806      	add	r0, sp, #24
3400333e:	f016 fef1 	bl	3401a124 <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
34003342:	462a      	mov	r2, r5
34003344:	2100      	movs	r1, #0
34003346:	a801      	add	r0, sp, #4
34003348:	f016 feec 	bl	3401a124 <memset>

  /* Initialize the read command */
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
3400334c:	2301      	movs	r3, #1
3400334e:	9305      	str	r3, [sp, #20]
  s_command.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
34003350:	2304      	movs	r3, #4
34003352:	9308      	str	r3, [sp, #32]
  s_command.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
34003354:	2308      	movs	r3, #8
  s_command.InstructionWidth = HAL_XSPI_INSTRUCTION_16_BITS;
34003356:	e9cd 5309 	strd	r5, r3, [sp, #36]	@ 0x24
  s_command.Instruction = MX66UW1G45G_OCTA_READ_DTR_CMD;
3400335a:	f64e 6311 	movw	r3, #60945	@ 0xee11
3400335e:	9307      	str	r3, [sp, #28]
  s_command.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
34003360:	f44f 6380 	mov.w	r3, #1024	@ 0x400
  s_command.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34003364:	f44f 6e00 	mov.w	lr, #2048	@ 0x800
  s_command.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
34003368:	930c      	str	r3, [sp, #48]	@ 0x30
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
3400336a:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
3400336e:	e9cd 3e0d 	strd	r3, lr, [sp, #52]	@ 0x34
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
  s_command.DataMode = HAL_XSPI_DATA_8_LINES;
34003372:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  s_command.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
  s_command.DummyCycles = DUMMY_CYCLES_READ_OCTAL_DTR;
34003376:	f04f 6100 	mov.w	r1, #134217728	@ 0x8000000
  s_command.DataMode = HAL_XSPI_DATA_8_LINES;
3400337a:	9313      	str	r3, [sp, #76]	@ 0x4c
  s_command.DummyCycles = DUMMY_CYCLES_READ_OCTAL_DTR;
3400337c:	230a      	movs	r3, #10
3400337e:	e9cd 1315 	strd	r1, r3, [sp, #84]	@ 0x54
  s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
34003382:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003386:	f241 3288 	movw	r2, #5000	@ 0x1388
3400338a:	4620      	mov	r0, r4
3400338c:	a905      	add	r1, sp, #20
  s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
3400338e:	9317      	str	r3, [sp, #92]	@ 0x5c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003390:	f00c fd08 	bl	3400fda4 <HAL_XSPI_Command>
34003394:	b118      	cbz	r0, 3400339e <MX66UW1G45G_EnableDTRMemoryMappedMode+0x6e>
  {
    return MX66UW1G45G_ERROR;
34003396:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
3400339a:	b019      	add	sp, #100	@ 0x64
3400339c:	bd30      	pop	{r4, r5, pc}
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
3400339e:	2302      	movs	r3, #2
340033a0:	9305      	str	r3, [sp, #20]
  s_command.Instruction = MX66UW1G45G_OCTA_PAGE_PROG_CMD;
340033a2:	f241 23ed 	movw	r3, #4845	@ 0x12ed
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
340033a6:	e9cd 0016 	strd	r0, r0, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340033aa:	f241 3288 	movw	r2, #5000	@ 0x1388
340033ae:	4620      	mov	r0, r4
340033b0:	a905      	add	r1, sp, #20
  s_command.Instruction = MX66UW1G45G_OCTA_PAGE_PROG_CMD;
340033b2:	9307      	str	r3, [sp, #28]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340033b4:	f00c fcf6 	bl	3400fda4 <HAL_XSPI_Command>
340033b8:	2800      	cmp	r0, #0
340033ba:	d1ec      	bne.n	34003396 <MX66UW1G45G_EnableDTRMemoryMappedMode+0x66>
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
340033bc:	9001      	str	r0, [sp, #4]
  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
340033be:	a901      	add	r1, sp, #4
340033c0:	4620      	mov	r0, r4
340033c2:	f00c ff1d 	bl	34010200 <HAL_XSPI_MemoryMapped>
340033c6:	3800      	subs	r0, #0
340033c8:	bf18      	it	ne
340033ca:	2001      	movne	r0, #1
340033cc:	4240      	negs	r0, r0
340033ce:	e7e4      	b.n	3400339a <MX66UW1G45G_EnableDTRMemoryMappedMode+0x6a>

340033d0 <MX66UW1G45G_WriteEnable>:
  * @param  Mode Interface mode
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_WriteEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
340033d0:	b5f0      	push	{r4, r5, r6, r7, lr}
340033d2:	460c      	mov	r4, r1
340033d4:	b099      	sub	sp, #100	@ 0x64
  XSPI_RegularCmdTypeDef s_command = {0};
340033d6:	2100      	movs	r1, #0
{
340033d8:	4606      	mov	r6, r0
340033da:	4615      	mov	r5, r2
  XSPI_RegularCmdTypeDef s_command = {0};
340033dc:	a805      	add	r0, sp, #20
340033de:	224c      	movs	r2, #76	@ 0x4c
340033e0:	f016 fea0 	bl	3401a124 <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
340033e4:	2214      	movs	r2, #20
340033e6:	2100      	movs	r1, #0
340033e8:	4668      	mov	r0, sp
340033ea:	f016 fe9b 	bl	3401a124 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
340033ee:	b92c      	cbnz	r4, 340033fc <MX66UW1G45G_WriteEnable+0x2c>
340033f0:	2d01      	cmp	r5, #1
340033f2:	d15d      	bne.n	340034b0 <MX66UW1G45G_WriteEnable+0xe0>
  {
    return MX66UW1G45G_ERROR;
340033f4:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
340033f8:	b019      	add	sp, #100	@ 0x64
340033fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
340033fc:	2204      	movs	r2, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
340033fe:	1e69      	subs	r1, r5, #1
34003400:	424b      	negs	r3, r1
34003402:	414b      	adcs	r3, r1
34003404:	00db      	lsls	r3, r3, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34003406:	9208      	str	r2, [sp, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34003408:	930a      	str	r3, [sp, #40]	@ 0x28
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
3400340a:	2c00      	cmp	r4, #0
3400340c:	d053      	beq.n	340034b6 <MX66UW1G45G_WriteEnable+0xe6>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
3400340e:	2310      	movs	r3, #16
34003410:	9309      	str	r3, [sp, #36]	@ 0x24
                              : MX66UW1G45G_OCTA_WRITE_ENABLE_CMD;
34003412:	f240 63f9 	movw	r3, #1785	@ 0x6f9
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003416:	f241 3288 	movw	r2, #5000	@ 0x1388
3400341a:	4630      	mov	r0, r6
3400341c:	a905      	add	r1, sp, #20
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
3400341e:	9307      	str	r3, [sp, #28]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003420:	f00c fcc0 	bl	3400fda4 <HAL_XSPI_Command>
34003424:	4603      	mov	r3, r0
34003426:	2800      	cmp	r0, #0
34003428:	d1e4      	bne.n	340033f4 <MX66UW1G45G_WriteEnable+0x24>
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
3400342a:	2c00      	cmp	r4, #0
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
3400342c:	f105 32ff 	add.w	r2, r5, #4294967295
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34003430:	f240 5cfa 	movw	ip, #1530	@ 0x5fa
34003434:	bf12      	itee	ne
34003436:	f44f 6e80 	movne.w	lr, #1024	@ 0x400
3400343a:	f04f 0c05 	moveq.w	ip, #5
3400343e:	f04f 0e00 	moveq.w	lr, #0
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34003442:	4257      	negs	r7, r2
34003444:	4157      	adcs	r7, r2
34003446:	02ff      	lsls	r7, r7, #11
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34003448:	2c00      	cmp	r4, #0
3400344a:	d036      	beq.n	340034ba <MX66UW1G45G_WriteEnable+0xea>
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
3400344c:	2d01      	cmp	r5, #1
3400344e:	d03a      	beq.n	340034c6 <MX66UW1G45G_WriteEnable+0xf6>
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34003450:	f04f 6080 	mov.w	r0, #67108864	@ 0x4000000
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34003454:	2404      	movs	r4, #4
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34003456:	2101      	movs	r1, #1
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34003458:	461a      	mov	r2, r3
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
3400345a:	f44f 5540 	mov.w	r5, #12288	@ 0x3000
3400345e:	950d      	str	r5, [sp, #52]	@ 0x34
  s_command.Address = 0U;
34003460:	2500      	movs	r5, #0
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34003462:	9013      	str	r0, [sp, #76]	@ 0x4c
34003464:	9114      	str	r1, [sp, #80]	@ 0x50
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34003466:	9217      	str	r2, [sp, #92]	@ 0x5c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003468:	4630      	mov	r0, r6
3400346a:	f241 3288 	movw	r2, #5000	@ 0x1388
3400346e:	a905      	add	r1, sp, #20
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34003470:	e9cd 3415 	strd	r3, r4, [sp, #84]	@ 0x54
34003474:	f8cd c01c 	str.w	ip, [sp, #28]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34003478:	f8cd e030 	str.w	lr, [sp, #48]	@ 0x30
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
3400347c:	970e      	str	r7, [sp, #56]	@ 0x38
  s_command.Address = 0U;
3400347e:	950b      	str	r5, [sp, #44]	@ 0x2c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003480:	f00c fc90 	bl	3400fda4 <HAL_XSPI_Command>
34003484:	2800      	cmp	r0, #0
34003486:	d1b5      	bne.n	340033f4 <MX66UW1G45G_WriteEnable+0x24>
  s_config.MatchValue = 2U;
34003488:	2302      	movs	r3, #2
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
3400348a:	2210      	movs	r2, #16
  s_config.MatchMask = 2U;
3400348c:	e9cd 3300 	strd	r3, r3, [sp]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34003490:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
  s_config.MatchMode = HAL_XSPI_MATCH_MODE_AND;
34003494:	9002      	str	r0, [sp, #8]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34003496:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400349a:	4669      	mov	r1, sp
3400349c:	f241 3288 	movw	r2, #5000	@ 0x1388
340034a0:	4630      	mov	r0, r6
340034a2:	f00c fe31 	bl	34010108 <HAL_XSPI_AutoPolling>
340034a6:	1b40      	subs	r0, r0, r5
340034a8:	bf18      	it	ne
340034aa:	2001      	movne	r0, #1
340034ac:	4240      	negs	r0, r0
340034ae:	e7a3      	b.n	340033f8 <MX66UW1G45G_WriteEnable+0x28>
340034b0:	2201      	movs	r2, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
340034b2:	4623      	mov	r3, r4
340034b4:	e7a7      	b.n	34003406 <MX66UW1G45G_WriteEnable+0x36>
                              : MX66UW1G45G_OCTA_WRITE_ENABLE_CMD;
340034b6:	2306      	movs	r3, #6
340034b8:	e7ad      	b.n	34003416 <MX66UW1G45G_WriteEnable+0x46>
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
340034ba:	2d01      	cmp	r5, #1
340034bc:	d00c      	beq.n	340034d8 <MX66UW1G45G_WriteEnable+0x108>
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
340034be:	4623      	mov	r3, r4
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340034c0:	f04f 7080 	mov.w	r0, #16777216	@ 0x1000000
340034c4:	e7c7      	b.n	34003456 <MX66UW1G45G_WriteEnable+0x86>
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
340034c6:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340034ca:	f04f 6080 	mov.w	r0, #67108864	@ 0x4000000
340034ce:	2405      	movs	r4, #5
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
340034d0:	2102      	movs	r1, #2
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
340034d2:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
340034d6:	e7c0      	b.n	3400345a <MX66UW1G45G_WriteEnable+0x8a>
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
340034d8:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340034dc:	f04f 7080 	mov.w	r0, #16777216	@ 0x1000000
340034e0:	e7f6      	b.n	340034d0 <MX66UW1G45G_WriteEnable+0x100>

340034e2 <MX66UW1G45G_WriteCfg2Register>:
  * @param  Value Value to write to configuration register
  * @retval error status
  */
int32_t MX66UW1G45G_WriteCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                      MX66UW1G45G_Transfer_t Rate, uint32_t WriteAddr, uint8_t Value)
{
340034e2:	b5f0      	push	{r4, r5, r6, r7, lr}
340034e4:	460d      	mov	r5, r1
340034e6:	b095      	sub	sp, #84	@ 0x54
340034e8:	4606      	mov	r6, r0
340034ea:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
340034ec:	2100      	movs	r1, #0
340034ee:	224c      	movs	r2, #76	@ 0x4c
340034f0:	a801      	add	r0, sp, #4
{
340034f2:	461f      	mov	r7, r3
  XSPI_RegularCmdTypeDef s_command = {0};
340034f4:	f016 fe16 	bl	3401a124 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
340034f8:	b92d      	cbnz	r5, 34003506 <MX66UW1G45G_WriteCfg2Register+0x24>
340034fa:	2c01      	cmp	r4, #1
340034fc:	d140      	bne.n	34003580 <MX66UW1G45G_WriteCfg2Register+0x9e>
  {
    return MX66UW1G45G_ERROR;
340034fe:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34003502:	b015      	add	sp, #84	@ 0x54
34003504:	bdf0      	pop	{r4, r5, r6, r7, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34003506:	2304      	movs	r3, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34003508:	1e61      	subs	r1, r4, #1
3400350a:	424a      	negs	r2, r1
3400350c:	414a      	adcs	r2, r1
3400350e:	00d2      	lsls	r2, r2, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34003510:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34003512:	9206      	str	r2, [sp, #24]
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34003514:	2d00      	cmp	r5, #0
34003516:	d036      	beq.n	34003586 <MX66UW1G45G_WriteCfg2Register+0xa4>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34003518:	2310      	movs	r3, #16
3400351a:	f247 228d 	movw	r2, #29325	@ 0x728d
3400351e:	9305      	str	r3, [sp, #20]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34003520:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34003524:	9308      	str	r3, [sp, #32]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34003526:	1e63      	subs	r3, r4, #1
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34003528:	9203      	str	r2, [sp, #12]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
3400352a:	425a      	negs	r2, r3
3400352c:	415a      	adcs	r2, r3
3400352e:	02d3      	lsls	r3, r2, #11
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34003530:	930a      	str	r3, [sp, #40]	@ 0x28
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34003532:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34003536:	2d00      	cmp	r5, #0
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34003538:	9309      	str	r3, [sp, #36]	@ 0x24
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
3400353a:	bf14      	ite	ne
3400353c:	f04f 6380 	movne.w	r3, #67108864	@ 0x4000000
34003540:	f04f 7380 	moveq.w	r3, #16777216	@ 0x1000000
                              : HAL_XSPI_DATA_DTR_DISABLE;
34003544:	ea4f 62c2 	mov.w	r2, r2, lsl #27
  s_command.Address = WriteAddr;
34003548:	9707      	str	r7, [sp, #28]
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
3400354a:	930f      	str	r3, [sp, #60]	@ 0x3c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
3400354c:	9211      	str	r2, [sp, #68]	@ 0x44
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
3400354e:	d01e      	beq.n	3400358e <MX66UW1G45G_WriteCfg2Register+0xac>
34003550:	2c01      	cmp	r4, #1
34003552:	bf0c      	ite	eq
34003554:	2302      	moveq	r3, #2
34003556:	2301      	movne	r3, #1
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003558:	f241 3288 	movw	r2, #5000	@ 0x1388
3400355c:	4630      	mov	r0, r6
3400355e:	a901      	add	r1, sp, #4
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
34003560:	9310      	str	r3, [sp, #64]	@ 0x40
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003562:	f00c fc1f 	bl	3400fda4 <HAL_XSPI_Command>
34003566:	2800      	cmp	r0, #0
34003568:	d1c9      	bne.n	340034fe <MX66UW1G45G_WriteCfg2Register+0x1c>
  if (HAL_XSPI_Transmit(Ctx, &Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400356a:	f241 3288 	movw	r2, #5000	@ 0x1388
3400356e:	4630      	mov	r0, r6
34003570:	a91a      	add	r1, sp, #104	@ 0x68
34003572:	f00c fd2f 	bl	3400ffd4 <HAL_XSPI_Transmit>
34003576:	3800      	subs	r0, #0
34003578:	bf18      	it	ne
3400357a:	2001      	movne	r0, #1
3400357c:	4240      	negs	r0, r0
3400357e:	e7c0      	b.n	34003502 <MX66UW1G45G_WriteCfg2Register+0x20>
34003580:	2301      	movs	r3, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34003582:	462a      	mov	r2, r5
34003584:	e7c4      	b.n	34003510 <MX66UW1G45G_WriteCfg2Register+0x2e>
34003586:	2272      	movs	r2, #114	@ 0x72
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34003588:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400358c:	e7ca      	b.n	34003524 <MX66UW1G45G_WriteCfg2Register+0x42>
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
3400358e:	2301      	movs	r3, #1
34003590:	e7e2      	b.n	34003558 <MX66UW1G45G_WriteCfg2Register+0x76>

34003592 <MX66UW1G45G_ReadCfg2Register>:
  * @param  Value configuration register 2 value pointer
  * @retval error status
  */
int32_t MX66UW1G45G_ReadCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                     MX66UW1G45G_Transfer_t Rate, uint32_t ReadAddr, uint8_t *Value)
{
34003592:	b5f0      	push	{r4, r5, r6, r7, lr}
34003594:	460d      	mov	r5, r1
34003596:	b095      	sub	sp, #84	@ 0x54
34003598:	4606      	mov	r6, r0
3400359a:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
3400359c:	2100      	movs	r1, #0
3400359e:	224c      	movs	r2, #76	@ 0x4c
340035a0:	a801      	add	r0, sp, #4
{
340035a2:	461f      	mov	r7, r3
  XSPI_RegularCmdTypeDef s_command = {0};
340035a4:	f016 fdbe 	bl	3401a124 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
340035a8:	b92d      	cbnz	r5, 340035b6 <MX66UW1G45G_ReadCfg2Register+0x24>
340035aa:	2c01      	cmp	r4, #1
340035ac:	d144      	bne.n	34003638 <MX66UW1G45G_ReadCfg2Register+0xa6>
  {
    return MX66UW1G45G_ERROR;
340035ae:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
340035b2:	b015      	add	sp, #84	@ 0x54
340035b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
340035b6:	2304      	movs	r3, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
340035b8:	1e61      	subs	r1, r4, #1
340035ba:	424a      	negs	r2, r1
340035bc:	414a      	adcs	r2, r1
340035be:	00d2      	lsls	r2, r2, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
340035c0:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
340035c2:	9206      	str	r2, [sp, #24]
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
340035c4:	2d00      	cmp	r5, #0
340035c6:	d03a      	beq.n	3400363e <MX66UW1G45G_ReadCfg2Register+0xac>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
340035c8:	2310      	movs	r3, #16
340035ca:	f247 128e 	movw	r2, #29070	@ 0x718e
340035ce:	9305      	str	r3, [sp, #20]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
340035d0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
340035d4:	9308      	str	r3, [sp, #32]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
340035d6:	1e63      	subs	r3, r4, #1
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
340035d8:	9203      	str	r2, [sp, #12]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
340035da:	425a      	negs	r2, r3
340035dc:	415a      	adcs	r2, r3
340035de:	02d3      	lsls	r3, r2, #11
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
340035e0:	930a      	str	r3, [sp, #40]	@ 0x28
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
340035e2:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340035e6:	2d00      	cmp	r5, #0
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
340035e8:	9309      	str	r3, [sp, #36]	@ 0x24
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340035ea:	bf14      	ite	ne
340035ec:	f04f 6380 	movne.w	r3, #67108864	@ 0x4000000
340035f0:	f04f 7380 	moveq.w	r3, #16777216	@ 0x1000000
                              : HAL_XSPI_DATA_DTR_DISABLE;
340035f4:	ea4f 62c2 	mov.w	r2, r2, lsl #27
  s_command.Address = ReadAddr;
340035f8:	9707      	str	r7, [sp, #28]
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340035fa:	930f      	str	r3, [sp, #60]	@ 0x3c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
340035fc:	9211      	str	r2, [sp, #68]	@ 0x44
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
340035fe:	d027      	beq.n	34003650 <MX66UW1G45G_ReadCfg2Register+0xbe>
34003600:	2c01      	cmp	r4, #1
34003602:	d120      	bne.n	34003646 <MX66UW1G45G_ReadCfg2Register+0xb4>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34003604:	2305      	movs	r3, #5
34003606:	9312      	str	r3, [sp, #72]	@ 0x48
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34003608:	2202      	movs	r2, #2
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
3400360a:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
3400360e:	9210      	str	r2, [sp, #64]	@ 0x40
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003610:	4630      	mov	r0, r6
34003612:	f241 3288 	movw	r2, #5000	@ 0x1388
34003616:	a901      	add	r1, sp, #4
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34003618:	9313      	str	r3, [sp, #76]	@ 0x4c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400361a:	f00c fbc3 	bl	3400fda4 <HAL_XSPI_Command>
3400361e:	2800      	cmp	r0, #0
34003620:	d1c5      	bne.n	340035ae <MX66UW1G45G_ReadCfg2Register+0x1c>
  if (HAL_XSPI_Receive(Ctx, Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003622:	f241 3288 	movw	r2, #5000	@ 0x1388
34003626:	4630      	mov	r0, r6
34003628:	991a      	ldr	r1, [sp, #104]	@ 0x68
3400362a:	f00c fd17 	bl	3401005c <HAL_XSPI_Receive>
3400362e:	3800      	subs	r0, #0
34003630:	bf18      	it	ne
34003632:	2001      	movne	r0, #1
34003634:	4240      	negs	r0, r0
34003636:	e7bc      	b.n	340035b2 <MX66UW1G45G_ReadCfg2Register+0x20>
34003638:	2301      	movs	r3, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
3400363a:	462a      	mov	r2, r5
3400363c:	e7c0      	b.n	340035c0 <MX66UW1G45G_ReadCfg2Register+0x2e>
3400363e:	2271      	movs	r2, #113	@ 0x71
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34003640:	f44f 7380 	mov.w	r3, #256	@ 0x100
34003644:	e7c6      	b.n	340035d4 <MX66UW1G45G_ReadCfg2Register+0x42>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34003646:	2304      	movs	r3, #4
34003648:	9312      	str	r3, [sp, #72]	@ 0x48
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
3400364a:	2201      	movs	r2, #1
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
3400364c:	2300      	movs	r3, #0
3400364e:	e7de      	b.n	3400360e <MX66UW1G45G_ReadCfg2Register+0x7c>
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34003650:	2c01      	cmp	r4, #1
34003652:	d1fa      	bne.n	3400364a <MX66UW1G45G_ReadCfg2Register+0xb8>
34003654:	e7d8      	b.n	34003608 <MX66UW1G45G_ReadCfg2Register+0x76>

34003656 <MX66UW1G45G_ResetEnable>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34003656:	b570      	push	{r4, r5, r6, lr}
34003658:	460d      	mov	r5, r1
3400365a:	b094      	sub	sp, #80	@ 0x50
3400365c:	4606      	mov	r6, r0
3400365e:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34003660:	2100      	movs	r1, #0
34003662:	224c      	movs	r2, #76	@ 0x4c
34003664:	a801      	add	r0, sp, #4
34003666:	f016 fd5d 	bl	3401a124 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
3400366a:	b9d5      	cbnz	r5, 340036a2 <MX66UW1G45G_ResetEnable+0x4c>
3400366c:	2c01      	cmp	r4, #1
3400366e:	d01c      	beq.n	340036aa <MX66UW1G45G_ResetEnable+0x54>
  /* Initialize the reset enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
  s_command.IOSelect =  HAL_XSPI_SELECT_IO_3_0;
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34003670:	2301      	movs	r3, #1
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34003672:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34003674:	1e63      	subs	r3, r4, #1
34003676:	425c      	negs	r4, r3
34003678:	415c      	adcs	r4, r3
3400367a:	00e4      	lsls	r4, r4, #3
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
3400367c:	9406      	str	r4, [sp, #24]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
3400367e:	b195      	cbz	r5, 340036a6 <MX66UW1G45G_ResetEnable+0x50>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34003680:	2310      	movs	r3, #16
34003682:	9305      	str	r3, [sp, #20]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_ENABLE_CMD
                              : MX66UW1G45G_OCTA_RESET_ENABLE_CMD;
34003684:	f246 6399 	movw	r3, #26265	@ 0x6699
  s_command.DummyCycles = 0U;
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;


  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003688:	f241 3288 	movw	r2, #5000	@ 0x1388
3400368c:	4630      	mov	r0, r6
3400368e:	a901      	add	r1, sp, #4
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34003690:	9303      	str	r3, [sp, #12]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003692:	f00c fb87 	bl	3400fda4 <HAL_XSPI_Command>
34003696:	3800      	subs	r0, #0
34003698:	bf18      	it	ne
3400369a:	2001      	movne	r0, #1
3400369c:	4240      	negs	r0, r0
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
3400369e:	b014      	add	sp, #80	@ 0x50
340036a0:	bd70      	pop	{r4, r5, r6, pc}
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
340036a2:	2304      	movs	r3, #4
340036a4:	e7e5      	b.n	34003672 <MX66UW1G45G_ResetEnable+0x1c>
                              : MX66UW1G45G_OCTA_RESET_ENABLE_CMD;
340036a6:	2366      	movs	r3, #102	@ 0x66
340036a8:	e7ee      	b.n	34003688 <MX66UW1G45G_ResetEnable+0x32>
    return MX66UW1G45G_ERROR;
340036aa:	f04f 30ff 	mov.w	r0, #4294967295
340036ae:	e7f6      	b.n	3400369e <MX66UW1G45G_ResetEnable+0x48>

340036b0 <MX66UW1G45G_ResetMemory>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetMemory(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
340036b0:	b570      	push	{r4, r5, r6, lr}
340036b2:	460d      	mov	r5, r1
340036b4:	b094      	sub	sp, #80	@ 0x50
340036b6:	4606      	mov	r6, r0
340036b8:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
340036ba:	2100      	movs	r1, #0
340036bc:	224c      	movs	r2, #76	@ 0x4c
340036be:	a801      	add	r0, sp, #4
340036c0:	f016 fd30 	bl	3401a124 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
340036c4:	b9bd      	cbnz	r5, 340036f6 <MX66UW1G45G_ResetMemory+0x46>
340036c6:	2c01      	cmp	r4, #1
340036c8:	d01d      	beq.n	34003706 <MX66UW1G45G_ResetMemory+0x56>
340036ca:	2301      	movs	r3, #1
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
340036cc:	462c      	mov	r4, r5
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
340036ce:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
340036d0:	9406      	str	r4, [sp, #24]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
340036d2:	b1b5      	cbz	r5, 34003702 <MX66UW1G45G_ResetMemory+0x52>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
340036d4:	2310      	movs	r3, #16
340036d6:	9305      	str	r3, [sp, #20]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_MEMORY_CMD
                              : MX66UW1G45G_OCTA_RESET_MEMORY_CMD;
340036d8:	f649 1366 	movw	r3, #39270	@ 0x9966
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340036dc:	f241 3288 	movw	r2, #5000	@ 0x1388
340036e0:	4630      	mov	r0, r6
340036e2:	a901      	add	r1, sp, #4
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
340036e4:	9303      	str	r3, [sp, #12]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340036e6:	f00c fb5d 	bl	3400fda4 <HAL_XSPI_Command>
340036ea:	3800      	subs	r0, #0
340036ec:	bf18      	it	ne
340036ee:	2001      	movne	r0, #1
340036f0:	4240      	negs	r0, r0
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
340036f2:	b014      	add	sp, #80	@ 0x50
340036f4:	bd70      	pop	{r4, r5, r6, pc}
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
340036f6:	1e63      	subs	r3, r4, #1
340036f8:	425c      	negs	r4, r3
340036fa:	415c      	adcs	r4, r3
340036fc:	00e4      	lsls	r4, r4, #3
340036fe:	2304      	movs	r3, #4
34003700:	e7e5      	b.n	340036ce <MX66UW1G45G_ResetMemory+0x1e>
                              : MX66UW1G45G_OCTA_RESET_MEMORY_CMD;
34003702:	2399      	movs	r3, #153	@ 0x99
34003704:	e7ea      	b.n	340036dc <MX66UW1G45G_ResetMemory+0x2c>
    return MX66UW1G45G_ERROR;
34003706:	f04f 30ff 	mov.w	r0, #4294967295
3400370a:	e7f2      	b.n	340036f2 <MX66UW1G45G_ResetMemory+0x42>

3400370c <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3400370c:	4b04      	ldr	r3, [pc, #16]	@ (34003720 <LL_AHB4_GRP1_EnableClock+0x14>)
{
3400370e:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003710:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34003714:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34003718:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400371a:	9b01      	ldr	r3, [sp, #4]
}
3400371c:	b002      	add	sp, #8
3400371e:	4770      	bx	lr
34003720:	56028000 	.word	0x56028000

34003724 <BSP_SMPS_Init>:
  * @param Voltage configuration
  *          This parameter can be one of the following values:
  *            @arg  SMPS_VOLTAGE_NOMINAL
  *            @arg  SMPS_VOLTAGE_OVERDRIVE
  */
void BSP_SMPS_Init(SMPSVoltage_TypeDef Voltage){
34003724:	b570      	push	{r4, r5, r6, lr}
34003726:	4604      	mov	r4, r0
34003728:	b086      	sub	sp, #24
  SMPS_GPIO_CLK_ENABLE();
3400372a:	2020      	movs	r0, #32
3400372c:	f7ff ffee 	bl	3400370c <LL_AHB4_GRP1_EnableClock>
  GPIO_InitTypeDef  gpio_init_structure = {0};
34003730:	2300      	movs	r3, #0
  /* configure the external SMPS control pin */
  gpio_init_structure.Pin = SMPS_GPIO_PIN;
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
34003732:	2610      	movs	r6, #16
  GPIO_InitTypeDef  gpio_init_structure = {0};
34003734:	9303      	str	r3, [sp, #12]
34003736:	9305      	str	r3, [sp, #20]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
34003738:	2301      	movs	r3, #1
3400373a:	e9cd 6301 	strd	r6, r3, [sp, #4]
  gpio_init_structure.Pull = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
3400373e:	2303      	movs	r3, #3
  HAL_GPIO_Init (SMPS_GPIO_PORT, &gpio_init_structure);
34003740:	4d06      	ldr	r5, [pc, #24]	@ (3400375c <BSP_SMPS_Init+0x38>)
34003742:	a901      	add	r1, sp, #4
34003744:	4628      	mov	r0, r5
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34003746:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init (SMPS_GPIO_PORT, &gpio_init_structure);
34003748:	f004 faaa 	bl	34007ca0 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(SMPS_GPIO_PORT, SMPS_GPIO_PIN, (GPIO_PinState) Voltage);
3400374c:	4622      	mov	r2, r4
3400374e:	4631      	mov	r1, r6
34003750:	4628      	mov	r0, r5
34003752:	f004 fdeb 	bl	3400832c <HAL_GPIO_WritePin>
}
34003756:	b006      	add	sp, #24
34003758:	bd70      	pop	{r4, r5, r6, pc}
3400375a:	bf00      	nop
3400375c:	56021400 	.word	0x56021400

34003760 <__io_putchar>:

/**
  * @brief  Redirect console output to COM
  */
PUTCHAR_PROTOTYPE
{
34003760:	b537      	push	{r0, r1, r2, r4, r5, lr}
  HAL_UART_Transmit (&hcom_uart [COM_ActiveLogPort], (uint8_t *) &ch, 1, COM_POLL_TIMEOUT);
34003762:	2594      	movs	r5, #148	@ 0x94
34003764:	4b07      	ldr	r3, [pc, #28]	@ (34003784 <__io_putchar+0x24>)
{
34003766:	9001      	str	r0, [sp, #4]
  HAL_UART_Transmit (&hcom_uart [COM_ActiveLogPort], (uint8_t *) &ch, 1, COM_POLL_TIMEOUT);
34003768:	4c07      	ldr	r4, [pc, #28]	@ (34003788 <__io_putchar+0x28>)
3400376a:	7818      	ldrb	r0, [r3, #0]
3400376c:	2201      	movs	r2, #1
3400376e:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34003772:	fb05 4000 	mla	r0, r5, r0, r4
34003776:	a901      	add	r1, sp, #4
34003778:	f015 f9ce 	bl	34018b18 <HAL_UART_Transmit>
  return ch;
}
3400377c:	9801      	ldr	r0, [sp, #4]
3400377e:	b003      	add	sp, #12
34003780:	bd30      	pop	{r4, r5, pc}
34003782:	bf00      	nop
34003784:	340cd1fc 	.word	0x340cd1fc
34003788:	340cd200 	.word	0x340cd200

3400378c <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3400378c:	4b04      	ldr	r3, [pc, #16]	@ (340037a0 <LL_AHB4_GRP1_EnableClock+0x14>)
{
3400378e:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003790:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34003794:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34003798:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400379a:	9b01      	ldr	r3, [sp, #4]
}
3400379c:	b002      	add	sp, #8
3400379e:	4770      	bx	lr
340037a0:	56028000 	.word	0x56028000

340037a4 <I2C_GetTiming.constprop.0>:
  * @brief  Compute I2C timing according current I2C clock source and required I2C clock.
  * @param  clock_src_freq I2C clock source in Hz.
  * @param  i2c_freq Required I2C clock in Hz.
  * @retval I2C timing or 0 in case of error.
  */
static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq)
340037a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340037a8:	b08b      	sub	sp, #44	@ 0x2c
{
  uint32_t ret = 0;
  uint32_t speed;
  uint32_t idx;

  if ((clock_src_freq != 0U) && (i2c_freq != 0U))
340037aa:	b918      	cbnz	r0, 340037b4 <I2C_GetTiming.constprop.0+0x10>
  uint32_t ret = 0;
340037ac:	2000      	movs	r0, #0
      }
    }
  }

  return ret;
}
340037ae:	b00b      	add	sp, #44	@ 0x2c
340037b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint32_t scldel;
  uint32_t sdadel;
  uint32_t tafdel_min;
  uint32_t tafdel_max;

  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
340037b4:	4b6f      	ldr	r3, [pc, #444]	@ (34003974 <I2C_GetTiming.constprop.0+0x1d0>)
     SDADEL <= {tVD;DAT(max) - tr - tAF(max) - tDNF- [4 x tI2CCLK]} / tPRESC */

  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);

  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
340037b6:	f640 15f6 	movw	r5, #2550	@ 0x9f6
  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
340037ba:	eb03 0350 	add.w	r3, r3, r0, lsr #1
340037be:	fbb3 f3f0 	udiv	r3, r3, r0
340037c2:	9300      	str	r3, [sp, #0]
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
340037c4:	005b      	lsls	r3, r3, #1
340037c6:	9301      	str	r3, [sp, #4]
340037c8:	9b00      	ldr	r3, [sp, #0]
  uint32_t prev_presc = I2C_PRESC_MAX;
340037ca:	f04f 0b10 	mov.w	fp, #16
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
340037ce:	eb03 0443 	add.w	r4, r3, r3, lsl #1
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
340037d2:	eba5 0583 	sub.w	r5, r5, r3, lsl #2
  if (tsdadel_min <= 0)
  {
    tsdadel_min = 0;
  }

  if (tsdadel_max <= 0)
340037d6:	4619      	mov	r1, r3
340037d8:	2300      	movs	r3, #0
340037da:	469a      	mov	sl, r3
340037dc:	f8df c19c 	ldr.w	ip, [pc, #412]	@ 3400397c <I2C_GetTiming.constprop.0+0x1d8>
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
340037e0:	f1c4 24ff 	rsb	r4, r4, #4278255360	@ 0xff00ff00
340037e4:	f504 047f 	add.w	r4, r4, #16711680	@ 0xff0000
340037e8:	34e2      	adds	r4, #226	@ 0xe2
340037ea:	f8dc 2000 	ldr.w	r2, [ip]
  if (tsdadel_min <= 0)
340037ee:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
  if (tsdadel_max <= 0)
340037f2:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq)
340037f6:	468e      	mov	lr, r1
    tsdadel_max = 0;
  }

  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
  {
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
340037f8:	2700      	movs	r7, #0
    {
      /* TSCLDEL = (SCLDEL+1) * (PRESC+1) * TI2CCLK */
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;

      if (tscldel >= (uint32_t)tscldel_min)
340037fa:	f240 3079 	movw	r0, #889	@ 0x379
340037fe:	4586      	cmp	lr, r0
34003800:	9702      	str	r7, [sp, #8]
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;
34003802:	f107 0701 	add.w	r7, r7, #1
      if (tscldel >= (uint32_t)tscldel_min)
34003806:	d950      	bls.n	340038aa <I2C_GetTiming.constprop.0+0x106>
34003808:	2600      	movs	r6, #0
3400380a:	f04f 0810 	mov.w	r8, #16
      {
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
3400380e:	46b1      	mov	r9, r6
        {
          /* TSDADEL = SDADEL * (PRESC+1) * TI2CCLK */
          uint32_t tsdadel = (sdadel * (presc + 1U)) * ti2cclk;

          if ((tsdadel >= (uint32_t)tsdadel_min) && (tsdadel <= (uint32_t)tsdadel_max))
34003810:	42b4      	cmp	r4, r6
34003812:	d844      	bhi.n	3400389e <I2C_GetTiming.constprop.0+0xfa>
34003814:	42b5      	cmp	r5, r6
34003816:	d342      	bcc.n	3400389e <I2C_GetTiming.constprop.0+0xfa>
          {
            if (presc != prev_presc)
34003818:	459b      	cmp	fp, r3
3400381a:	d040      	beq.n	3400389e <I2C_GetTiming.constprop.0+0xfa>
            {
              I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
3400381c:	2014      	movs	r0, #20
3400381e:	fb00 fb02 	mul.w	fp, r0, r2
34003822:	4855      	ldr	r0, [pc, #340]	@ (34003978 <I2C_GetTiming.constprop.0+0x1d4>)
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
              prev_presc = presc;
              I2c_valid_timing_nbr ++;
34003824:	3201      	adds	r2, #1
              I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
34003826:	eb00 0a0b 	add.w	sl, r0, fp
3400382a:	f840 300b 	str.w	r3, [r0, fp]
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
3400382e:	9802      	ldr	r0, [sp, #8]

              if (I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
34003830:	2a7f      	cmp	r2, #127	@ 0x7f
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
34003832:	e9ca 0901 	strd	r0, r9, [sl, #4]
              if (I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
34003836:	d92f      	bls.n	34003898 <I2C_GetTiming.constprop.0+0xf4>
34003838:	f8cc 2000 	str.w	r2, [ip]
  clk_max = SEC2NSEC / I2C_Charac[I2C_speed].freq_min;
  clk_min = SEC2NSEC / I2C_Charac[I2C_speed].freq_max;

  prev_error = ti2cspeed;

  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
3400383c:	f8dc 3000 	ldr.w	r3, [ip]
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;

    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
    {
      /* tLOW(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLL+1) x tPRESC ] */
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
34003840:	2600      	movs	r6, #0
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
34003842:	9306      	str	r3, [sp, #24]
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
34003844:	f242 7310 	movw	r3, #10000	@ 0x2710
34003848:	f04f 32ff 	mov.w	r2, #4294967295
3400384c:	9304      	str	r3, [sp, #16]
3400384e:	9b01      	ldr	r3, [sp, #4]
34003850:	4949      	ldr	r1, [pc, #292]	@ (34003978 <I2C_GetTiming.constprop.0+0x1d4>)
34003852:	3332      	adds	r3, #50	@ 0x32
34003854:	9309      	str	r3, [sp, #36]	@ 0x24
34003856:	9b01      	ldr	r3, [sp, #4]
34003858:	f5c3 5e90 	rsb	lr, r3, #4608	@ 0x1200
3400385c:	f10e 0e0c 	add.w	lr, lr, #12
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
34003860:	9b06      	ldr	r3, [sp, #24]
34003862:	429e      	cmp	r6, r3
34003864:	d12d      	bne.n	340038c2 <I2C_GetTiming.constprop.0+0x11e>
        if (idx < I2C_VALID_TIMING_NBR)
34003866:	2a7f      	cmp	r2, #127	@ 0x7f
34003868:	d8a0      	bhi.n	340037ac <I2C_GetTiming.constprop.0+0x8>
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
3400386a:	2114      	movs	r1, #20
3400386c:	434a      	muls	r2, r1
3400386e:	4b42      	ldr	r3, [pc, #264]	@ (34003978 <I2C_GetTiming.constprop.0+0x1d4>)
34003870:	1899      	adds	r1, r3, r2
                ((I2c_valid_timing[idx].scll & 0xFFU) << 0);
34003872:	7c08      	ldrb	r0, [r1, #16]
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34003874:	589b      	ldr	r3, [r3, r2]
34003876:	ea40 7003 	orr.w	r0, r0, r3, lsl #28
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
3400387a:	684b      	ldr	r3, [r1, #4]
3400387c:	051b      	lsls	r3, r3, #20
3400387e:	f403 0370 	and.w	r3, r3, #15728640	@ 0xf00000
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34003882:	4318      	orrs	r0, r3
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
34003884:	688b      	ldr	r3, [r1, #8]
34003886:	041b      	lsls	r3, r3, #16
34003888:	f403 2370 	and.w	r3, r3, #983040	@ 0xf0000
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
3400388c:	4318      	orrs	r0, r3
                ((I2c_valid_timing[idx].sclh & 0xFFU) << 8) |\
3400388e:	68cb      	ldr	r3, [r1, #12]
34003890:	021b      	lsls	r3, r3, #8
34003892:	b29b      	uxth	r3, r3
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34003894:	4318      	orrs	r0, r3
  return ret;
34003896:	e78a      	b.n	340037ae <I2C_GetTiming.constprop.0+0xa>
              prev_presc = presc;
34003898:	469b      	mov	fp, r3
3400389a:	f04f 0a01 	mov.w	sl, #1
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
3400389e:	f1b8 0801 	subs.w	r8, r8, #1
340038a2:	f109 0901 	add.w	r9, r9, #1
340038a6:	440e      	add	r6, r1
340038a8:	d1b2      	bne.n	34003810 <I2C_GetTiming.constprop.0+0x6c>
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
340038aa:	2f10      	cmp	r7, #16
340038ac:	448e      	add	lr, r1
340038ae:	d1a4      	bne.n	340037fa <I2C_GetTiming.constprop.0+0x56>
  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
340038b0:	9800      	ldr	r0, [sp, #0]
340038b2:	3301      	adds	r3, #1
340038b4:	2b10      	cmp	r3, #16
340038b6:	4401      	add	r1, r0
340038b8:	d19d      	bne.n	340037f6 <I2C_GetTiming.constprop.0+0x52>
340038ba:	f1ba 0f00 	cmp.w	sl, #0
340038be:	d1bb      	bne.n	34003838 <I2C_GetTiming.constprop.0+0x94>
340038c0:	e7bc      	b.n	3400383c <I2C_GetTiming.constprop.0+0x98>
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
340038c2:	2700      	movs	r7, #0
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
340038c4:	9800      	ldr	r0, [sp, #0]
340038c6:	680b      	ldr	r3, [r1, #0]
340038c8:	fb03 0300 	mla	r3, r3, r0, r0
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
340038cc:	9809      	ldr	r0, [sp, #36]	@ 0x24
340038ce:	ebae 0403 	sub.w	r4, lr, r3
340038d2:	4418      	add	r0, r3
340038d4:	9003      	str	r0, [sp, #12]
340038d6:	9801      	ldr	r0, [sp, #4]
340038d8:	ea4f 0b44 	mov.w	fp, r4, lsl #1
340038dc:	181d      	adds	r5, r3, r0
340038de:	f5a5 5011 	sub.w	r0, r5, #9280	@ 0x2440
340038e2:	380a      	subs	r0, #10
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
340038e4:	9c03      	ldr	r4, [sp, #12]
340038e6:	9002      	str	r0, [sp, #8]


      /* The I2CCLK period tI2CCLK must respect the following conditions:
      tI2CCLK < (tLOW - tfilters) / 4 and tI2CCLK < tHIGH */
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
340038e8:	f241 205c 	movw	r0, #4700	@ 0x125c
340038ec:	4284      	cmp	r4, r0
340038ee:	9708      	str	r7, [sp, #32]
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
340038f0:	f107 0701 	add.w	r7, r7, #1
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
340038f4:	d935      	bls.n	34003962 <I2C_GetTiming.constprop.0+0x1be>
340038f6:	9800      	ldr	r0, [sp, #0]
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
340038f8:	f1a4 0532 	sub.w	r5, r4, #50	@ 0x32
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
340038fc:	ebb0 0f95 	cmp.w	r0, r5, lsr #2
34003900:	d22f      	bcs.n	34003962 <I2C_GetTiming.constprop.0+0x1be>
34003902:	9802      	ldr	r0, [sp, #8]
34003904:	46d8      	mov	r8, fp
34003906:	1905      	adds	r5, r0, r4
            if ((uint32_t)error < prev_error)
            {
              prev_error = (uint32_t)error;
              I2c_valid_timing[count].scll = scll;
              I2c_valid_timing[count].sclh = sclh;
              ret = count;
34003908:	f44f 7080 	mov.w	r0, #256	@ 0x100
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
3400390c:	f04f 0900 	mov.w	r9, #0
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
34003910:	f8dd c00c 	ldr.w	ip, [sp, #12]
              ret = count;
34003914:	9005      	str	r0, [sp, #20]
          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
34003916:	f241 0047 	movw	r0, #4167	@ 0x1047
3400391a:	f205 6a83 	addw	sl, r5, #1667	@ 0x683
3400391e:	4582      	cmp	sl, r0
34003920:	f8cd 901c 	str.w	r9, [sp, #28]
          uint32_t tscl_h = tafdel_min + dnf_delay + (2U * ti2cclk) + ((sclh + 1U) * tpresc);
34003924:	f109 0901 	add.w	r9, r9, #1
          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
34003928:	d813      	bhi.n	34003952 <I2C_GetTiming.constprop.0+0x1ae>
3400392a:	f5bc 6f7a 	cmp.w	ip, #4000	@ 0xfa0
3400392e:	d310      	bcc.n	34003952 <I2C_GetTiming.constprop.0+0x1ae>
34003930:	9800      	ldr	r0, [sp, #0]
34003932:	4560      	cmp	r0, ip
34003934:	d20d      	bcs.n	34003952 <I2C_GetTiming.constprop.0+0x1ae>
              error = -error;
34003936:	2d00      	cmp	r5, #0
34003938:	bfac      	ite	ge
3400393a:	46aa      	movge	sl, r5
3400393c:	46c2      	movlt	sl, r8
            if ((uint32_t)error < prev_error)
3400393e:	9804      	ldr	r0, [sp, #16]
34003940:	4582      	cmp	sl, r0
34003942:	d206      	bcs.n	34003952 <I2C_GetTiming.constprop.0+0x1ae>
              I2c_valid_timing[count].scll = scll;
34003944:	9a08      	ldr	r2, [sp, #32]
              prev_error = (uint32_t)error;
34003946:	f8cd a010 	str.w	sl, [sp, #16]
              I2c_valid_timing[count].scll = scll;
3400394a:	610a      	str	r2, [r1, #16]
              I2c_valid_timing[count].sclh = sclh;
3400394c:	9a07      	ldr	r2, [sp, #28]
3400394e:	60ca      	str	r2, [r1, #12]
              ret = count;
34003950:	4632      	mov	r2, r6
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
34003952:	9805      	ldr	r0, [sp, #20]
34003954:	449c      	add	ip, r3
34003956:	3801      	subs	r0, #1
34003958:	441d      	add	r5, r3
3400395a:	eba8 0803 	sub.w	r8, r8, r3
3400395e:	9005      	str	r0, [sp, #20]
34003960:	d1d9      	bne.n	34003916 <I2C_GetTiming.constprop.0+0x172>
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
34003962:	f5b7 7f80 	cmp.w	r7, #256	@ 0x100
34003966:	441c      	add	r4, r3
34003968:	ebab 0b03 	sub.w	fp, fp, r3
3400396c:	d1bc      	bne.n	340038e8 <I2C_GetTiming.constprop.0+0x144>
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
3400396e:	3601      	adds	r6, #1
34003970:	3114      	adds	r1, #20
34003972:	e775      	b.n	34003860 <I2C_GetTiming.constprop.0+0xbc>
34003974:	3b9aca00 	.word	0x3b9aca00
34003978:	340cd380 	.word	0x340cd380
3400397c:	340cd37c 	.word	0x340cd37c

34003980 <BSP_I2C1_DeInit>:
  I2c1InitCounter--;
34003980:	4a0e      	ldr	r2, [pc, #56]	@ (340039bc <BSP_I2C1_DeInit+0x3c>)
{
34003982:	b508      	push	{r3, lr}
  I2c1InitCounter--;
34003984:	6813      	ldr	r3, [r2, #0]
34003986:	3b01      	subs	r3, #1
34003988:	6013      	str	r3, [r2, #0]
  if (I2c1InitCounter == 0U)
3400398a:	b10b      	cbz	r3, 34003990 <BSP_I2C1_DeInit+0x10>
  int32_t ret = BSP_ERROR_NONE;
3400398c:	2000      	movs	r0, #0
}
3400398e:	bd08      	pop	{r3, pc}
  HAL_GPIO_DeInit(BUS_I2C1_SCL_GPIO_PORT, gpio_init_structure.Pin );
34003990:	f44f 7100 	mov.w	r1, #512	@ 0x200
34003994:	480a      	ldr	r0, [pc, #40]	@ (340039c0 <BSP_I2C1_DeInit+0x40>)
34003996:	f004 fb9b 	bl	340080d0 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(BUS_I2C1_SDA_GPIO_PORT, gpio_init_structure.Pin);
3400399a:	480a      	ldr	r0, [pc, #40]	@ (340039c4 <BSP_I2C1_DeInit+0x44>)
3400399c:	2102      	movs	r1, #2
3400399e:	f004 fb97 	bl	340080d0 <HAL_GPIO_DeInit>
  WRITE_REG(RCC->APB1ENCR1, Periphs);
340039a2:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
340039a6:	4b08      	ldr	r3, [pc, #32]	@ (340039c8 <BSP_I2C1_DeInit+0x48>)
    if (HAL_I2C_DeInit(&hbus_i2c1) != HAL_OK)
340039a8:	4808      	ldr	r0, [pc, #32]	@ (340039cc <BSP_I2C1_DeInit+0x4c>)
340039aa:	f8c3 2264 	str.w	r2, [r3, #612]	@ 0x264
340039ae:	f004 ff1d 	bl	340087ec <HAL_I2C_DeInit>
340039b2:	2800      	cmp	r0, #0
340039b4:	d0ea      	beq.n	3400398c <BSP_I2C1_DeInit+0xc>
      ret = BSP_ERROR_BUS_FAILURE;
340039b6:	f06f 0007 	mvn.w	r0, #7
  return ret;
340039ba:	e7e8      	b.n	3400398e <BSP_I2C1_DeInit+0xe>
340039bc:	340cdd80 	.word	0x340cdd80
340039c0:	56021c00 	.word	0x56021c00
340039c4:	56020800 	.word	0x56020800
340039c8:	56029000 	.word	0x56029000
340039cc:	340cd328 	.word	0x340cd328

340039d0 <MX_I2C1_Init>:
  hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
340039d0:	2300      	movs	r3, #0
340039d2:	2201      	movs	r2, #1
{
340039d4:	b510      	push	{r4, lr}
  hI2c->Init.Timing           = timing;
340039d6:	6041      	str	r1, [r0, #4]
  hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
340039d8:	e9c0 3202 	strd	r3, r2, [r0, #8]
  hI2c->Init.OwnAddress2      = 0;
340039dc:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hI2c->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
340039e0:	e9c0 3306 	strd	r3, r3, [r0, #24]
  hI2c->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
340039e4:	6203      	str	r3, [r0, #32]
{
340039e6:	4604      	mov	r4, r0
  if (HAL_I2C_Init(hI2c) != HAL_OK)
340039e8:	f004 fe3e 	bl	34008668 <HAL_I2C_Init>
340039ec:	4601      	mov	r1, r0
340039ee:	b108      	cbz	r0, 340039f4 <MX_I2C1_Init+0x24>
    status = HAL_ERROR;
340039f0:	2001      	movs	r0, #1
}
340039f2:	bd10      	pop	{r4, pc}
    if (HAL_I2CEx_ConfigAnalogFilter(hI2c, analog_filter) != HAL_OK)
340039f4:	4620      	mov	r0, r4
340039f6:	f005 f913 	bl	34008c20 <HAL_I2CEx_ConfigAnalogFilter>
340039fa:	4601      	mov	r1, r0
340039fc:	2800      	cmp	r0, #0
340039fe:	d1f7      	bne.n	340039f0 <MX_I2C1_Init+0x20>
      if (HAL_I2CEx_ConfigDigitalFilter(hI2c, I2C_DIGITAL_FILTER_COEF) != HAL_OK)
34003a00:	4620      	mov	r0, r4
34003a02:	f005 f967 	bl	34008cd4 <HAL_I2CEx_ConfigDigitalFilter>
34003a06:	3800      	subs	r0, #0
34003a08:	bf18      	it	ne
34003a0a:	2001      	movne	r0, #1
34003a0c:	e7f1      	b.n	340039f2 <MX_I2C1_Init+0x22>
	...

34003a10 <BSP_I2C1_Init>:
{
34003a10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  hbus_i2c1.Instance = BUS_I2C1;
34003a14:	4b28      	ldr	r3, [pc, #160]	@ (34003ab8 <BSP_I2C1_Init+0xa8>)
34003a16:	4e29      	ldr	r6, [pc, #164]	@ (34003abc <BSP_I2C1_Init+0xac>)
{
34003a18:	b086      	sub	sp, #24
  hbus_i2c1.Instance = BUS_I2C1;
34003a1a:	6033      	str	r3, [r6, #0]
  if (I2c1InitCounter == 0U)
34003a1c:	4b28      	ldr	r3, [pc, #160]	@ (34003ac0 <BSP_I2C1_Init+0xb0>)
34003a1e:	681a      	ldr	r2, [r3, #0]
34003a20:	b11a      	cbz	r2, 34003a2a <BSP_I2C1_Init+0x1a>
  int32_t ret = BSP_ERROR_NONE;
34003a22:	2000      	movs	r0, #0
}
34003a24:	b006      	add	sp, #24
34003a26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    I2c1InitCounter++;
34003a2a:	2201      	movs	r2, #1
    if (HAL_I2C_GetState(&hbus_i2c1) == HAL_I2C_STATE_RESET)
34003a2c:	4630      	mov	r0, r6
    I2c1InitCounter++;
34003a2e:	601a      	str	r2, [r3, #0]
    if (HAL_I2C_GetState(&hbus_i2c1) == HAL_I2C_STATE_RESET)
34003a30:	f005 f8f0 	bl	34008c14 <HAL_I2C_GetState>
34003a34:	4604      	mov	r4, r0
34003a36:	2800      	cmp	r0, #0
34003a38:	d1f3      	bne.n	34003a22 <BSP_I2C1_Init+0x12>
  HAL_PWREx_EnableVddIO4();
34003a3a:	f005 fe4b 	bl	340096d4 <HAL_PWREx_EnableVddIO4>
  BUS_I2C1_SCL_GPIO_CLK_ENABLE();
34003a3e:	2080      	movs	r0, #128	@ 0x80
34003a40:	f7ff fea4 	bl	3400378c <LL_AHB4_GRP1_EnableClock>
  BUS_I2C1_SDA_GPIO_CLK_ENABLE();
34003a44:	2004      	movs	r0, #4
34003a46:	f7ff fea1 	bl	3400378c <LL_AHB4_GRP1_EnableClock>
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34003a4a:	2702      	movs	r7, #2
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
34003a4c:	f44f 7300 	mov.w	r3, #512	@ 0x200
  gpio_init_structure.Alternate = BUS_I2C1_SCL_AF;
34003a50:	4605      	mov	r5, r0
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
34003a52:	f04f 0812 	mov.w	r8, #18
  HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &gpio_init_structure);
34003a56:	eb0d 0100 	add.w	r1, sp, r0
  gpio_init_structure.Alternate = BUS_I2C1_SCL_AF;
34003a5a:	9005      	str	r0, [sp, #20]
  HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &gpio_init_structure);
34003a5c:	4819      	ldr	r0, [pc, #100]	@ (34003ac4 <BSP_I2C1_Init+0xb4>)
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
34003a5e:	e9cd 3801 	strd	r3, r8, [sp, #4]
  gpio_init_structure.Pull      = GPIO_NOPULL;
34003a62:	9403      	str	r4, [sp, #12]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34003a64:	9704      	str	r7, [sp, #16]
  HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &gpio_init_structure);
34003a66:	f004 f91b 	bl	34007ca0 <HAL_GPIO_Init>
  HAL_GPIO_Init(BUS_I2C1_SDA_GPIO_PORT, &gpio_init_structure);
34003a6a:	4817      	ldr	r0, [pc, #92]	@ (34003ac8 <BSP_I2C1_Init+0xb8>)
34003a6c:	eb0d 0105 	add.w	r1, sp, r5
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
34003a70:	e9cd 7801 	strd	r7, r8, [sp, #4]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34003a74:	e9cd 4703 	strd	r4, r7, [sp, #12]
  gpio_init_structure.Alternate = BUS_I2C1_SDA_AF;
34003a78:	9505      	str	r5, [sp, #20]
  HAL_GPIO_Init(BUS_I2C1_SDA_GPIO_PORT, &gpio_init_structure);
34003a7a:	f004 f911 	bl	34007ca0 <HAL_GPIO_Init>
  WRITE_REG(RCC->APB1ENSR1, Periphs);
34003a7e:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
34003a82:	4a12      	ldr	r2, [pc, #72]	@ (34003acc <BSP_I2C1_Init+0xbc>)
34003a84:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
34003a88:	f8d2 1264 	ldr.w	r1, [r2, #612]	@ 0x264
34003a8c:	9100      	str	r1, [sp, #0]
  (void)tmpreg;
34003a8e:	9900      	ldr	r1, [sp, #0]
  WRITE_REG(RCC->APB1RSTSR1, Periphs);
34003a90:	f8c2 3a24 	str.w	r3, [r2, #2596]	@ 0xa24
  WRITE_REG(RCC->APB1RSTCR1, Periphs);
34003a94:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34003a98:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
        if (MX_I2C1_Init(&hbus_i2c1, I2C_GetTiming(HAL_RCC_GetPCLK1Freq(), BUS_I2C1_FREQUENCY)) != HAL_OK)
34003a9c:	f006 fed0 	bl	3400a840 <HAL_RCC_GetPCLK1Freq>
34003aa0:	f7ff fe80 	bl	340037a4 <I2C_GetTiming.constprop.0>
34003aa4:	4601      	mov	r1, r0
34003aa6:	4630      	mov	r0, r6
34003aa8:	f7ff ff92 	bl	340039d0 <MX_I2C1_Init>
34003aac:	2800      	cmp	r0, #0
34003aae:	d0b8      	beq.n	34003a22 <BSP_I2C1_Init+0x12>
          ret = BSP_ERROR_BUS_FAILURE;
34003ab0:	f06f 0007 	mvn.w	r0, #7
  return ret;
34003ab4:	e7b6      	b.n	34003a24 <BSP_I2C1_Init+0x14>
34003ab6:	bf00      	nop
34003ab8:	50005400 	.word	0x50005400
34003abc:	340cd328 	.word	0x340cd328
34003ac0:	340cdd80 	.word	0x340cdd80
34003ac4:	56021c00 	.word	0x56021c00
34003ac8:	56020800 	.word	0x56020800
34003acc:	56028000 	.word	0x56028000

34003ad0 <BSP_I2C1_WriteReg16>:
{
34003ad0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if (HAL_I2C_Mem_Write(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
34003ad2:	f44f 747a 	mov.w	r4, #1000	@ 0x3e8
34003ad6:	9200      	str	r2, [sp, #0]
34003ad8:	e9cd 3401 	strd	r3, r4, [sp, #4]
34003adc:	460a      	mov	r2, r1
34003ade:	2302      	movs	r3, #2
34003ae0:	4601      	mov	r1, r0
34003ae2:	4808      	ldr	r0, [pc, #32]	@ (34003b04 <BSP_I2C1_WriteReg16+0x34>)
34003ae4:	f004 feca 	bl	3400887c <HAL_I2C_Mem_Write>
    ret = BSP_ERROR_NONE;
34003ae8:	2300      	movs	r3, #0
  if (HAL_I2C_Mem_Write(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
34003aea:	b140      	cbz	r0, 34003afe <BSP_I2C1_WriteReg16+0x2e>
    if (HAL_I2C_GetError(&hbus_i2c1) == HAL_I2C_ERROR_AF)
34003aec:	4805      	ldr	r0, [pc, #20]	@ (34003b04 <BSP_I2C1_WriteReg16+0x34>)
34003aee:	f005 f894 	bl	34008c1a <HAL_I2C_GetError>
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
34003af2:	2804      	cmp	r0, #4
34003af4:	bf14      	ite	ne
34003af6:	f06f 0303 	mvnne.w	r3, #3
34003afa:	f06f 0365 	mvneq.w	r3, #101	@ 0x65
}
34003afe:	4618      	mov	r0, r3
34003b00:	b004      	add	sp, #16
34003b02:	bd10      	pop	{r4, pc}
34003b04:	340cd328 	.word	0x340cd328

34003b08 <BSP_I2C1_ReadReg16>:
{
34003b08:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if (HAL_I2C_Mem_Read(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
34003b0a:	f44f 747a 	mov.w	r4, #1000	@ 0x3e8
34003b0e:	9200      	str	r2, [sp, #0]
34003b10:	e9cd 3401 	strd	r3, r4, [sp, #4]
34003b14:	460a      	mov	r2, r1
34003b16:	2302      	movs	r3, #2
34003b18:	4601      	mov	r1, r0
34003b1a:	4808      	ldr	r0, [pc, #32]	@ (34003b3c <BSP_I2C1_ReadReg16+0x34>)
34003b1c:	f004 ff92 	bl	34008a44 <HAL_I2C_Mem_Read>
    ret = BSP_ERROR_NONE;
34003b20:	2300      	movs	r3, #0
  if (HAL_I2C_Mem_Read(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
34003b22:	b140      	cbz	r0, 34003b36 <BSP_I2C1_ReadReg16+0x2e>
    if (HAL_I2C_GetError(&hbus_i2c1) == HAL_I2C_ERROR_AF)
34003b24:	4805      	ldr	r0, [pc, #20]	@ (34003b3c <BSP_I2C1_ReadReg16+0x34>)
34003b26:	f005 f878 	bl	34008c1a <HAL_I2C_GetError>
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
34003b2a:	2804      	cmp	r0, #4
34003b2c:	bf14      	ite	ne
34003b2e:	f06f 0303 	mvnne.w	r3, #3
34003b32:	f06f 0365 	mvneq.w	r3, #101	@ 0x65
}
34003b36:	4618      	mov	r0, r3
34003b38:	b004      	add	sp, #16
34003b3a:	bd10      	pop	{r4, pc}
34003b3c:	340cd328 	.word	0x340cd328

34003b40 <BSP_GetTick>:
  return (int32_t)HAL_GetTick();
34003b40:	f001 b99c 	b.w	34004e7c <HAL_GetTick>

34003b44 <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003b44:	4b04      	ldr	r3, [pc, #16]	@ (34003b58 <LL_AHB4_GRP1_EnableClock+0x14>)
{
34003b46:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003b48:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34003b4c:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34003b50:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34003b52:	9b01      	ldr	r3, [sp, #4]
}
34003b54:	b002      	add	sp, #8
34003b56:	4770      	bx	lr
34003b58:	56028000 	.word	0x56028000

34003b5c <BSP_LCD_GetPixelFormat>:
  */
int32_t BSP_LCD_GetPixelFormat(uint32_t Instance, uint32_t *PixelFormat)
{
  int32_t ret = BSP_ERROR_NONE;

  if(Instance >= LCD_INSTANCES_NBR)
34003b5c:	b918      	cbnz	r0, 34003b66 <BSP_LCD_GetPixelFormat+0xa>
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    /* Only RGB565 format is supported */
    *PixelFormat =  Lcd_Ctx[Instance].PixelFormat;
34003b5e:	4b03      	ldr	r3, [pc, #12]	@ (34003b6c <BSP_LCD_GetPixelFormat+0x10>)
34003b60:	68db      	ldr	r3, [r3, #12]
34003b62:	600b      	str	r3, [r1, #0]
34003b64:	4770      	bx	lr
    ret = BSP_ERROR_WRONG_PARAM;
34003b66:	f06f 0001 	mvn.w	r0, #1
  }

  return ret;
}
34003b6a:	4770      	bx	lr
34003b6c:	340cdd84 	.word	0x340cdd84

34003b70 <BSP_LCD_SetActiveLayer>:
  * @param  Instance    LCD Instance
  * @param  LayerIndex  LCD layer index
  * @retval BSP status
  */
int32_t BSP_LCD_SetActiveLayer(uint32_t Instance, uint32_t LayerIndex)
{
34003b70:	b510      	push	{r4, lr}
  int32_t ret = BSP_ERROR_NONE;
  LTDC_LayerCfgTypeDef *pLayerCfg;

  if(Instance >= LCD_INSTANCES_NBR)
34003b72:	bb08      	cbnz	r0, 34003bb8 <BSP_LCD_SetActiveLayer+0x48>
  else
  {
    pLayerCfg = &hlcd_ltdc.LayerCfg[LayerIndex];

    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
34003b74:	2434      	movs	r4, #52	@ 0x34
    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
34003b76:	4b12      	ldr	r3, [pc, #72]	@ (34003bc0 <BSP_LCD_SetActiveLayer+0x50>)
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
34003b78:	4a12      	ldr	r2, [pc, #72]	@ (34003bc4 <BSP_LCD_SetActiveLayer+0x54>)
    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
34003b7a:	6099      	str	r1, [r3, #8]
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
34003b7c:	fb04 2101 	mla	r1, r4, r1, r2
34003b80:	6e0a      	ldr	r2, [r1, #96]	@ 0x60
34003b82:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].YSize = pLayerCfg->ImageHeight;
34003b84:	6e4a      	ldr	r2, [r1, #100]	@ 0x64
34003b86:	605a      	str	r2, [r3, #4]

    if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB565)
34003b88:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
34003b8a:	2a04      	cmp	r2, #4
34003b8c:	d104      	bne.n	34003b98 <BSP_LCD_SetActiveLayer+0x28>
    {
      Lcd_Ctx[Instance].BppFactor = 2;
34003b8e:	2202      	movs	r2, #2
34003b90:	611a      	str	r2, [r3, #16]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB565;
    }
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_ARGB4444)
    {
      Lcd_Ctx[Instance].BppFactor = 2;
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
34003b92:	60da      	str	r2, [r3, #12]
  int32_t ret = BSP_ERROR_NONE;
34003b94:	2000      	movs	r0, #0
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB8888;
    }
  }

  return ret;
}
34003b96:	bd10      	pop	{r4, pc}
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_ARGB4444)
34003b98:	2a08      	cmp	r2, #8
34003b9a:	d103      	bne.n	34003ba4 <BSP_LCD_SetActiveLayer+0x34>
      Lcd_Ctx[Instance].BppFactor = 2;
34003b9c:	2202      	movs	r2, #2
34003b9e:	611a      	str	r2, [r3, #16]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
34003ba0:	2204      	movs	r2, #4
34003ba2:	e7f6      	b.n	34003b92 <BSP_LCD_SetActiveLayer+0x22>
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB888)
34003ba4:	2a06      	cmp	r2, #6
34003ba6:	d103      	bne.n	34003bb0 <BSP_LCD_SetActiveLayer+0x40>
      Lcd_Ctx[Instance].BppFactor = 3;
34003ba8:	2203      	movs	r2, #3
34003baa:	611a      	str	r2, [r3, #16]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB888;
34003bac:	2201      	movs	r2, #1
34003bae:	e7f0      	b.n	34003b92 <BSP_LCD_SetActiveLayer+0x22>
      Lcd_Ctx[Instance].BppFactor = 4;
34003bb0:	2204      	movs	r2, #4
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB8888;
34003bb2:	e9c3 0203 	strd	r0, r2, [r3, #12]
34003bb6:	e7ed      	b.n	34003b94 <BSP_LCD_SetActiveLayer+0x24>
    ret = BSP_ERROR_WRONG_PARAM;
34003bb8:	f06f 0001 	mvn.w	r0, #1
  return ret;
34003bbc:	e7eb      	b.n	34003b96 <BSP_LCD_SetActiveLayer+0x26>
34003bbe:	bf00      	nop
34003bc0:	340cdd84 	.word	0x340cdd84
34003bc4:	340cdda4 	.word	0x340cdda4

34003bc8 <BSP_LCD_GetXSize>:
  */
int32_t BSP_LCD_GetXSize(uint32_t Instance, uint32_t *XSize)
{
  int32_t ret = BSP_ERROR_NONE;

  if(Instance >= LCD_INSTANCES_NBR)
34003bc8:	b918      	cbnz	r0, 34003bd2 <BSP_LCD_GetXSize+0xa>
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    *XSize = Lcd_Ctx[Instance].XSize;
34003bca:	4b03      	ldr	r3, [pc, #12]	@ (34003bd8 <BSP_LCD_GetXSize+0x10>)
34003bcc:	681b      	ldr	r3, [r3, #0]
34003bce:	600b      	str	r3, [r1, #0]
34003bd0:	4770      	bx	lr
    ret = BSP_ERROR_WRONG_PARAM;
34003bd2:	f06f 0001 	mvn.w	r0, #1
  }

  return ret;
}
34003bd6:	4770      	bx	lr
34003bd8:	340cdd84 	.word	0x340cdd84

34003bdc <BSP_LCD_GetYSize>:
  */
int32_t BSP_LCD_GetYSize(uint32_t Instance, uint32_t *YSize)
{
  int32_t ret = BSP_ERROR_NONE;

  if(Instance >= LCD_INSTANCES_NBR)
34003bdc:	b918      	cbnz	r0, 34003be6 <BSP_LCD_GetYSize+0xa>
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    *YSize = Lcd_Ctx[Instance].YSize;
34003bde:	4b03      	ldr	r3, [pc, #12]	@ (34003bec <BSP_LCD_GetYSize+0x10>)
34003be0:	685b      	ldr	r3, [r3, #4]
34003be2:	600b      	str	r3, [r1, #0]
34003be4:	4770      	bx	lr
    ret = BSP_ERROR_WRONG_PARAM;
34003be6:	f06f 0001 	mvn.w	r0, #1
  }

  return ret;
}
34003bea:	4770      	bx	lr
34003bec:	340cdd84 	.word	0x340cdd84

34003bf0 <BSP_LCD_ReadPixel>:
  * @param  Ypos Y position
  * @param  Color RGB pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_ReadPixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t *Color)
{
34003bf0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34003bf2:	2734      	movs	r7, #52	@ 0x34
34003bf4:	4d0f      	ldr	r5, [pc, #60]	@ (34003c34 <BSP_LCD_ReadPixel+0x44>)
34003bf6:	0146      	lsls	r6, r0, #5
34003bf8:	eb05 1040 	add.w	r0, r5, r0, lsl #5
34003bfc:	6884      	ldr	r4, [r0, #8]
34003bfe:	480e      	ldr	r0, [pc, #56]	@ (34003c38 <BSP_LCD_ReadPixel+0x48>)
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003c00:	59ad      	ldr	r5, [r5, r6]
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34003c02:	fb07 0004 	mla	r0, r7, r4, r0
34003c06:	6c84      	ldr	r4, [r0, #72]	@ 0x48
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003c08:	fb05 1202 	mla	r2, r5, r2, r1
34003c0c:	6dc0      	ldr	r0, [r0, #92]	@ 0x5c
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34003c0e:	b924      	cbnz	r4, 34003c1a <BSP_LCD_ReadPixel+0x2a>
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003c10:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
    /* Read data value from RAM memory */
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
  }

  return BSP_ERROR_NONE;
}
34003c14:	2000      	movs	r0, #0
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003c16:	601a      	str	r2, [r3, #0]
}
34003c18:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
34003c1a:	2c06      	cmp	r4, #6
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003c1c:	bf05      	ittet	eq
34003c1e:	eb02 0242 	addeq.w	r2, r2, r2, lsl #1
34003c22:	5812      	ldreq	r2, [r2, r0]
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003c24:	f830 2012 	ldrhne.w	r2, [r0, r2, lsl #1]
    *Color = CONVERTARGB88882RGB888(*Color);
34003c28:	f022 427f 	biceq.w	r2, r2, #4278190080	@ 0xff000000
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003c2c:	bf18      	it	ne
34003c2e:	b292      	uxthne	r2, r2
34003c30:	e7f0      	b.n	34003c14 <BSP_LCD_ReadPixel+0x24>
34003c32:	bf00      	nop
34003c34:	340cdd84 	.word	0x340cdd84
34003c38:	340cdda4 	.word	0x340cdda4

34003c3c <BSP_LCD_WritePixel>:
  * @param  Ypos Y position
  * @param  Color Pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_WritePixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Color)
{
34003c3c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34003c40:	2734      	movs	r7, #52	@ 0x34
34003c42:	4e24      	ldr	r6, [pc, #144]	@ (34003cd4 <BSP_LCD_WritePixel+0x98>)
34003c44:	ea4f 1c40 	mov.w	ip, r0, lsl #5
34003c48:	eb06 1040 	add.w	r0, r6, r0, lsl #5
34003c4c:	6884      	ldr	r4, [r0, #8]
34003c4e:	4d22      	ldr	r5, [pc, #136]	@ (34003cd8 <BSP_LCD_WritePixel+0x9c>)
34003c50:	fb07 5404 	mla	r4, r7, r4, r5
34003c54:	f8d4 8048 	ldr.w	r8, [r4, #72]	@ 0x48
  {
    /* Write data value to RAM memory */
    *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = Color;
34003c58:	f8d4 e05c 	ldr.w	lr, [r4, #92]	@ 0x5c
34003c5c:	f856 400c 	ldr.w	r4, [r6, ip]
34003c60:	fb04 1402 	mla	r4, r4, r2, r1
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34003c64:	f1b8 0f00 	cmp.w	r8, #0
34003c68:	d104      	bne.n	34003c74 <BSP_LCD_WritePixel+0x38>
    *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = Color;
34003c6a:	f84e 3024 	str.w	r3, [lr, r4, lsl #2]
    /* Write data value to RAM memory */
    *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = (uint16_t)Color;
  }

  return BSP_ERROR_NONE;
}
34003c6e:	2000      	movs	r0, #0
34003c70:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
34003c74:	f1b8 0f06 	cmp.w	r8, #6
34003c78:	d127      	bne.n	34003cca <BSP_LCD_WritePixel+0x8e>
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-3U)) = (uint8_t) (Color);
34003c7a:	fa5f f883 	uxtb.w	r8, r3
34003c7e:	eb04 0444 	add.w	r4, r4, r4, lsl #1
34003c82:	f1ae 0e03 	sub.w	lr, lr, #3
34003c86:	f804 800e 	strb.w	r8, [r4, lr]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-2U)) = (uint8_t) (Color>>8U);
34003c8a:	f856 400c 	ldr.w	r4, [r6, ip]
34003c8e:	f3c3 2807 	ubfx	r8, r3, #8, #8
34003c92:	fb04 1402 	mla	r4, r4, r2, r1
34003c96:	eb04 0944 	add.w	r9, r4, r4, lsl #1
34003c9a:	6884      	ldr	r4, [r0, #8]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-1U)) = (uint8_t) (Color>>16U);
34003c9c:	f3c3 4307 	ubfx	r3, r3, #16, #8
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-2U)) = (uint8_t) (Color>>8U);
34003ca0:	fb07 5e04 	mla	lr, r7, r4, r5
34003ca4:	f8de e05c 	ldr.w	lr, [lr, #92]	@ 0x5c
34003ca8:	f1ae 0e02 	sub.w	lr, lr, #2
34003cac:	f809 800e 	strb.w	r8, [r9, lr]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-1U)) = (uint8_t) (Color>>16U);
34003cb0:	f856 400c 	ldr.w	r4, [r6, ip]
34003cb4:	fb04 1202 	mla	r2, r4, r2, r1
34003cb8:	6881      	ldr	r1, [r0, #8]
34003cba:	eb02 0242 	add.w	r2, r2, r2, lsl #1
34003cbe:	fb07 5501 	mla	r5, r7, r1, r5
34003cc2:	6de9      	ldr	r1, [r5, #92]	@ 0x5c
34003cc4:	3901      	subs	r1, #1
34003cc6:	5453      	strb	r3, [r2, r1]
34003cc8:	e7d1      	b.n	34003c6e <BSP_LCD_WritePixel+0x32>
    *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = (uint16_t)Color;
34003cca:	b29b      	uxth	r3, r3
34003ccc:	f82e 3014 	strh.w	r3, [lr, r4, lsl #1]
34003cd0:	e7cd      	b.n	34003c6e <BSP_LCD_WritePixel+0x32>
34003cd2:	bf00      	nop
34003cd4:	340cdd84 	.word	0x340cdd84
34003cd8:	340cdda4 	.word	0x340cdda4

34003cdc <BSP_LCD_FillRGBRect>:
{
34003cdc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
34003ce0:	4680      	mov	r8, r0
34003ce2:	460e      	mov	r6, r1
34003ce4:	4614      	mov	r4, r2
34003ce6:	461d      	mov	r5, r3
  for(i = 0; i < Height; i++)
34003ce8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
34003cea:	eb03 0902 	add.w	r9, r3, r2
      pdata += Lcd_Ctx[Instance].BppFactor;
34003cee:	4b0d      	ldr	r3, [pc, #52]	@ (34003d24 <BSP_LCD_FillRGBRect+0x48>)
34003cf0:	eb03 1a40 	add.w	sl, r3, r0, lsl #5
  for(i = 0; i < Height; i++)
34003cf4:	454c      	cmp	r4, r9
34003cf6:	d012      	beq.n	34003d1e <BSP_LCD_FillRGBRect+0x42>
34003cf8:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34003cfa:	4637      	mov	r7, r6
34003cfc:	eb03 0b06 	add.w	fp, r3, r6
34003d00:	e009      	b.n	34003d16 <BSP_LCD_FillRGBRect+0x3a>
      (void)BSP_LCD_WritePixel(Instance, Xpos + j, Ypos + i, color);
34003d02:	682b      	ldr	r3, [r5, #0]
34003d04:	4639      	mov	r1, r7
34003d06:	4622      	mov	r2, r4
34003d08:	4640      	mov	r0, r8
34003d0a:	f7ff ff97 	bl	34003c3c <BSP_LCD_WritePixel>
      pdata += Lcd_Ctx[Instance].BppFactor;
34003d0e:	f8da 3010 	ldr.w	r3, [sl, #16]
34003d12:	3701      	adds	r7, #1
34003d14:	441d      	add	r5, r3
    for(j = 0; j < Width; j++)
34003d16:	455f      	cmp	r7, fp
34003d18:	d1f3      	bne.n	34003d02 <BSP_LCD_FillRGBRect+0x26>
  for(i = 0; i < Height; i++)
34003d1a:	3401      	adds	r4, #1
34003d1c:	e7ea      	b.n	34003cf4 <BSP_LCD_FillRGBRect+0x18>
}
34003d1e:	2000      	movs	r0, #0
34003d20:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
34003d24:	340cdd84 	.word	0x340cdd84

34003d28 <BSP_LCD_DrawBitmap>:
{
34003d28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
34003d2c:	2634      	movs	r6, #52	@ 0x34
  width = (uint32_t)pBmp[18] + ((uint32_t)pBmp[19] << 8) + ((uint32_t)pBmp[20] << 16)  + ((uint32_t)pBmp[21] << 24);
34003d2e:	f8d3 4012 	ldr.w	r4, [r3, #18]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
34003d32:	4f39      	ldr	r7, [pc, #228]	@ (34003e18 <BSP_LCD_DrawBitmap+0xf0>)
34003d34:	ea4f 1840 	mov.w	r8, r0, lsl #5
{
34003d38:	b085      	sub	sp, #20
  width = (uint32_t)pBmp[18] + ((uint32_t)pBmp[19] << 8) + ((uint32_t)pBmp[20] << 16)  + ((uint32_t)pBmp[21] << 24);
34003d3a:	9402      	str	r4, [sp, #8]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
34003d3c:	f857 4008 	ldr.w	r4, [r7, r8]
34003d40:	eb07 1040 	add.w	r0, r7, r0, lsl #5
34003d44:	fb04 1202 	mla	r2, r4, r2, r1
34003d48:	6904      	ldr	r4, [r0, #16]
34003d4a:	4934      	ldr	r1, [pc, #208]	@ (34003e1c <BSP_LCD_DrawBitmap+0xf4>)
34003d4c:	6880      	ldr	r0, [r0, #8]
  bit_pixel = (uint32_t)pBmp[28] + ((uint32_t)pBmp[29] << 8);
34003d4e:	8b9d      	ldrh	r5, [r3, #28]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
34003d50:	fb06 1100 	mla	r1, r6, r0, r1
34003d54:	6dce      	ldr	r6, [r1, #92]	@ 0x5c
  index = (uint32_t)pBmp[10] + ((uint32_t)pBmp[11] << 8) + ((uint32_t)pBmp[12] << 16)  + ((uint32_t)pBmp[13] << 24);
34003d56:	f8d3 c00a 	ldr.w	ip, [r3, #10]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
34003d5a:	fb04 6602 	mla	r6, r4, r2, r6
  if ((bit_pixel/8U) == 4U)
34003d5e:	f1a5 0220 	sub.w	r2, r5, #32
34003d62:	2a07      	cmp	r2, #7
  height = (uint32_t)pBmp[22] + ((uint32_t)pBmp[23] << 8) + ((uint32_t)pBmp[24] << 16)  + ((uint32_t)pBmp[25] << 24);
34003d64:	f8d3 a016 	ldr.w	sl, [r3, #22]
  if ((bit_pixel/8U) == 4U)
34003d68:	d91b      	bls.n	34003da2 <BSP_LCD_DrawBitmap+0x7a>
  else if ((bit_pixel/8U) == 2U)
34003d6a:	f1a5 0210 	sub.w	r2, r5, #16
    input_color_mode = DMA2D_INPUT_RGB565;
34003d6e:	2a07      	cmp	r2, #7
34003d70:	bf8c      	ite	hi
34003d72:	f04f 0b01 	movhi.w	fp, #1
34003d76:	f04f 0b02 	movls.w	fp, #2
  for(index=0; index < height; index++)
34003d7a:	f04f 0900 	mov.w	r9, #0
34003d7e:	9a02      	ldr	r2, [sp, #8]
  pbmp = pBmp + (index + (width * (height - 1U) * (bit_pixel/8U)));
34003d80:	08ed      	lsrs	r5, r5, #3
34003d82:	4355      	muls	r5, r2
34003d84:	f10a 32ff 	add.w	r2, sl, #4294967295
34003d88:	fb05 cc02 	mla	ip, r5, r2, ip
34003d8c:	eb03 040c 	add.w	r4, r3, ip
    pbmp -= width*(bit_pixel/8U);
34003d90:	426b      	negs	r3, r5
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
    break;
  }

  /* Configure the DMA2D Mode, Color Mode and output offset */
  hlcd_dma2d.Init.Mode         = DMA2D_M2M_PFC;
34003d92:	4d23      	ldr	r5, [pc, #140]	@ (34003e20 <BSP_LCD_DrawBitmap+0xf8>)
    pbmp -= width*(bit_pixel/8U);
34003d94:	9303      	str	r3, [sp, #12]
  for(index=0; index < height; index++)
34003d96:	45d1      	cmp	r9, sl
34003d98:	d106      	bne.n	34003da8 <BSP_LCD_DrawBitmap+0x80>
}
34003d9a:	2000      	movs	r0, #0
34003d9c:	b005      	add	sp, #20
34003d9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    input_color_mode = DMA2D_INPUT_ARGB8888;
34003da2:	f04f 0b00 	mov.w	fp, #0
34003da6:	e7e8      	b.n	34003d7a <BSP_LCD_DrawBitmap+0x52>
  switch(Lcd_Ctx[Instance].PixelFormat)
34003da8:	eb07 0308 	add.w	r3, r7, r8
34003dac:	68db      	ldr	r3, [r3, #12]
  hlcd_dma2d.LayerCfg[1].InputOffset = 0;

  hlcd_dma2d.Instance = DMA2D;

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
34003dae:	481c      	ldr	r0, [pc, #112]	@ (34003e20 <BSP_LCD_DrawBitmap+0xf8>)
34003db0:	3b01      	subs	r3, #1
34003db2:	2b03      	cmp	r3, #3
34003db4:	bf96      	itet	ls
34003db6:	4a1b      	ldrls	r2, [pc, #108]	@ (34003e24 <BSP_LCD_DrawBitmap+0xfc>)
  switch(Lcd_Ctx[Instance].PixelFormat)
34003db8:	2300      	movhi	r3, #0
34003dba:	5cd3      	ldrbls	r3, [r2, r3]
  hlcd_dma2d.Init.Mode         = DMA2D_M2M_PFC;
34003dbc:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
34003dc0:	e9c5 2301 	strd	r2, r3, [r5, #4]
  hlcd_dma2d.Init.OutputOffset = 0;
34003dc4:	2300      	movs	r3, #0
  hlcd_dma2d.LayerCfg[1].InputAlpha = 0xFF;
34003dc6:	22ff      	movs	r2, #255	@ 0xff
  hlcd_dma2d.LayerCfg[1].InputOffset = 0;
34003dc8:	e9c5 3b11 	strd	r3, fp, [r5, #68]	@ 0x44
  hlcd_dma2d.Init.OutputOffset = 0;
34003dcc:	60eb      	str	r3, [r5, #12]
  hlcd_dma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
34003dce:	64eb      	str	r3, [r5, #76]	@ 0x4c
  hlcd_dma2d.Instance = DMA2D;
34003dd0:	4b15      	ldr	r3, [pc, #84]	@ (34003e28 <BSP_LCD_DrawBitmap+0x100>)
  hlcd_dma2d.LayerCfg[1].InputAlpha = 0xFF;
34003dd2:	652a      	str	r2, [r5, #80]	@ 0x50
  hlcd_dma2d.Instance = DMA2D;
34003dd4:	602b      	str	r3, [r5, #0]
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
34003dd6:	f003 fd77 	bl	340078c8 <HAL_DMA2D_Init>
34003dda:	b988      	cbnz	r0, 34003e00 <BSP_LCD_DrawBitmap+0xd8>
  {
    if(HAL_DMA2D_ConfigLayer(&hlcd_dma2d, 1) == HAL_OK)
34003ddc:	2101      	movs	r1, #1
34003dde:	4628      	mov	r0, r5
34003de0:	f003 feae 	bl	34007b40 <HAL_DMA2D_ConfigLayer>
34003de4:	b960      	cbnz	r0, 34003e00 <BSP_LCD_DrawBitmap+0xd8>
    {
      if (HAL_DMA2D_Start(&hlcd_dma2d, (uint32_t)pSrc, (uint32_t)pDst, xSize, 1) == HAL_OK)
34003de6:	2301      	movs	r3, #1
34003de8:	4632      	mov	r2, r6
34003dea:	9300      	str	r3, [sp, #0]
34003dec:	4621      	mov	r1, r4
34003dee:	9b02      	ldr	r3, [sp, #8]
34003df0:	480b      	ldr	r0, [pc, #44]	@ (34003e20 <BSP_LCD_DrawBitmap+0xf8>)
34003df2:	f003 fdf1 	bl	340079d8 <HAL_DMA2D_Start>
34003df6:	b918      	cbnz	r0, 34003e00 <BSP_LCD_DrawBitmap+0xd8>
      {
        /* Polling For DMA transfer */
        (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
34003df8:	2132      	movs	r1, #50	@ 0x32
34003dfa:	4809      	ldr	r0, [pc, #36]	@ (34003e20 <BSP_LCD_DrawBitmap+0xf8>)
34003dfc:	f003 fe22 	bl	34007a44 <HAL_DMA2D_PollForTransfer>
    Address+=  (Lcd_Ctx[Instance].XSize * Lcd_Ctx[Instance].BppFactor);
34003e00:	eb07 0308 	add.w	r3, r7, r8
34003e04:	691b      	ldr	r3, [r3, #16]
34003e06:	f857 2008 	ldr.w	r2, [r7, r8]
  for(index=0; index < height; index++)
34003e0a:	f109 0901 	add.w	r9, r9, #1
    Address+=  (Lcd_Ctx[Instance].XSize * Lcd_Ctx[Instance].BppFactor);
34003e0e:	fb03 6602 	mla	r6, r3, r2, r6
    pbmp -= width*(bit_pixel/8U);
34003e12:	9b03      	ldr	r3, [sp, #12]
34003e14:	441c      	add	r4, r3
  for(index=0; index < height; index++)
34003e16:	e7be      	b.n	34003d96 <BSP_LCD_DrawBitmap+0x6e>
34003e18:	340cdd84 	.word	0x340cdd84
34003e1c:	340cdda4 	.word	0x340cdda4
34003e20:	340cde4c 	.word	0x340cde4c
34003e24:	340a6d80 	.word	0x340a6d80
34003e28:	58021000 	.word	0x58021000

34003e2c <LL_FillBuffer>:
{
34003e2c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
34003e30:	461f      	mov	r7, r3
  switch(Lcd_Ctx[Instance].PixelFormat)
34003e32:	4b34      	ldr	r3, [pc, #208]	@ (34003f04 <LL_FillBuffer+0xd8>)
{
34003e34:	4616      	mov	r6, r2
  switch(Lcd_Ctx[Instance].PixelFormat)
34003e36:	eb03 1340 	add.w	r3, r3, r0, lsl #5
34003e3a:	68da      	ldr	r2, [r3, #12]
{
34003e3c:	460d      	mov	r5, r1
34003e3e:	e9dd 1408 	ldrd	r1, r4, [sp, #32]
  switch(Lcd_Ctx[Instance].PixelFormat)
34003e42:	2a02      	cmp	r2, #2
34003e44:	d023      	beq.n	34003e8e <LL_FillBuffer+0x62>
34003e46:	2a04      	cmp	r2, #4
34003e48:	d03e      	beq.n	34003ec8 <LL_FillBuffer+0x9c>
34003e4a:	2a01      	cmp	r2, #1
34003e4c:	d054      	beq.n	34003ef8 <LL_FillBuffer+0xcc>
34003e4e:	2200      	movs	r2, #0
  hlcd_dma2d.Init.Mode         = DMA2D_R2M;
34003e50:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
34003e54:	f8df 80b4 	ldr.w	r8, [pc, #180]	@ 34003f0c <LL_FillBuffer+0xe0>
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
34003e58:	e9c8 3201 	strd	r3, r2, [r8, #4]
  hlcd_dma2d.Instance = DMA2D;
34003e5c:	4b2a      	ldr	r3, [pc, #168]	@ (34003f08 <LL_FillBuffer+0xdc>)
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
34003e5e:	4640      	mov	r0, r8
  hlcd_dma2d.Init.OutputOffset = OffLine;
34003e60:	f8c8 100c 	str.w	r1, [r8, #12]
  hlcd_dma2d.Instance = DMA2D;
34003e64:	f8c8 3000 	str.w	r3, [r8]
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
34003e68:	f003 fd2e 	bl	340078c8 <HAL_DMA2D_Init>
34003e6c:	2800      	cmp	r0, #0
34003e6e:	d146      	bne.n	34003efe <LL_FillBuffer+0xd2>
    if (HAL_DMA2D_Start(&hlcd_dma2d, input_color, (uint32_t)pDst, xSize, ySize) == HAL_OK)
34003e70:	4633      	mov	r3, r6
34003e72:	462a      	mov	r2, r5
34003e74:	4621      	mov	r1, r4
34003e76:	4640      	mov	r0, r8
34003e78:	9700      	str	r7, [sp, #0]
34003e7a:	f003 fdad 	bl	340079d8 <HAL_DMA2D_Start>
34003e7e:	bbf0      	cbnz	r0, 34003efe <LL_FillBuffer+0xd2>
      (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
34003e80:	2132      	movs	r1, #50	@ 0x32
34003e82:	4640      	mov	r0, r8
}
34003e84:	b002      	add	sp, #8
34003e86:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
34003e8a:	f003 bddb 	b.w	34007a44 <HAL_DMA2D_PollForTransfer>
    input_color = CONVERTRGB5652ARGB8888(Color);
34003e8e:	f240 1e03 	movw	lr, #259	@ 0x103
34003e92:	f240 2c0f 	movw	ip, #527	@ 0x20f
34003e96:	f3c4 1045 	ubfx	r0, r4, #5, #6
34003e9a:	f3c4 23c4 	ubfx	r3, r4, #11, #5
34003e9e:	fb0e f000 	mul.w	r0, lr, r0
34003ea2:	fb0c f303 	mul.w	r3, ip, r3
34003ea6:	f004 041f 	and.w	r4, r4, #31
34003eaa:	fb0c f404 	mul.w	r4, ip, r4
34003eae:	3021      	adds	r0, #33	@ 0x21
34003eb0:	3317      	adds	r3, #23
34003eb2:	0980      	lsrs	r0, r0, #6
34003eb4:	099b      	lsrs	r3, r3, #6
34003eb6:	0200      	lsls	r0, r0, #8
34003eb8:	3417      	adds	r4, #23
34003eba:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
34003ebe:	ea40 1094 	orr.w	r0, r0, r4, lsr #6
34003ec2:	f040 447f 	orr.w	r4, r0, #4278190080	@ 0xff000000
    break;
34003ec6:	e7c3      	b.n	34003e50 <LL_FillBuffer+0x24>
    input_color = CONVERTARGB44442ARGB8888(Color);
34003ec8:	f3c4 3303 	ubfx	r3, r4, #12, #4
34003ecc:	eb03 1003 	add.w	r0, r3, r3, lsl #4
34003ed0:	f3c4 2303 	ubfx	r3, r4, #8, #4
34003ed4:	eb03 1303 	add.w	r3, r3, r3, lsl #4
34003ed8:	041b      	lsls	r3, r3, #16
34003eda:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
34003ede:	f004 000f 	and.w	r0, r4, #15
34003ee2:	eb00 1000 	add.w	r0, r0, r0, lsl #4
34003ee6:	4303      	orrs	r3, r0
34003ee8:	f3c4 1003 	ubfx	r0, r4, #4, #4
34003eec:	f004 04f0 	and.w	r4, r4, #240	@ 0xf0
34003ef0:	4404      	add	r4, r0
34003ef2:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
    break;
34003ef6:	e7ab      	b.n	34003e50 <LL_FillBuffer+0x24>
    input_color = CONVERTRGB8882ARGB8888(Color);
34003ef8:	f044 447f 	orr.w	r4, r4, #4278190080	@ 0xff000000
    break;
34003efc:	e7a8      	b.n	34003e50 <LL_FillBuffer+0x24>
}
34003efe:	b002      	add	sp, #8
34003f00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34003f04:	340cdd84 	.word	0x340cdd84
34003f08:	58021000 	.word	0x58021000
34003f0c:	340cde4c 	.word	0x340cde4c

34003f10 <BSP_LCD_DrawHLine>:
{
34003f10:	b573      	push	{r0, r1, r4, r5, r6, lr}
34003f12:	4615      	mov	r5, r2
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003f14:	4c0d      	ldr	r4, [pc, #52]	@ (34003f4c <BSP_LCD_DrawHLine+0x3c>)
34003f16:	0146      	lsls	r6, r0, #5
{
34003f18:	461a      	mov	r2, r3
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003f1a:	eb04 1340 	add.w	r3, r4, r0, lsl #5
34003f1e:	59a4      	ldr	r4, [r4, r6]
34003f20:	691e      	ldr	r6, [r3, #16]
34003f22:	fb04 1105 	mla	r1, r4, r5, r1
34003f26:	2534      	movs	r5, #52	@ 0x34
34003f28:	689c      	ldr	r4, [r3, #8]
34003f2a:	4b09      	ldr	r3, [pc, #36]	@ (34003f50 <BSP_LCD_DrawHLine+0x40>)
34003f2c:	fb05 3304 	mla	r3, r5, r4, r3
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Length, 1, 0, Color);
34003f30:	2400      	movs	r4, #0
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003f32:	6ddd      	ldr	r5, [r3, #92]	@ 0x5c
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Length, 1, 0, Color);
34003f34:	9b06      	ldr	r3, [sp, #24]
34003f36:	fb06 5101 	mla	r1, r6, r1, r5
34003f3a:	9301      	str	r3, [sp, #4]
34003f3c:	9400      	str	r4, [sp, #0]
34003f3e:	2301      	movs	r3, #1
34003f40:	f7ff ff74 	bl	34003e2c <LL_FillBuffer>
}
34003f44:	4620      	mov	r0, r4
34003f46:	b002      	add	sp, #8
34003f48:	bd70      	pop	{r4, r5, r6, pc}
34003f4a:	bf00      	nop
34003f4c:	340cdd84 	.word	0x340cdd84
34003f50:	340cdda4 	.word	0x340cdda4

34003f54 <BSP_LCD_DrawVLine>:
{
34003f54:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003f56:	2734      	movs	r7, #52	@ 0x34
34003f58:	4d0c      	ldr	r5, [pc, #48]	@ (34003f8c <BSP_LCD_DrawVLine+0x38>)
34003f5a:	0146      	lsls	r6, r0, #5
34003f5c:	eb05 1440 	add.w	r4, r5, r0, lsl #5
34003f60:	59ad      	ldr	r5, [r5, r6]
34003f62:	6926      	ldr	r6, [r4, #16]
34003f64:	fb02 1105 	mla	r1, r2, r5, r1
34003f68:	68a4      	ldr	r4, [r4, #8]
34003f6a:	4a09      	ldr	r2, [pc, #36]	@ (34003f90 <BSP_LCD_DrawVLine+0x3c>)
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, 1, Length, (Lcd_Ctx[Instance].XSize - 1U), Color);
34003f6c:	3d01      	subs	r5, #1
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003f6e:	fb07 2204 	mla	r2, r7, r4, r2
34003f72:	6dd4      	ldr	r4, [r2, #92]	@ 0x5c
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, 1, Length, (Lcd_Ctx[Instance].XSize - 1U), Color);
34003f74:	9a08      	ldr	r2, [sp, #32]
34003f76:	fb06 4101 	mla	r1, r6, r1, r4
34003f7a:	9201      	str	r2, [sp, #4]
34003f7c:	9500      	str	r5, [sp, #0]
34003f7e:	2201      	movs	r2, #1
34003f80:	f7ff ff54 	bl	34003e2c <LL_FillBuffer>
}
34003f84:	2000      	movs	r0, #0
34003f86:	b003      	add	sp, #12
34003f88:	bdf0      	pop	{r4, r5, r6, r7, pc}
34003f8a:	bf00      	nop
34003f8c:	340cdd84 	.word	0x340cdd84
34003f90:	340cdda4 	.word	0x340cdda4

34003f94 <BSP_LCD_FillRect>:
{
34003f94:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34003f96:	4615      	mov	r5, r2
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003f98:	2734      	movs	r7, #52	@ 0x34
{
34003f9a:	461a      	mov	r2, r3
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003f9c:	4b0c      	ldr	r3, [pc, #48]	@ (34003fd0 <BSP_LCD_FillRect+0x3c>)
34003f9e:	0146      	lsls	r6, r0, #5
34003fa0:	eb03 1440 	add.w	r4, r3, r0, lsl #5
34003fa4:	599b      	ldr	r3, [r3, r6]
34003fa6:	6926      	ldr	r6, [r4, #16]
34003fa8:	fb05 1503 	mla	r5, r5, r3, r1
34003fac:	68a1      	ldr	r1, [r4, #8]
34003fae:	4c09      	ldr	r4, [pc, #36]	@ (34003fd4 <BSP_LCD_FillRect+0x40>)
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Width, Height, (Lcd_Ctx[Instance].XSize - Width), Color);
34003fb0:	1a9b      	subs	r3, r3, r2
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003fb2:	fb07 4401 	mla	r4, r7, r1, r4
34003fb6:	6de1      	ldr	r1, [r4, #92]	@ 0x5c
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Width, Height, (Lcd_Ctx[Instance].XSize - Width), Color);
34003fb8:	9c09      	ldr	r4, [sp, #36]	@ 0x24
34003fba:	9300      	str	r3, [sp, #0]
34003fbc:	fb06 1105 	mla	r1, r6, r5, r1
34003fc0:	9b08      	ldr	r3, [sp, #32]
34003fc2:	9401      	str	r4, [sp, #4]
34003fc4:	f7ff ff32 	bl	34003e2c <LL_FillBuffer>
}
34003fc8:	2000      	movs	r0, #0
34003fca:	b003      	add	sp, #12
34003fcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
34003fce:	bf00      	nop
34003fd0:	340cdd84 	.word	0x340cdd84
34003fd4:	340cdda4 	.word	0x340cdda4

34003fd8 <MX_LTDC_Init>:
{
34003fd8:	b4f0      	push	{r4, r5, r6, r7}
  hltdc->Init.HSPolarity = LTDC_HSPOLARITY_AL;
34003fda:	2400      	movs	r4, #0
34003fdc:	4d0c      	ldr	r5, [pc, #48]	@ (34004010 <MX_LTDC_Init+0x38>)
  hltdc->Init.HorizontalSync     = (uint32_t)RK050HR18_HSYNC - 1U;
34003fde:	2603      	movs	r6, #3
  hltdc->Init.HSPolarity = LTDC_HSPOLARITY_AL;
34003fe0:	e9c0 5400 	strd	r5, r4, [r0]
  hltdc->Init.AccumulatedHBP     = (uint32_t)RK050HR18_HSYNC + (uint32_t)RK050HR18_HBP - 1U;
34003fe4:	2507      	movs	r5, #7
  hltdc->Init.AccumulatedActiveW = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP -1U;
34003fe6:	194f      	adds	r7, r1, r5
  hltdc->Init.TotalWidth         = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP + RK050HR18_HFP - 1U;
34003fe8:	310b      	adds	r1, #11
34003fea:	62c1      	str	r1, [r0, #44]	@ 0x2c
  hltdc->Init.Backcolor.Blue  = 0x0;
34003fec:	8684      	strh	r4, [r0, #52]	@ 0x34
  hltdc->Init.AccumulatedActiveH = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP -1U;
34003fee:	1951      	adds	r1, r2, r5
  hltdc->Init.Backcolor.Red   = 0x0;
34003ff0:	f880 4036 	strb.w	r4, [r0, #54]	@ 0x36
  hltdc->Init.TotalHeigh         = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP + RK050HR18_VFP - 1U;
34003ff4:	320b      	adds	r2, #11
  hltdc->Init.DEPolarity = LTDC_DEPOLARITY_AL;
34003ff6:	e9c0 4402 	strd	r4, r4, [r0, #8]
  hltdc->Init.PCPolarity = LTDC_PCPOLARITY_IPC;
34003ffa:	6104      	str	r4, [r0, #16]
  hltdc->Init.HorizontalSync     = (uint32_t)RK050HR18_HSYNC - 1U;
34003ffc:	6146      	str	r6, [r0, #20]
  hltdc->Init.AccumulatedHBP     = (uint32_t)RK050HR18_HSYNC + (uint32_t)RK050HR18_HBP - 1U;
34003ffe:	61c5      	str	r5, [r0, #28]
  hltdc->Init.AccumulatedActiveW = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP -1U;
34004000:	6247      	str	r7, [r0, #36]	@ 0x24
  hltdc->Init.VerticalSync       = (uint32_t)RK050HR18_VSYNC - 1U;
34004002:	6186      	str	r6, [r0, #24]
  hltdc->Init.AccumulatedVBP     = (uint32_t)RK050HR18_VSYNC + (uint32_t)RK050HR18_VBP - 1U;
34004004:	6205      	str	r5, [r0, #32]
  hltdc->Init.AccumulatedActiveH = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP -1U;
34004006:	6281      	str	r1, [r0, #40]	@ 0x28
  hltdc->Init.TotalHeigh         = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP + RK050HR18_VFP - 1U;
34004008:	6302      	str	r2, [r0, #48]	@ 0x30
}
3400400a:	bcf0      	pop	{r4, r5, r6, r7}
  return HAL_LTDC_Init(hltdc);
3400400c:	f005 b938 	b.w	34009280 <HAL_LTDC_Init>
34004010:	58001000 	.word	0x58001000

34004014 <MX_LTDC_ConfigLayer>:
{
34004014:	b5f0      	push	{r4, r5, r6, r7, lr}
34004016:	4614      	mov	r4, r2
  LTDC_LayerCfgTypeDef pLayerCfg ={0};
34004018:	221c      	movs	r2, #28
{
3400401a:	b08f      	sub	sp, #60	@ 0x3c
3400401c:	4606      	mov	r6, r0
3400401e:	460f      	mov	r7, r1
  LTDC_LayerCfgTypeDef pLayerCfg ={0};
34004020:	eb0d 0002 	add.w	r0, sp, r2
34004024:	2100      	movs	r1, #0
34004026:	f016 f87d 	bl	3401a124 <memset>
  pLayerCfg.PixelFormat = Config->PixelFormat;
3400402a:	6920      	ldr	r0, [r4, #16]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
3400402c:	f44f 6ec0 	mov.w	lr, #1536	@ 0x600
  pLayerCfg.PixelFormat = Config->PixelFormat;
34004030:	9005      	str	r0, [sp, #20]
  pLayerCfg.Alpha = LTDC_LxCACR_CONSTA;
34004032:	20ff      	movs	r0, #255	@ 0xff
34004034:	9006      	str	r0, [sp, #24]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
34004036:	2007      	movs	r0, #7
  pLayerCfg.WindowX0 = Config->X0;
34004038:	6821      	ldr	r1, [r4, #0]
  pLayerCfg.WindowY0 = Config->Y0;
3400403a:	68a2      	ldr	r2, [r4, #8]
  pLayerCfg.WindowX1 = Config->X1;
3400403c:	6865      	ldr	r5, [r4, #4]
  pLayerCfg.WindowY1 = Config->Y1;
3400403e:	68e3      	ldr	r3, [r4, #12]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
34004040:	e9cd e008 	strd	lr, r0, [sp, #32]
  pLayerCfg.FBStartAdress = Config->Address;
34004044:	6960      	ldr	r0, [r4, #20]
  pLayerCfg.WindowX0 = Config->X0;
34004046:	9101      	str	r1, [sp, #4]
  pLayerCfg.WindowX1 = Config->X1;
34004048:	9502      	str	r5, [sp, #8]
  pLayerCfg.WindowY0 = Config->Y0;
3400404a:	9203      	str	r2, [sp, #12]
  pLayerCfg.WindowY1 = Config->Y1;
3400404c:	9304      	str	r3, [sp, #16]
  pLayerCfg.FBStartAdress = Config->Address;
3400404e:	900a      	str	r0, [sp, #40]	@ 0x28
  pLayerCfg.ImageHeight = (Config->Y1 - Config->Y0);
34004050:	1a9b      	subs	r3, r3, r2
  pLayerCfg.ImageWidth = (Config->X1 - Config->X0);
34004052:	1a6d      	subs	r5, r5, r1
  return HAL_LTDC_ConfigLayer(hltdc, &pLayerCfg, LayerIndex);
34004054:	463a      	mov	r2, r7
34004056:	4630      	mov	r0, r6
34004058:	a901      	add	r1, sp, #4
  pLayerCfg.ImageWidth = (Config->X1 - Config->X0);
3400405a:	950b      	str	r5, [sp, #44]	@ 0x2c
  pLayerCfg.ImageHeight = (Config->Y1 - Config->Y0);
3400405c:	930c      	str	r3, [sp, #48]	@ 0x30
  return HAL_LTDC_ConfigLayer(hltdc, &pLayerCfg, LayerIndex);
3400405e:	f005 f9e1 	bl	34009424 <HAL_LTDC_ConfigLayer>
}
34004062:	b00f      	add	sp, #60	@ 0x3c
34004064:	bdf0      	pop	{r4, r5, r6, r7, pc}

34004066 <MX_LTDC_ClockConfig>:
{
34004066:	b500      	push	{lr}
34004068:	b0e5      	sub	sp, #404	@ 0x194
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
3400406a:	f44f 72c8 	mov.w	r2, #400	@ 0x190
3400406e:	2100      	movs	r1, #0
34004070:	4668      	mov	r0, sp
34004072:	f016 f857 	bl	3401a124 <memset>
  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
34004076:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3400407a:	2300      	movs	r3, #0
3400407c:	e9cd 2300 	strd	r2, r3, [sp]
  RCC_PeriphCLKInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
34004080:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
34004084:	f04f 5140 	mov.w	r1, #805306368	@ 0x30000000
  RCC_PeriphCLKInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
34004088:	9346      	str	r3, [sp, #280]	@ 0x118
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
3400408a:	2302      	movs	r3, #2
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
3400408c:	4668      	mov	r0, sp
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
3400408e:	e9cd 1320 	strd	r1, r3, [sp, #128]	@ 0x80
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34004092:	f006 fd01 	bl	3400aa98 <HAL_RCCEx_PeriphCLKConfig>
}
34004096:	3800      	subs	r0, #0
34004098:	bf18      	it	ne
3400409a:	2001      	movne	r0, #1
3400409c:	b065      	add	sp, #404	@ 0x194
3400409e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

340040a4 <BSP_LCD_InitEx>:
{
340040a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340040a8:	4614      	mov	r4, r2
  MX_LTDC_LayerConfig_t config = {0};
340040aa:	2218      	movs	r2, #24
{
340040ac:	460e      	mov	r6, r1
340040ae:	b08d      	sub	sp, #52	@ 0x34
340040b0:	4605      	mov	r5, r0
  MX_LTDC_LayerConfig_t config = {0};
340040b2:	2100      	movs	r1, #0
340040b4:	eb0d 0002 	add.w	r0, sp, r2
{
340040b8:	4699      	mov	r9, r3
  MX_LTDC_LayerConfig_t config = {0};
340040ba:	f016 f833 	bl	3401a124 <memset>
  if ((Orientation > LCD_ORIENTATION_LANDSCAPE) || (Instance >= LCD_INSTANCES_NBR) || \
340040be:	2e01      	cmp	r6, #1
340040c0:	f200 80da 	bhi.w	34004278 <BSP_LCD_InitEx+0x1d4>
340040c4:	2d00      	cmp	r5, #0
340040c6:	f040 80d7 	bne.w	34004278 <BSP_LCD_InitEx+0x1d4>
340040ca:	2c02      	cmp	r4, #2
340040cc:	f240 80ad 	bls.w	3400422a <BSP_LCD_InitEx+0x186>
      (PixelFormat != LCD_PIXEL_FORMAT_ARGB8888) &&  (PixelFormat != LCD_PIXEL_FORMAT_ARGB4444)))
340040d0:	2c04      	cmp	r4, #4
340040d2:	f040 80d1 	bne.w	34004278 <BSP_LCD_InitEx+0x1d4>
340040d6:	2302      	movs	r3, #2
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB4444;
340040d8:	2508      	movs	r5, #8
      Lcd_Ctx[Instance].BppFactor = 2U;
340040da:	f8df 81d4 	ldr.w	r8, [pc, #468]	@ 340042b0 <BSP_LCD_InitEx+0x20c>
    hlcd_ltdc.Instance = LTDC;
340040de:	4a68      	ldr	r2, [pc, #416]	@ (34004280 <BSP_LCD_InitEx+0x1dc>)
    Lcd_Ctx[Instance].PixelFormat = PixelFormat;
340040e0:	e9c8 4303 	strd	r4, r3, [r8, #12]
  WRITE_REG(RCC->APB5ENSR, Periphs);
340040e4:	2402      	movs	r4, #2
    Lcd_Ctx[Instance].YSize  = Height;
340040e6:	9b16      	ldr	r3, [sp, #88]	@ 0x58
340040e8:	4e66      	ldr	r6, [pc, #408]	@ (34004284 <BSP_LCD_InitEx+0x1e0>)
340040ea:	f8c8 3004 	str.w	r3, [r8, #4]
    hlcd_ltdc.Instance = LTDC;
340040ee:	4b66      	ldr	r3, [pc, #408]	@ (34004288 <BSP_LCD_InitEx+0x1e4>)
    hlcd_dma2d.Instance = DMA2D;
340040f0:	f8df b1c0 	ldr.w	fp, [pc, #448]	@ 340042b4 <BSP_LCD_InitEx+0x210>
    hlcd_ltdc.Instance = LTDC;
340040f4:	601a      	str	r2, [r3, #0]
    hlcd_dma2d.Instance = DMA2D;
340040f6:	4b65      	ldr	r3, [pc, #404]	@ (3400428c <BSP_LCD_InitEx+0x1e8>)
    Lcd_Ctx[Instance].XSize  = Width;
340040f8:	f8c8 9000 	str.w	r9, [r8]
    hlcd_dma2d.Instance = DMA2D;
340040fc:	f8cb 3000 	str.w	r3, [fp]
34004100:	f8c6 4a7c 	str.w	r4, [r6, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
34004104:	f8d6 327c 	ldr.w	r3, [r6, #636]	@ 0x27c
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34004108:	f8df a1ac 	ldr.w	sl, [pc, #428]	@ 340042b8 <BSP_LCD_InitEx+0x214>
  tmpreg = READ_REG(RCC->APB5ENR);
3400410c:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
3400410e:	9b00      	ldr	r3, [sp, #0]
    /* PB13 LCD_CLK     */
    /* PQ4  LCD_INT     */
    /* PQ6  LCD_BL_CTRL */
    /* PE1  NRST        */

    __HAL_RCC_GPIOA_CLK_ENABLE();
34004110:	2001      	movs	r0, #1
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34004112:	f8c6 4a3c 	str.w	r4, [r6, #2620]	@ 0xa3c
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34004116:	f8ca 423c 	str.w	r4, [sl, #572]	@ 0x23c
3400411a:	f7ff fd13 	bl	34003b44 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
3400411e:	4620      	mov	r0, r4
34004120:	f7ff fd10 	bl	34003b44 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOD_CLK_ENABLE();
34004124:	2008      	movs	r0, #8
34004126:	f7ff fd0d 	bl	34003b44 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOE_CLK_ENABLE();
3400412a:	2010      	movs	r0, #16
3400412c:	f7ff fd0a 	bl	34003b44 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOG_CLK_ENABLE();
34004130:	2040      	movs	r0, #64	@ 0x40
34004132:	f7ff fd07 	bl	34003b44 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
34004136:	2080      	movs	r0, #128	@ 0x80
34004138:	f7ff fd04 	bl	34003b44 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOQ_CLK_ENABLE();
3400413c:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
34004140:	f7ff fd00 	bl	34003b44 <LL_AHB4_GRP1_EnableClock>

    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
    gpio_init_structure.Pull      = GPIO_NOPULL;
34004144:	2300      	movs	r3, #0
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;

    /* G3, G2, B7, B1, B6, R5 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34004146:	270e      	movs	r7, #14
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34004148:	e9cd 3403 	strd	r3, r4, [sp, #12]
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
3400414c:	f248 1387 	movw	r3, #33159	@ 0x8187
    HAL_GPIO_Init(GPIOA, &gpio_init_structure);
34004150:	484f      	ldr	r0, [pc, #316]	@ (34004290 <BSP_LCD_InitEx+0x1ec>)
34004152:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
34004154:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34004156:	9705      	str	r7, [sp, #20]
    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
34004158:	9402      	str	r4, [sp, #8]
    HAL_GPIO_Init(GPIOA, &gpio_init_structure);
3400415a:	f003 fda1 	bl	34007ca0 <HAL_GPIO_Init>

    /* LCD_CLK, LCD_HSYNC B2, R3, G6, G5, G4 */
    gpio_init_structure.Pin       = GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_15;
3400415e:	f64f 0314 	movw	r3, #63508	@ 0xf814
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOB, &gpio_init_structure);
34004162:	484c      	ldr	r0, [pc, #304]	@ (34004294 <BSP_LCD_InitEx+0x1f0>)
34004164:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_15;
34004166:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34004168:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOB, &gpio_init_structure);
3400416a:	f003 fd99 	bl	34007ca0 <HAL_GPIO_Init>

    /* R7, R1, R2 */
    gpio_init_structure.Pin       = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_15;
3400416e:	f44f 4303 	mov.w	r3, #33536	@ 0x8300
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOD, &gpio_init_structure);
34004172:	4849      	ldr	r0, [pc, #292]	@ (34004298 <BSP_LCD_InitEx+0x1f4>)
34004174:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_15;
34004176:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34004178:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOD, &gpio_init_structure);
3400417a:	f003 fd91 	bl	34007ca0 <HAL_GPIO_Init>

    /* LCD_VSYNC */
    gpio_init_structure.Pin       = GPIO_PIN_11;
3400417e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34004182:	4846      	ldr	r0, [pc, #280]	@ (3400429c <BSP_LCD_InitEx+0x1f8>)
34004184:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_11;
34004186:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34004188:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
3400418a:	f003 fd89 	bl	34007ca0 <HAL_GPIO_Init>

    /* R0, G1, B3, G7, R6, G0 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_6 | GPIO_PIN_8 | GPIO_PIN_11 | GPIO_PIN_12 ;
3400418e:	f641 1343 	movw	r3, #6467	@ 0x1943
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34004192:	4843      	ldr	r0, [pc, #268]	@ (340042a0 <BSP_LCD_InitEx+0x1fc>)
34004194:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_6 | GPIO_PIN_8 | GPIO_PIN_11 | GPIO_PIN_12 ;
34004196:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34004198:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
3400419a:	f003 fd81 	bl	34007ca0 <HAL_GPIO_Init>

    /* B4, R4, B5 */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6;
3400419e:	2358      	movs	r3, #88	@ 0x58
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
340041a0:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);

    /* NRST */
    gpio_init_structure.Pin       = GPIO_PIN_1;
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
340041a2:	2701      	movs	r7, #1
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);
340041a4:	483f      	ldr	r0, [pc, #252]	@ (340042a4 <BSP_LCD_InitEx+0x200>)
340041a6:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6;
340041a8:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);
340041aa:	f003 fd79 	bl	34007ca0 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
340041ae:	483b      	ldr	r0, [pc, #236]	@ (3400429c <BSP_LCD_InitEx+0x1f8>)
340041b0:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_1;
340041b2:	9401      	str	r4, [sp, #4]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
340041b4:	9702      	str	r7, [sp, #8]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
340041b6:	f003 fd73 	bl	34007ca0 <HAL_GPIO_Init>

    /* LCD_ONOFF, LCD_BL_CTRL */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_6;
340041ba:	2348      	movs	r3, #72	@ 0x48
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
    HAL_GPIO_Init(GPIOQ, &gpio_init_structure);
340041bc:	483a      	ldr	r0, [pc, #232]	@ (340042a8 <BSP_LCD_InitEx+0x204>)
340041be:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
340041c0:	e9cd 3701 	strd	r3, r7, [sp, #4]
    HAL_GPIO_Init(GPIOQ, &gpio_init_structure);
340041c4:	f003 fd6c 	bl	34007ca0 <HAL_GPIO_Init>

    /* LCD_DE */
    gpio_init_structure.Pin       = GPIO_PIN_13;
340041c8:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
340041cc:	4834      	ldr	r0, [pc, #208]	@ (340042a0 <BSP_LCD_InitEx+0x1fc>)
340041ce:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
340041d0:	e9cd 3701 	strd	r3, r7, [sp, #4]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
340041d4:	f003 fd64 	bl	34007ca0 <HAL_GPIO_Init>

    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_3, GPIO_PIN_SET); /* LCD On */ /* PQ3  LCD_ONOFF   */
340041d8:	463a      	mov	r2, r7
340041da:	2108      	movs	r1, #8
340041dc:	4832      	ldr	r0, [pc, #200]	@ (340042a8 <BSP_LCD_InitEx+0x204>)
340041de:	f004 f8a5 	bl	3400832c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13, GPIO_PIN_SET); /* Display Enable */ /* PG13 LCD_DE      */
340041e2:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
340041e6:	463a      	mov	r2, r7
340041e8:	4619      	mov	r1, r3
340041ea:	482d      	ldr	r0, [pc, #180]	@ (340042a0 <BSP_LCD_InitEx+0x1fc>)
340041ec:	f004 f89e 	bl	3400832c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_6, GPIO_PIN_SET); /* 100% Brightness */ /* PQ6  LCD_BL_CTRL */
340041f0:	463a      	mov	r2, r7
340041f2:	2140      	movs	r1, #64	@ 0x40
340041f4:	482c      	ldr	r0, [pc, #176]	@ (340042a8 <BSP_LCD_InitEx+0x204>)
340041f6:	f004 f899 	bl	3400832c <HAL_GPIO_WritePin>
  * @param  hdma2d  DMA2D handle
  * @retval None
  */
static void DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
  if(hdma2d->Instance == DMA2D)
340041fa:	f8db 3000 	ldr.w	r3, [fp]
340041fe:	4a23      	ldr	r2, [pc, #140]	@ (3400428c <BSP_LCD_InitEx+0x1e8>)
34004200:	4293      	cmp	r3, r2
34004202:	d109      	bne.n	34004218 <BSP_LCD_InitEx+0x174>
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34004204:	f8c6 4a60 	str.w	r4, [r6, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34004208:	f8d6 3260 	ldr.w	r3, [r6, #608]	@ 0x260
3400420c:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400420e:	9b01      	ldr	r3, [sp, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34004210:	f8c6 4a20 	str.w	r4, [r6, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34004214:	f8ca 4220 	str.w	r4, [sl, #544]	@ 0x220
    if (MX_LTDC_ClockConfig(&hlcd_ltdc) != HAL_OK)
34004218:	481b      	ldr	r0, [pc, #108]	@ (34004288 <BSP_LCD_InitEx+0x1e4>)
3400421a:	f7ff ff24 	bl	34004066 <MX_LTDC_ClockConfig>
3400421e:	b170      	cbz	r0, 3400423e <BSP_LCD_InitEx+0x19a>
      ret = BSP_ERROR_PERIPH_FAILURE;
34004220:	f06f 0003 	mvn.w	r0, #3
}
34004224:	b00d      	add	sp, #52	@ 0x34
34004226:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (PixelFormat == LCD_PIXEL_FORMAT_RGB565)
3400422a:	d005      	beq.n	34004238 <BSP_LCD_InitEx+0x194>
    else if  (PixelFormat == LCD_PIXEL_FORMAT_RGB888)
3400422c:	2c01      	cmp	r4, #1
3400422e:	bf0a      	itet	eq
34004230:	2303      	moveq	r3, #3
34004232:	2304      	movne	r3, #4
34004234:	2506      	moveq	r5, #6
34004236:	e750      	b.n	340040da <BSP_LCD_InitEx+0x36>
34004238:	4623      	mov	r3, r4
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB565;
3400423a:	2504      	movs	r5, #4
3400423c:	e74d      	b.n	340040da <BSP_LCD_InitEx+0x36>
      if (MX_LTDC_Init(&hlcd_ltdc, Width, Height) != HAL_OK)
3400423e:	4649      	mov	r1, r9
34004240:	9a16      	ldr	r2, [sp, #88]	@ 0x58
34004242:	4811      	ldr	r0, [pc, #68]	@ (34004288 <BSP_LCD_InitEx+0x1e4>)
34004244:	f7ff fec8 	bl	34003fd8 <MX_LTDC_Init>
34004248:	4601      	mov	r1, r0
3400424a:	2800      	cmp	r0, #0
3400424c:	d1e8      	bne.n	34004220 <BSP_LCD_InitEx+0x17c>
        config.Y1          = Height;
3400424e:	9b16      	ldr	r3, [sp, #88]	@ 0x58
        config.X1          = Width;
34004250:	e9cd 0906 	strd	r0, r9, [sp, #24]
        config.PixelFormat = ltdc_pixel_format;
34004254:	e9cd 3509 	strd	r3, r5, [sp, #36]	@ 0x24
        config.Address     = LCD_LAYER_0_ADDRESS;
34004258:	4b14      	ldr	r3, [pc, #80]	@ (340042ac <BSP_LCD_InitEx+0x208>)
        config.Y0          = 0;
3400425a:	9008      	str	r0, [sp, #32]
        if (MX_LTDC_ConfigLayer(&hlcd_ltdc, 0, &config) != HAL_OK)
3400425c:	aa06      	add	r2, sp, #24
3400425e:	480a      	ldr	r0, [pc, #40]	@ (34004288 <BSP_LCD_InitEx+0x1e4>)
        config.Address     = LCD_LAYER_0_ADDRESS;
34004260:	930b      	str	r3, [sp, #44]	@ 0x2c
        if (MX_LTDC_ConfigLayer(&hlcd_ltdc, 0, &config) != HAL_OK)
34004262:	f7ff fed7 	bl	34004014 <MX_LTDC_ConfigLayer>
        Lcd_Ctx[Instance].ReloadEnable = 1U;
34004266:	2301      	movs	r3, #1
  int32_t ret = BSP_ERROR_NONE;
34004268:	2800      	cmp	r0, #0
3400426a:	bf14      	ite	ne
3400426c:	f06f 0003 	mvnne.w	r0, #3
34004270:	2000      	moveq	r0, #0
        Lcd_Ctx[Instance].ReloadEnable = 1U;
34004272:	f8c8 3018 	str.w	r3, [r8, #24]
34004276:	e7d5      	b.n	34004224 <BSP_LCD_InitEx+0x180>
    ret = BSP_ERROR_WRONG_PARAM;
34004278:	f06f 0001 	mvn.w	r0, #1
  return ret;
3400427c:	e7d2      	b.n	34004224 <BSP_LCD_InitEx+0x180>
3400427e:	bf00      	nop
34004280:	58001000 	.word	0x58001000
34004284:	56028000 	.word	0x56028000
34004288:	340cdda4 	.word	0x340cdda4
3400428c:	58021000 	.word	0x58021000
34004290:	56020000 	.word	0x56020000
34004294:	56020400 	.word	0x56020400
34004298:	56020c00 	.word	0x56020c00
3400429c:	56021000 	.word	0x56021000
340042a0:	56021800 	.word	0x56021800
340042a4:	56021c00 	.word	0x56021c00
340042a8:	56024000 	.word	0x56024000
340042ac:	34200000 	.word	0x34200000
340042b0:	340cdd84 	.word	0x340cdd84
340042b4:	340cde4c 	.word	0x340cde4c
340042b8:	56029000 	.word	0x56029000

340042bc <BSP_LCD_Init>:
  return BSP_LCD_InitEx(Instance, Orientation, LCD_PIXEL_FORMAT_RGB565, LCD_DEFAULT_WIDTH, LCD_DEFAULT_HEIGHT);
340042bc:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
{
340042c0:	b507      	push	{r0, r1, r2, lr}
  return BSP_LCD_InitEx(Instance, Orientation, LCD_PIXEL_FORMAT_RGB565, LCD_DEFAULT_WIDTH, LCD_DEFAULT_HEIGHT);
340042c2:	2202      	movs	r2, #2
340042c4:	9300      	str	r3, [sp, #0]
340042c6:	f44f 7348 	mov.w	r3, #800	@ 0x320
340042ca:	f7ff feeb 	bl	340040a4 <BSP_LCD_InitEx>
}
340042ce:	b003      	add	sp, #12
340042d0:	f85d fb04 	ldr.w	pc, [sp], #4

340042d4 <BSP_LCD_ConfigLayer>:
{
340042d4:	b508      	push	{r3, lr}
  if(Instance >= LCD_INSTANCES_NBR)
340042d6:	b9a8      	cbnz	r0, 34004304 <BSP_LCD_ConfigLayer+0x30>
    if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_RGB565)
340042d8:	6913      	ldr	r3, [r2, #16]
340042da:	2b02      	cmp	r3, #2
340042dc:	d10a      	bne.n	340042f4 <BSP_LCD_ConfigLayer+0x20>
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
340042de:	2304      	movs	r3, #4
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
340042e0:	6113      	str	r3, [r2, #16]
    if (MX_LTDC_ConfigLayer(&hlcd_ltdc, LayerIndex, Config) != HAL_OK)
340042e2:	480a      	ldr	r0, [pc, #40]	@ (3400430c <BSP_LCD_ConfigLayer+0x38>)
340042e4:	f7ff fe96 	bl	34004014 <MX_LTDC_ConfigLayer>
  int32_t ret = BSP_ERROR_NONE;
340042e8:	2800      	cmp	r0, #0
340042ea:	bf14      	ite	ne
340042ec:	f06f 0003 	mvnne.w	r0, #3
340042f0:	2000      	moveq	r0, #0
}
340042f2:	bd08      	pop	{r3, pc}
    else if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_ARGB4444)
340042f4:	2b04      	cmp	r3, #4
340042f6:	d101      	bne.n	340042fc <BSP_LCD_ConfigLayer+0x28>
      Config->PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
340042f8:	2308      	movs	r3, #8
340042fa:	e7f1      	b.n	340042e0 <BSP_LCD_ConfigLayer+0xc>
    else if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_ARGB8888)
340042fc:	2b00      	cmp	r3, #0
340042fe:	d0f0      	beq.n	340042e2 <BSP_LCD_ConfigLayer+0xe>
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
34004300:	2306      	movs	r3, #6
34004302:	e7ed      	b.n	340042e0 <BSP_LCD_ConfigLayer+0xc>
    ret = BSP_ERROR_WRONG_PARAM;
34004304:	f06f 0001 	mvn.w	r0, #1
34004308:	e7f3      	b.n	340042f2 <BSP_LCD_ConfigLayer+0x1e>
3400430a:	bf00      	nop
3400430c:	340cdda4 	.word	0x340cdda4

34004310 <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34004310:	4b04      	ldr	r3, [pc, #16]	@ (34004324 <LL_AHB4_GRP1_EnableClock+0x14>)
{
34004312:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34004314:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34004318:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3400431c:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400431e:	9b01      	ldr	r3, [sp, #4]
}
34004320:	b002      	add	sp, #8
34004322:	4770      	bx	lr
34004324:	56028000 	.word	0x56028000

34004328 <XSPI_NOR_EnterSOPIMode.constprop.0>:
/**
  * @brief  This function enables the octal STR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_EnterSOPIMode(uint32_t Instance)
34004328:	b530      	push	{r4, r5, lr}
{
  int32_t ret;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
3400432a:	4c20      	ldr	r4, [pc, #128]	@ (340043ac <XSPI_NOR_EnterSOPIMode.constprop.0+0x84>)
static int32_t XSPI_NOR_EnterSOPIMode(uint32_t Instance)
3400432c:	b085      	sub	sp, #20
  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
3400432e:	78a2      	ldrb	r2, [r4, #2]
34004330:	7861      	ldrb	r1, [r4, #1]
34004332:	481f      	ldr	r0, [pc, #124]	@ (340043b0 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34004334:	f7ff f84c 	bl	340033d0 <MX66UW1G45G_WriteEnable>
34004338:	b118      	cbz	r0, 34004342 <XSPI_NOR_EnterSOPIMode.constprop.0+0x1a>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
3400433a:	f06f 0004 	mvn.w	r0, #4
    }
  }

  /* Return BSP status */
  return ret;
}
3400433e:	b005      	add	sp, #20
34004340:	bd30      	pop	{r4, r5, pc}
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34004342:	9000      	str	r0, [sp, #0]
34004344:	f44f 7340 	mov.w	r3, #768	@ 0x300
34004348:	78a2      	ldrb	r2, [r4, #2]
3400434a:	7861      	ldrb	r1, [r4, #1]
3400434c:	4818      	ldr	r0, [pc, #96]	@ (340043b0 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
3400434e:	f7ff f8c8 	bl	340034e2 <MX66UW1G45G_WriteCfg2Register>
34004352:	2800      	cmp	r0, #0
34004354:	d1f1      	bne.n	3400433a <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34004356:	78a2      	ldrb	r2, [r4, #2]
34004358:	7861      	ldrb	r1, [r4, #1]
3400435a:	4815      	ldr	r0, [pc, #84]	@ (340043b0 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
3400435c:	f7ff f838 	bl	340033d0 <MX66UW1G45G_WriteEnable>
34004360:	4603      	mov	r3, r0
34004362:	2800      	cmp	r0, #0
34004364:	d1e9      	bne.n	3400433a <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34004366:	2501      	movs	r5, #1
34004368:	9500      	str	r5, [sp, #0]
3400436a:	78a2      	ldrb	r2, [r4, #2]
3400436c:	7861      	ldrb	r1, [r4, #1]
3400436e:	4810      	ldr	r0, [pc, #64]	@ (340043b0 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34004370:	f7ff f8b7 	bl	340034e2 <MX66UW1G45G_WriteCfg2Register>
34004374:	4604      	mov	r4, r0
34004376:	2800      	cmp	r0, #0
34004378:	d1df      	bne.n	3400433a <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
3400437a:	2028      	movs	r0, #40	@ 0x28
3400437c:	f000 fd84 	bl	34004e88 <HAL_Delay>
    if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34004380:	4622      	mov	r2, r4
34004382:	4629      	mov	r1, r5
34004384:	480a      	ldr	r0, [pc, #40]	@ (340043b0 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34004386:	f7fe ff00 	bl	3400318a <MX66UW1G45G_AutoPollingMemReady>
3400438a:	4603      	mov	r3, r0
3400438c:	2800      	cmp	r0, #0
3400438e:	d1d4      	bne.n	3400433a <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
34004390:	aa03      	add	r2, sp, #12
34004392:	9200      	str	r2, [sp, #0]
34004394:	4629      	mov	r1, r5
34004396:	4602      	mov	r2, r0
34004398:	4805      	ldr	r0, [pc, #20]	@ (340043b0 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
3400439a:	f7ff f8fa 	bl	34003592 <MX66UW1G45G_ReadCfg2Register>
3400439e:	2800      	cmp	r0, #0
340043a0:	d1cb      	bne.n	3400433a <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
    else if (reg[0] != MX66UW1G45G_CR2_SOPI)
340043a2:	f89d 300c 	ldrb.w	r3, [sp, #12]
340043a6:	42ab      	cmp	r3, r5
340043a8:	d0c9      	beq.n	3400433e <XSPI_NOR_EnterSOPIMode.constprop.0+0x16>
340043aa:	e7c6      	b.n	3400433a <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
340043ac:	340cdf1c 	.word	0x340cdf1c
340043b0:	340cdf20 	.word	0x340cdf20

340043b4 <XSPI_NOR_EnterDOPIMode.constprop.0>:
static int32_t XSPI_NOR_EnterDOPIMode(uint32_t Instance)
340043b4:	b530      	push	{r4, r5, lr}
  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
340043b6:	4d27      	ldr	r5, [pc, #156]	@ (34004454 <XSPI_NOR_EnterDOPIMode.constprop.0+0xa0>)
340043b8:	4c27      	ldr	r4, [pc, #156]	@ (34004458 <XSPI_NOR_EnterDOPIMode.constprop.0+0xa4>)
static int32_t XSPI_NOR_EnterDOPIMode(uint32_t Instance)
340043ba:	b085      	sub	sp, #20
  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
340043bc:	4620      	mov	r0, r4
340043be:	78aa      	ldrb	r2, [r5, #2]
340043c0:	7869      	ldrb	r1, [r5, #1]
340043c2:	f7ff f805 	bl	340033d0 <MX66UW1G45G_WriteEnable>
340043c6:	b118      	cbz	r0, 340043d0 <XSPI_NOR_EnterDOPIMode.constprop.0+0x1c>
    ret = BSP_ERROR_COMPONENT_FAILURE;
340043c8:	f06f 0004 	mvn.w	r0, #4
}
340043cc:	b005      	add	sp, #20
340043ce:	bd30      	pop	{r4, r5, pc}
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
340043d0:	9000      	str	r0, [sp, #0]
340043d2:	f44f 7340 	mov.w	r3, #768	@ 0x300
340043d6:	4620      	mov	r0, r4
340043d8:	78aa      	ldrb	r2, [r5, #2]
340043da:	7869      	ldrb	r1, [r5, #1]
340043dc:	f7ff f881 	bl	340034e2 <MX66UW1G45G_WriteCfg2Register>
340043e0:	2800      	cmp	r0, #0
340043e2:	d1f1      	bne.n	340043c8 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
340043e4:	4620      	mov	r0, r4
340043e6:	78aa      	ldrb	r2, [r5, #2]
340043e8:	7869      	ldrb	r1, [r5, #1]
340043ea:	f7fe fff1 	bl	340033d0 <MX66UW1G45G_WriteEnable>
340043ee:	4603      	mov	r3, r0
340043f0:	2800      	cmp	r0, #0
340043f2:	d1e9      	bne.n	340043c8 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
340043f4:	2202      	movs	r2, #2
340043f6:	9200      	str	r2, [sp, #0]
340043f8:	4620      	mov	r0, r4
340043fa:	78aa      	ldrb	r2, [r5, #2]
340043fc:	7869      	ldrb	r1, [r5, #1]
340043fe:	f7ff f870 	bl	340034e2 <MX66UW1G45G_WriteCfg2Register>
34004402:	2800      	cmp	r0, #0
34004404:	d1e0      	bne.n	340043c8 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34004406:	2028      	movs	r0, #40	@ 0x28
34004408:	f000 fd3e 	bl	34004e88 <HAL_Delay>
    hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
3400440c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34004410:	60e3      	str	r3, [r4, #12]
    hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34004412:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
    if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34004416:	4620      	mov	r0, r4
    hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34004418:	62e3      	str	r3, [r4, #44]	@ 0x2c
    if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
3400441a:	f00b fb8f 	bl	3400fb3c <HAL_XSPI_Init>
3400441e:	b9a8      	cbnz	r0, 3400444c <XSPI_NOR_EnterDOPIMode.constprop.0+0x98>
    else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34004420:	2201      	movs	r2, #1
34004422:	4620      	mov	r0, r4
34004424:	4611      	mov	r1, r2
34004426:	f7fe feb0 	bl	3400318a <MX66UW1G45G_AutoPollingMemReady>
3400442a:	4603      	mov	r3, r0
3400442c:	2800      	cmp	r0, #0
3400442e:	d1cb      	bne.n	340043c8 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_DTR_TRANSFER,
34004430:	aa03      	add	r2, sp, #12
34004432:	9200      	str	r2, [sp, #0]
34004434:	2201      	movs	r2, #1
34004436:	4620      	mov	r0, r4
34004438:	4611      	mov	r1, r2
3400443a:	f7ff f8aa 	bl	34003592 <MX66UW1G45G_ReadCfg2Register>
3400443e:	2800      	cmp	r0, #0
34004440:	d1c2      	bne.n	340043c8 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
    else if (reg[0] != MX66UW1G45G_CR2_DOPI)
34004442:	f89d 300c 	ldrb.w	r3, [sp, #12]
34004446:	2b02      	cmp	r3, #2
34004448:	d0c0      	beq.n	340043cc <XSPI_NOR_EnterDOPIMode.constprop.0+0x18>
3400444a:	e7bd      	b.n	340043c8 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
      ret = BSP_ERROR_PERIPH_FAILURE;
3400444c:	f06f 0003 	mvn.w	r0, #3
  return ret;
34004450:	e7bc      	b.n	340043cc <XSPI_NOR_EnterDOPIMode.constprop.0+0x18>
34004452:	bf00      	nop
34004454:	340cdf1c 	.word	0x340cdf1c
34004458:	340cdf20 	.word	0x340cdf20

3400445c <MX_XSPI_NOR_Init>:
  hxspi->Init.FifoThresholdByte       = 1;
3400445c:	2301      	movs	r3, #1
3400445e:	4a0f      	ldr	r2, [pc, #60]	@ (3400449c <MX_XSPI_NOR_Init+0x40>)
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
34004460:	f04f 0c02 	mov.w	ip, #2
  hxspi->Init.FifoThresholdByte       = 1;
34004464:	e9c0 2300 	strd	r2, r3, [r0]
  hxspi->Init.MemorySize              = Init->MemorySize; /* 1 GBits */
34004468:	680b      	ldr	r3, [r1, #0]
  hxspi->Init.ClockPrescaler          = Init->ClockPrescaler;
3400446a:	684a      	ldr	r2, [r1, #4]
  hxspi->Init.MemorySize              = Init->MemorySize; /* 1 GBits */
3400446c:	6103      	str	r3, [r0, #16]
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
3400446e:	2300      	movs	r3, #0
  hxspi->Init.ClockPrescaler          = Init->ClockPrescaler;
34004470:	6242      	str	r2, [r0, #36]	@ 0x24
  hxspi->Init.DelayHoldQuarterCycle   = HAL_XSPI_DHQC_DISABLE;
34004472:	62c3      	str	r3, [r0, #44]	@ 0x2c
  hxspi->Init.SampleShifting          = Init->SampleShifting;
34004474:	688a      	ldr	r2, [r1, #8]
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
34004476:	e9c0 c305 	strd	ip, r3, [r0, #20]
  hxspi->Init.ClockMode               = HAL_XSPI_CLOCK_MODE_0;
3400447a:	61c3      	str	r3, [r0, #28]
  hxspi->Init.ChipSelectBoundary      = HAL_XSPI_BONDARYOF_NONE;
3400447c:	6303      	str	r3, [r0, #48]	@ 0x30
  hxspi->Init.MemoryMode              = HAL_XSPI_SINGLE_MEM;
3400447e:	6083      	str	r3, [r0, #8]
  hxspi->Init.WrapSize                = HAL_XSPI_WRAP_NOT_SUPPORTED;
34004480:	6203      	str	r3, [r0, #32]
  if (Init->TransferRate == (uint32_t) BSP_XSPI_NOR_DTR_TRANSFER)
34004482:	68cb      	ldr	r3, [r1, #12]
  hxspi->Init.SampleShifting          = Init->SampleShifting;
34004484:	6282      	str	r2, [r0, #40]	@ 0x28
  if (Init->TransferRate == (uint32_t) BSP_XSPI_NOR_DTR_TRANSFER)
34004486:	2b01      	cmp	r3, #1
34004488:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
    hxspi->Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
3400448c:	60c3      	str	r3, [r0, #12]
    hxspi->Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
3400448e:	bf04      	itt	eq
34004490:	f04f 5380 	moveq.w	r3, #268435456	@ 0x10000000
34004494:	62c3      	streq	r3, [r0, #44]	@ 0x2c
  return HAL_XSPI_Init(hxspi);
34004496:	f00b bb51 	b.w	3400fb3c <HAL_XSPI_Init>
3400449a:	bf00      	nop
3400449c:	5802a000 	.word	0x5802a000

340044a0 <BSP_XSPI_NOR_EnableMemoryMappedMode>:
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
340044a0:	4601      	mov	r1, r0
{
340044a2:	b510      	push	{r4, lr}
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
340044a4:	b9b0      	cbnz	r0, 340044d4 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x34>
    if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
340044a6:	4c0d      	ldr	r4, [pc, #52]	@ (340044dc <BSP_XSPI_NOR_EnableMemoryMappedMode+0x3c>)
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
340044a8:	480d      	ldr	r0, [pc, #52]	@ (340044e0 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x40>)
340044aa:	f00b ff17 	bl	340102dc <HAL_XSPI_SetClockPrescaler>
    if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
340044ae:	78a3      	ldrb	r3, [r4, #2]
340044b0:	7861      	ldrb	r1, [r4, #1]
340044b2:	b95b      	cbnz	r3, 340044cc <BSP_XSPI_NOR_EnableMemoryMappedMode+0x2c>
      if (MX66UW1G45G_EnableMemoryMappedModeSTR(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
340044b4:	2201      	movs	r2, #1
340044b6:	480a      	ldr	r0, [pc, #40]	@ (340044e0 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x40>)
340044b8:	f7fe fed5 	bl	34003266 <MX66UW1G45G_EnableSTRMemoryMappedMode>
340044bc:	b110      	cbz	r0, 340044c4 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x24>
        ret = BSP_ERROR_COMPONENT_FAILURE;
340044be:	f06f 0004 	mvn.w	r0, #4
}
340044c2:	bd10      	pop	{r4, pc}
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
340044c4:	2302      	movs	r3, #2
  int32_t ret = BSP_ERROR_NONE;
340044c6:	2000      	movs	r0, #0
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
340044c8:	7023      	strb	r3, [r4, #0]
340044ca:	e7fa      	b.n	340044c2 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x22>
      if (MX66UW1G45G_EnableMemoryMappedModeDTR(&hxspi_nor[Instance],
340044cc:	4804      	ldr	r0, [pc, #16]	@ (340044e0 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x40>)
340044ce:	f7fe ff2f 	bl	34003330 <MX66UW1G45G_EnableDTRMemoryMappedMode>
340044d2:	e7f3      	b.n	340044bc <BSP_XSPI_NOR_EnableMemoryMappedMode+0x1c>
    ret = BSP_ERROR_WRONG_PARAM;
340044d4:	f06f 0001 	mvn.w	r0, #1
  return ret;
340044d8:	e7f3      	b.n	340044c2 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x22>
340044da:	bf00      	nop
340044dc:	340cdf1c 	.word	0x340cdf1c
340044e0:	340cdf20 	.word	0x340cdf20

340044e4 <BSP_XSPI_NOR_ConfigFlash>:
{
340044e4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
340044e8:	460d      	mov	r5, r1
340044ea:	4616      	mov	r6, r2
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
340044ec:	2800      	cmp	r0, #0
340044ee:	d15f      	bne.n	340045b0 <BSP_XSPI_NOR_ConfigFlash+0xcc>
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_MMP)
340044f0:	4c32      	ldr	r4, [pc, #200]	@ (340045bc <BSP_XSPI_NOR_ConfigFlash+0xd8>)
340044f2:	7823      	ldrb	r3, [r4, #0]
340044f4:	2b02      	cmp	r3, #2
340044f6:	d05e      	beq.n	340045b6 <BSP_XSPI_NOR_ConfigFlash+0xd2>
      switch (XSPI_Nor_Ctx[Instance].InterfaceMode)
340044f8:	7863      	ldrb	r3, [r4, #1]
340044fa:	2b01      	cmp	r3, #1
340044fc:	d14f      	bne.n	3400459e <BSP_XSPI_NOR_ConfigFlash+0xba>
          if ((Mode != BSP_XSPI_NOR_OPI_MODE) || (Rate != XSPI_Nor_Ctx[Instance].TransferRate))
340044fe:	2901      	cmp	r1, #1
34004500:	78a2      	ldrb	r2, [r4, #2]
34004502:	d109      	bne.n	34004518 <BSP_XSPI_NOR_ConfigFlash+0x34>
34004504:	4296      	cmp	r6, r2
34004506:	d107      	bne.n	34004518 <BSP_XSPI_NOR_ConfigFlash+0x34>
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
34004508:	2301      	movs	r3, #1
        XSPI_Nor_Ctx[Instance].TransferRate  = Rate;
3400450a:	2000      	movs	r0, #0
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
3400450c:	7023      	strb	r3, [r4, #0]
        XSPI_Nor_Ctx[Instance].InterfaceMode = Mode;
3400450e:	7065      	strb	r5, [r4, #1]
        XSPI_Nor_Ctx[Instance].TransferRate  = Rate;
34004510:	70a6      	strb	r6, [r4, #2]
}
34004512:	b004      	add	sp, #16
34004514:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
static int32_t XSPI_NOR_ExitOPIMode(uint32_t Instance)
{
  int32_t ret = BSP_ERROR_NONE;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34004518:	4f29      	ldr	r7, [pc, #164]	@ (340045c0 <BSP_XSPI_NOR_ConfigFlash+0xdc>)
3400451a:	2101      	movs	r1, #1
3400451c:	4638      	mov	r0, r7
3400451e:	f7fe ff57 	bl	340033d0 <MX66UW1G45G_WriteEnable>
34004522:	4603      	mov	r3, r0
34004524:	b110      	cbz	r0, 3400452c <BSP_XSPI_NOR_ConfigFlash+0x48>
            ret = XSPI_NOR_ExitOPIMode(Instance);
34004526:	f06f 0004 	mvn.w	r0, #4
3400452a:	e7f2      	b.n	34004512 <BSP_XSPI_NOR_ConfigFlash+0x2e>
  else
  {
    /* Write Configuration register 2 (with SPI protocol) */
    reg[0] = 0;
    reg[1] = 0;
    if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
3400452c:	9000      	str	r0, [sp, #0]
    reg[0] = 0;
3400452e:	f8ad 000c 	strh.w	r0, [sp, #12]
    if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34004532:	78a2      	ldrb	r2, [r4, #2]
34004534:	4638      	mov	r0, r7
34004536:	7861      	ldrb	r1, [r4, #1]
34004538:	f7fe ffd3 	bl	340034e2 <MX66UW1G45G_WriteCfg2Register>
3400453c:	4680      	mov	r8, r0
3400453e:	2800      	cmp	r0, #0
34004540:	d1f1      	bne.n	34004526 <BSP_XSPI_NOR_ConfigFlash+0x42>
      ret = BSP_ERROR_COMPONENT_FAILURE;
    }
    else
    {
      /* Wait that the configuration is effective and check that memory is ready */
      HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34004542:	2028      	movs	r0, #40	@ 0x28
34004544:	f000 fca0 	bl	34004e88 <HAL_Delay>

      if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_DTR_TRANSFER)
34004548:	78a3      	ldrb	r3, [r4, #2]
3400454a:	2b01      	cmp	r3, #1
3400454c:	d01b      	beq.n	34004586 <BSP_XSPI_NOR_ConfigFlash+0xa2>
      }

      if (ret == BSP_ERROR_NONE)
      {
        /* Check Flash busy ? */
        if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
3400454e:	2200      	movs	r2, #0
34004550:	481b      	ldr	r0, [pc, #108]	@ (340045c0 <BSP_XSPI_NOR_ConfigFlash+0xdc>)
34004552:	4611      	mov	r1, r2
34004554:	f7fe fe19 	bl	3400318a <MX66UW1G45G_AutoPollingMemReady>
34004558:	4603      	mov	r3, r0
3400455a:	2800      	cmp	r0, #0
3400455c:	d1e3      	bne.n	34004526 <BSP_XSPI_NOR_ConfigFlash+0x42>
                                             BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
        }
        /* Check the configuration has been correctly done */
        else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
3400455e:	aa03      	add	r2, sp, #12
34004560:	4601      	mov	r1, r0
34004562:	9200      	str	r2, [sp, #0]
34004564:	4602      	mov	r2, r0
34004566:	4816      	ldr	r0, [pc, #88]	@ (340045c0 <BSP_XSPI_NOR_ConfigFlash+0xdc>)
34004568:	f7ff f813 	bl	34003592 <MX66UW1G45G_ReadCfg2Register>
3400456c:	2800      	cmp	r0, #0
3400456e:	d1da      	bne.n	34004526 <BSP_XSPI_NOR_ConfigFlash+0x42>
                                               MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
        }
        else if (reg[0] != 0U)
34004570:	f89d 300c 	ldrb.w	r3, [sp, #12]
34004574:	2b00      	cmp	r3, #0
34004576:	d1d6      	bne.n	34004526 <BSP_XSPI_NOR_ConfigFlash+0x42>
            if ((ret == BSP_ERROR_NONE) && (Mode == BSP_XSPI_NOR_OPI_MODE))
34004578:	2d01      	cmp	r5, #1
3400457a:	d1c5      	bne.n	34004508 <BSP_XSPI_NOR_ConfigFlash+0x24>
              if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
3400457c:	78a3      	ldrb	r3, [r4, #2]
3400457e:	b993      	cbnz	r3, 340045a6 <BSP_XSPI_NOR_ConfigFlash+0xc2>
              ret = XSPI_NOR_EnterDOPIMode(Instance);
34004580:	f7ff ff18 	bl	340043b4 <XSPI_NOR_EnterDOPIMode.constprop.0>
34004584:	e011      	b.n	340045aa <BSP_XSPI_NOR_ConfigFlash+0xc6>
        if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34004586:	4638      	mov	r0, r7
        hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MICRON;
34004588:	f8c7 800c 	str.w	r8, [r7, #12]
        hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
3400458c:	f8c7 802c 	str.w	r8, [r7, #44]	@ 0x2c
        if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34004590:	f00b fad4 	bl	3400fb3c <HAL_XSPI_Init>
34004594:	2800      	cmp	r0, #0
34004596:	d0da      	beq.n	3400454e <BSP_XSPI_NOR_ConfigFlash+0x6a>
            ret = XSPI_NOR_ExitOPIMode(Instance);
34004598:	f06f 0003 	mvn.w	r0, #3
3400459c:	e7b9      	b.n	34004512 <BSP_XSPI_NOR_ConfigFlash+0x2e>
          if (Mode == BSP_XSPI_NOR_OPI_MODE)
3400459e:	2901      	cmp	r1, #1
340045a0:	d1b2      	bne.n	34004508 <BSP_XSPI_NOR_ConfigFlash+0x24>
            if (Rate == BSP_XSPI_NOR_STR_TRANSFER)
340045a2:	2a00      	cmp	r2, #0
340045a4:	d1ec      	bne.n	34004580 <BSP_XSPI_NOR_ConfigFlash+0x9c>
              ret = XSPI_NOR_EnterSOPIMode(Instance);
340045a6:	f7ff febf 	bl	34004328 <XSPI_NOR_EnterSOPIMode.constprop.0>
      if (ret == BSP_ERROR_NONE)
340045aa:	2800      	cmp	r0, #0
340045ac:	d1b1      	bne.n	34004512 <BSP_XSPI_NOR_ConfigFlash+0x2e>
340045ae:	e7ab      	b.n	34004508 <BSP_XSPI_NOR_ConfigFlash+0x24>
    ret = BSP_ERROR_WRONG_PARAM;
340045b0:	f06f 0001 	mvn.w	r0, #1
340045b4:	e7ad      	b.n	34004512 <BSP_XSPI_NOR_ConfigFlash+0x2e>
      ret = BSP_ERROR_XSPI_MMP_LOCK_FAILURE;
340045b6:	f06f 0019 	mvn.w	r0, #25
  return ret;
340045ba:	e7aa      	b.n	34004512 <BSP_XSPI_NOR_ConfigFlash+0x2e>
340045bc:	340cdf1c 	.word	0x340cdf1c
340045c0:	340cdf20 	.word	0x340cdf20

340045c4 <BSP_XSPI_NOR_Init>:
{
340045c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340045c8:	4689      	mov	r9, r1
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
340045ca:	4604      	mov	r4, r0
340045cc:	4e82      	ldr	r6, [pc, #520]	@ (340047d8 <BSP_XSPI_NOR_Init+0x214>)
{
340045ce:	b08f      	sub	sp, #60	@ 0x3c
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
340045d0:	2800      	cmp	r0, #0
340045d2:	f040 80fa 	bne.w	340047ca <BSP_XSPI_NOR_Init+0x206>
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
340045d6:	f8df 820c 	ldr.w	r8, [pc, #524]	@ 340047e4 <BSP_XSPI_NOR_Init+0x220>
340045da:	f898 3000 	ldrb.w	r3, [r8]
340045de:	b153      	cbz	r3, 340045f6 <BSP_XSPI_NOR_Init+0x32>
      ret = BSP_ERROR_NONE;
340045e0:	2500      	movs	r5, #0
 (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
340045e2:	2064      	movs	r0, #100	@ 0x64
340045e4:	2100      	movs	r1, #0
340045e6:	fb00 6004 	mla	r0, r0, r4, r6
340045ea:	f00b fe77 	bl	340102dc <HAL_XSPI_SetClockPrescaler>
}
340045ee:	4628      	mov	r0, r5
340045f0:	b00f      	add	sp, #60	@ 0x3c
340045f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  WRITE_REG(RCC->AHB5ENSR, Periphs);
340045f6:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
340045fa:	4a78      	ldr	r2, [pc, #480]	@ (340047dc <BSP_XSPI_NOR_Init+0x218>)
  __HAL_RCC_PWR_CLK_ENABLE();
340045fc:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
34004600:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34004604:	f8d2 1260 	ldr.w	r1, [r2, #608]	@ 0x260
  GPIO_InitStruct.Alternate = XSPI_NOR_CS_PIN_AF;
34004608:	2509      	movs	r5, #9
3400460a:	9100      	str	r1, [sp, #0]
  (void)tmpreg;
3400460c:	9900      	ldr	r1, [sp, #0]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
3400460e:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34004612:	441a      	add	r2, r3
34004614:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
  __HAL_RCC_PWR_CLK_ENABLE();
34004618:	f7ff fe7a 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO3();
3400461c:	f005 f852 	bl	340096c4 <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3, PWR_VDDIO_RANGE_1V8);
34004620:	2101      	movs	r1, #1
34004622:	2002      	movs	r0, #2
34004624:	f005 f800 	bl	34009628 <HAL_PWREx_ConfigVddIORange>
  XSPI_NOR_CLK_GPIO_CLK_ENABLE();
34004628:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3400462c:	f7ff fe70 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
34004630:	2701      	movs	r7, #1
  XSPI_NOR_DQS_GPIO_CLK_ENABLE();
34004632:	f7ff fe6d 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
34004636:	f04f 0b03 	mov.w	fp, #3
  XSPI_NOR_CS_GPIO_CLK_ENABLE();
3400463a:	f7ff fe69 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D0_GPIO_CLK_ENABLE();
3400463e:	f7ff fe67 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D1_GPIO_CLK_ENABLE();
34004642:	f7ff fe65 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D2_GPIO_CLK_ENABLE();
34004646:	f7ff fe63 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D3_GPIO_CLK_ENABLE();
3400464a:	f7ff fe61 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D4_GPIO_CLK_ENABLE();
3400464e:	f7ff fe5f 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D5_GPIO_CLK_ENABLE();
34004652:	f7ff fe5d 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D6_GPIO_CLK_ENABLE();
34004656:	f7ff fe5b 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D7_GPIO_CLK_ENABLE();
3400465a:	f7ff fe59 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  GPIO_InitStruct.Pin       = XSPI_NOR_CS_PIN;
3400465e:	2302      	movs	r3, #2
  HAL_GPIO_Init(XSPI_NOR_CS_GPIO_PORT, &GPIO_InitStruct);
34004660:	485f      	ldr	r0, [pc, #380]	@ (340047e0 <BSP_XSPI_NOR_Init+0x21c>)
34004662:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
34004664:	e9cd 3305 	strd	r3, r3, [sp, #20]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
34004668:	e9cd 7b07 	strd	r7, fp, [sp, #28]
  GPIO_InitStruct.Alternate = XSPI_NOR_CS_PIN_AF;
3400466c:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_CS_GPIO_PORT, &GPIO_InitStruct);
3400466e:	f003 fb17 	bl	34007ca0 <HAL_GPIO_Init>
  HAL_GPIO_Init(XSPI_NOR_DQS_GPIO_PORT, &GPIO_InitStruct);
34004672:	485b      	ldr	r0, [pc, #364]	@ (340047e0 <BSP_XSPI_NOR_Init+0x21c>)
34004674:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_DQS_PIN;
34004676:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_DQS_PIN_AF;
34004678:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_DQS_GPIO_PORT, &GPIO_InitStruct);
3400467a:	f003 fb11 	bl	34007ca0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_CLK_PIN;
3400467e:	2340      	movs	r3, #64	@ 0x40
  HAL_GPIO_Init(XSPI_NOR_CLK_GPIO_PORT, &GPIO_InitStruct);
34004680:	4857      	ldr	r0, [pc, #348]	@ (340047e0 <BSP_XSPI_NOR_Init+0x21c>)
34004682:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_CLK_PIN;
34004684:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
34004686:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Alternate = XSPI_NOR_CLK_PIN_AF;
34004688:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_CLK_GPIO_PORT, &GPIO_InitStruct);
3400468a:	f003 fb09 	bl	34007ca0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D0_PIN;
3400468e:	2304      	movs	r3, #4
  HAL_GPIO_Init(XSPI_NOR_D0_GPIO_PORT, &GPIO_InitStruct);
34004690:	4853      	ldr	r0, [pc, #332]	@ (340047e0 <BSP_XSPI_NOR_Init+0x21c>)
34004692:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D0_PIN;
34004694:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D0_PIN_AF;
34004696:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D0_GPIO_PORT, &GPIO_InitStruct);
34004698:	f003 fb02 	bl	34007ca0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D1_PIN;
3400469c:	2308      	movs	r3, #8
  HAL_GPIO_Init(XSPI_NOR_D1_GPIO_PORT, &GPIO_InitStruct);
3400469e:	4850      	ldr	r0, [pc, #320]	@ (340047e0 <BSP_XSPI_NOR_Init+0x21c>)
340046a0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D1_PIN;
340046a2:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D1_PIN_AF;
340046a4:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D1_GPIO_PORT, &GPIO_InitStruct);
340046a6:	f003 fafb 	bl	34007ca0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D2_PIN;
340046aa:	2310      	movs	r3, #16
  GPIO_InitStruct.Pin       = XSPI_NOR_D3_PIN;
340046ac:	f04f 0a20 	mov.w	sl, #32
  HAL_GPIO_Init(XSPI_NOR_D2_GPIO_PORT, &GPIO_InitStruct);
340046b0:	484b      	ldr	r0, [pc, #300]	@ (340047e0 <BSP_XSPI_NOR_Init+0x21c>)
340046b2:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D2_PIN;
340046b4:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D2_PIN_AF;
340046b6:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D2_GPIO_PORT, &GPIO_InitStruct);
340046b8:	f003 faf2 	bl	34007ca0 <HAL_GPIO_Init>
  HAL_GPIO_Init(XSPI_NOR_D3_GPIO_PORT, &GPIO_InitStruct);
340046bc:	4848      	ldr	r0, [pc, #288]	@ (340047e0 <BSP_XSPI_NOR_Init+0x21c>)
340046be:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D3_PIN;
340046c0:	f8cd a014 	str.w	sl, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D3_PIN_AF;
340046c4:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D3_GPIO_PORT, &GPIO_InitStruct);
340046c6:	f003 faeb 	bl	34007ca0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D4_PIN;
340046ca:	f44f 7380 	mov.w	r3, #256	@ 0x100
  HAL_GPIO_Init(XSPI_NOR_D4_GPIO_PORT, &GPIO_InitStruct);
340046ce:	4844      	ldr	r0, [pc, #272]	@ (340047e0 <BSP_XSPI_NOR_Init+0x21c>)
340046d0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D4_PIN;
340046d2:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D4_PIN_AF;
340046d4:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D4_GPIO_PORT, &GPIO_InitStruct);
340046d6:	f003 fae3 	bl	34007ca0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D5_PIN;
340046da:	f44f 7300 	mov.w	r3, #512	@ 0x200
  HAL_GPIO_Init(XSPI_NOR_D5_GPIO_PORT, &GPIO_InitStruct);
340046de:	4840      	ldr	r0, [pc, #256]	@ (340047e0 <BSP_XSPI_NOR_Init+0x21c>)
340046e0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D5_PIN;
340046e2:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D5_PIN_AF;
340046e4:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D5_GPIO_PORT, &GPIO_InitStruct);
340046e6:	f003 fadb 	bl	34007ca0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D6_PIN;
340046ea:	f44f 6380 	mov.w	r3, #1024	@ 0x400
  HAL_GPIO_Init(XSPI_NOR_D6_GPIO_PORT, &GPIO_InitStruct);
340046ee:	483c      	ldr	r0, [pc, #240]	@ (340047e0 <BSP_XSPI_NOR_Init+0x21c>)
340046f0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D6_PIN;
340046f2:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D6_PIN_AF;
340046f4:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D6_GPIO_PORT, &GPIO_InitStruct);
340046f6:	f003 fad3 	bl	34007ca0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D7_PIN;
340046fa:	f44f 6300 	mov.w	r3, #2048	@ 0x800
  HAL_GPIO_Init(XSPI_NOR_D7_GPIO_PORT, &GPIO_InitStruct);
340046fe:	a905      	add	r1, sp, #20
34004700:	4837      	ldr	r0, [pc, #220]	@ (340047e0 <BSP_XSPI_NOR_Init+0x21c>)
  GPIO_InitStruct.Pin       = XSPI_NOR_D7_PIN;
34004702:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D7_PIN_AF;
34004704:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D7_GPIO_PORT, &GPIO_InitStruct);
34004706:	f003 facb 	bl	34007ca0 <HAL_GPIO_Init>
      (void)MX66UW1G45G_GetFlashInfo(&pInfo);
3400470a:	a805      	add	r0, sp, #20
3400470c:	f7fe fd24 	bl	34003158 <MX66UW1G45G_GetFlashInfo>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34004710:	9b05      	ldr	r3, [sp, #20]
34004712:	fa93 f3a3 	rbit	r3, r3
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
34004716:	2b00      	cmp	r3, #0
34004718:	fab3 f283 	clz	r2, r3
3400471c:	bf08      	it	eq
3400471e:	4652      	moveq	r2, sl
      xspi_init.TransferRate   = (uint32_t)Init->TransferRate;
34004720:	f899 3001 	ldrb.w	r3, [r9, #1]
      if (MX_XSPI_NOR_Init(&hxspi_nor[Instance], &xspi_init) != HAL_OK)
34004724:	4630      	mov	r0, r6
34004726:	a901      	add	r1, sp, #4
      xspi_init.ClockPrescaler = 0x03; /* XSPI clock = 200MHz / ClockPrescaler = 50MHz, then switch to 200MHz*/
34004728:	f8cd b008 	str.w	fp, [sp, #8]
      xspi_init.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
3400472c:	9201      	str	r2, [sp, #4]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
3400472e:	9403      	str	r4, [sp, #12]
      xspi_init.TransferRate   = (uint32_t)Init->TransferRate;
34004730:	9304      	str	r3, [sp, #16]
      if (MX_XSPI_NOR_Init(&hxspi_nor[Instance], &xspi_init) != HAL_OK)
34004732:	f7ff fe93 	bl	3400445c <MX_XSPI_NOR_Init>
34004736:	2800      	cmp	r0, #0
34004738:	d14a      	bne.n	340047d0 <BSP_XSPI_NOR_Init+0x20c>
  if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
3400473a:	4622      	mov	r2, r4
3400473c:	4621      	mov	r1, r4
3400473e:	4630      	mov	r0, r6
34004740:	f7fe ff89 	bl	34003656 <MX66UW1G45G_ResetEnable>
34004744:	b110      	cbz	r0, 3400474c <BSP_XSPI_NOR_Init+0x188>
        ret = BSP_ERROR_COMPONENT_FAILURE;
34004746:	f06f 0504 	mvn.w	r5, #4
3400474a:	e74a      	b.n	340045e2 <BSP_XSPI_NOR_Init+0x1e>
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
3400474c:	4622      	mov	r2, r4
3400474e:	4621      	mov	r1, r4
34004750:	4630      	mov	r0, r6
34004752:	f7fe ffad 	bl	340036b0 <MX66UW1G45G_ResetMemory>
34004756:	2800      	cmp	r0, #0
34004758:	d1f5      	bne.n	34004746 <BSP_XSPI_NOR_Init+0x182>
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
3400475a:	4622      	mov	r2, r4
3400475c:	4639      	mov	r1, r7
3400475e:	4630      	mov	r0, r6
34004760:	f7fe ff79 	bl	34003656 <MX66UW1G45G_ResetEnable>
34004764:	2800      	cmp	r0, #0
34004766:	d1ee      	bne.n	34004746 <BSP_XSPI_NOR_Init+0x182>
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34004768:	4622      	mov	r2, r4
3400476a:	4639      	mov	r1, r7
3400476c:	4630      	mov	r0, r6
3400476e:	f7fe ff9f 	bl	340036b0 <MX66UW1G45G_ResetMemory>
34004772:	2800      	cmp	r0, #0
34004774:	d1e7      	bne.n	34004746 <BSP_XSPI_NOR_Init+0x182>
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34004776:	463a      	mov	r2, r7
34004778:	4639      	mov	r1, r7
3400477a:	4630      	mov	r0, r6
3400477c:	f7fe ff6b 	bl	34003656 <MX66UW1G45G_ResetEnable>
34004780:	2800      	cmp	r0, #0
34004782:	d1e0      	bne.n	34004746 <BSP_XSPI_NOR_Init+0x182>
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34004784:	463a      	mov	r2, r7
34004786:	4639      	mov	r1, r7
34004788:	4630      	mov	r0, r6
3400478a:	f7fe ff91 	bl	340036b0 <MX66UW1G45G_ResetMemory>
3400478e:	2800      	cmp	r0, #0
34004790:	d1d9      	bne.n	34004746 <BSP_XSPI_NOR_Init+0x182>
    HAL_Delay(MX66UW1G45G_RESET_MAX_TIME);
34004792:	2064      	movs	r0, #100	@ 0x64
    XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;     /* After reset S/W setting to indirect access  */
34004794:	f888 7000 	strb.w	r7, [r8]
    XSPI_Nor_Ctx[Instance].InterfaceMode = BSP_XSPI_NOR_SPI_MODE;    /* After reset H/W back to SPI mode by default */
34004798:	f888 4001 	strb.w	r4, [r8, #1]
    XSPI_Nor_Ctx[Instance].TransferRate  = BSP_XSPI_NOR_STR_TRANSFER; /* After reset S/W setting to STR mode        */
3400479c:	f888 4002 	strb.w	r4, [r8, #2]
    HAL_Delay(MX66UW1G45G_RESET_MAX_TIME);
340047a0:	f000 fb72 	bl	34004e88 <HAL_Delay>
      else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
340047a4:	4630      	mov	r0, r6
340047a6:	f898 2002 	ldrb.w	r2, [r8, #2]
340047aa:	f898 1001 	ldrb.w	r1, [r8, #1]
340047ae:	f7fe fcec 	bl	3400318a <MX66UW1G45G_AutoPollingMemReady>
340047b2:	2800      	cmp	r0, #0
340047b4:	d1c7      	bne.n	34004746 <BSP_XSPI_NOR_Init+0x182>
      else if (BSP_XSPI_NOR_ConfigFlash(Instance, Init->InterfaceMode, Init->TransferRate) != BSP_ERROR_NONE)
340047b6:	f899 2001 	ldrb.w	r2, [r9, #1]
340047ba:	f899 1000 	ldrb.w	r1, [r9]
340047be:	f7ff fe91 	bl	340044e4 <BSP_XSPI_NOR_ConfigFlash>
340047c2:	2800      	cmp	r0, #0
340047c4:	f43f af0c 	beq.w	340045e0 <BSP_XSPI_NOR_Init+0x1c>
340047c8:	e7bd      	b.n	34004746 <BSP_XSPI_NOR_Init+0x182>
    ret = BSP_ERROR_WRONG_PARAM;
340047ca:	f06f 0501 	mvn.w	r5, #1
340047ce:	e708      	b.n	340045e2 <BSP_XSPI_NOR_Init+0x1e>
        ret = BSP_ERROR_PERIPH_FAILURE;
340047d0:	f06f 0503 	mvn.w	r5, #3
340047d4:	e705      	b.n	340045e2 <BSP_XSPI_NOR_Init+0x1e>
340047d6:	bf00      	nop
340047d8:	340cdf20 	.word	0x340cdf20
340047dc:	56028000 	.word	0x56028000
340047e0:	56023400 	.word	0x56023400
340047e4:	340cdf1c 	.word	0x340cdf1c

340047e8 <MX_XSPI_RAM_Init>:
{
340047e8:	b538      	push	{r3, r4, r5, lr}
340047ea:	4604      	mov	r4, r0
340047ec:	460d      	mov	r5, r1
  uint32_t hspi_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI1);
340047ee:	2000      	movs	r0, #0
340047f0:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
340047f4:	f00a fabe 	bl	3400ed74 <HAL_RCCEx_GetPeriphCLKFreq>
  hxspi->Init.FifoThresholdByte          = 8;
340047f8:	2308      	movs	r3, #8
340047fa:	4a13      	ldr	r2, [pc, #76]	@ (34004848 <MX_XSPI_RAM_Init+0x60>)
  hxspi->Init.SampleShifting             = Init->SampleShifting;
340047fc:	68a9      	ldr	r1, [r5, #8]
  hxspi->Init.FifoThresholdByte          = 8;
340047fe:	e9c4 2300 	strd	r2, r3, [r4]
  hxspi->Init.MemoryMode                 = HAL_XSPI_SINGLE_MEM;
34004802:	2200      	movs	r2, #0
34004804:	f04f 63c0 	mov.w	r3, #100663296	@ 0x6000000
34004808:	e9c4 2302 	strd	r2, r3, [r4, #8]
  hxspi->Init.MemorySize                 = Init->MemorySize;
3400480c:	682b      	ldr	r3, [r5, #0]
  hxspi->Init.MemorySelect               = HAL_XSPI_CSSEL_NCS1;
3400480e:	63e2      	str	r2, [r4, #60]	@ 0x3c
  hxspi->Init.MemorySize                 = Init->MemorySize;
34004810:	6123      	str	r3, [r4, #16]
  hxspi->Init.ChipSelectHighTimeCycle    = 5;
34004812:	2305      	movs	r3, #5
34004814:	6163      	str	r3, [r4, #20]
  hxspi->Init.ClockPrescaler             = Init->ClockPrescaler;
34004816:	686b      	ldr	r3, [r5, #4]
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
34004818:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
  hxspi->Init.SampleShifting             = Init->SampleShifting;
3400481c:	62a1      	str	r1, [r4, #40]	@ 0x28
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
3400481e:	210b      	movs	r1, #11
  hxspi->Init.ClockPrescaler             = Init->ClockPrescaler;
34004820:	6263      	str	r3, [r4, #36]	@ 0x24
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
34004822:	fbb0 f3f3 	udiv	r3, r0, r3
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
34004826:	e9c4 510b 	strd	r5, r1, [r4, #44]	@ 0x2c
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
3400482a:	4908      	ldr	r1, [pc, #32]	@ (3400484c <MX_XSPI_RAM_Init+0x64>)
3400482c:	005b      	lsls	r3, r3, #1
3400482e:	fbb3 f3f1 	udiv	r3, r3, r1
34004832:	3b04      	subs	r3, #4
  return HAL_XSPI_Init(hxspi);
34004834:	4620      	mov	r0, r4
  hxspi->Init.ClockMode                  = HAL_XSPI_CLOCK_MODE_0;
34004836:	61e2      	str	r2, [r4, #28]
  hxspi->Init.FreeRunningClock           = HAL_XSPI_FREERUNCLK_DISABLE;
34004838:	61a2      	str	r2, [r4, #24]
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
3400483a:	63a3      	str	r3, [r4, #56]	@ 0x38
  hxspi->Init.WrapSize                   = HAL_XSPI_WRAP_NOT_SUPPORTED;
3400483c:	6222      	str	r2, [r4, #32]
}
3400483e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return HAL_XSPI_Init(hxspi);
34004842:	f00b b97b 	b.w	3400fb3c <HAL_XSPI_Init>
34004846:	bf00      	nop
34004848:	58025000 	.word	0x58025000
3400484c:	000f4240 	.word	0x000f4240

34004850 <BSP_XSPI_RAM_Init>:
{
34004850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
34004854:	4604      	mov	r4, r0
{
34004856:	b08b      	sub	sp, #44	@ 0x2c
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
34004858:	2800      	cmp	r0, #0
3400485a:	f040 810d 	bne.w	34004a78 <BSP_XSPI_RAM_Init+0x228>
    if (XSPI_Ram_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
3400485e:	4e88      	ldr	r6, [pc, #544]	@ (34004a80 <BSP_XSPI_RAM_Init+0x230>)
34004860:	7833      	ldrb	r3, [r6, #0]
34004862:	9301      	str	r3, [sp, #4]
34004864:	2b00      	cmp	r3, #0
34004866:	f040 80f0 	bne.w	34004a4a <BSP_XSPI_RAM_Init+0x1fa>

  /* hxspi unused argument(s) compilation warning */
  UNUSED(hxspi);

 /* XSPI power enable */
  __HAL_RCC_PWR_CLK_ENABLE();
3400486a:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
3400486e:	f7ff fd4f 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO2();
34004872:	f004 ff1f 	bl	340096b4 <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO2, PWR_VDDIO_RANGE_1V8);
34004876:	2101      	movs	r1, #1
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34004878:	f04f 0820 	mov.w	r8, #32
3400487c:	f44f 5700 	mov.w	r7, #8192	@ 0x2000
34004880:	4608      	mov	r0, r1
34004882:	f004 fed1 	bl	34009628 <HAL_PWREx_ConfigVddIORange>
34004886:	4b7f      	ldr	r3, [pc, #508]	@ (34004a84 <BSP_XSPI_RAM_Init+0x234>)
  /* XSPI CS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CS_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
34004888:	2409      	movs	r4, #9
3400488a:	f8c3 8a60 	str.w	r8, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
3400488e:	f8d3 2260 	ldr.w	r2, [r3, #608]	@ 0x260
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
34004892:	2501      	movs	r5, #1
34004894:	9204      	str	r2, [sp, #16]
  (void)tmpreg;
34004896:	9a04      	ldr	r2, [sp, #16]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34004898:	4a7b      	ldr	r2, [pc, #492]	@ (34004a88 <BSP_XSPI_RAM_Init+0x238>)
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
3400489a:	f8c3 8a20 	str.w	r8, [r3, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
3400489e:	f8c2 8220 	str.w	r8, [r2, #544]	@ 0x220
  WRITE_REG(RCC->AHB5ENSR, Periphs);
340048a2:	f8c3 7a60 	str.w	r7, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
340048a6:	f8d3 1260 	ldr.w	r1, [r3, #608]	@ 0x260
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
340048aa:	f04f 0903 	mov.w	r9, #3
340048ae:	9103      	str	r1, [sp, #12]
  (void)tmpreg;
340048b0:	9903      	ldr	r1, [sp, #12]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
340048b2:	f8c3 7a20 	str.w	r7, [r3, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
340048b6:	f8c2 7220 	str.w	r7, [r2, #544]	@ 0x220
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
340048ba:	2202      	movs	r2, #2
  XSPI_RAM_CLK_GPIO_CLK_ENABLE();
340048bc:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
340048c0:	f7ff fd26 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_DQS_GPIO_CLK_ENABLE();
340048c4:	f7ff fd24 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_CS_GPIO_CLK_ENABLE();
340048c8:	f7ff fd22 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D0_GPIO_CLK_ENABLE();
340048cc:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
340048d0:	f7ff fd1e 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
340048d4:	a905      	add	r1, sp, #20
  XSPI_RAM_D1_GPIO_CLK_ENABLE();
340048d6:	f7ff fd1b 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D2_GPIO_CLK_ENABLE();
340048da:	f7ff fd19 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D3_GPIO_CLK_ENABLE();
340048de:	f7ff fd17 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D4_GPIO_CLK_ENABLE();
340048e2:	f7ff fd15 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D5_GPIO_CLK_ENABLE();
340048e6:	f7ff fd13 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D6_GPIO_CLK_ENABLE();
340048ea:	f7ff fd11 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D7_GPIO_CLK_ENABLE();
340048ee:	f7ff fd0f 	bl	34004310 <LL_AHB4_GRP1_EnableClock>
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
340048f2:	4866      	ldr	r0, [pc, #408]	@ (34004a8c <BSP_XSPI_RAM_Init+0x23c>)
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
340048f4:	e9cd 5205 	strd	r5, r2, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
340048f8:	e9cd 9408 	strd	r9, r4, [sp, #32]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
340048fc:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
340048fe:	f003 f9cf 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI DQS0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS0_PIN;
34004902:	2304      	movs	r3, #4
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS0_PIN_AF;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);

  /* XSPI DQS1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS1_PIN;
34004904:	f04f 0b08 	mov.w	fp, #8
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS1_PIN_AF;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);

  /* XSPI CLK GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CLK_PIN;
34004908:	f04f 0a10 	mov.w	sl, #16
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);
3400490c:	485f      	ldr	r0, [pc, #380]	@ (34004a8c <BSP_XSPI_RAM_Init+0x23c>)
3400490e:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS0_PIN;
34004910:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS0_PIN_AF;
34004912:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34004914:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);
34004916:	f003 f9c3 	bl	34007ca0 <HAL_GPIO_Init>
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);
3400491a:	485c      	ldr	r0, [pc, #368]	@ (34004a8c <BSP_XSPI_RAM_Init+0x23c>)
3400491c:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS1_PIN_AF;
3400491e:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS1_PIN;
34004920:	f8cd b014 	str.w	fp, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34004924:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);
34004926:	f003 f9bb 	bl	34007ca0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Alternate = XSPI_RAM_CLK_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_CLK_GPIO_PORT, &GPIO_InitStruct);
3400492a:	4858      	ldr	r0, [pc, #352]	@ (34004a8c <BSP_XSPI_RAM_Init+0x23c>)
3400492c:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_CLK_PIN_AF;
3400492e:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_CLK_PIN;
34004930:	f8cd a014 	str.w	sl, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34004934:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_CLK_GPIO_PORT, &GPIO_InitStruct);
34004936:	f003 f9b3 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D0_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D0_PIN_AF;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  HAL_GPIO_Init(XSPI_RAM_D0_GPIO_PORT, &GPIO_InitStruct);
3400493a:	4855      	ldr	r0, [pc, #340]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
3400493c:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D0_PIN_AF;
3400493e:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D0_PIN;
34004940:	9505      	str	r5, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34004942:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_D0_GPIO_PORT, &GPIO_InitStruct);
34004944:	f003 f9ac 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D1_PIN;
34004948:	2202      	movs	r2, #2
  GPIO_InitStruct.Alternate = XSPI_RAM_D1_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D1_GPIO_PORT, &GPIO_InitStruct);
3400494a:	4851      	ldr	r0, [pc, #324]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
3400494c:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_D1_PIN;
3400494e:	9205      	str	r2, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_D1_PIN_AF;
34004950:	9409      	str	r4, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_RAM_D1_GPIO_PORT, &GPIO_InitStruct);
34004952:	f003 f9a5 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D2 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D2_PIN;
34004956:	2304      	movs	r3, #4
  GPIO_InitStruct.Alternate = XSPI_RAM_D2_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D2_GPIO_PORT, &GPIO_InitStruct);
34004958:	484d      	ldr	r0, [pc, #308]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
3400495a:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_D2_PIN;
3400495c:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_D2_PIN_AF;
3400495e:	9409      	str	r4, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_RAM_D2_GPIO_PORT, &GPIO_InitStruct);
34004960:	f003 f99e 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D3 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D3_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D3_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D3_GPIO_PORT, &GPIO_InitStruct);
34004964:	484a      	ldr	r0, [pc, #296]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
34004966:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D3_PIN_AF;
34004968:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D3_PIN;
3400496a:	f8cd b014 	str.w	fp, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D3_GPIO_PORT, &GPIO_InitStruct);
3400496e:	f003 f997 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D4 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D4_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D4_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D4_GPIO_PORT, &GPIO_InitStruct);
34004972:	4847      	ldr	r0, [pc, #284]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
34004974:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D4_PIN_AF;
34004976:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D4_PIN;
34004978:	f8cd a014 	str.w	sl, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D4_GPIO_PORT, &GPIO_InitStruct);
3400497c:	f003 f990 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D5 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D5_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D5_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D5_GPIO_PORT, &GPIO_InitStruct);
34004980:	4843      	ldr	r0, [pc, #268]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
34004982:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D5_PIN_AF;
34004984:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D5_PIN;
34004986:	f8cd 8014 	str.w	r8, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D5_GPIO_PORT, &GPIO_InitStruct);
3400498a:	f003 f989 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D6 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D6_PIN;
3400498e:	2340      	movs	r3, #64	@ 0x40
  GPIO_InitStruct.Alternate = XSPI_RAM_D6_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D6_GPIO_PORT, &GPIO_InitStruct);
34004990:	483f      	ldr	r0, [pc, #252]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
34004992:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D6_PIN_AF;
34004994:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D6_PIN;
34004996:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D6_GPIO_PORT, &GPIO_InitStruct);
34004998:	f003 f982 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D7 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D7_PIN;
3400499c:	2380      	movs	r3, #128	@ 0x80
  GPIO_InitStruct.Alternate = XSPI_RAM_D7_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D7_GPIO_PORT, &GPIO_InitStruct);
3400499e:	483c      	ldr	r0, [pc, #240]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
340049a0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D7_PIN_AF;
340049a2:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D7_PIN;
340049a4:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D7_GPIO_PORT, &GPIO_InitStruct);
340049a6:	f003 f97b 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D8 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D8_PIN;
340049aa:	f44f 7380 	mov.w	r3, #256	@ 0x100
  GPIO_InitStruct.Alternate = XSPI_RAM_D8_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D8_GPIO_PORT, &GPIO_InitStruct);
340049ae:	4838      	ldr	r0, [pc, #224]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
340049b0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D8_PIN_AF;
340049b2:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D8_PIN;
340049b4:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D8_GPIO_PORT, &GPIO_InitStruct);
340049b6:	f003 f973 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D9 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D9_PIN;
340049ba:	f44f 7300 	mov.w	r3, #512	@ 0x200
  GPIO_InitStruct.Alternate = XSPI_RAM_D9_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D9_GPIO_PORT, &GPIO_InitStruct);
340049be:	4834      	ldr	r0, [pc, #208]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
340049c0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D9_PIN_AF;
340049c2:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D9_PIN;
340049c4:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D9_GPIO_PORT, &GPIO_InitStruct);
340049c6:	f003 f96b 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D10 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D10_PIN;
340049ca:	f44f 6380 	mov.w	r3, #1024	@ 0x400
  GPIO_InitStruct.Alternate = XSPI_RAM_D10_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D10_GPIO_PORT, &GPIO_InitStruct);
340049ce:	4830      	ldr	r0, [pc, #192]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
340049d0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D10_PIN_AF;
340049d2:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D10_PIN;
340049d4:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D10_GPIO_PORT, &GPIO_InitStruct);
340049d6:	f003 f963 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D11 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D11_PIN;
340049da:	f44f 6300 	mov.w	r3, #2048	@ 0x800
  GPIO_InitStruct.Alternate = XSPI_RAM_D11_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D11_GPIO_PORT, &GPIO_InitStruct);
340049de:	482c      	ldr	r0, [pc, #176]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
340049e0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D11_PIN_AF;
340049e2:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D11_PIN;
340049e4:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D11_GPIO_PORT, &GPIO_InitStruct);
340049e6:	f003 f95b 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D12 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D12_PIN;
340049ea:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
  GPIO_InitStruct.Alternate = XSPI_RAM_D12_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D12_GPIO_PORT, &GPIO_InitStruct);
340049ee:	4828      	ldr	r0, [pc, #160]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
340049f0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_D12_PIN;
340049f2:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_D12_PIN_AF;
340049f4:	9409      	str	r4, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_RAM_D12_GPIO_PORT, &GPIO_InitStruct);
340049f6:	f003 f953 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D13 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D13_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D13_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D13_GPIO_PORT, &GPIO_InitStruct);
340049fa:	4825      	ldr	r0, [pc, #148]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
340049fc:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D13_PIN_AF;
340049fe:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D13_PIN;
34004a00:	9705      	str	r7, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D13_GPIO_PORT, &GPIO_InitStruct);
34004a02:	f003 f94d 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D14 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D14_PIN;
34004a06:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
  GPIO_InitStruct.Alternate = XSPI_RAM_D14_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D14_GPIO_PORT, &GPIO_InitStruct);
34004a0a:	4821      	ldr	r0, [pc, #132]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
34004a0c:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D14_PIN_AF;
34004a0e:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D14_PIN;
34004a10:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D14_GPIO_PORT, &GPIO_InitStruct);
34004a12:	f003 f945 	bl	34007ca0 <HAL_GPIO_Init>

  /* XSPI D15 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D15_PIN;
34004a16:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  GPIO_InitStruct.Alternate = XSPI_RAM_D15_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D15_GPIO_PORT, &GPIO_InitStruct);
34004a1a:	481d      	ldr	r0, [pc, #116]	@ (34004a90 <BSP_XSPI_RAM_Init+0x240>)
34004a1c:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D15_PIN_AF;
34004a1e:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D15_PIN;
34004a20:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D15_GPIO_PORT, &GPIO_InitStruct);
34004a22:	f003 f93d 	bl	34007ca0 <HAL_GPIO_Init>
      xspi_init.MemorySize     = HAL_XSPI_SIZE_256MB;
34004a26:	2318      	movs	r3, #24
34004a28:	9305      	str	r3, [sp, #20]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
34004a2a:	9b01      	ldr	r3, [sp, #4]
      if (MX_XSPI_RAM_Init(&hxspi_ram[Instance], &xspi_init) != HAL_OK)
34004a2c:	4819      	ldr	r0, [pc, #100]	@ (34004a94 <BSP_XSPI_RAM_Init+0x244>)
34004a2e:	a905      	add	r1, sp, #20
      xspi_init.ClockPrescaler = 3;
34004a30:	f8cd 9018 	str.w	r9, [sp, #24]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
34004a34:	9307      	str	r3, [sp, #28]
      if (MX_XSPI_RAM_Init(&hxspi_ram[Instance], &xspi_init) != HAL_OK)
34004a36:	f7ff fed7 	bl	340047e8 <MX_XSPI_RAM_Init>
  int32_t ret = BSP_ERROR_NONE;
34004a3a:	2800      	cmp	r0, #0
34004a3c:	bf14      	ite	ne
34004a3e:	f06f 0403 	mvnne.w	r4, #3
34004a42:	2400      	moveq	r4, #0
      XSPI_Ram_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
34004a44:	7035      	strb	r5, [r6, #0]
      XSPI_Ram_Ctx[Instance].LatencyType   = BSP_XSPI_RAM_FIXED_LATENCY;
34004a46:	7075      	strb	r5, [r6, #1]
      XSPI_Ram_Ctx[Instance].BurstType     = BSP_XSPI_RAM_LINEAR_BURST;
34004a48:	70b5      	strb	r5, [r6, #2]
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 0, 0x30));
34004a4a:	2230      	movs	r2, #48	@ 0x30
34004a4c:	2100      	movs	r1, #0
34004a4e:	4811      	ldr	r0, [pc, #68]	@ (34004a94 <BSP_XSPI_RAM_Init+0x244>)
34004a50:	f7fe fb4a 	bl	340030e8 <APS256XX_WriteReg>
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 4, 0x20));
34004a54:	2220      	movs	r2, #32
34004a56:	2104      	movs	r1, #4
34004a58:	480e      	ldr	r0, [pc, #56]	@ (34004a94 <BSP_XSPI_RAM_Init+0x244>)
34004a5a:	f7fe fb45 	bl	340030e8 <APS256XX_WriteReg>
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 8, 0x40));
34004a5e:	2108      	movs	r1, #8
34004a60:	2240      	movs	r2, #64	@ 0x40
34004a62:	480c      	ldr	r0, [pc, #48]	@ (34004a94 <BSP_XSPI_RAM_Init+0x244>)
34004a64:	f7fe fb40 	bl	340030e8 <APS256XX_WriteReg>
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_ram[Instance], 0));
34004a68:	2100      	movs	r1, #0
34004a6a:	480a      	ldr	r0, [pc, #40]	@ (34004a94 <BSP_XSPI_RAM_Init+0x244>)
34004a6c:	f00b fc36 	bl	340102dc <HAL_XSPI_SetClockPrescaler>
}
34004a70:	4620      	mov	r0, r4
34004a72:	b00b      	add	sp, #44	@ 0x2c
34004a74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ret = BSP_ERROR_WRONG_PARAM;
34004a78:	f06f 0401 	mvn.w	r4, #1
  return ret;
34004a7c:	e7f8      	b.n	34004a70 <BSP_XSPI_RAM_Init+0x220>
34004a7e:	bf00      	nop
34004a80:	340cdeb4 	.word	0x340cdeb4
34004a84:	56028000 	.word	0x56028000
34004a88:	56029000 	.word	0x56029000
34004a8c:	56023800 	.word	0x56023800
34004a90:	56023c00 	.word	0x56023c00
34004a94:	340cdeb8 	.word	0x340cdeb8

34004a98 <BSP_XSPI_RAM_EnableMemoryMappedMode>:
{
34004a98:	b507      	push	{r0, r1, r2, lr}
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
34004a9a:	b968      	cbnz	r0, 34004ab8 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x20>
    if (APS256XX_EnableMemoryMappedMode(&hxspi_ram[Instance], 7, 7, 1, 0) != APS256XX_OK)
34004a9c:	2207      	movs	r2, #7
34004a9e:	9000      	str	r0, [sp, #0]
34004aa0:	2301      	movs	r3, #1
34004aa2:	4611      	mov	r1, r2
34004aa4:	4806      	ldr	r0, [pc, #24]	@ (34004ac0 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x28>)
34004aa6:	f7fe fac4 	bl	34003032 <APS256XX_EnableMemoryMappedMode>
      ret = BSP_ERROR_PERIPH_FAILURE;
34004aaa:	2800      	cmp	r0, #0
34004aac:	bf18      	it	ne
34004aae:	f06f 0003 	mvnne.w	r0, #3
}
34004ab2:	b003      	add	sp, #12
34004ab4:	f85d fb04 	ldr.w	pc, [sp], #4
    ret = BSP_ERROR_WRONG_PARAM;
34004ab8:	f06f 0001 	mvn.w	r0, #1
34004abc:	e7f9      	b.n	34004ab2 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x1a>
34004abe:	bf00      	nop
34004ac0:	340cdeb8 	.word	0x340cdeb8

34004ac4 <SystemInit>:

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34004ac4:	4b44      	ldr	r3, [pc, #272]	@ (34004bd8 <SystemInit+0x114>)
34004ac6:	4a45      	ldr	r2, [pc, #276]	@ (34004bdc <SystemInit+0x118>)
{
34004ac8:	b570      	push	{r4, r5, r6, lr}
#endif  /* USER_VECT_TAB_ADDRESS */

  /* RNG reset */
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
34004aca:	2001      	movs	r0, #1
  SCB->VTOR = INTVECT_START;
34004acc:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
  SAU->RLAR = 0;
  SAU->RNR = 1;
  SAU->RBAR = 0;
  SAU->RLAR = 0;
  SAU->RNR = 2;
34004ace:	2502      	movs	r5, #2
  SAU->RNR = 0;
34004ad0:	2200      	movs	r2, #0
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
34004ad2:	4943      	ldr	r1, [pc, #268]	@ (34004be0 <SystemInit+0x11c>)
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34004ad4:	4e43      	ldr	r6, [pc, #268]	@ (34004be4 <SystemInit+0x120>)
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
34004ad6:	f501 5480 	add.w	r4, r1, #4096	@ 0x1000
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
34004ada:	f8c1 0a18 	str.w	r0, [r1, #2584]	@ 0xa18
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
34004ade:	f8c4 0218 	str.w	r0, [r4, #536]	@ 0x218
  RCC->AHB3ENCR = RCC_AHB3ENCR_RNGENC;
34004ae2:	f8c4 0258 	str.w	r0, [r4, #600]	@ 0x258
  SAU->RNR = 0;
34004ae6:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SAU->RBAR = 0;
34004aea:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
34004aee:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 1;
34004af2:	f8c3 00d8 	str.w	r0, [r3, #216]	@ 0xd8
  SAU->RBAR = 0;
34004af6:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
34004afa:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 2;
34004afe:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 3;
34004b02:	2503      	movs	r5, #3
  SAU->RBAR = 0;
34004b04:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
34004b08:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 3;
34004b0c:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 4;
34004b10:	2504      	movs	r5, #4
  SAU->RBAR = 0;
34004b12:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
34004b16:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 4;
34004b1a:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 5;
34004b1e:	2505      	movs	r5, #5
  SAU->RBAR = 0;
34004b20:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
34004b24:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 5;
34004b28:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 6;
34004b2c:	2506      	movs	r5, #6
  SAU->RBAR = 0;
34004b2e:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
34004b32:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 6;
34004b36:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 7;
34004b3a:	2507      	movs	r5, #7
  SAU->RBAR = 0;
34004b3c:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
34004b40:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 7;
34004b44:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RBAR = 0;
34004b48:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
34004b4c:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
34004b50:	f8c1 0a78 	str.w	r0, [r1, #2680]	@ 0xa78
  (void)RCC->APB4ENR2;
34004b54:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
  SYSCFG->INITSVTORCR = SCB->VTOR;
34004b58:	689a      	ldr	r2, [r3, #8]
34004b5a:	6132      	str	r2, [r6, #16]

  /* Enable VDDADC CLAMP */
  PWR->SVMCR3 |= PWR_SVMCR3_ASV;
34004b5c:	4a22      	ldr	r2, [pc, #136]	@ (34004be8 <SystemInit+0x124>)
34004b5e:	6bd5      	ldr	r5, [r2, #60]	@ 0x3c
34004b60:	f445 5580 	orr.w	r5, r5, #4096	@ 0x1000
34004b64:	63d5      	str	r5, [r2, #60]	@ 0x3c
  PWR->SVMCR3 |= PWR_SVMCR3_AVMEN;
34004b66:	6bd5      	ldr	r5, [r2, #60]	@ 0x3c
34004b68:	f045 0510 	orr.w	r5, r5, #16
34004b6c:	63d5      	str	r5, [r2, #60]	@ 0x3c
  /* read back the register to make sure that the transaction has taken place */
  (void) PWR->SVMCR3;
34004b6e:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
  /* enable VREF */
  RCC->APB4ENR1 |= RCC_APB4ENR1_VREFBUFEN;
34004b70:	f8d1 2274 	ldr.w	r2, [r1, #628]	@ 0x274
34004b74:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34004b78:	f8c1 2274 	str.w	r2, [r1, #628]	@ 0x274

  /* RCC Fix to lower power consumption */
  RCC->APB4ENR2 |= 0x00000010UL;
34004b7c:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
34004b80:	f042 0210 	orr.w	r2, r2, #16
34004b84:	f8c1 2278 	str.w	r2, [r1, #632]	@ 0x278
  (void) RCC->APB4ENR2;
34004b88:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
  RCC->APB4ENR2 &= ~(0x00000010UL);
34004b8c:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
34004b90:	f022 0210 	bic.w	r2, r2, #16
34004b94:	f8c1 2278 	str.w	r2, [r1, #632]	@ 0x278

  /* XSPI2 & XSPIM reset                                  */
  RCC->AHB5RSTSR = RCC_AHB5RSTSR_XSPIMRSTS | RCC_AHB5RSTSR_XSPI2RSTS;
34004b98:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
34004b9c:	f8c1 2a20 	str.w	r2, [r1, #2592]	@ 0xa20
  RCC->AHB5RSTCR = RCC_AHB5RSTCR_XSPIMRSTC | RCC_AHB5RSTCR_XSPI2RSTC;
34004ba0:	f8c4 2220 	str.w	r2, [r4, #544]	@ 0x220
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
  /* Deactivate TIM2 clock */
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;

  /* Deactivate GPIOG clock */
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34004ba4:	2240      	movs	r2, #64	@ 0x40
  RCC->APB1RSTSR1 = RCC_APB1RSTSR1_TIM2RSTS;
34004ba6:	f8c1 0a24 	str.w	r0, [r1, #2596]	@ 0xa24
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
34004baa:	f8c4 0224 	str.w	r0, [r4, #548]	@ 0x224
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;
34004bae:	f8c4 0264 	str.w	r0, [r4, #612]	@ 0x264
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34004bb2:	f8c4 225c 	str.w	r2, [r4, #604]	@ 0x25c

  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
34004bb6:	6932      	ldr	r2, [r6, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34004bb8:	f8c4 0278 	str.w	r0, [r4, #632]	@ 0x278
  TZ_SAU_Setup();
#endif /* USER_TZ_SAU_SETUP */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34004bbc:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
34004bc0:	f442 0270 	orr.w	r2, r2, #15728640	@ 0xf00000
34004bc4:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34004bc8:	4a08      	ldr	r2, [pc, #32]	@ (34004bec <SystemInit+0x128>)
34004bca:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
34004bce:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34004bd2:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34004bd6:	bd70      	pop	{r4, r5, r6, pc}
34004bd8:	e000ed00 	.word	0xe000ed00
34004bdc:	34000400 	.word	0x34000400
34004be0:	56028000 	.word	0x56028000
34004be4:	56008000 	.word	0x56008000
34004be8:	56024800 	.word	0x56024800
34004bec:	e002ed00 	.word	0xe002ed00

34004bf0 <SystemCoreClockUpdate>:
  uint32_t pllp2 = 0;
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34004bf0:	4b6e      	ldr	r3, [pc, #440]	@ (34004dac <SystemCoreClockUpdate+0x1bc>)
{
34004bf2:	b5f0      	push	{r4, r5, r6, r7, lr}
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34004bf4:	6a1a      	ldr	r2, [r3, #32]
34004bf6:	f402 1240 	and.w	r2, r2, #3145728	@ 0x300000
34004bfa:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
34004bfe:	f000 80b8 	beq.w	34004d72 <SystemCoreClockUpdate+0x182>
34004c02:	d806      	bhi.n	34004c12 <SystemCoreClockUpdate+0x22>
34004c04:	b962      	cbnz	r2, 34004c20 <SystemCoreClockUpdate+0x30>
  {
  case 0:  /* HSI used as system clock source (default after reset) */
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34004c06:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34004c08:	4b69      	ldr	r3, [pc, #420]	@ (34004db0 <SystemCoreClockUpdate+0x1c0>)
34004c0a:	f3c2 12c1 	ubfx	r2, r2, #7, #2
34004c0e:	40d3      	lsrs	r3, r2
    break;
34004c10:	e003      	b.n	34004c1a <SystemCoreClockUpdate+0x2a>
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34004c12:	f5b2 1f40 	cmp.w	r2, #3145728	@ 0x300000
34004c16:	d00b      	beq.n	34004c30 <SystemCoreClockUpdate+0x40>
  uint32_t sysclk = 0;
34004c18:	2300      	movs	r3, #0
    /* Nothing to do, should not occur */
    break;
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
34004c1a:	4a66      	ldr	r2, [pc, #408]	@ (34004db4 <SystemCoreClockUpdate+0x1c4>)
34004c1c:	6013      	str	r3, [r2, #0]
}
34004c1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34004c20:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
      sysclk = MSI_VALUE;
34004c22:	4a65      	ldr	r2, [pc, #404]	@ (34004db8 <SystemCoreClockUpdate+0x1c8>)
34004c24:	f413 7f00 	tst.w	r3, #512	@ 0x200
34004c28:	4b64      	ldr	r3, [pc, #400]	@ (34004dbc <SystemCoreClockUpdate+0x1cc>)
34004c2a:	bf08      	it	eq
34004c2c:	4613      	moveq	r3, r2
34004c2e:	e7f4      	b.n	34004c1a <SystemCoreClockUpdate+0x2a>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34004c30:	f8d3 20c4 	ldr.w	r2, [r3, #196]	@ 0xc4
34004c34:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
34004c38:	f1b2 5f80 	cmp.w	r2, #268435456	@ 0x10000000
34004c3c:	d02a      	beq.n	34004c94 <SystemCoreClockUpdate+0xa4>
34004c3e:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
34004c42:	d036      	beq.n	34004cb2 <SystemCoreClockUpdate+0xc2>
34004c44:	2a00      	cmp	r2, #0
34004c46:	d143      	bne.n	34004cd0 <SystemCoreClockUpdate+0xe0>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34004c48:	f8d3 7080 	ldr.w	r7, [r3, #128]	@ 0x80
      if (pllbypass == 0U)
34004c4c:	013d      	lsls	r5, r7, #4
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34004c4e:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
34004c52:	f100 8096 	bmi.w	34004d82 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34004c56:	f8d3 0084 	ldr.w	r0, [r3, #132]	@ 0x84
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
34004c5a:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
34004c5e:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34004c62:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34004c66:	460e      	mov	r6, r1
    switch (pllsource)
34004c68:	f1b6 5f00 	cmp.w	r6, #536870912	@ 0x20000000
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
34004c6c:	f3c2 65c2 	ubfx	r5, r2, #27, #3
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34004c70:	f3c7 5105 	ubfx	r1, r7, #20, #6
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
34004c74:	f3c2 6202 	ubfx	r2, r2, #24, #3
    switch (pllsource)
34004c78:	d04f      	beq.n	34004d1a <SystemCoreClockUpdate+0x12a>
34004c7a:	d87c      	bhi.n	34004d76 <SystemCoreClockUpdate+0x186>
34004c7c:	2e00      	cmp	r6, #0
34004c7e:	d03c      	beq.n	34004cfa <SystemCoreClockUpdate+0x10a>
34004c80:	2600      	movs	r6, #0
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34004c82:	4b4a      	ldr	r3, [pc, #296]	@ (34004dac <SystemCoreClockUpdate+0x1bc>)
        sysclk = MSI_VALUE;
34004c84:	4f4c      	ldr	r7, [pc, #304]	@ (34004db8 <SystemCoreClockUpdate+0x1c8>)
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34004c86:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        sysclk = MSI_VALUE;
34004c88:	f413 7f00 	tst.w	r3, #512	@ 0x200
34004c8c:	4b4b      	ldr	r3, [pc, #300]	@ (34004dbc <SystemCoreClockUpdate+0x1cc>)
34004c8e:	bf08      	it	eq
34004c90:	463b      	moveq	r3, r7
34004c92:	e038      	b.n	34004d06 <SystemCoreClockUpdate+0x116>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
34004c94:	f8d3 7090 	ldr.w	r7, [r3, #144]	@ 0x90
      if (pllbypass == 0U)
34004c98:	013c      	lsls	r4, r7, #4
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
34004c9a:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
34004c9e:	d470      	bmi.n	34004d82 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34004ca0:	f8d3 0094 	ldr.w	r0, [r3, #148]	@ 0x94
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34004ca4:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
34004ca8:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34004cac:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34004cb0:	e7d9      	b.n	34004c66 <SystemCoreClockUpdate+0x76>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
34004cb2:	f8d3 70a0 	ldr.w	r7, [r3, #160]	@ 0xa0
      if (pllbypass == 0U)
34004cb6:	0138      	lsls	r0, r7, #4
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
34004cb8:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
34004cbc:	d461      	bmi.n	34004d82 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34004cbe:	f8d3 00a4 	ldr.w	r0, [r3, #164]	@ 0xa4
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34004cc2:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34004cc6:	f8d3 20a8 	ldr.w	r2, [r3, #168]	@ 0xa8
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34004cca:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34004cce:	e7ca      	b.n	34004c66 <SystemCoreClockUpdate+0x76>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
34004cd0:	f8d3 70b0 	ldr.w	r7, [r3, #176]	@ 0xb0
      if (pllbypass == 0U)
34004cd4:	013a      	lsls	r2, r7, #4
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34004cd6:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
34004cda:	d452      	bmi.n	34004d82 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34004cdc:	f8d3 00b4 	ldr.w	r0, [r3, #180]	@ 0xb4
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34004ce0:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34004ce4:	f8d3 20b8 	ldr.w	r2, [r3, #184]	@ 0xb8
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34004ce8:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34004cec:	e7bb      	b.n	34004c66 <SystemCoreClockUpdate+0x76>
    switch (pllsource)
34004cee:	460a      	mov	r2, r1
34004cf0:	460d      	mov	r5, r1
34004cf2:	4608      	mov	r0, r1
34004cf4:	460c      	mov	r4, r1
34004cf6:	f04f 6600 	mov.w	r6, #134217728	@ 0x8000000
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34004cfa:	4b2c      	ldr	r3, [pc, #176]	@ (34004dac <SystemCoreClockUpdate+0x1bc>)
34004cfc:	6c9f      	ldr	r7, [r3, #72]	@ 0x48
34004cfe:	4b2c      	ldr	r3, [pc, #176]	@ (34004db0 <SystemCoreClockUpdate+0x1c0>)
34004d00:	f3c7 17c1 	ubfx	r7, r7, #7, #2
34004d04:	40fb      	lsrs	r3, r7
    if (pllbypass == 0U)
34004d06:	b14e      	cbz	r6, 34004d1c <SystemCoreClockUpdate+0x12c>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
34004d08:	4a28      	ldr	r2, [pc, #160]	@ (34004dac <SystemCoreClockUpdate+0x1bc>)
34004d0a:	f8d2 20c4 	ldr.w	r2, [r2, #196]	@ 0xc4
34004d0e:	f3c2 4207 	ubfx	r2, r2, #16, #8
34004d12:	3201      	adds	r2, #1
    sysclk = sysclk / ic_divider;
34004d14:	fbb3 f3f2 	udiv	r3, r3, r2
    break;
34004d18:	e77f      	b.n	34004c1a <SystemCoreClockUpdate+0x2a>
      sysclk = HSE_VALUE;
34004d1a:	4b29      	ldr	r3, [pc, #164]	@ (34004dc0 <SystemCoreClockUpdate+0x1d0>)
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34004d1c:	ee07 0a10 	vmov	s14, r0
34004d20:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
34004d24:	ee07 4a10 	vmov	s14, r4
34004d28:	ee07 3a90 	vmov	s15, r3
34004d2c:	eddf 6a25 	vldr	s13, [pc, #148]	@ 34004dc4 <SystemCoreClockUpdate+0x1d4>
34004d30:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34004d34:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34004d38:	eea6 7a26 	vfma.f32	s14, s12, s13
34004d3c:	ee67 7a87 	vmul.f32	s15, s15, s14
34004d40:	ee07 1a10 	vmov	s14, r1
34004d44:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34004d48:	eec7 6a87 	vdiv.f32	s13, s15, s14
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
34004d4c:	ee07 5a90 	vmov	s15, r5
34004d50:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
34004d54:	ee07 2a90 	vmov	s15, r2
34004d58:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34004d5c:	ee27 7a27 	vmul.f32	s14, s14, s15
34004d60:	eec6 7a87 	vdiv.f32	s15, s13, s14
34004d64:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34004d68:	ee17 3a90 	vmov	r3, s15
34004d6c:	e7cc      	b.n	34004d08 <SystemCoreClockUpdate+0x118>
      sysclk = HSE_VALUE;
34004d6e:	4b14      	ldr	r3, [pc, #80]	@ (34004dc0 <SystemCoreClockUpdate+0x1d0>)
34004d70:	e7ca      	b.n	34004d08 <SystemCoreClockUpdate+0x118>
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34004d72:	4b13      	ldr	r3, [pc, #76]	@ (34004dc0 <SystemCoreClockUpdate+0x1d0>)
34004d74:	e751      	b.n	34004c1a <SystemCoreClockUpdate+0x2a>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34004d76:	f1b6 5f40 	cmp.w	r6, #805306368	@ 0x30000000
34004d7a:	4b13      	ldr	r3, [pc, #76]	@ (34004dc8 <SystemCoreClockUpdate+0x1d8>)
34004d7c:	bf18      	it	ne
34004d7e:	2300      	movne	r3, #0
34004d80:	e7cc      	b.n	34004d1c <SystemCoreClockUpdate+0x12c>
    switch (pllsource)
34004d82:	f1b1 5f00 	cmp.w	r1, #536870912	@ 0x20000000
34004d86:	d0f2      	beq.n	34004d6e <SystemCoreClockUpdate+0x17e>
34004d88:	d809      	bhi.n	34004d9e <SystemCoreClockUpdate+0x1ae>
34004d8a:	2900      	cmp	r1, #0
34004d8c:	d0af      	beq.n	34004cee <SystemCoreClockUpdate+0xfe>
34004d8e:	2200      	movs	r2, #0
34004d90:	f04f 6600 	mov.w	r6, #134217728	@ 0x8000000
34004d94:	4615      	mov	r5, r2
34004d96:	4610      	mov	r0, r2
34004d98:	4614      	mov	r4, r2
34004d9a:	4611      	mov	r1, r2
34004d9c:	e771      	b.n	34004c82 <SystemCoreClockUpdate+0x92>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34004d9e:	f1b1 5f40 	cmp.w	r1, #805306368	@ 0x30000000
34004da2:	4b09      	ldr	r3, [pc, #36]	@ (34004dc8 <SystemCoreClockUpdate+0x1d8>)
34004da4:	bf18      	it	ne
34004da6:	2300      	movne	r3, #0
34004da8:	e7ae      	b.n	34004d08 <SystemCoreClockUpdate+0x118>
34004daa:	bf00      	nop
34004dac:	56028000 	.word	0x56028000
34004db0:	03d09000 	.word	0x03d09000
34004db4:	340b0f2c 	.word	0x340b0f2c
34004db8:	003d0900 	.word	0x003d0900
34004dbc:	00f42400 	.word	0x00f42400
34004dc0:	02dc6c00 	.word	0x02dc6c00
34004dc4:	33800000 	.word	0x33800000
34004dc8:	00bb8000 	.word	0x00bb8000

34004dcc <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34004dcc:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34004dd0:	b500      	push	{lr}
  SystemCoreClockUpdate();
34004dd2:	f7ff ff0d 	bl	34004bf0 <SystemCoreClockUpdate>

  return SystemCoreClock;
}
34004dd6:	4b05      	ldr	r3, [pc, #20]	@ (34004dec <__acle_se_SECURE_SystemCoreClockUpdate+0x20>)
34004dd8:	f85d eb04 	ldr.w	lr, [sp], #4
34004ddc:	6818      	ldr	r0, [r3, #0]
34004dde:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34004de2:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34004de6:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34004dea:	4774      	bxns	lr
34004dec:	340b0f2c 	.word	0x340b0f2c

34004df0 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
34004df0:	4770      	bx	lr
	...

34004df4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
34004df4:	b538      	push	{r3, r4, r5, lr}
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
34004df6:	4b0f      	ldr	r3, [pc, #60]	@ (34004e34 <HAL_InitTick+0x40>)
{
34004df8:	4605      	mov	r5, r0
  if ((uint32_t)uwTickFreq == 0UL)
34004dfa:	781a      	ldrb	r2, [r3, #0]
34004dfc:	b90a      	cbnz	r2, 34004e02 <HAL_InitTick+0xe>
  {
    return HAL_ERROR;
34004dfe:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
34004e00:	bd38      	pop	{r3, r4, r5, pc}
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
34004e02:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34004e06:	fbb3 f3f2 	udiv	r3, r3, r2
34004e0a:	4a0b      	ldr	r2, [pc, #44]	@ (34004e38 <HAL_InitTick+0x44>)
34004e0c:	6810      	ldr	r0, [r2, #0]
34004e0e:	fbb0 f0f3 	udiv	r0, r0, r3
34004e12:	f000 f9f1 	bl	340051f8 <HAL_SYSTICK_Config>
34004e16:	4604      	mov	r4, r0
34004e18:	2800      	cmp	r0, #0
34004e1a:	d1f0      	bne.n	34004dfe <HAL_InitTick+0xa>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
34004e1c:	2d0f      	cmp	r5, #15
34004e1e:	d8ee      	bhi.n	34004dfe <HAL_InitTick+0xa>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
34004e20:	4602      	mov	r2, r0
34004e22:	4629      	mov	r1, r5
34004e24:	f04f 30ff 	mov.w	r0, #4294967295
34004e28:	f000 f974 	bl	34005114 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
34004e2c:	4b03      	ldr	r3, [pc, #12]	@ (34004e3c <HAL_InitTick+0x48>)
34004e2e:	4620      	mov	r0, r4
34004e30:	601d      	str	r5, [r3, #0]
  return HAL_OK;
34004e32:	e7e5      	b.n	34004e00 <HAL_InitTick+0xc>
34004e34:	340b0f30 	.word	0x340b0f30
34004e38:	340b0f2c 	.word	0x340b0f2c
34004e3c:	340b0f34 	.word	0x340b0f34

34004e40 <HAL_Init>:
{
34004e40:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
34004e42:	2003      	movs	r0, #3
34004e44:	f000 f948 	bl	340050d8 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
34004e48:	f7ff fed2 	bl	34004bf0 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
34004e4c:	200f      	movs	r0, #15
34004e4e:	f7ff ffd1 	bl	34004df4 <HAL_InitTick>
34004e52:	4604      	mov	r4, r0
34004e54:	b918      	cbnz	r0, 34004e5e <HAL_Init+0x1e>
  HAL_MspInit();
34004e56:	f7ff ffcb 	bl	34004df0 <HAL_MspInit>
}
34004e5a:	4620      	mov	r0, r4
34004e5c:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34004e5e:	2401      	movs	r4, #1
34004e60:	e7fb      	b.n	34004e5a <HAL_Init+0x1a>
	...

34004e64 <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
34004e64:	4a03      	ldr	r2, [pc, #12]	@ (34004e74 <HAL_IncTick+0x10>)
34004e66:	4b04      	ldr	r3, [pc, #16]	@ (34004e78 <HAL_IncTick+0x14>)
34004e68:	6811      	ldr	r1, [r2, #0]
34004e6a:	781b      	ldrb	r3, [r3, #0]
34004e6c:	440b      	add	r3, r1
34004e6e:	6013      	str	r3, [r2, #0]
}
34004e70:	4770      	bx	lr
34004e72:	bf00      	nop
34004e74:	340cdf84 	.word	0x340cdf84
34004e78:	340b0f30 	.word	0x340b0f30

34004e7c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
34004e7c:	4b01      	ldr	r3, [pc, #4]	@ (34004e84 <HAL_GetTick+0x8>)
34004e7e:	6818      	ldr	r0, [r3, #0]
}
34004e80:	4770      	bx	lr
34004e82:	bf00      	nop
34004e84:	340cdf84 	.word	0x340cdf84

34004e88 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay Specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
34004e88:	b538      	push	{r3, r4, r5, lr}
34004e8a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
34004e8c:	f7ff fff6 	bl	34004e7c <HAL_GetTick>
34004e90:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
34004e92:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
34004e94:	bf1e      	ittt	ne
34004e96:	4b04      	ldrne	r3, [pc, #16]	@ (34004ea8 <HAL_Delay+0x20>)
34004e98:	781b      	ldrbne	r3, [r3, #0]
34004e9a:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
34004e9c:	f7ff ffee 	bl	34004e7c <HAL_GetTick>
34004ea0:	1b43      	subs	r3, r0, r5
34004ea2:	42a3      	cmp	r3, r4
34004ea4:	d3fa      	bcc.n	34004e9c <HAL_Delay+0x14>
  {
  }
}
34004ea6:	bd38      	pop	{r3, r4, r5, pc}
34004ea8:	340b0f30 	.word	0x340b0f30

34004eac <HAL_BSEC_OTP_Reload>:
  * @param  FuseId  Fuse to be reload, this parameter value is between 0 and BSEC_NB_FUSES-1
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_BSEC_OTP_Reload(BSEC_HandleTypeDef *hbsec, uint32_t FuseId)
{
34004eac:	b570      	push	{r4, r5, r6, lr}
34004eae:	4604      	mov	r4, r0
34004eb0:	460d      	mov	r5, r1
  uint32_t status_reg;
  uint32_t status_bit;
  uint32_t tick_start = HAL_GetTick();
34004eb2:	f7ff ffe3 	bl	34004e7c <HAL_GetTick>
34004eb6:	4606      	mov	r6, r0

  /* Check the handle pointer */
  if (hbsec == NULL)
34004eb8:	b12c      	cbz	r4, 34004ec6 <HAL_BSEC_OTP_Reload+0x1a>
  {
    return HAL_ERROR;
  }

  /* Check the instance */
 if (hbsec->Instance != BSEC)
34004eba:	6822      	ldr	r2, [r4, #0]
34004ebc:	4b1b      	ldr	r3, [pc, #108]	@ (34004f2c <HAL_BSEC_OTP_Reload+0x80>)
34004ebe:	429a      	cmp	r2, r3
34004ec0:	d003      	beq.n	34004eca <HAL_BSEC_OTP_Reload+0x1e>
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
34004ec2:	2301      	movs	r3, #1
34004ec4:	6063      	str	r3, [r4, #4]
    return HAL_ERROR;
34004ec6:	2001      	movs	r0, #1
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
    return HAL_ERROR;
  }

  return HAL_OK;
}
34004ec8:	bd70      	pop	{r4, r5, r6, pc}
  if (FuseId < BSEC_NB_FUSES)
34004eca:	f5b5 7fbc 	cmp.w	r5, #376	@ 0x178
34004ece:	d2f8      	bcs.n	34004ec2 <HAL_BSEC_OTP_Reload+0x16>
    status_reg = FuseId / 32U;
34004ed0:	096b      	lsrs	r3, r5, #5
    if ((hbsec->Instance->SRLOCKx[status_reg] & status_bit) == 0U)
34004ed2:	f503 7308 	add.w	r3, r3, #544	@ 0x220
34004ed6:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    status_bit = (uint32_t)(1UL << (FuseId % 32U));
34004eda:	2301      	movs	r3, #1
34004edc:	f005 001f 	and.w	r0, r5, #31
34004ee0:	4083      	lsls	r3, r0
    if ((hbsec->Instance->SRLOCKx[status_reg] & status_bit) == 0U)
34004ee2:	420b      	tst	r3, r1
34004ee4:	d11f      	bne.n	34004f26 <HAL_BSEC_OTP_Reload+0x7a>
      MODIFY_REG(hbsec->Instance->OTPCR, (BSEC_OTPCR_PPLOCK | BSEC_OTPCR_PROG | BSEC_OTPCR_ADDR), FuseId);
34004ee6:	f8d2 3c04 	ldr.w	r3, [r2, #3076]	@ 0xc04
34004eea:	f423 43c3 	bic.w	r3, r3, #24960	@ 0x6180
34004eee:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34004ef2:	432b      	orrs	r3, r5
34004ef4:	f8c2 3c04 	str.w	r3, [r2, #3076]	@ 0xc04
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
34004ef8:	6823      	ldr	r3, [r4, #0]
34004efa:	f8d3 2e44 	ldr.w	r2, [r3, #3652]	@ 0xe44
34004efe:	07d2      	lsls	r2, r2, #31
34004f00:	d409      	bmi.n	34004f16 <HAL_BSEC_OTP_Reload+0x6a>
      if ((hbsec->Instance->OTPSR & BSEC_OTPSR_RELOAD_ERRORS) != 0U)
34004f02:	f8d3 0e44 	ldr.w	r0, [r3, #3652]	@ 0xe44
34004f06:	f410 008c 	ands.w	r0, r0, #4587520	@ 0x460000
34004f0a:	d0dd      	beq.n	34004ec8 <HAL_BSEC_OTP_Reload+0x1c>
        hbsec->ErrorCode = (hbsec->Instance->OTPSR & BSEC_OTPSR_RELOAD_ERRORS);
34004f0c:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
34004f10:	f403 038c 	and.w	r3, r3, #4587520	@ 0x460000
34004f14:	e7d6      	b.n	34004ec4 <HAL_BSEC_OTP_Reload+0x18>
        if ((HAL_GetTick() - tick_start) > BSEC_TIMEOUT)
34004f16:	f7ff ffb1 	bl	34004e7c <HAL_GetTick>
34004f1a:	1b80      	subs	r0, r0, r6
34004f1c:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
34004f20:	d9ea      	bls.n	34004ef8 <HAL_BSEC_OTP_Reload+0x4c>
          hbsec->ErrorCode = HAL_BSEC_ERROR_TIMEOUT;
34004f22:	230a      	movs	r3, #10
34004f24:	e7ce      	b.n	34004ec4 <HAL_BSEC_OTP_Reload+0x18>
      hbsec->ErrorCode = HAL_BSEC_ERROR_LOCK;
34004f26:	2304      	movs	r3, #4
34004f28:	e7cc      	b.n	34004ec4 <HAL_BSEC_OTP_Reload+0x18>
34004f2a:	bf00      	nop
34004f2c:	56009000 	.word	0x56009000

34004f30 <HAL_BSEC_OTP_Read>:
{
34004f30:	b570      	push	{r4, r5, r6, lr}
34004f32:	460e      	mov	r6, r1
34004f34:	4615      	mov	r5, r2
  if (hbsec == NULL)
34004f36:	4604      	mov	r4, r0
34004f38:	b130      	cbz	r0, 34004f48 <HAL_BSEC_OTP_Read+0x18>
 if ((pFuseData == NULL) || (hbsec->Instance != BSEC))
34004f3a:	b11a      	cbz	r2, 34004f44 <HAL_BSEC_OTP_Read+0x14>
34004f3c:	6802      	ldr	r2, [r0, #0]
34004f3e:	4b09      	ldr	r3, [pc, #36]	@ (34004f64 <HAL_BSEC_OTP_Read+0x34>)
34004f40:	429a      	cmp	r2, r3
34004f42:	d003      	beq.n	34004f4c <HAL_BSEC_OTP_Read+0x1c>
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
34004f44:	2301      	movs	r3, #1
34004f46:	6063      	str	r3, [r4, #4]
    return HAL_ERROR;
34004f48:	2001      	movs	r0, #1
}
34004f4a:	bd70      	pop	{r4, r5, r6, pc}
  if (FuseId < BSEC_NB_FUSES)
34004f4c:	f5b1 7fbc 	cmp.w	r1, #376	@ 0x178
34004f50:	d2f8      	bcs.n	34004f44 <HAL_BSEC_OTP_Read+0x14>
    if (HAL_BSEC_OTP_Reload(hbsec, FuseId) == HAL_OK)
34004f52:	f7ff ffab 	bl	34004eac <HAL_BSEC_OTP_Reload>
34004f56:	2800      	cmp	r0, #0
34004f58:	d1f6      	bne.n	34004f48 <HAL_BSEC_OTP_Read+0x18>
      *pFuseData = hbsec->Instance->FVRw[FuseId];
34004f5a:	6823      	ldr	r3, [r4, #0]
34004f5c:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
34004f60:	602b      	str	r3, [r5, #0]
  return HAL_OK;
34004f62:	e7f2      	b.n	34004f4a <HAL_BSEC_OTP_Read+0x1a>
34004f64:	56009000 	.word	0x56009000

34004f68 <HAL_BSEC_OTP_Program>:
{
34004f68:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
34004f6c:	4604      	mov	r4, r0
34004f6e:	460e      	mov	r6, r1
34004f70:	4617      	mov	r7, r2
34004f72:	4699      	mov	r9, r3
  uint32_t tick_start = HAL_GetTick();
34004f74:	f7ff ff82 	bl	34004e7c <HAL_GetTick>
34004f78:	4680      	mov	r8, r0
  if (hbsec == NULL)
34004f7a:	b12c      	cbz	r4, 34004f88 <HAL_BSEC_OTP_Program+0x20>
 if (hbsec->Instance != BSEC)
34004f7c:	6822      	ldr	r2, [r4, #0]
34004f7e:	4b28      	ldr	r3, [pc, #160]	@ (34005020 <HAL_BSEC_OTP_Program+0xb8>)
34004f80:	429a      	cmp	r2, r3
34004f82:	d005      	beq.n	34004f90 <HAL_BSEC_OTP_Program+0x28>
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
34004f84:	2301      	movs	r3, #1
34004f86:	6063      	str	r3, [r4, #4]
    return HAL_ERROR;
34004f88:	2001      	movs	r0, #1
}
34004f8a:	b003      	add	sp, #12
34004f8c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_BSEC_PERMANENT_LOCK(Lock));
34004f90:	f439 4380 	bics.w	r3, r9, #16384	@ 0x4000
34004f94:	d004      	beq.n	34004fa0 <HAL_BSEC_OTP_Program+0x38>
34004f96:	f44f 71dd 	mov.w	r1, #442	@ 0x1ba
34004f9a:	4822      	ldr	r0, [pc, #136]	@ (34005024 <HAL_BSEC_OTP_Program+0xbc>)
34004f9c:	f7fd fe38 	bl	34002c10 <assert_failed>
  if (FuseId < BSEC_NB_FUSES)
34004fa0:	f5b6 7fbc 	cmp.w	r6, #376	@ 0x178
34004fa4:	d2ee      	bcs.n	34004f84 <HAL_BSEC_OTP_Program+0x1c>
    if ((hbsec->Instance->SPLOCKx[status_reg] & status_bit) == 0U)
34004fa6:	6822      	ldr	r2, [r4, #0]
    status_reg = FuseId / 32U;
34004fa8:	0973      	lsrs	r3, r6, #5
    if ((hbsec->Instance->SPLOCKx[status_reg] & status_bit) == 0U)
34004faa:	f503 7300 	add.w	r3, r3, #512	@ 0x200
34004fae:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    status_bit = (uint32_t)(1UL << (FuseId % 32U));
34004fb2:	2301      	movs	r3, #1
34004fb4:	f006 001f 	and.w	r0, r6, #31
34004fb8:	4083      	lsls	r3, r0
    if ((hbsec->Instance->SPLOCKx[status_reg] & status_bit) == 0U)
34004fba:	420b      	tst	r3, r1
34004fbc:	d12e      	bne.n	3400501c <HAL_BSEC_OTP_Program+0xb4>
      hbsec->Instance->WDR = FuseData;
34004fbe:	f8c2 7c08 	str.w	r7, [r2, #3080]	@ 0xc08
      MODIFY_REG(hbsec->Instance->OTPCR, (BSEC_OTPCR_PPLOCK | BSEC_OTPCR_PROG | BSEC_OTPCR_ADDR),
34004fc2:	f8d2 5c04 	ldr.w	r5, [r2, #3076]	@ 0xc04
34004fc6:	f425 45c3 	bic.w	r5, r5, #24960	@ 0x6180
34004fca:	f025 057f 	bic.w	r5, r5, #127	@ 0x7f
34004fce:	4335      	orrs	r5, r6
34004fd0:	ea45 0509 	orr.w	r5, r5, r9
34004fd4:	f445 5500 	orr.w	r5, r5, #8192	@ 0x2000
34004fd8:	f8c2 5c04 	str.w	r5, [r2, #3076]	@ 0xc04
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
34004fdc:	6823      	ldr	r3, [r4, #0]
34004fde:	f8d3 2e44 	ldr.w	r2, [r3, #3652]	@ 0xe44
34004fe2:	07d2      	lsls	r2, r2, #31
34004fe4:	d406      	bmi.n	34004ff4 <HAL_BSEC_OTP_Program+0x8c>
      if ((hbsec->Instance->OTPSR & BSEC_OTPSR_PROGFAIL) != 0U)
34004fe6:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
34004fea:	03db      	lsls	r3, r3, #15
34004fec:	d50b      	bpl.n	34005006 <HAL_BSEC_OTP_Program+0x9e>
        hbsec->ErrorCode = HAL_BSEC_ERROR_PROGFAIL;
34004fee:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
34004ff2:	e7c8      	b.n	34004f86 <HAL_BSEC_OTP_Program+0x1e>
        if ((HAL_GetTick() - tick_start) > BSEC_TIMEOUT)
34004ff4:	f7ff ff42 	bl	34004e7c <HAL_GetTick>
34004ff8:	eba0 0008 	sub.w	r0, r0, r8
34004ffc:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
34005000:	d9ec      	bls.n	34004fdc <HAL_BSEC_OTP_Program+0x74>
          hbsec->ErrorCode = HAL_BSEC_ERROR_TIMEOUT;
34005002:	230a      	movs	r3, #10
34005004:	e7bf      	b.n	34004f86 <HAL_BSEC_OTP_Program+0x1e>
      if (HAL_BSEC_OTP_Read(hbsec, FuseId, &read_data) == HAL_OK)
34005006:	4631      	mov	r1, r6
34005008:	4620      	mov	r0, r4
3400500a:	aa01      	add	r2, sp, #4
3400500c:	f7ff ff90 	bl	34004f30 <HAL_BSEC_OTP_Read>
34005010:	2800      	cmp	r0, #0
34005012:	d1b9      	bne.n	34004f88 <HAL_BSEC_OTP_Program+0x20>
        if (read_data != FuseData)
34005014:	9b01      	ldr	r3, [sp, #4]
34005016:	42bb      	cmp	r3, r7
34005018:	d1e9      	bne.n	34004fee <HAL_BSEC_OTP_Program+0x86>
3400501a:	e7b6      	b.n	34004f8a <HAL_BSEC_OTP_Program+0x22>
      hbsec->ErrorCode = HAL_BSEC_ERROR_LOCK;
3400501c:	2304      	movs	r3, #4
3400501e:	e7b2      	b.n	34004f86 <HAL_BSEC_OTP_Program+0x1e>
34005020:	56009000 	.word	0x56009000
34005024:	3401fb12 	.word	0x3401fb12

34005028 <HAL_CACHEAXI_Enable>:
  * @param  hcacheaxi Pointer to a CACHEAXI_HandleTypeDef structure that contains
  *                   the configuration information for the specified CACHEAXIx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CACHEAXI_Enable(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34005028:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tickstart;

  /* Check the cacheaxi handle allocation */
  if (hcacheaxi == NULL)
3400502a:	4604      	mov	r4, r0
3400502c:	b350      	cbz	r0, 34005084 <HAL_CACHEAXI_Enable+0x5c>
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));
3400502e:	6803      	ldr	r3, [r0, #0]
34005030:	4a15      	ldr	r2, [pc, #84]	@ (34005088 <HAL_CACHEAXI_Enable+0x60>)
34005032:	4293      	cmp	r3, r2
34005034:	d008      	beq.n	34005048 <HAL_CACHEAXI_Enable+0x20>
34005036:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400503a:	4293      	cmp	r3, r2
3400503c:	d004      	beq.n	34005048 <HAL_CACHEAXI_Enable+0x20>
3400503e:	f44f 71b5 	mov.w	r1, #362	@ 0x16a
34005042:	4812      	ldr	r0, [pc, #72]	@ (3400508c <HAL_CACHEAXI_Enable+0x64>)
34005044:	f7fd fde4 	bl	34002c10 <assert_failed>

  /* Check if ongoing full invalidation operation */
  if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34005048:	6823      	ldr	r3, [r4, #0]
3400504a:	685b      	ldr	r3, [r3, #4]
3400504c:	07d9      	lsls	r1, r3, #31
3400504e:	d407      	bmi.n	34005060 <HAL_CACHEAXI_Enable+0x38>
  }

  if (status == HAL_OK)
  {
    /* Update the error code */
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34005050:	2000      	movs	r0, #0
    /* Enable the selected CACHEAXI peripheral */
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
34005052:	6822      	ldr	r2, [r4, #0]
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34005054:	60a0      	str	r0, [r4, #8]
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
34005056:	6813      	ldr	r3, [r2, #0]
34005058:	f043 0301 	orr.w	r3, r3, #1
3400505c:	6013      	str	r3, [r2, #0]
  }

  return status;
}
3400505e:	bd38      	pop	{r3, r4, r5, pc}
    tickstart = HAL_GetTick();
34005060:	f7ff ff0c 	bl	34004e7c <HAL_GetTick>
34005064:	4605      	mov	r5, r0
    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34005066:	6823      	ldr	r3, [r4, #0]
34005068:	685b      	ldr	r3, [r3, #4]
3400506a:	07db      	lsls	r3, r3, #31
3400506c:	d5f0      	bpl.n	34005050 <HAL_CACHEAXI_Enable+0x28>
      if ((HAL_GetTick() - tickstart) > CACHEAXI_ENABLE_TIMEOUT_VALUE)
3400506e:	f7ff ff05 	bl	34004e7c <HAL_GetTick>
34005072:	1b40      	subs	r0, r0, r5
34005074:	2801      	cmp	r0, #1
34005076:	d9f6      	bls.n	34005066 <HAL_CACHEAXI_Enable+0x3e>
        if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) == 0U)
34005078:	6823      	ldr	r3, [r4, #0]
3400507a:	685b      	ldr	r3, [r3, #4]
3400507c:	07da      	lsls	r2, r3, #31
3400507e:	d4f2      	bmi.n	34005066 <HAL_CACHEAXI_Enable+0x3e>
          hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_TIMEOUT;
34005080:	2310      	movs	r3, #16
34005082:	60a3      	str	r3, [r4, #8]
    return HAL_ERROR;
34005084:	2001      	movs	r0, #1
34005086:	e7ea      	b.n	3400505e <HAL_CACHEAXI_Enable+0x36>
34005088:	580dfc00 	.word	0x580dfc00
3400508c:	3401fbd6 	.word	0x3401fbd6

34005090 <HAL_CACHEAXI_Init>:
{
34005090:	b510      	push	{r4, lr}
  if (hcacheaxi == NULL)
34005092:	4604      	mov	r4, r0
34005094:	b1c8      	cbz	r0, 340050ca <HAL_CACHEAXI_Init+0x3a>
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));
34005096:	6803      	ldr	r3, [r0, #0]
34005098:	4a0d      	ldr	r2, [pc, #52]	@ (340050d0 <HAL_CACHEAXI_Init+0x40>)
3400509a:	4293      	cmp	r3, r2
3400509c:	d007      	beq.n	340050ae <HAL_CACHEAXI_Init+0x1e>
3400509e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340050a2:	4293      	cmp	r3, r2
340050a4:	d003      	beq.n	340050ae <HAL_CACHEAXI_Init+0x1e>
340050a6:	21bc      	movs	r1, #188	@ 0xbc
340050a8:	480a      	ldr	r0, [pc, #40]	@ (340050d4 <HAL_CACHEAXI_Init+0x44>)
340050aa:	f7fd fdb1 	bl	34002c10 <assert_failed>
  if (hcacheaxi->State == HAL_CACHEAXI_STATE_RESET)
340050ae:	7923      	ldrb	r3, [r4, #4]
340050b0:	b913      	cbnz	r3, 340050b8 <HAL_CACHEAXI_Init+0x28>
    HAL_CACHEAXI_MspInit(hcacheaxi);
340050b2:	4620      	mov	r0, r4
340050b4:	f7fd fd92 	bl	34002bdc <HAL_CACHEAXI_MspInit>
  hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
340050b8:	2300      	movs	r3, #0
340050ba:	60a3      	str	r3, [r4, #8]
  hcacheaxi->State = HAL_CACHEAXI_STATE_READY;
340050bc:	2301      	movs	r3, #1
340050be:	7123      	strb	r3, [r4, #4]
  status = HAL_CACHEAXI_Enable(hcacheaxi);
340050c0:	4620      	mov	r0, r4
}
340050c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  status = HAL_CACHEAXI_Enable(hcacheaxi);
340050c6:	f7ff bfaf 	b.w	34005028 <HAL_CACHEAXI_Enable>
}
340050ca:	2001      	movs	r0, #1
340050cc:	bd10      	pop	{r4, pc}
340050ce:	bf00      	nop
340050d0:	580dfc00 	.word	0x580dfc00
340050d4:	3401fbd6 	.word	0x3401fbd6

340050d8 <HAL_NVIC_SetPriorityGrouping>:
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
340050d8:	1ec3      	subs	r3, r0, #3
340050da:	2b04      	cmp	r3, #4
{
340050dc:	b510      	push	{r4, lr}
340050de:	4604      	mov	r4, r0
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
340050e0:	d903      	bls.n	340050ea <HAL_NVIC_SetPriorityGrouping+0x12>
340050e2:	21e6      	movs	r1, #230	@ 0xe6
340050e4:	4809      	ldr	r0, [pc, #36]	@ (3400510c <HAL_NVIC_SetPriorityGrouping+0x34>)
340050e6:	f7fd fd93 	bl	34002c10 <assert_failed>
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
340050ea:	4909      	ldr	r1, [pc, #36]	@ (34005110 <HAL_NVIC_SetPriorityGrouping+0x38>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
340050ec:	0223      	lsls	r3, r4, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
340050ee:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
340050f0:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
340050f4:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
340050f8:	0412      	lsls	r2, r2, #16
340050fa:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
340050fc:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
340050fe:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
34005102:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
34005106:	60cb      	str	r3, [r1, #12]

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
34005108:	bd10      	pop	{r4, pc}
3400510a:	bf00      	nop
3400510c:	3401fc9e 	.word	0x3401fc9e
34005110:	e000ed00 	.word	0xe000ed00

34005114 <HAL_NVIC_SetPriority>:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));
34005114:	f110 0f0c 	cmn.w	r0, #12
{
34005118:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400511c:	4605      	mov	r5, r0
3400511e:	460c      	mov	r4, r1
34005120:	4617      	mov	r7, r2
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));
34005122:	db01      	blt.n	34005128 <HAL_NVIC_SetPriority+0x14>
34005124:	1d03      	adds	r3, r0, #4
34005126:	d103      	bne.n	34005130 <HAL_NVIC_SetPriority+0x1c>
34005128:	21ff      	movs	r1, #255	@ 0xff
3400512a:	4826      	ldr	r0, [pc, #152]	@ (340051c4 <HAL_NVIC_SetPriority+0xb0>)
3400512c:	f7fd fd70 	bl	34002c10 <assert_failed>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34005130:	4b25      	ldr	r3, [pc, #148]	@ (340051c8 <HAL_NVIC_SetPriority+0xb4>)
34005132:	68de      	ldr	r6, [r3, #12]
34005134:	f3c6 2602 	ubfx	r6, r6, #8, #3

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
34005138:	2e02      	cmp	r6, #2
3400513a:	d806      	bhi.n	3400514a <HAL_NVIC_SetPriority+0x36>
3400513c:	b157      	cbz	r7, 34005154 <HAL_NVIC_SetPriority+0x40>
3400513e:	f44f 7181 	mov.w	r1, #258	@ 0x102
34005142:	4820      	ldr	r0, [pc, #128]	@ (340051c4 <HAL_NVIC_SetPriority+0xb0>)
34005144:	f7fd fd64 	bl	34002c10 <assert_failed>
34005148:	e004      	b.n	34005154 <HAL_NVIC_SetPriority+0x40>
3400514a:	2301      	movs	r3, #1
3400514c:	1ef2      	subs	r2, r6, #3
3400514e:	4093      	lsls	r3, r2
34005150:	42bb      	cmp	r3, r7
34005152:	d9f4      	bls.n	3400513e <HAL_NVIC_SetPriority+0x2a>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));
34005154:	2c0f      	cmp	r4, #15
34005156:	f1c6 0807 	rsb	r8, r6, #7
3400515a:	d804      	bhi.n	34005166 <HAL_NVIC_SetPriority+0x52>
3400515c:	2301      	movs	r3, #1
3400515e:	fa03 f308 	lsl.w	r3, r3, r8
34005162:	42a3      	cmp	r3, r4
34005164:	d804      	bhi.n	34005170 <HAL_NVIC_SetPriority+0x5c>
34005166:	f240 1103 	movw	r1, #259	@ 0x103
3400516a:	4816      	ldr	r0, [pc, #88]	@ (340051c4 <HAL_NVIC_SetPriority+0xb0>)
3400516c:	f7fd fd50 	bl	34002c10 <assert_failed>
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34005170:	f1b8 0f04 	cmp.w	r8, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34005174:	f106 0304 	add.w	r3, r6, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34005178:	bf28      	it	cs
3400517a:	f04f 0804 	movcs.w	r8, #4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
3400517e:	f04f 32ff 	mov.w	r2, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34005182:	2b06      	cmp	r3, #6
34005184:	f1a6 0603 	sub.w	r6, r6, #3
34005188:	bf98      	it	ls
3400518a:	2600      	movls	r6, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
3400518c:	fa02 f808 	lsl.w	r8, r2, r8
34005190:	ea24 0308 	bic.w	r3, r4, r8
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34005194:	40b2      	lsls	r2, r6
34005196:	ea27 0702 	bic.w	r7, r7, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
3400519a:	40b3      	lsls	r3, r6
  if ((int32_t)(IRQn) >= 0)
3400519c:	2d00      	cmp	r5, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
3400519e:	ea43 0307 	orr.w	r3, r3, r7
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340051a2:	bfac      	ite	ge
340051a4:	f105 4560 	addge.w	r5, r5, #3758096384	@ 0xe0000000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340051a8:	4a08      	ldrlt	r2, [pc, #32]	@ (340051cc <HAL_NVIC_SetPriority+0xb8>)
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340051aa:	ea4f 1303 	mov.w	r3, r3, lsl #4
340051ae:	b2db      	uxtb	r3, r3
340051b0:	bfab      	itete	ge
340051b2:	f505 4561 	addge.w	r5, r5, #57600	@ 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340051b6:	f005 050f 	andlt.w	r5, r5, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340051ba:	f885 3300 	strbge.w	r3, [r5, #768]	@ 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340051be:	5553      	strblt	r3, [r2, r5]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
340051c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
340051c4:	3401fc9e 	.word	0x3401fc9e
340051c8:	e000ed00 	.word	0xe000ed00
340051cc:	e000ed14 	.word	0xe000ed14

340051d0 <HAL_NVIC_EnableIRQ>:
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
340051d0:	2800      	cmp	r0, #0
340051d2:	db08      	blt.n	340051e6 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
340051d4:	2301      	movs	r3, #1
340051d6:	0941      	lsrs	r1, r0, #5
340051d8:	4a05      	ldr	r2, [pc, #20]	@ (340051f0 <HAL_NVIC_EnableIRQ+0x20>)
340051da:	f000 001f 	and.w	r0, r0, #31
340051de:	4083      	lsls	r3, r0
340051e0:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
340051e4:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
340051e6:	f240 1115 	movw	r1, #277	@ 0x115
340051ea:	4802      	ldr	r0, [pc, #8]	@ (340051f4 <HAL_NVIC_EnableIRQ+0x24>)
340051ec:	f7fd bd10 	b.w	34002c10 <assert_failed>
340051f0:	e000e100 	.word	0xe000e100
340051f4:	3401fc9e 	.word	0x3401fc9e

340051f8 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
340051f8:	3801      	subs	r0, #1
340051fa:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
340051fe:	d20b      	bcs.n	34005218 <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
34005200:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34005204:	21f0      	movs	r1, #240	@ 0xf0
34005206:	4a05      	ldr	r2, [pc, #20]	@ (3400521c <HAL_SYSTICK_Config+0x24>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
34005208:	6158      	str	r0, [r3, #20]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
3400520a:	f882 1023 	strb.w	r1, [r2, #35]	@ 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
3400520e:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34005210:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34005212:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34005214:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
34005216:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
34005218:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
3400521a:	4770      	bx	lr
3400521c:	e000ed00 	.word	0xe000ed00

34005220 <DCMIPP_CSI_SetVCConfig>:
  * @param  hdcmipp         Pointer to DCMIPP handle
  * @param  Pipe            Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @param  VirtualChannel  Specifies the virtual channel, can be a value from @ref DCMIPP_Virtual_Channel
  */
static HAL_StatusTypeDef DCMIPP_CSI_SetVCConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t VirtualChannel)
{
34005220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34005222:	4614      	mov	r4, r2
  uint32_t tickstart;

  /* Set Virtual Channel ID for the selected Pipe */
  if (Pipe == DCMIPP_PIPE0)
  {
    MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_VC, VirtualChannel << DCMIPP_P0FSCR_VC_Pos);
34005224:	6803      	ldr	r3, [r0, #0]
  if (Pipe == DCMIPP_PIPE0)
34005226:	bb71      	cbnz	r1, 34005286 <DCMIPP_CSI_SetVCConfig+0x66>
    MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_VC, VirtualChannel << DCMIPP_P0FSCR_VC_Pos);
34005228:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
3400522c:	f422 12c0 	bic.w	r2, r2, #1572864	@ 0x180000
34005230:	ea42 42c4 	orr.w	r2, r2, r4, lsl #19
34005234:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_VC, VirtualChannel << DCMIPP_P2FSCR_VC_Pos);
    }
  }

  /* Enable the selected virtual channel */
  switch (VirtualChannel)
34005238:	4b23      	ldr	r3, [pc, #140]	@ (340052c8 <DCMIPP_CSI_SetVCConfig+0xa8>)
3400523a:	2c02      	cmp	r4, #2
    case DCMIPP_VIRTUAL_CHANNEL3:
      SET_BIT(csi_instance->CR, CSI_CR_VC3START);
      break;
    default:
      /* DCMIPP_VIRTUAL_CHANNEL0: */
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
3400523c:	681a      	ldr	r2, [r3, #0]
  switch (VirtualChannel)
3400523e:	d038      	beq.n	340052b2 <DCMIPP_CSI_SetVCConfig+0x92>
34005240:	2c03      	cmp	r4, #3
34005242:	d039      	beq.n	340052b8 <DCMIPP_CSI_SetVCConfig+0x98>
34005244:	2c01      	cmp	r4, #1
34005246:	d13a      	bne.n	340052be <DCMIPP_CSI_SetVCConfig+0x9e>
      SET_BIT(csi_instance->CR, CSI_CR_VC1START);
34005248:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
3400524c:	601a      	str	r2, [r3, #0]
      break;
  }

  /* wait for the selected virtual channel active state */
  tickstart = HAL_GetTick();
3400524e:	f7ff fe15 	bl	34004e7c <HAL_GetTick>
  {
    if ((HAL_GetTick() - tickstart) > DCMIPP_TIMEOUT)
    {
      return HAL_ERROR;
    }
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
34005252:	f44f 3600 	mov.w	r6, #131072	@ 0x20000
  tickstart = HAL_GetTick();
34005256:	4607      	mov	r7, r0
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
34005258:	4d1b      	ldr	r5, [pc, #108]	@ (340052c8 <DCMIPP_CSI_SetVCConfig+0xa8>)
3400525a:	40a6      	lsls	r6, r4
    if ((HAL_GetTick() - tickstart) > DCMIPP_TIMEOUT)
3400525c:	f7ff fe0e 	bl	34004e7c <HAL_GetTick>
34005260:	1bc0      	subs	r0, r0, r7
34005262:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
34005266:	d82d      	bhi.n	340052c4 <DCMIPP_CSI_SetVCConfig+0xa4>
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
34005268:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
3400526c:	ea36 0303 	bics.w	r3, r6, r3
34005270:	d1f4      	bne.n	3400525c <DCMIPP_CSI_SetVCConfig+0x3c>

  /* Enable the SOF and EOF interrupts for the selected virtual channel */
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, (DCMIPP_CSI_IT_EOF0 << VirtualChannel) | \
34005272:	f44f 5388 	mov.w	r3, #4352	@ 0x1100
                             (DCMIPP_CSI_IT_SOF0 << VirtualChannel));
  return HAL_OK;
34005276:	2000      	movs	r0, #0
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, (DCMIPP_CSI_IT_EOF0 << VirtualChannel) | \
34005278:	f8d5 2080 	ldr.w	r2, [r5, #128]	@ 0x80
3400527c:	40a3      	lsls	r3, r4
3400527e:	4313      	orrs	r3, r2
34005280:	f8c5 3080 	str.w	r3, [r5, #128]	@ 0x80
}
34005284:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (Pipe == DCMIPP_PIPE1)
34005286:	2901      	cmp	r1, #1
    MODIFY_REG(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_VC, VirtualChannel << DCMIPP_P1FSCR_VC_Pos);
34005288:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
  else if (Pipe == DCMIPP_PIPE1)
3400528c:	d106      	bne.n	3400529c <DCMIPP_CSI_SetVCConfig+0x7c>
    MODIFY_REG(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_VC, VirtualChannel << DCMIPP_P1FSCR_VC_Pos);
3400528e:	f422 12c0 	bic.w	r2, r2, #1572864	@ 0x180000
34005292:	ea42 42c4 	orr.w	r2, r2, r4, lsl #19
34005296:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
3400529a:	e7cd      	b.n	34005238 <DCMIPP_CSI_SetVCConfig+0x18>
    if ((hdcmipp->Instance->P1FSCR & DCMIPP_P1FSCR_PIPEDIFF) == DCMIPP_P1FSCR_PIPEDIFF)
3400529c:	0352      	lsls	r2, r2, #13
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_VC, VirtualChannel << DCMIPP_P2FSCR_VC_Pos);
3400529e:	bf41      	itttt	mi
340052a0:	f8d3 2c04 	ldrmi.w	r2, [r3, #3076]	@ 0xc04
340052a4:	f422 12c0 	bicmi.w	r2, r2, #1572864	@ 0x180000
340052a8:	ea42 42c4 	orrmi.w	r2, r2, r4, lsl #19
340052ac:	f8c3 2c04 	strmi.w	r2, [r3, #3076]	@ 0xc04
340052b0:	e7c2      	b.n	34005238 <DCMIPP_CSI_SetVCConfig+0x18>
      SET_BIT(csi_instance->CR, CSI_CR_VC2START);
340052b2:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
340052b6:	e7c9      	b.n	3400524c <DCMIPP_CSI_SetVCConfig+0x2c>
      SET_BIT(csi_instance->CR, CSI_CR_VC3START);
340052b8:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
340052bc:	e7c6      	b.n	3400524c <DCMIPP_CSI_SetVCConfig+0x2c>
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
340052be:	f042 0204 	orr.w	r2, r2, #4
340052c2:	e7c3      	b.n	3400524c <DCMIPP_CSI_SetVCConfig+0x2c>
      return HAL_ERROR;
340052c4:	2001      	movs	r0, #1
340052c6:	e7dd      	b.n	34005284 <DCMIPP_CSI_SetVCConfig+0x64>
340052c8:	58006000 	.word	0x58006000

340052cc <DCMIPP_SetConfig.part.0>:
  else if (Pipe == DCMIPP_PIPE1)
340052cc:	2901      	cmp	r1, #1
static void DCMIPP_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t DstAddress, uint32_t CaptureMode)
340052ce:	b530      	push	{r4, r5, lr}
340052d0:	f04f 0502 	mov.w	r5, #2
    hdcmipp->Instance->P1FCTCR |= CaptureMode;
340052d4:	6804      	ldr	r4, [r0, #0]
  else if (Pipe == DCMIPP_PIPE1)
340052d6:	d110      	bne.n	340052fa <DCMIPP_SetConfig.part.0+0x2e>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
340052d8:	7185      	strb	r5, [r0, #6]
    hdcmipp->Instance->P1FCTCR |= CaptureMode;
340052da:	f8d4 1900 	ldr.w	r1, [r4, #2304]	@ 0x900
340052de:	430b      	orrs	r3, r1
340052e0:	f8c4 3900 	str.w	r3, [r4, #2304]	@ 0x900
    WRITE_REG(hdcmipp->Instance->P1PPM0AR1, DstAddress);
340052e4:	f8c4 29c4 	str.w	r2, [r4, #2500]	@ 0x9c4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME  | DCMIPP_IT_PIPE1_OVR | DCMIPP_IT_PIPE1_VSYNC |
340052e8:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
340052ec:	f443 0306 	orr.w	r3, r3, #8781824	@ 0x860000
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
340052f0:	f043 0320 	orr.w	r3, r3, #32
340052f4:	f8c4 33f0 	str.w	r3, [r4, #1008]	@ 0x3f0
}
340052f8:	bd30      	pop	{r4, r5, pc}
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
340052fa:	4408      	add	r0, r1
340052fc:	7145      	strb	r5, [r0, #5]
    hdcmipp->Instance->P2FCTCR |= CaptureMode;
340052fe:	f8d4 1d00 	ldr.w	r1, [r4, #3328]	@ 0xd00
34005302:	430b      	orrs	r3, r1
34005304:	f8c4 3d00 	str.w	r3, [r4, #3328]	@ 0xd00
    WRITE_REG(hdcmipp->Instance->P2PPM0AR1, DstAddress);
34005308:	f8c4 2dc4 	str.w	r2, [r4, #3524]	@ 0xdc4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
3400530c:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
34005310:	f043 4306 	orr.w	r3, r3, #2248146944	@ 0x86000000
34005314:	e7ec      	b.n	340052f0 <DCMIPP_SetConfig.part.0+0x24>

34005316 <DCMIPP_SetConfig>:
{
34005316:	b470      	push	{r4, r5, r6}
34005318:	4615      	mov	r5, r2
3400531a:	461e      	mov	r6, r3
  if (Pipe == DCMIPP_PIPE0)
3400531c:	b999      	cbnz	r1, 34005346 <DCMIPP_SetConfig+0x30>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
3400531e:	2302      	movs	r3, #2
    hdcmipp->Instance->P0FCTCR |= CaptureMode;
34005320:	6801      	ldr	r1, [r0, #0]
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34005322:	7143      	strb	r3, [r0, #5]
    hdcmipp->Instance->P0FCTCR |= CaptureMode;
34005324:	f8d1 2500 	ldr.w	r2, [r1, #1280]	@ 0x500
34005328:	4332      	orrs	r2, r6
3400532a:	f8c1 2500 	str.w	r2, [r1, #1280]	@ 0x500
    WRITE_REG(hdcmipp->Instance->P0PPM0AR1, DstAddress);
3400532e:	f8c1 55c4 	str.w	r5, [r1, #1476]	@ 0x5c4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR |
34005332:	f8d1 33f0 	ldr.w	r3, [r1, #1008]	@ 0x3f0
}
34005336:	bc70      	pop	{r4, r5, r6}
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR |
34005338:	f443 4306 	orr.w	r3, r3, #34304	@ 0x8600
3400533c:	f043 0320 	orr.w	r3, r3, #32
34005340:	f8c1 33f0 	str.w	r3, [r1, #1008]	@ 0x3f0
}
34005344:	4770      	bx	lr
34005346:	bc70      	pop	{r4, r5, r6}
34005348:	f7ff bfc0 	b.w	340052cc <DCMIPP_SetConfig.part.0>

3400534c <DCMIPP_EnableCapture.part.0>:
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
3400534c:	2302      	movs	r3, #2
3400534e:	7183      	strb	r3, [r0, #6]
    SET_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEN);
34005350:	6803      	ldr	r3, [r0, #0]
34005352:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
34005356:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3400535a:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
    SET_BIT(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_CPTREQ);
3400535e:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
34005362:	f042 0208 	orr.w	r2, r2, #8
34005366:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
}
3400536a:	4770      	bx	lr

3400536c <DCMIPP_EnableCapture>:
  if (Pipe == DCMIPP_PIPE0)
3400536c:	b969      	cbnz	r1, 3400538a <DCMIPP_EnableCapture+0x1e>
    SET_BIT(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_PIPEN);
3400536e:	6803      	ldr	r3, [r0, #0]
34005370:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
34005374:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34005378:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
    SET_BIT(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
3400537c:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
34005380:	f042 0208 	orr.w	r2, r2, #8
34005384:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500
34005388:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE1)
3400538a:	2901      	cmp	r1, #1
3400538c:	d101      	bne.n	34005392 <DCMIPP_EnableCapture+0x26>
3400538e:	f7ff bfdd 	b.w	3400534c <DCMIPP_EnableCapture.part.0>
    SET_BIT(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_PIPEN);
34005392:	6803      	ldr	r3, [r0, #0]
34005394:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	@ 0xc04
34005398:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3400539c:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    SET_BIT(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_CPTREQ);
340053a0:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
340053a4:	f042 0208 	orr.w	r2, r2, #8
340053a8:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
}
340053ac:	4770      	bx	lr
	...

340053b0 <DCMIPP_CSI_WritePHYReg.constprop.0>:
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
340053b0:	4b18      	ldr	r3, [pc, #96]	@ (34005414 <DCMIPP_CSI_WritePHYReg.constprop.0+0x64>)
static void DCMIPP_CSI_WritePHYReg(CSI_TypeDef *hcsi, uint32_t reg_msb, uint32_t reg_lsb, uint32_t val)
340053b2:	b510      	push	{r4, lr}
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
340053b4:	695a      	ldr	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
340053b6:	b2c9      	uxtb	r1, r1
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
340053b8:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
340053bc:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
340053be:	691a      	ldr	r2, [r3, #16]
340053c0:	f042 0201 	orr.w	r2, r2, #1
340053c4:	611a      	str	r2, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
340053c6:	695a      	ldr	r2, [r3, #20]
340053c8:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
340053cc:	615a      	str	r2, [r3, #20]
  CLEAR_REG(hcsi->PTCR0);
340053ce:	2200      	movs	r2, #0
340053d0:	611a      	str	r2, [r3, #16]
  CLEAR_REG(hcsi->PTCR1);
340053d2:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, reg_msb & 0xFFU);
340053d4:	695c      	ldr	r4, [r3, #20]
340053d6:	615c      	str	r4, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
340053d8:	691c      	ldr	r4, [r3, #16]
340053da:	f044 0401 	orr.w	r4, r4, #1
340053de:	611c      	str	r4, [r3, #16]
  CLEAR_REG(hcsi->PTCR0);
340053e0:	611a      	str	r2, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
340053e2:	695c      	ldr	r4, [r3, #20]
340053e4:	f444 3480 	orr.w	r4, r4, #65536	@ 0x10000
340053e8:	615c      	str	r4, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
340053ea:	691c      	ldr	r4, [r3, #16]
340053ec:	f044 0401 	orr.w	r4, r4, #1
340053f0:	611c      	str	r4, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM | (reg_lsb & 0xFFU));
340053f2:	695c      	ldr	r4, [r3, #20]
340053f4:	4304      	orrs	r4, r0
340053f6:	f444 3480 	orr.w	r4, r4, #65536	@ 0x10000
340053fa:	615c      	str	r4, [r3, #20]
  CLEAR_REG(hcsi->PTCR0);
340053fc:	611a      	str	r2, [r3, #16]
  CLEAR_REG(hcsi->PTCR1);
340053fe:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
34005400:	6958      	ldr	r0, [r3, #20]
34005402:	4301      	orrs	r1, r0
34005404:	6159      	str	r1, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34005406:	6919      	ldr	r1, [r3, #16]
34005408:	f041 0101 	orr.w	r1, r1, #1
3400540c:	6119      	str	r1, [r3, #16]
  CLEAR_REG(hcsi->PTCR0);
3400540e:	611a      	str	r2, [r3, #16]
}
34005410:	bd10      	pop	{r4, pc}
34005412:	bf00      	nop
34005414:	58007000 	.word	0x58007000

34005418 <HAL_DCMIPP_Init>:
{
34005418:	b510      	push	{r4, lr}
  if (hdcmipp == NULL)
3400541a:	4604      	mov	r4, r0
3400541c:	b1d8      	cbz	r0, 34005456 <HAL_DCMIPP_Init+0x3e>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
3400541e:	6803      	ldr	r3, [r0, #0]
34005420:	4a0e      	ldr	r2, [pc, #56]	@ (3400545c <HAL_DCMIPP_Init+0x44>)
34005422:	4293      	cmp	r3, r2
34005424:	d008      	beq.n	34005438 <HAL_DCMIPP_Init+0x20>
34005426:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400542a:	4293      	cmp	r3, r2
3400542c:	d004      	beq.n	34005438 <HAL_DCMIPP_Init+0x20>
3400542e:	f44f 71a7 	mov.w	r1, #334	@ 0x14e
34005432:	480b      	ldr	r0, [pc, #44]	@ (34005460 <HAL_DCMIPP_Init+0x48>)
34005434:	f7fd fbec 	bl	34002c10 <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_RESET)
34005438:	7923      	ldrb	r3, [r4, #4]
3400543a:	b913      	cbnz	r3, 34005442 <HAL_DCMIPP_Init+0x2a>
    HAL_DCMIPP_MspInit(hdcmipp);
3400543c:	4620      	mov	r0, r4
3400543e:	f00b fb39 	bl	34010ab4 <HAL_DCMIPP_MspInit>
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
34005442:	2303      	movs	r3, #3
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
34005444:	2000      	movs	r0, #0
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
34005446:	7123      	strb	r3, [r4, #4]
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
34005448:	2301      	movs	r3, #1
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
3400544a:	7160      	strb	r0, [r4, #5]
3400544c:	71a0      	strb	r0, [r4, #6]
3400544e:	71e0      	strb	r0, [r4, #7]
  hdcmipp->ErrorCode = HAL_DCMIPP_ERROR_NONE;
34005450:	60a0      	str	r0, [r4, #8]
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
34005452:	7123      	strb	r3, [r4, #4]
}
34005454:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34005456:	2001      	movs	r0, #1
34005458:	e7fc      	b.n	34005454 <HAL_DCMIPP_Init+0x3c>
3400545a:	bf00      	nop
3400545c:	58002000 	.word	0x58002000
34005460:	3401fd64 	.word	0x3401fd64

34005464 <HAL_DCMIPP_CSI_SetConfig>:
{
34005464:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34005468:	4605      	mov	r5, r0
3400546a:	b0fe      	sub	sp, #504	@ 0x1f8
3400546c:	460c      	mov	r4, r1
  const SNPS_FreqsTypeDef SNPS_Freqs[63] =
3400546e:	f44f 72fc 	mov.w	r2, #504	@ 0x1f8
34005472:	4668      	mov	r0, sp
34005474:	4954      	ldr	r1, [pc, #336]	@ (340055c8 <HAL_DCMIPP_CSI_SetConfig+0x164>)
34005476:	f015 f8ec 	bl	3401a652 <memcpy>
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
3400547a:	b91d      	cbnz	r5, 34005484 <HAL_DCMIPP_CSI_SetConfig+0x20>
    return HAL_ERROR;
3400547c:	2001      	movs	r0, #1
}
3400547e:	b07e      	add	sp, #504	@ 0x1f8
34005480:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
34005484:	2c00      	cmp	r4, #0
34005486:	d0f9      	beq.n	3400547c <HAL_DCMIPP_CSI_SetConfig+0x18>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34005488:	682b      	ldr	r3, [r5, #0]
3400548a:	4a50      	ldr	r2, [pc, #320]	@ (340055cc <HAL_DCMIPP_CSI_SetConfig+0x168>)
3400548c:	4293      	cmp	r3, r2
3400548e:	d008      	beq.n	340054a2 <HAL_DCMIPP_CSI_SetConfig+0x3e>
34005490:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34005494:	4293      	cmp	r3, r2
34005496:	d004      	beq.n	340054a2 <HAL_DCMIPP_CSI_SetConfig+0x3e>
34005498:	f240 218b 	movw	r1, #651	@ 0x28b
3400549c:	484c      	ldr	r0, [pc, #304]	@ (340055d0 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
3400549e:	f7fd fbb7 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_NUMBER_OF_LANES(pCSI_Config->NumberOfLanes));
340054a2:	6823      	ldr	r3, [r4, #0]
340054a4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340054a8:	d007      	beq.n	340054ba <HAL_DCMIPP_CSI_SetConfig+0x56>
340054aa:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340054ae:	d004      	beq.n	340054ba <HAL_DCMIPP_CSI_SetConfig+0x56>
340054b0:	f44f 7123 	mov.w	r1, #652	@ 0x28c
340054b4:	4846      	ldr	r0, [pc, #280]	@ (340055d0 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
340054b6:	f7fd fbab 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_CSI_DATA_LANE_MAPPING(pCSI_Config->DataLaneMapping));
340054ba:	6863      	ldr	r3, [r4, #4]
340054bc:	3b01      	subs	r3, #1
340054be:	2b01      	cmp	r3, #1
340054c0:	d904      	bls.n	340054cc <HAL_DCMIPP_CSI_SetConfig+0x68>
340054c2:	f240 218d 	movw	r1, #653	@ 0x28d
340054c6:	4842      	ldr	r0, [pc, #264]	@ (340055d0 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
340054c8:	f7fd fba2 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_CSI_DATA_PHY_BITRATE(pCSI_Config->PHYBitrate));
340054cc:	68a3      	ldr	r3, [r4, #8]
340054ce:	2b3e      	cmp	r3, #62	@ 0x3e
340054d0:	d904      	bls.n	340054dc <HAL_DCMIPP_CSI_SetConfig+0x78>
340054d2:	f240 218e 	movw	r1, #654	@ 0x28e
340054d6:	483e      	ldr	r0, [pc, #248]	@ (340055d0 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
340054d8:	f7fd fb9a 	bl	34002c10 <assert_failed>
  CLEAR_BIT(csi_instance->CR, CSI_CR_CSIEN);
340054dc:	4b3d      	ldr	r3, [pc, #244]	@ (340055d4 <HAL_DCMIPP_CSI_SetConfig+0x170>)
340054de:	681a      	ldr	r2, [r3, #0]
340054e0:	f022 0201 	bic.w	r2, r2, #1
340054e4:	601a      	str	r2, [r3, #0]
  if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
340054e6:	6861      	ldr	r1, [r4, #4]
340054e8:	2901      	cmp	r1, #1
340054ea:	d11a      	bne.n	34005522 <HAL_DCMIPP_CSI_SetConfig+0xbe>
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL0MAP_Pos) | \
340054ec:	6822      	ldr	r2, [r4, #0]
340054ee:	f442 1204 	orr.w	r2, r2, #2162688	@ 0x210000
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
340054f2:	671a      	str	r2, [r3, #112]	@ 0x70
  SET_BIT(csi_instance->CR, CSI_CR_CSIEN);
340054f4:	681a      	ldr	r2, [r3, #0]
340054f6:	f042 0201 	orr.w	r2, r2, #1
340054fa:	601a      	str	r2, [r3, #0]
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO |  DCMIPP_CSI_IT_SYNCERR | \
340054fc:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005500:	f042 42b0 	orr.w	r2, r2, #1476395008	@ 0x58000000
34005504:	f442 1204 	orr.w	r2, r2, #2162688	@ 0x210000
34005508:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
3400550c:	6822      	ldr	r2, [r4, #0]
3400550e:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0 | DCMIPP_CSI_IT_ESOTSYNCDL0 |
34005512:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34005516:	d154      	bne.n	340055c2 <HAL_DCMIPP_CSI_SetConfig+0x15e>
    if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34005518:	2901      	cmp	r1, #1
3400551a:	d108      	bne.n	3400552e <HAL_DCMIPP_CSI_SetConfig+0xca>
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
3400551c:	f042 021f 	orr.w	r2, r2, #31
34005520:	e007      	b.n	34005532 <HAL_DCMIPP_CSI_SetConfig+0xce>
  else if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_INVERTED_DATA_LANES)
34005522:	2902      	cmp	r1, #2
34005524:	d1aa      	bne.n	3400547c <HAL_DCMIPP_CSI_SetConfig+0x18>
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
34005526:	6822      	ldr	r2, [r4, #0]
34005528:	f442 1290 	orr.w	r2, r2, #1179648	@ 0x120000
3400552c:	e7e1      	b.n	340054f2 <HAL_DCMIPP_CSI_SetConfig+0x8e>
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
3400552e:	f442 52f8 	orr.w	r2, r2, #7936	@ 0x1f00
  CLEAR_REG(csi_instance-> PCR);
34005532:	2600      	movs	r6, #0
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34005534:	4d28      	ldr	r5, [pc, #160]	@ (340055d8 <HAL_DCMIPP_CSI_SetConfig+0x174>)
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34005536:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
3400553a:	682b      	ldr	r3, [r5, #0]
3400553c:	4f25      	ldr	r7, [pc, #148]	@ (340055d4 <HAL_DCMIPP_CSI_SetConfig+0x170>)
3400553e:	f023 0302 	bic.w	r3, r3, #2
34005542:	602b      	str	r3, [r5, #0]
  CLEAR_REG(csi_instance-> PCR);
34005544:	607e      	str	r6, [r7, #4]
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
34005546:	692b      	ldr	r3, [r5, #16]
  HAL_Delay(1);
34005548:	2001      	movs	r0, #1
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
3400554a:	f043 0301 	orr.w	r3, r3, #1
3400554e:	612b      	str	r3, [r5, #16]
  HAL_Delay(1);
34005550:	f7ff fc9a 	bl	34004e88 <HAL_Delay>
  CLEAR_REG(csi_instance->PTCR0);
34005554:	612e      	str	r6, [r5, #16]
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
34005556:	f8d4 8008 	ldr.w	r8, [r4, #8]
3400555a:	68ab      	ldr	r3, [r5, #8]
3400555c:	f85d 2038 	ldr.w	r2, [sp, r8, lsl #3]
34005560:	f423 43fe 	bic.w	r3, r3, #32512	@ 0x7f00
34005564:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
34005568:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
3400556c:	60ab      	str	r3, [r5, #8]
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
3400556e:	2138      	movs	r1, #56	@ 0x38
34005570:	2008      	movs	r0, #8
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
34005572:	0216      	lsls	r6, r2, #8
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
34005574:	f7ff ff1c 	bl	340053b0 <DCMIPP_CSI_WritePHYReg.constprop.0>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe4, 0x11);
34005578:	2111      	movs	r1, #17
3400557a:	20e4      	movs	r0, #228	@ 0xe4
3400557c:	f7ff ff18 	bl	340053b0 <DCMIPP_CSI_WritePHYReg.constprop.0>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
34005580:	eb0d 03c8 	add.w	r3, sp, r8, lsl #3
34005584:	f8d3 8004 	ldr.w	r8, [r3, #4]
34005588:	20e3      	movs	r0, #227	@ 0xe3
3400558a:	ea4f 2118 	mov.w	r1, r8, lsr #8
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
3400558e:	f446 3680 	orr.w	r6, r6, #65536	@ 0x10000
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
34005592:	f7ff ff0d 	bl	340053b0 <DCMIPP_CSI_WritePHYReg.constprop.0>
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34005596:	f046 0628 	orr.w	r6, r6, #40	@ 0x28
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target & 0xFFU);
3400559a:	20e3      	movs	r0, #227	@ 0xe3
3400559c:	fa5f f188 	uxtb.w	r1, r8
340055a0:	f7ff ff06 	bl	340053b0 <DCMIPP_CSI_WritePHYReg.constprop.0>
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
340055a4:	60ae      	str	r6, [r5, #8]
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
340055a6:	6823      	ldr	r3, [r4, #0]
  CLEAR_REG(csi_instance->PMCR);
340055a8:	2000      	movs	r0, #0
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
340055aa:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
340055ae:	bf0c      	ite	eq
340055b0:	2307      	moveq	r3, #7
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_DL1EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
340055b2:	230f      	movne	r3, #15
340055b4:	607b      	str	r3, [r7, #4]
  SET_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
340055b6:	682b      	ldr	r3, [r5, #0]
340055b8:	f043 0302 	orr.w	r3, r3, #2
340055bc:	602b      	str	r3, [r5, #0]
  CLEAR_REG(csi_instance->PMCR);
340055be:	6068      	str	r0, [r5, #4]
  return HAL_OK;
340055c0:	e75d      	b.n	3400547e <HAL_DCMIPP_CSI_SetConfig+0x1a>
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
340055c2:	f442 52f8 	orr.w	r2, r2, #7936	@ 0x1f00
340055c6:	e7a9      	b.n	3400551c <HAL_DCMIPP_CSI_SetConfig+0xb8>
340055c8:	3401d1a0 	.word	0x3401d1a0
340055cc:	58002000 	.word	0x58002000
340055d0:	3401fd64 	.word	0x3401fd64
340055d4:	58006000 	.word	0x58006000
340055d8:	58007000 	.word	0x58007000

340055dc <HAL_DCMIPP_CSI_PIPE_SetConfig>:
{
340055dc:	b570      	push	{r4, r5, r6, lr}
340055de:	460d      	mov	r5, r1
340055e0:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pCSI_PipeConfig == NULL))
340055e2:	4606      	mov	r6, r0
340055e4:	b908      	cbnz	r0, 340055ea <HAL_DCMIPP_CSI_PIPE_SetConfig+0xe>
    return HAL_ERROR;
340055e6:	2001      	movs	r0, #1
}
340055e8:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pCSI_PipeConfig == NULL))
340055ea:	2a00      	cmp	r2, #0
340055ec:	d0fb      	beq.n	340055e6 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340055ee:	6803      	ldr	r3, [r0, #0]
340055f0:	4a50      	ldr	r2, [pc, #320]	@ (34005734 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x158>)
340055f2:	4293      	cmp	r3, r2
340055f4:	d008      	beq.n	34005608 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x2c>
340055f6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340055fa:	4293      	cmp	r3, r2
340055fc:	d004      	beq.n	34005608 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x2c>
340055fe:	f44f 7144 	mov.w	r1, #784	@ 0x310
34005602:	484d      	ldr	r0, [pc, #308]	@ (34005738 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34005604:	f7fd fb04 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005608:	2d02      	cmp	r5, #2
3400560a:	d904      	bls.n	34005616 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x3a>
3400560c:	f240 3111 	movw	r1, #785	@ 0x311
34005610:	4849      	ldr	r0, [pc, #292]	@ (34005738 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34005612:	f7fd fafd 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));
34005616:	6823      	ldr	r3, [r4, #0]
34005618:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
3400561c:	d004      	beq.n	34005628 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x4c>
3400561e:	f240 3112 	movw	r1, #786	@ 0x312
34005622:	4845      	ldr	r0, [pc, #276]	@ (34005738 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34005624:	f7fd faf4 	bl	34002c10 <assert_failed>
  if (Pipe != DCMIPP_PIPE2)
34005628:	2d02      	cmp	r5, #2
    assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));
3400562a:	6823      	ldr	r3, [r4, #0]
  if (Pipe != DCMIPP_PIPE2)
3400562c:	d01c      	beq.n	34005668 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x8c>
    assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));
3400562e:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
34005632:	d004      	beq.n	3400563e <HAL_DCMIPP_CSI_PIPE_SetConfig+0x62>
34005634:	f240 3116 	movw	r1, #790	@ 0x316
34005638:	483f      	ldr	r0, [pc, #252]	@ (34005738 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
3400563a:	f7fd fae9 	bl	34002c10 <assert_failed>
    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
3400563e:	6823      	ldr	r3, [r4, #0]
34005640:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34005644:	d002      	beq.n	3400564c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x70>
        || (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB))
34005646:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400564a:	d10d      	bne.n	34005668 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x8c>
      assert_param(IS_DCMIPP_DATA_TYPE(pCSI_PipeConfig->DataTypeIDB));
3400564c:	68a3      	ldr	r3, [r4, #8]
3400564e:	3b18      	subs	r3, #24
34005650:	2b15      	cmp	r3, #21
34005652:	d804      	bhi.n	3400565e <HAL_DCMIPP_CSI_PIPE_SetConfig+0x82>
34005654:	4a39      	ldr	r2, [pc, #228]	@ (3400573c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x160>)
34005656:	fa22 f303 	lsr.w	r3, r2, r3
3400565a:	07da      	lsls	r2, r3, #31
3400565c:	d404      	bmi.n	34005668 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x8c>
3400565e:	f240 311b 	movw	r1, #795	@ 0x31b
34005662:	4835      	ldr	r0, [pc, #212]	@ (34005738 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34005664:	f7fd fad4 	bl	34002c10 <assert_failed>
  if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
34005668:	6823      	ldr	r3, [r4, #0]
3400566a:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400566e:	d00d      	beq.n	3400568c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xb0>
    assert_param(IS_DCMIPP_DATA_TYPE(pCSI_PipeConfig->DataTypeIDA));
34005670:	6863      	ldr	r3, [r4, #4]
34005672:	3b18      	subs	r3, #24
34005674:	2b15      	cmp	r3, #21
34005676:	d804      	bhi.n	34005682 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa6>
34005678:	4a30      	ldr	r2, [pc, #192]	@ (3400573c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x160>)
3400567a:	fa22 f303 	lsr.w	r3, r2, r3
3400567e:	07db      	lsls	r3, r3, #31
34005680:	d404      	bmi.n	3400568c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xb0>
34005682:	f240 3121 	movw	r1, #801	@ 0x321
34005686:	482c      	ldr	r0, [pc, #176]	@ (34005738 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34005688:	f7fd fac2 	bl	34002c10 <assert_failed>
  state = hdcmipp->State;
3400568c:	7933      	ldrb	r3, [r6, #4]
  if ((state == HAL_DCMIPP_STATE_INIT) || (state == HAL_DCMIPP_STATE_READY))
3400568e:	3b01      	subs	r3, #1
34005690:	2b01      	cmp	r3, #1
34005692:	d82e      	bhi.n	340056f2 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x116>
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34005694:	6822      	ldr	r2, [r4, #0]
34005696:	f5b2 3f40 	cmp.w	r2, #196608	@ 0x30000
3400569a:	d045      	beq.n	34005728 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x14c>
3400569c:	f5b2 3f00 	cmp.w	r2, #131072	@ 0x20000
340056a0:	d12b      	bne.n	340056fa <HAL_DCMIPP_CSI_PIPE_SetConfig+0x11e>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
340056a2:	2d00      	cmp	r5, #0
340056a4:	d19f      	bne.n	340055e6 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa>
340056a6:	4613      	mov	r3, r2
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
340056a8:	6861      	ldr	r1, [r4, #4]
    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
340056aa:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
340056ae:	ea43 0301 	orr.w	r3, r3, r1
    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
340056b2:	6831      	ldr	r1, [r6, #0]
340056b4:	d002      	beq.n	340056bc <HAL_DCMIPP_CSI_PIPE_SetConfig+0xe0>
        || (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB))
340056b6:	f5b2 3f00 	cmp.w	r2, #131072	@ 0x20000
340056ba:	d104      	bne.n	340056c6 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xea>
      if (Pipe != DCMIPP_PIPE2)
340056bc:	2d02      	cmp	r5, #2
340056be:	d02b      	beq.n	34005718 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>
        pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDB << DCMIPP_P0FSCR_DTIDB_Pos);
340056c0:	68a2      	ldr	r2, [r4, #8]
340056c2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    if (Pipe == DCMIPP_PIPE0)
340056c6:	b9ed      	cbnz	r5, 34005704 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x128>
      MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_DTMODE | DCMIPP_P0FSCR_DTIDA |
340056c8:	6831      	ldr	r1, [r6, #0]
340056ca:	4a1d      	ldr	r2, [pc, #116]	@ (34005740 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x164>)
340056cc:	f8d1 0404 	ldr.w	r0, [r1, #1028]	@ 0x404
340056d0:	4002      	ands	r2, r0
340056d2:	431a      	orrs	r2, r3
340056d4:	f8c1 2404 	str.w	r2, [r1, #1028]	@ 0x404
    CLEAR_BIT(hdcmipp->Instance->PRCR, DCMIPP_PRCR_ENABLE);
340056d8:	6833      	ldr	r3, [r6, #0]
340056da:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
340056de:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
340056e2:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    SET_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
340056e6:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
340056ea:	f042 0201 	orr.w	r2, r2, #1
340056ee:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
  hdcmipp->State = HAL_DCMIPP_STATE_READY;
340056f2:	2302      	movs	r3, #2
  return HAL_OK;
340056f4:	2000      	movs	r0, #0
  hdcmipp->State = HAL_DCMIPP_STATE_READY;
340056f6:	7133      	strb	r3, [r6, #4]
  return HAL_OK;
340056f8:	e776      	b.n	340055e8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xc>
  uint32_t pxfscr_reg = 0;
340056fa:	2d02      	cmp	r5, #2
340056fc:	bf14      	ite	ne
340056fe:	4613      	movne	r3, r2
34005700:	2300      	moveq	r3, #0
34005702:	e7d1      	b.n	340056a8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xcc>
    else if (Pipe == DCMIPP_PIPE1)
34005704:	2d01      	cmp	r5, #1
34005706:	d107      	bne.n	34005718 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>
      MODIFY_REG(hdcmipp->Instance->P1FSCR, (DCMIPP_P1FSCR_DTIDA | DCMIPP_P1FSCR_DTIDB |
34005708:	f8d1 0804 	ldr.w	r0, [r1, #2052]	@ 0x804
3400570c:	4a0c      	ldr	r2, [pc, #48]	@ (34005740 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x164>)
3400570e:	4002      	ands	r2, r0
34005710:	431a      	orrs	r2, r3
34005712:	f8c1 2804 	str.w	r2, [r1, #2052]	@ 0x804
34005716:	e7df      	b.n	340056d8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xfc>
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_DTIDA, pxfscr_reg);
34005718:	f8d1 2c04 	ldr.w	r2, [r1, #3076]	@ 0xc04
3400571c:	f022 023f 	bic.w	r2, r2, #63	@ 0x3f
34005720:	4313      	orrs	r3, r2
34005722:	f8c1 3c04 	str.w	r3, [r1, #3076]	@ 0xc04
34005726:	e7d7      	b.n	340056d8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xfc>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
34005728:	2d00      	cmp	r5, #0
3400572a:	f47f af5c 	bne.w	340055e6 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa>
3400572e:	4613      	mov	r3, r2
34005730:	e7ca      	b.n	340056c8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xec>
34005732:	bf00      	nop
34005734:	58002000 	.word	0x58002000
34005738:	3401fd64 	.word	0x3401fd64
3400573c:	003c1fc3 	.word	0x003c1fc3
34005740:	fffcc0c0 	.word	0xfffcc0c0

34005744 <HAL_DCMIPP_CSI_SetVCConfig>:
  assert_param(IS_DCMIPP_VCID(VirtualChannel));
34005744:	2903      	cmp	r1, #3
{
34005746:	b570      	push	{r4, r5, r6, lr}
34005748:	4606      	mov	r6, r0
3400574a:	460d      	mov	r5, r1
3400574c:	4614      	mov	r4, r2
  assert_param(IS_DCMIPP_VCID(VirtualChannel));
3400574e:	d904      	bls.n	3400575a <HAL_DCMIPP_CSI_SetVCConfig+0x16>
34005750:	f44f 7172 	mov.w	r1, #968	@ 0x3c8
34005754:	4815      	ldr	r0, [pc, #84]	@ (340057ac <HAL_DCMIPP_CSI_SetVCConfig+0x68>)
34005756:	f7fd fa5b 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_CSI_DATA_TYPE_FORMAT(DataTypeFormat));
3400575a:	2c06      	cmp	r4, #6
3400575c:	d904      	bls.n	34005768 <HAL_DCMIPP_CSI_SetVCConfig+0x24>
3400575e:	f240 31c9 	movw	r1, #969	@ 0x3c9
34005762:	4812      	ldr	r0, [pc, #72]	@ (340057ac <HAL_DCMIPP_CSI_SetVCConfig+0x68>)
34005764:	f7fd fa54 	bl	34002c10 <assert_failed>
  if (hdcmipp == NULL)
34005768:	b1f6      	cbz	r6, 340057a8 <HAL_DCMIPP_CSI_SetVCConfig+0x64>
  switch (VirtualChannel)
3400576a:	2d03      	cmp	r5, #3
3400576c:	d808      	bhi.n	34005780 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
3400576e:	e8df f005 	tbb	[pc, r5]
34005772:	0902      	.short	0x0902
34005774:	150f      	.short	0x150f
      WRITE_REG(csi_instance->VC0CFGR1, (DataTypeFormat << CSI_VC0CFGR1_CDTFT_Pos) | CSI_VC0CFGR1_ALLDT);
34005776:	4b0e      	ldr	r3, [pc, #56]	@ (340057b0 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
34005778:	0224      	lsls	r4, r4, #8
3400577a:	f044 0401 	orr.w	r4, r4, #1
3400577e:	611c      	str	r4, [r3, #16]
  return HAL_OK;
34005780:	2000      	movs	r0, #0
}
34005782:	bd70      	pop	{r4, r5, r6, pc}
      WRITE_REG(csi_instance->VC1CFGR1, (DataTypeFormat << CSI_VC1CFGR1_CDTFT_Pos) | CSI_VC1CFGR1_ALLDT);
34005784:	4b0a      	ldr	r3, [pc, #40]	@ (340057b0 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
34005786:	0224      	lsls	r4, r4, #8
34005788:	f044 0401 	orr.w	r4, r4, #1
3400578c:	621c      	str	r4, [r3, #32]
      break;
3400578e:	e7f7      	b.n	34005780 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
      WRITE_REG(csi_instance->VC2CFGR1, (DataTypeFormat << CSI_VC2CFGR1_CDTFT_Pos) | CSI_VC2CFGR1_ALLDT);
34005790:	4b07      	ldr	r3, [pc, #28]	@ (340057b0 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
34005792:	0224      	lsls	r4, r4, #8
34005794:	f044 0401 	orr.w	r4, r4, #1
34005798:	631c      	str	r4, [r3, #48]	@ 0x30
      break;
3400579a:	e7f1      	b.n	34005780 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
      WRITE_REG(csi_instance->VC3CFGR1, (DataTypeFormat << CSI_VC3CFGR1_CDTFT_Pos) | CSI_VC3CFGR1_ALLDT);
3400579c:	4b04      	ldr	r3, [pc, #16]	@ (340057b0 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
3400579e:	0224      	lsls	r4, r4, #8
340057a0:	f044 0401 	orr.w	r4, r4, #1
340057a4:	641c      	str	r4, [r3, #64]	@ 0x40
      break;
340057a6:	e7eb      	b.n	34005780 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
    return HAL_ERROR;
340057a8:	2001      	movs	r0, #1
340057aa:	e7ea      	b.n	34005782 <HAL_DCMIPP_CSI_SetVCConfig+0x3e>
340057ac:	3401fd64 	.word	0x3401fd64
340057b0:	58006000 	.word	0x58006000

340057b4 <HAL_DCMIPP_PIPE_SetConfig>:
{
340057b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
340057b6:	460d      	mov	r5, r1
340057b8:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
340057ba:	4606      	mov	r6, r0
340057bc:	b908      	cbnz	r0, 340057c2 <HAL_DCMIPP_PIPE_SetConfig+0xe>
    return HAL_ERROR;
340057be:	2001      	movs	r0, #1
}
340057c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
340057c2:	2a00      	cmp	r2, #0
340057c4:	d0fb      	beq.n	340057be <HAL_DCMIPP_PIPE_SetConfig+0xa>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340057c6:	6803      	ldr	r3, [r0, #0]
340057c8:	4a46      	ldr	r2, [pc, #280]	@ (340058e4 <HAL_DCMIPP_PIPE_SetConfig+0x130>)
340057ca:	4293      	cmp	r3, r2
340057cc:	d008      	beq.n	340057e0 <HAL_DCMIPP_PIPE_SetConfig+0x2c>
340057ce:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340057d2:	4293      	cmp	r3, r2
340057d4:	d004      	beq.n	340057e0 <HAL_DCMIPP_PIPE_SetConfig+0x2c>
340057d6:	f240 4102 	movw	r1, #1026	@ 0x402
340057da:	4843      	ldr	r0, [pc, #268]	@ (340058e8 <HAL_DCMIPP_PIPE_SetConfig+0x134>)
340057dc:	f7fd fa18 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340057e0:	2d02      	cmp	r5, #2
340057e2:	d904      	bls.n	340057ee <HAL_DCMIPP_PIPE_SetConfig+0x3a>
340057e4:	f240 4103 	movw	r1, #1027	@ 0x403
340057e8:	483f      	ldr	r0, [pc, #252]	@ (340058e8 <HAL_DCMIPP_PIPE_SetConfig+0x134>)
340057ea:	f7fd fa11 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_FRAME_RATE(pPipeConfig->FrameRate));
340057ee:	6823      	ldr	r3, [r4, #0]
340057f0:	2b03      	cmp	r3, #3
340057f2:	d904      	bls.n	340057fe <HAL_DCMIPP_PIPE_SetConfig+0x4a>
340057f4:	f240 4104 	movw	r1, #1028	@ 0x404
340057f8:	483b      	ldr	r0, [pc, #236]	@ (340058e8 <HAL_DCMIPP_PIPE_SetConfig+0x134>)
340057fa:	f7fd fa09 	bl	34002c10 <assert_failed>
  if (Pipe != DCMIPP_PIPE0)
340057fe:	b9bd      	cbnz	r5, 34005830 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
  pipe_state = hdcmipp->PipeState[Pipe];
34005800:	1971      	adds	r1, r6, r5
34005802:	7948      	ldrb	r0, [r1, #5]
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005804:	7933      	ldrb	r3, [r6, #4]
  pipe_state = hdcmipp->PipeState[Pipe];
34005806:	b2c0      	uxtb	r0, r0
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005808:	2b02      	cmp	r3, #2
3400580a:	b2da      	uxtb	r2, r3
3400580c:	d1d7      	bne.n	340057be <HAL_DCMIPP_PIPE_SetConfig+0xa>
    if ((pipe_state == HAL_DCMIPP_PIPE_STATE_RESET) || (pipe_state == HAL_DCMIPP_PIPE_STATE_ERROR))
3400580e:	f010 00fb 	ands.w	r0, r0, #251	@ 0xfb
34005812:	d1d4      	bne.n	340057be <HAL_DCMIPP_PIPE_SetConfig+0xa>
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34005814:	714a      	strb	r2, [r1, #5]
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
34005816:	6833      	ldr	r3, [r6, #0]
34005818:	6827      	ldr	r7, [r4, #0]
  if (Pipe == DCMIPP_PIPE0)
3400581a:	bb15      	cbnz	r5, 34005862 <HAL_DCMIPP_PIPE_SetConfig+0xae>
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
3400581c:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
34005820:	f022 0203 	bic.w	r2, r2, #3
34005824:	433a      	orrs	r2, r7
34005826:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_READY;
3400582a:	2301      	movs	r3, #1
3400582c:	714b      	strb	r3, [r1, #5]
  return HAL_OK;
3400582e:	e7c7      	b.n	340057c0 <HAL_DCMIPP_PIPE_SetConfig+0xc>
    assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(pPipeConfig->PixelPackerFormat));
34005830:	68a3      	ldr	r3, [r4, #8]
34005832:	2b0a      	cmp	r3, #10
34005834:	d904      	bls.n	34005840 <HAL_DCMIPP_PIPE_SetConfig+0x8c>
34005836:	f240 4107 	movw	r1, #1031	@ 0x407
3400583a:	482b      	ldr	r0, [pc, #172]	@ (340058e8 <HAL_DCMIPP_PIPE_SetConfig+0x134>)
3400583c:	f7fd f9e8 	bl	34002c10 <assert_failed>
    assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(pPipeConfig->PixelPipePitch));
34005840:	6863      	ldr	r3, [r4, #4]
34005842:	071a      	lsls	r2, r3, #28
34005844:	d102      	bne.n	3400584c <HAL_DCMIPP_PIPE_SetConfig+0x98>
34005846:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3400584a:	d304      	bcc.n	34005856 <HAL_DCMIPP_PIPE_SetConfig+0xa2>
3400584c:	f44f 6181 	mov.w	r1, #1032	@ 0x408
34005850:	4825      	ldr	r0, [pc, #148]	@ (340058e8 <HAL_DCMIPP_PIPE_SetConfig+0x134>)
34005852:	f7fd f9dd 	bl	34002c10 <assert_failed>
  if ((Pipe == DCMIPP_PIPE2) && ((pPipeConfig->PixelPackerFormat) > DCMIPP_PIXEL_PACKER_FORMAT_YUV422_1))
34005856:	2d02      	cmp	r5, #2
34005858:	d1d2      	bne.n	34005800 <HAL_DCMIPP_PIPE_SetConfig+0x4c>
3400585a:	68a3      	ldr	r3, [r4, #8]
3400585c:	2b06      	cmp	r3, #6
3400585e:	d9cf      	bls.n	34005800 <HAL_DCMIPP_PIPE_SetConfig+0x4c>
34005860:	e7ad      	b.n	340057be <HAL_DCMIPP_PIPE_SetConfig+0xa>
  else if (Pipe == DCMIPP_PIPE1)
34005862:	2d01      	cmp	r5, #1
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
34005864:	e9d4 4601 	ldrd	r4, r6, [r4, #4]
  else if (Pipe == DCMIPP_PIPE1)
34005868:	d126      	bne.n	340058b8 <HAL_DCMIPP_PIPE_SetConfig+0x104>
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
3400586a:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
3400586e:	4d1f      	ldr	r5, [pc, #124]	@ (340058ec <HAL_DCMIPP_PIPE_SetConfig+0x138>)
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
34005870:	f022 0203 	bic.w	r2, r2, #3
34005874:	433a      	orrs	r2, r7
34005876:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
3400587a:	f8d3 29c0 	ldr.w	r2, [r3, #2496]	@ 0x9c0
3400587e:	f022 020f 	bic.w	r2, r2, #15
34005882:	4332      	orrs	r2, r6
34005884:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
34005888:	f8d3 29cc 	ldr.w	r2, [r3, #2508]	@ 0x9cc
3400588c:	402a      	ands	r2, r5
3400588e:	4322      	orrs	r2, r4
34005890:	f8c3 29cc 	str.w	r2, [r3, #2508]	@ 0x9cc
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
34005894:	1ff2      	subs	r2, r6, #7
34005896:	2a01      	cmp	r2, #1
34005898:	d806      	bhi.n	340058a8 <HAL_DCMIPP_PIPE_SetConfig+0xf4>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
3400589a:	f8d3 29dc 	ldr.w	r2, [r3, #2524]	@ 0x9dc
3400589e:	402a      	ands	r2, r5
340058a0:	4322      	orrs	r2, r4
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
340058a2:	f8c3 29dc 	str.w	r2, [r3, #2524]	@ 0x9dc
340058a6:	e7c0      	b.n	3400582a <HAL_DCMIPP_PIPE_SetConfig+0x76>
    else if (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_3)
340058a8:	2e09      	cmp	r6, #9
340058aa:	d1be      	bne.n	3400582a <HAL_DCMIPP_PIPE_SetConfig+0x76>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
340058ac:	f8d3 29dc 	ldr.w	r2, [r3, #2524]	@ 0x9dc
340058b0:	402a      	ands	r2, r5
340058b2:	ea42 0254 	orr.w	r2, r2, r4, lsr #1
340058b6:	e7f4      	b.n	340058a2 <HAL_DCMIPP_PIPE_SetConfig+0xee>
    MODIFY_REG(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_FRATE, pPipeConfig->FrameRate);
340058b8:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
340058bc:	f022 0203 	bic.w	r2, r2, #3
340058c0:	433a      	orrs	r2, r7
340058c2:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
340058c6:	f8d3 2dc0 	ldr.w	r2, [r3, #3520]	@ 0xdc0
340058ca:	f022 020f 	bic.w	r2, r2, #15
340058ce:	4332      	orrs	r2, r6
340058d0:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
340058d4:	f8d3 2dcc 	ldr.w	r2, [r3, #3532]	@ 0xdcc
340058d8:	f36f 020e 	bfc	r2, #0, #15
340058dc:	4322      	orrs	r2, r4
340058de:	f8c3 2dcc 	str.w	r2, [r3, #3532]	@ 0xdcc
340058e2:	e7a2      	b.n	3400582a <HAL_DCMIPP_PIPE_SetConfig+0x76>
340058e4:	58002000 	.word	0x58002000
340058e8:	3401fd64 	.word	0x3401fd64
340058ec:	ffff8000 	.word	0xffff8000

340058f0 <HAL_DCMIPP_CSI_PIPE_Start>:
{
340058f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
340058f4:	2902      	cmp	r1, #2
{
340058f6:	4604      	mov	r4, r0
340058f8:	460d      	mov	r5, r1
340058fa:	4616      	mov	r6, r2
340058fc:	461f      	mov	r7, r3
340058fe:	f8dd 8018 	ldr.w	r8, [sp, #24]
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005902:	d904      	bls.n	3400590e <HAL_DCMIPP_CSI_PIPE_Start+0x1e>
34005904:	f44f 61c2 	mov.w	r1, #1552	@ 0x610
34005908:	481a      	ldr	r0, [pc, #104]	@ (34005974 <HAL_DCMIPP_CSI_PIPE_Start+0x84>)
3400590a:	f7fd f981 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_VCID(VirtualChannel));
3400590e:	2e03      	cmp	r6, #3
34005910:	d904      	bls.n	3400591c <HAL_DCMIPP_CSI_PIPE_Start+0x2c>
34005912:	f240 6111 	movw	r1, #1553	@ 0x611
34005916:	4817      	ldr	r0, [pc, #92]	@ (34005974 <HAL_DCMIPP_CSI_PIPE_Start+0x84>)
34005918:	f7fd f97a 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_CAPTURE_MODE(CaptureMode));
3400591c:	f038 0304 	bics.w	r3, r8, #4
34005920:	d004      	beq.n	3400592c <HAL_DCMIPP_CSI_PIPE_Start+0x3c>
34005922:	f240 6112 	movw	r1, #1554	@ 0x612
34005926:	4813      	ldr	r0, [pc, #76]	@ (34005974 <HAL_DCMIPP_CSI_PIPE_Start+0x84>)
34005928:	f7fd f972 	bl	34002c10 <assert_failed>
  if ((hdcmipp == NULL) || ((DstAddress & 0xFU) != 0U))
3400592c:	b91c      	cbnz	r4, 34005936 <HAL_DCMIPP_CSI_PIPE_Start+0x46>
    return HAL_ERROR;
3400592e:	2601      	movs	r6, #1
}
34005930:	4630      	mov	r0, r6
34005932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((hdcmipp == NULL) || ((DstAddress & 0xFU) != 0U))
34005936:	073a      	lsls	r2, r7, #28
34005938:	d1f9      	bne.n	3400592e <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
  mode = READ_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
3400593a:	6823      	ldr	r3, [r4, #0]
  if ((hdcmipp->PipeState[Pipe] != HAL_DCMIPP_PIPE_STATE_READY) || (mode != DCMIPP_SERIAL_MODE))
3400593c:	1962      	adds	r2, r4, r5
  mode = READ_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
3400593e:	f8d3 3204 	ldr.w	r3, [r3, #516]	@ 0x204
  if ((hdcmipp->PipeState[Pipe] != HAL_DCMIPP_PIPE_STATE_READY) || (mode != DCMIPP_SERIAL_MODE))
34005942:	7952      	ldrb	r2, [r2, #5]
34005944:	2a01      	cmp	r2, #1
34005946:	d1f2      	bne.n	3400592e <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
34005948:	07db      	lsls	r3, r3, #31
3400594a:	d5f0      	bpl.n	3400592e <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
  if (DCMIPP_CSI_SetVCConfig(hdcmipp, Pipe, VirtualChannel) != HAL_OK)
3400594c:	4632      	mov	r2, r6
3400594e:	4629      	mov	r1, r5
34005950:	4620      	mov	r0, r4
34005952:	f7ff fc65 	bl	34005220 <DCMIPP_CSI_SetVCConfig>
34005956:	4606      	mov	r6, r0
34005958:	2800      	cmp	r0, #0
3400595a:	d1e8      	bne.n	3400592e <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
  DCMIPP_SetConfig(hdcmipp, Pipe, DstAddress, CaptureMode);
3400595c:	4629      	mov	r1, r5
3400595e:	4620      	mov	r0, r4
34005960:	4643      	mov	r3, r8
34005962:	463a      	mov	r2, r7
34005964:	f7ff fcd7 	bl	34005316 <DCMIPP_SetConfig>
  DCMIPP_EnableCapture(hdcmipp, Pipe);
34005968:	4629      	mov	r1, r5
3400596a:	4620      	mov	r0, r4
3400596c:	f7ff fcfe 	bl	3400536c <DCMIPP_EnableCapture>
  return HAL_OK;
34005970:	e7de      	b.n	34005930 <HAL_DCMIPP_CSI_PIPE_Start+0x40>
34005972:	bf00      	nop
34005974:	3401fd64 	.word	0x3401fd64

34005978 <HAL_DCMIPP_PIPE_LineEventCallback>:
__weak void HAL_DCMIPP_PIPE_LineEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
34005978:	4770      	bx	lr

3400597a <HAL_DCMIPP_PIPE_LimitEventCallback>:
__weak void HAL_DCMIPP_PIPE_LimitEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
3400597a:	4770      	bx	lr

3400597c <HAL_DCMIPP_PIPE_ErrorCallback>:
__weak void HAL_DCMIPP_PIPE_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
3400597c:	4770      	bx	lr

3400597e <HAL_DCMIPP_ErrorCallback>:
__weak void HAL_DCMIPP_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp)
3400597e:	4770      	bx	lr

34005980 <HAL_DCMIPP_IRQHandler>:
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
34005980:	6803      	ldr	r3, [r0, #0]
{
34005982:	b570      	push	{r4, r5, r6, lr}
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
34005984:	f8d3 63f8 	ldr.w	r6, [r3, #1016]	@ 0x3f8
{
34005988:	4604      	mov	r4, r0
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
3400598a:	0472      	lsls	r2, r6, #17
  uint32_t cmierflags = READ_REG(hdcmipp->Instance->CMIER);
3400598c:	f8d3 53f0 	ldr.w	r5, [r3, #1008]	@ 0x3f0
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
34005990:	d512      	bpl.n	340059b8 <HAL_DCMIPP_IRQHandler+0x38>
    if ((cmierflags & DCMIPP_IT_PIPE0_LIMIT) != 0U)
34005992:	0469      	lsls	r1, r5, #17
34005994:	d510      	bpl.n	340059b8 <HAL_DCMIPP_IRQHandler+0x38>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
34005996:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
3400599a:	2100      	movs	r1, #0
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
3400599c:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
340059a0:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_LIMIT;
340059a4:	6882      	ldr	r2, [r0, #8]
340059a6:	f042 0204 	orr.w	r2, r2, #4
340059aa:	6082      	str	r2, [r0, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LIMIT);
340059ac:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
340059b0:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
340059b4:	f7ff ffe1 	bl	3400597a <HAL_DCMIPP_PIPE_LimitEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_VSYNC) != 0U)
340059b8:	0572      	lsls	r2, r6, #21
340059ba:	d50a      	bpl.n	340059d2 <HAL_DCMIPP_IRQHandler+0x52>
    if ((cmierflags & DCMIPP_IT_PIPE0_VSYNC) != 0U)
340059bc:	056b      	lsls	r3, r5, #21
340059be:	d508      	bpl.n	340059d2 <HAL_DCMIPP_IRQHandler+0x52>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
340059c0:	f44f 6280 	mov.w	r2, #1024	@ 0x400
340059c4:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
340059c6:	2100      	movs	r1, #0
340059c8:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
340059ca:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
340059ce:	f00b f851 	bl	34010a74 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_FRAME) != 0U)
340059d2:	05b0      	lsls	r0, r6, #22
340059d4:	d516      	bpl.n	34005a04 <HAL_DCMIPP_IRQHandler+0x84>
    if ((cmierflags & DCMIPP_IT_PIPE0_FRAME) != 0U)
340059d6:	05a9      	lsls	r1, r5, #22
340059d8:	d514      	bpl.n	34005a04 <HAL_DCMIPP_IRQHandler+0x84>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340059da:	6823      	ldr	r3, [r4, #0]
340059dc:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
340059e0:	0752      	lsls	r2, r2, #29
340059e2:	d507      	bpl.n	340059f4 <HAL_DCMIPP_IRQHandler+0x74>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR);
340059e4:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
340059e8:	f422 4206 	bic.w	r2, r2, #34304	@ 0x8600
340059ec:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_READY;
340059f0:	2201      	movs	r2, #1
340059f2:	7162      	strb	r2, [r4, #5]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
340059f4:	f44f 7200 	mov.w	r2, #512	@ 0x200
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
340059f8:	2100      	movs	r1, #0
340059fa:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
340059fc:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
34005a00:	f00b f848 	bl	34010a94 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LINE) != 0U)
34005a04:	05f3      	lsls	r3, r6, #23
34005a06:	d50a      	bpl.n	34005a1e <HAL_DCMIPP_IRQHandler+0x9e>
    if ((cmierflags & DCMIPP_IT_PIPE0_LINE) != 0U)
34005a08:	05e8      	lsls	r0, r5, #23
34005a0a:	d508      	bpl.n	34005a1e <HAL_DCMIPP_IRQHandler+0x9e>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
34005a0c:	f44f 7280 	mov.w	r2, #256	@ 0x100
34005a10:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
34005a12:	2100      	movs	r1, #0
34005a14:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
34005a16:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
34005a1a:	f7ff ffad 	bl	34005978 <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_OVR) != 0U)
34005a1e:	0431      	lsls	r1, r6, #16
34005a20:	d516      	bpl.n	34005a50 <HAL_DCMIPP_IRQHandler+0xd0>
    if ((cmierflags & DCMIPP_IT_PIPE0_OVR) != 0U)
34005a22:	042a      	lsls	r2, r5, #16
34005a24:	d514      	bpl.n	34005a50 <HAL_DCMIPP_IRQHandler+0xd0>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
34005a26:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
34005a28:	2100      	movs	r1, #0
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
34005a2a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
34005a2e:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
34005a30:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34005a34:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_OVR;
34005a38:	68a2      	ldr	r2, [r4, #8]
34005a3a:	f042 0208 	orr.w	r2, r2, #8
34005a3e:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_OVR);
34005a40:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34005a44:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_ERROR;
34005a48:	2304      	movs	r3, #4
34005a4a:	7163      	strb	r3, [r4, #5]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
34005a4c:	f7ff ff96 	bl	3400597c <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
34005a50:	03f3      	lsls	r3, r6, #15
34005a52:	d50a      	bpl.n	34005a6a <HAL_DCMIPP_IRQHandler+0xea>
    if ((cmierflags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
34005a54:	03e8      	lsls	r0, r5, #15
34005a56:	d508      	bpl.n	34005a6a <HAL_DCMIPP_IRQHandler+0xea>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
34005a58:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34005a5c:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
34005a5e:	2101      	movs	r1, #1
34005a60:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
34005a62:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
34005a66:	f7ff ff87 	bl	34005978 <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_VSYNC) != 0U)
34005a6a:	0371      	lsls	r1, r6, #13
34005a6c:	d50a      	bpl.n	34005a84 <HAL_DCMIPP_IRQHandler+0x104>
    if ((cmierflags & DCMIPP_IT_PIPE1_VSYNC) != 0U)
34005a6e:	036a      	lsls	r2, r5, #13
34005a70:	d508      	bpl.n	34005a84 <HAL_DCMIPP_IRQHandler+0x104>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
34005a72:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
34005a76:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
34005a78:	2101      	movs	r1, #1
34005a7a:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
34005a7c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
34005a80:	f00a fff8 	bl	34010a74 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_FRAME) != 0U)
34005a84:	03b3      	lsls	r3, r6, #14
34005a86:	d516      	bpl.n	34005ab6 <HAL_DCMIPP_IRQHandler+0x136>
    if ((cmierflags & DCMIPP_IT_PIPE1_FRAME) != 0U)
34005a88:	03a8      	lsls	r0, r5, #14
34005a8a:	d514      	bpl.n	34005ab6 <HAL_DCMIPP_IRQHandler+0x136>
      if ((hdcmipp->Instance->P1FCTCR & DCMIPP_P1FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005a8c:	6823      	ldr	r3, [r4, #0]
34005a8e:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
34005a92:	0751      	lsls	r1, r2, #29
34005a94:	d507      	bpl.n	34005aa6 <HAL_DCMIPP_IRQHandler+0x126>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME | DCMIPP_IT_PIPE1_VSYNC | DCMIPP_IT_PIPE1_OVR);
34005a96:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34005a9a:	f422 0206 	bic.w	r2, r2, #8781824	@ 0x860000
34005a9e:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_READY;
34005aa2:	2201      	movs	r2, #1
34005aa4:	71a2      	strb	r2, [r4, #6]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
34005aa6:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
34005aaa:	2101      	movs	r1, #1
34005aac:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
34005aae:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
34005ab2:	f00a ffef 	bl	34010a94 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_OVR) != 0U)
34005ab6:	0232      	lsls	r2, r6, #8
34005ab8:	d516      	bpl.n	34005ae8 <HAL_DCMIPP_IRQHandler+0x168>
    if ((cmierflags & DCMIPP_IT_PIPE1_OVR) != 0U)
34005aba:	022b      	lsls	r3, r5, #8
34005abc:	d514      	bpl.n	34005ae8 <HAL_DCMIPP_IRQHandler+0x168>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34005abe:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34005ac0:	2101      	movs	r1, #1
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34005ac2:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34005ac6:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34005ac8:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
34005acc:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE1_OVR;
34005ad0:	68a2      	ldr	r2, [r4, #8]
34005ad2:	f042 0210 	orr.w	r2, r2, #16
34005ad6:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_OVR);
34005ad8:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
34005adc:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_ERROR;
34005ae0:	2304      	movs	r3, #4
34005ae2:	71a3      	strb	r3, [r4, #6]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34005ae4:	f7ff ff4a 	bl	3400597c <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_LINE) != 0U)
34005ae8:	01f0      	lsls	r0, r6, #7
34005aea:	d50a      	bpl.n	34005b02 <HAL_DCMIPP_IRQHandler+0x182>
    if ((cmierflags & DCMIPP_IT_PIPE2_LINE) != 0U)
34005aec:	01e9      	lsls	r1, r5, #7
34005aee:	d508      	bpl.n	34005b02 <HAL_DCMIPP_IRQHandler+0x182>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
34005af0:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34005af4:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
34005af6:	2102      	movs	r1, #2
34005af8:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
34005afa:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
34005afe:	f7ff ff3b 	bl	34005978 <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_VSYNC) != 0U)
34005b02:	0172      	lsls	r2, r6, #5
34005b04:	d50a      	bpl.n	34005b1c <HAL_DCMIPP_IRQHandler+0x19c>
    if ((cmierflags & DCMIPP_IT_PIPE2_VSYNC) != 0U)
34005b06:	016b      	lsls	r3, r5, #5
34005b08:	d508      	bpl.n	34005b1c <HAL_DCMIPP_IRQHandler+0x19c>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
34005b0a:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34005b0e:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
34005b10:	2102      	movs	r1, #2
34005b12:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
34005b14:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
34005b18:	f00a ffac 	bl	34010a74 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_FRAME) != 0U)
34005b1c:	01b0      	lsls	r0, r6, #6
34005b1e:	d516      	bpl.n	34005b4e <HAL_DCMIPP_IRQHandler+0x1ce>
    if ((cmierflags & DCMIPP_IT_PIPE2_FRAME) != 0U)
34005b20:	01a9      	lsls	r1, r5, #6
34005b22:	d514      	bpl.n	34005b4e <HAL_DCMIPP_IRQHandler+0x1ce>
      if ((hdcmipp->Instance->P2FCTCR & DCMIPP_P2FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005b24:	6823      	ldr	r3, [r4, #0]
34005b26:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
34005b2a:	0752      	lsls	r2, r2, #29
34005b2c:	d507      	bpl.n	34005b3e <HAL_DCMIPP_IRQHandler+0x1be>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_VSYNC | DCMIPP_IT_PIPE2_OVR);
34005b2e:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34005b32:	f022 4206 	bic.w	r2, r2, #2248146944	@ 0x86000000
34005b36:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_READY;
34005b3a:	2201      	movs	r2, #1
34005b3c:	71e2      	strb	r2, [r4, #7]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
34005b3e:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
34005b42:	2102      	movs	r1, #2
34005b44:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
34005b46:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
34005b4a:	f00a ffa3 	bl	34010a94 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_OVR) != 0U)
34005b4e:	2e00      	cmp	r6, #0
34005b50:	da16      	bge.n	34005b80 <HAL_DCMIPP_IRQHandler+0x200>
    if ((cmierflags & DCMIPP_IT_PIPE2_OVR) != 0U)
34005b52:	2d00      	cmp	r5, #0
34005b54:	da14      	bge.n	34005b80 <HAL_DCMIPP_IRQHandler+0x200>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
34005b56:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
34005b58:	2102      	movs	r1, #2
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
34005b5a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
34005b5e:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
34005b60:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34005b64:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE2_OVR;
34005b68:	68a2      	ldr	r2, [r4, #8]
34005b6a:	f042 0220 	orr.w	r2, r2, #32
34005b6e:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_OVR);
34005b70:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34005b74:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_ERROR;
34005b78:	2304      	movs	r3, #4
34005b7a:	71e3      	strb	r3, [r4, #7]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
34005b7c:	f7ff fefe 	bl	3400597c <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PARALLEL_SYNC_ERROR) != 0U)
34005b80:	0670      	lsls	r0, r6, #25
34005b82:	d514      	bpl.n	34005bae <HAL_DCMIPP_IRQHandler+0x22e>
    if ((cmierflags & DCMIPP_IT_PARALLEL_SYNC_ERROR) != 0U)
34005b84:	0669      	lsls	r1, r5, #25
34005b86:	d512      	bpl.n	34005bae <HAL_DCMIPP_IRQHandler+0x22e>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
34005b88:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005b8a:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
34005b8c:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34005b90:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
34005b94:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PARALLEL_SYNC;
34005b98:	68a2      	ldr	r2, [r4, #8]
34005b9a:	f042 0202 	orr.w	r2, r2, #2
34005b9e:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PARALLEL_SYNC_ERROR);
34005ba0:	2240      	movs	r2, #64	@ 0x40
34005ba2:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005ba6:	2304      	movs	r3, #4
34005ba8:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005baa:	f7ff fee8 	bl	3400597e <HAL_DCMIPP_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_AXI_TRANSFER_ERROR) != 0U)
34005bae:	06b2      	lsls	r2, r6, #26
34005bb0:	d514      	bpl.n	34005bdc <HAL_DCMIPP_IRQHandler+0x25c>
    if ((cmierflags & DCMIPP_IT_AXI_TRANSFER_ERROR) != 0U)
34005bb2:	06ab      	lsls	r3, r5, #26
34005bb4:	d512      	bpl.n	34005bdc <HAL_DCMIPP_IRQHandler+0x25c>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
34005bb6:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005bb8:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
34005bba:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34005bbe:	f022 0220 	bic.w	r2, r2, #32
34005bc2:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_AXI_TRANSFER;
34005bc6:	68a2      	ldr	r2, [r4, #8]
34005bc8:	f042 0201 	orr.w	r2, r2, #1
34005bcc:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_AXI_TRANSFER_ERROR);
34005bce:	2220      	movs	r2, #32
34005bd0:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005bd4:	2304      	movs	r3, #4
34005bd6:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005bd8:	f7ff fed1 	bl	3400597e <HAL_DCMIPP_ErrorCallback>
}
34005bdc:	bd70      	pop	{r4, r5, r6, pc}

34005bde <HAL_DCMIPP_CSI_LineErrorCallback>:
__weak void HAL_DCMIPP_CSI_LineErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t DataLane)
34005bde:	4770      	bx	lr

34005be0 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>:
__weak void HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
34005be0:	4770      	bx	lr

34005be2 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>:
__weak void HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
34005be2:	4770      	bx	lr

34005be4 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>:
__weak void HAL_DCMIPP_CSI_EndOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
34005be4:	4770      	bx	lr

34005be6 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>:
__weak void HAL_DCMIPP_CSI_StartOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
34005be6:	4770      	bx	lr

34005be8 <HAL_DCMIPP_CSI_TimerCounterEventCallback>:
__weak void HAL_DCMIPP_CSI_TimerCounterEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Timer)
34005be8:	4770      	bx	lr

34005bea <HAL_DCMIPP_CSI_LineByteEventCallback>:
__weak void HAL_DCMIPP_CSI_LineByteEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Counter)
34005bea:	4770      	bx	lr

34005bec <HAL_DCMIPP_CSI_IRQHandler>:
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
34005bec:	4bb5      	ldr	r3, [pc, #724]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
{
34005bee:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
34005bf2:	f8d3 6090 	ldr.w	r6, [r3, #144]	@ 0x90
{
34005bf6:	4604      	mov	r4, r0
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
34005bf8:	02b2      	lsls	r2, r6, #10
  uint32_t sr1flags = READ_REG(csi_instance->SR1);
34005bfa:	f8d3 8094 	ldr.w	r8, [r3, #148]	@ 0x94
  uint32_t ier0_flags = READ_REG(csi_instance->IER0);
34005bfe:	f8d3 5080 	ldr.w	r5, [r3, #128]	@ 0x80
  uint32_t ier1_flags = READ_REG(csi_instance->IER1);
34005c02:	f8d3 7084 	ldr.w	r7, [r3, #132]	@ 0x84
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
34005c06:	d50d      	bpl.n	34005c24 <HAL_DCMIPP_CSI_IRQHandler+0x38>
    if ((ier0_flags & DCMIPP_CSI_IT_CCFIFO) != 0U)
34005c08:	02a9      	lsls	r1, r5, #10
34005c0a:	d50b      	bpl.n	34005c24 <HAL_DCMIPP_CSI_IRQHandler+0x38>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO);
34005c0c:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005c10:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
34005c14:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CCFIFO);
34005c18:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
34005c1c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(hdcmipp);
34005c20:	f7ff ffde 	bl	34005be0 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB3) != 0U)
34005c24:	0732      	lsls	r2, r6, #28
34005c26:	d515      	bpl.n	34005c54 <HAL_DCMIPP_CSI_IRQHandler+0x68>
    if ((ier0_flags & DCMIPP_CSI_IT_LB3) != 0U)
34005c28:	072b      	lsls	r3, r5, #28
34005c2a:	d513      	bpl.n	34005c54 <HAL_DCMIPP_CSI_IRQHandler+0x68>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005c2c:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
34005c2e:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005c30:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
34005c34:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005c36:	f013 0f04 	tst.w	r3, #4
34005c3a:	4ba2      	ldr	r3, [pc, #648]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB3);
34005c3c:	bf1e      	ittt	ne
34005c3e:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005c42:	f022 0208 	bicne.w	r2, r2, #8
34005c46:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB3);
34005c4a:	2208      	movs	r2, #8
34005c4c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
34005c50:	f7ff ffcb 	bl	34005bea <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB2) != 0U)
34005c54:	0770      	lsls	r0, r6, #29
34005c56:	d515      	bpl.n	34005c84 <HAL_DCMIPP_CSI_IRQHandler+0x98>
    if ((ier0_flags & DCMIPP_CSI_IT_LB2) != 0U)
34005c58:	0769      	lsls	r1, r5, #29
34005c5a:	d513      	bpl.n	34005c84 <HAL_DCMIPP_CSI_IRQHandler+0x98>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005c5c:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
34005c5e:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005c60:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
34005c64:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005c66:	f013 0f04 	tst.w	r3, #4
34005c6a:	4b96      	ldr	r3, [pc, #600]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB2);
34005c6c:	bf1e      	ittt	ne
34005c6e:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005c72:	f022 0204 	bicne.w	r2, r2, #4
34005c76:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB2);
34005c7a:	2204      	movs	r2, #4
34005c7c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
34005c80:	f7ff ffb3 	bl	34005bea <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB1) != 0U)
34005c84:	07b2      	lsls	r2, r6, #30
34005c86:	d515      	bpl.n	34005cb4 <HAL_DCMIPP_CSI_IRQHandler+0xc8>
    if ((ier0_flags & DCMIPP_CSI_IT_LB1) != 0U)
34005c88:	07ab      	lsls	r3, r5, #30
34005c8a:	d513      	bpl.n	34005cb4 <HAL_DCMIPP_CSI_IRQHandler+0xc8>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005c8c:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34005c8e:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005c90:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34005c94:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005c96:	f013 0f04 	tst.w	r3, #4
34005c9a:	4b8a      	ldr	r3, [pc, #552]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB1);
34005c9c:	bf1e      	ittt	ne
34005c9e:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005ca2:	f022 0202 	bicne.w	r2, r2, #2
34005ca6:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB1);
34005caa:	2202      	movs	r2, #2
34005cac:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34005cb0:	f7ff ff9b 	bl	34005bea <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB0) != 0U)
34005cb4:	07f0      	lsls	r0, r6, #31
34005cb6:	d515      	bpl.n	34005ce4 <HAL_DCMIPP_CSI_IRQHandler+0xf8>
    if ((ier0_flags & DCMIPP_CSI_IT_LB0) != 0U)
34005cb8:	07e9      	lsls	r1, r5, #31
34005cba:	d513      	bpl.n	34005ce4 <HAL_DCMIPP_CSI_IRQHandler+0xf8>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005cbc:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34005cbe:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005cc0:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34005cc4:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005cc6:	f013 0f04 	tst.w	r3, #4
34005cca:	4b7e      	ldr	r3, [pc, #504]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB0);
34005ccc:	bf1e      	ittt	ne
34005cce:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005cd2:	f022 0201 	bicne.w	r2, r2, #1
34005cd6:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB0);
34005cda:	2201      	movs	r2, #1
34005cdc:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34005ce0:	f7ff ff83 	bl	34005bea <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF3) != 0U)
34005ce4:	0432      	lsls	r2, r6, #16
34005ce6:	d516      	bpl.n	34005d16 <HAL_DCMIPP_CSI_IRQHandler+0x12a>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF3) != 0U)
34005ce8:	042b      	lsls	r3, r5, #16
34005cea:	d514      	bpl.n	34005d16 <HAL_DCMIPP_CSI_IRQHandler+0x12a>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005cec:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005cee:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005cf0:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005cf4:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005cf6:	f013 0f04 	tst.w	r3, #4
34005cfa:	4b72      	ldr	r3, [pc, #456]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF3);
34005cfc:	bf1e      	ittt	ne
34005cfe:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005d02:	f422 4200 	bicne.w	r2, r2, #32768	@ 0x8000
34005d06:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF3);
34005d0a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34005d0e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005d12:	f7ff ff67 	bl	34005be4 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF2) != 0U)
34005d16:	0470      	lsls	r0, r6, #17
34005d18:	d516      	bpl.n	34005d48 <HAL_DCMIPP_CSI_IRQHandler+0x15c>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF2) != 0U)
34005d1a:	0469      	lsls	r1, r5, #17
34005d1c:	d514      	bpl.n	34005d48 <HAL_DCMIPP_CSI_IRQHandler+0x15c>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005d1e:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34005d20:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005d22:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34005d26:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005d28:	f013 0f04 	tst.w	r3, #4
34005d2c:	4b65      	ldr	r3, [pc, #404]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF2);
34005d2e:	bf1e      	ittt	ne
34005d30:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005d34:	f422 4280 	bicne.w	r2, r2, #16384	@ 0x4000
34005d38:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF2);
34005d3c:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34005d40:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34005d44:	f7ff ff4e 	bl	34005be4 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF1) != 0U)
34005d48:	04b2      	lsls	r2, r6, #18
34005d4a:	d516      	bpl.n	34005d7a <HAL_DCMIPP_CSI_IRQHandler+0x18e>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF1) != 0U)
34005d4c:	04ab      	lsls	r3, r5, #18
34005d4e:	d514      	bpl.n	34005d7a <HAL_DCMIPP_CSI_IRQHandler+0x18e>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005d50:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34005d52:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005d54:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34005d58:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005d5a:	f013 0f04 	tst.w	r3, #4
34005d5e:	4b59      	ldr	r3, [pc, #356]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF1);
34005d60:	bf1e      	ittt	ne
34005d62:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005d66:	f422 5200 	bicne.w	r2, r2, #8192	@ 0x2000
34005d6a:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF1);
34005d6e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34005d72:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34005d76:	f7ff ff35 	bl	34005be4 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF0) != 0U)
34005d7a:	04f0      	lsls	r0, r6, #19
34005d7c:	d516      	bpl.n	34005dac <HAL_DCMIPP_CSI_IRQHandler+0x1c0>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF0) != 0U)
34005d7e:	04e9      	lsls	r1, r5, #19
34005d80:	d514      	bpl.n	34005dac <HAL_DCMIPP_CSI_IRQHandler+0x1c0>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005d82:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34005d84:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005d86:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34005d8a:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005d8c:	f013 0f04 	tst.w	r3, #4
34005d90:	4b4c      	ldr	r3, [pc, #304]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF0);
34005d92:	bf1e      	ittt	ne
34005d94:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005d98:	f422 5280 	bicne.w	r2, r2, #4096	@ 0x1000
34005d9c:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF0);
34005da0:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34005da4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34005da8:	f7ff ff1c 	bl	34005be4 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF3) != 0U)
34005dac:	0532      	lsls	r2, r6, #20
34005dae:	d516      	bpl.n	34005dde <HAL_DCMIPP_CSI_IRQHandler+0x1f2>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF3) != 0U)
34005db0:	052b      	lsls	r3, r5, #20
34005db2:	d514      	bpl.n	34005dde <HAL_DCMIPP_CSI_IRQHandler+0x1f2>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005db4:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005db6:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005db8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005dbc:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005dbe:	f013 0f04 	tst.w	r3, #4
34005dc2:	4b40      	ldr	r3, [pc, #256]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF3);
34005dc4:	bf1e      	ittt	ne
34005dc6:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005dca:	f422 6200 	bicne.w	r2, r2, #2048	@ 0x800
34005dce:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF3);
34005dd2:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34005dd6:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005dda:	f7ff ff04 	bl	34005be6 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF2) != 0U)
34005dde:	0570      	lsls	r0, r6, #21
34005de0:	d516      	bpl.n	34005e10 <HAL_DCMIPP_CSI_IRQHandler+0x224>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF2) != 0U)
34005de2:	0569      	lsls	r1, r5, #21
34005de4:	d514      	bpl.n	34005e10 <HAL_DCMIPP_CSI_IRQHandler+0x224>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005de6:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34005de8:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005dea:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34005dee:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005df0:	f013 0f04 	tst.w	r3, #4
34005df4:	4b33      	ldr	r3, [pc, #204]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF2);
34005df6:	bf1e      	ittt	ne
34005df8:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005dfc:	f422 6280 	bicne.w	r2, r2, #1024	@ 0x400
34005e00:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF2);
34005e04:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34005e08:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34005e0c:	f7ff feeb 	bl	34005be6 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF1) != 0U)
34005e10:	05b2      	lsls	r2, r6, #22
34005e12:	d516      	bpl.n	34005e42 <HAL_DCMIPP_CSI_IRQHandler+0x256>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF1) != 0U)
34005e14:	05ab      	lsls	r3, r5, #22
34005e16:	d514      	bpl.n	34005e42 <HAL_DCMIPP_CSI_IRQHandler+0x256>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005e18:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34005e1a:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005e1c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34005e20:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005e22:	f013 0f04 	tst.w	r3, #4
34005e26:	4b27      	ldr	r3, [pc, #156]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF1);
34005e28:	bf1e      	ittt	ne
34005e2a:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005e2e:	f422 7200 	bicne.w	r2, r2, #512	@ 0x200
34005e32:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF1);
34005e36:	f44f 7200 	mov.w	r2, #512	@ 0x200
34005e3a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34005e3e:	f7ff fed2 	bl	34005be6 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF0) != 0U)
34005e42:	05f0      	lsls	r0, r6, #23
34005e44:	d516      	bpl.n	34005e74 <HAL_DCMIPP_CSI_IRQHandler+0x288>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF0) != 0U)
34005e46:	05e9      	lsls	r1, r5, #23
34005e48:	d514      	bpl.n	34005e74 <HAL_DCMIPP_CSI_IRQHandler+0x288>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005e4a:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34005e4c:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005e4e:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34005e52:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005e54:	f013 0f04 	tst.w	r3, #4
34005e58:	4b1a      	ldr	r3, [pc, #104]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF0);
34005e5a:	bf1e      	ittt	ne
34005e5c:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005e60:	f422 7280 	bicne.w	r2, r2, #256	@ 0x100
34005e64:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF0);
34005e68:	f44f 7280 	mov.w	r2, #256	@ 0x100
34005e6c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34005e70:	f7ff feb9 	bl	34005be6 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM3) != 0U)
34005e74:	0632      	lsls	r2, r6, #24
34005e76:	d515      	bpl.n	34005ea4 <HAL_DCMIPP_CSI_IRQHandler+0x2b8>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM3) != 0U)
34005e78:	062b      	lsls	r3, r5, #24
34005e7a:	d513      	bpl.n	34005ea4 <HAL_DCMIPP_CSI_IRQHandler+0x2b8>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005e7c:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
34005e7e:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005e80:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
34005e84:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005e86:	f013 0f04 	tst.w	r3, #4
34005e8a:	4b0e      	ldr	r3, [pc, #56]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM3);
34005e8c:	bf1e      	ittt	ne
34005e8e:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005e92:	f022 0280 	bicne.w	r2, r2, #128	@ 0x80
34005e96:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM3);
34005e9a:	2280      	movs	r2, #128	@ 0x80
34005e9c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
34005ea0:	f7ff fea2 	bl	34005be8 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM2) != 0U)
34005ea4:	0670      	lsls	r0, r6, #25
34005ea6:	d519      	bpl.n	34005edc <HAL_DCMIPP_CSI_IRQHandler+0x2f0>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM2) != 0U)
34005ea8:	0669      	lsls	r1, r5, #25
34005eaa:	d517      	bpl.n	34005edc <HAL_DCMIPP_CSI_IRQHandler+0x2f0>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005eac:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34005eae:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005eb0:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34005eb4:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005eb6:	f013 0f04 	tst.w	r3, #4
34005eba:	4b02      	ldr	r3, [pc, #8]	@ (34005ec4 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM2);
34005ebc:	bf18      	it	ne
34005ebe:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005ec2:	e001      	b.n	34005ec8 <HAL_DCMIPP_CSI_IRQHandler+0x2dc>
34005ec4:	58006000 	.word	0x58006000
34005ec8:	bf1c      	itt	ne
34005eca:	f022 0240 	bicne.w	r2, r2, #64	@ 0x40
34005ece:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM2);
34005ed2:	2240      	movs	r2, #64	@ 0x40
34005ed4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34005ed8:	f7ff fe86 	bl	34005be8 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM1) != 0U)
34005edc:	06b2      	lsls	r2, r6, #26
34005ede:	d515      	bpl.n	34005f0c <HAL_DCMIPP_CSI_IRQHandler+0x320>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM1) != 0U)
34005ee0:	06ab      	lsls	r3, r5, #26
34005ee2:	d513      	bpl.n	34005f0c <HAL_DCMIPP_CSI_IRQHandler+0x320>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005ee4:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
34005ee6:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005ee8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
34005eec:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005eee:	f013 0f04 	tst.w	r3, #4
34005ef2:	4bb9      	ldr	r3, [pc, #740]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM1);
34005ef4:	bf1e      	ittt	ne
34005ef6:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005efa:	f022 0220 	bicne.w	r2, r2, #32
34005efe:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM1);
34005f02:	2220      	movs	r2, #32
34005f04:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
34005f08:	f7ff fe6e 	bl	34005be8 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM0) != 0U)
34005f0c:	06f0      	lsls	r0, r6, #27
34005f0e:	d515      	bpl.n	34005f3c <HAL_DCMIPP_CSI_IRQHandler+0x350>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM0) != 0U)
34005f10:	06e9      	lsls	r1, r5, #27
34005f12:	d513      	bpl.n	34005f3c <HAL_DCMIPP_CSI_IRQHandler+0x350>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005f14:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
34005f16:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005f18:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
34005f1c:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005f1e:	f013 0f04 	tst.w	r3, #4
34005f22:	4bad      	ldr	r3, [pc, #692]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM0);
34005f24:	bf1e      	ittt	ne
34005f26:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005f2a:	f022 0210 	bicne.w	r2, r2, #16
34005f2e:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM0);
34005f32:	2210      	movs	r2, #16
34005f34:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
34005f38:	f7ff fe56 	bl	34005be8 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SYNCERR) != 0U)
34005f3c:	0072      	lsls	r2, r6, #1
34005f3e:	d513      	bpl.n	34005f68 <HAL_DCMIPP_CSI_IRQHandler+0x37c>
    if ((ier0_flags & DCMIPP_CSI_IT_SYNCERR) != 0U)
34005f40:	006b      	lsls	r3, r5, #1
34005f42:	d511      	bpl.n	34005f68 <HAL_DCMIPP_CSI_IRQHandler+0x37c>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
34005f44:	4ba4      	ldr	r3, [pc, #656]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005f46:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
34005f48:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005f4c:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
34005f50:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SYNCERR);
34005f54:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34005f58:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SYNC;
34005f5c:	68a3      	ldr	r3, [r4, #8]
34005f5e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34005f62:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005f64:	f7ff fd0b 	bl	3400597e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_WDERR) != 0U)
34005f68:	00b0      	lsls	r0, r6, #2
34005f6a:	d513      	bpl.n	34005f94 <HAL_DCMIPP_CSI_IRQHandler+0x3a8>
    if ((ier0_flags & DCMIPP_CSI_IT_WDERR) != 0U)
34005f6c:	00a9      	lsls	r1, r5, #2
34005f6e:	d511      	bpl.n	34005f94 <HAL_DCMIPP_CSI_IRQHandler+0x3a8>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
34005f70:	4b99      	ldr	r3, [pc, #612]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005f72:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
34005f74:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005f78:	f022 5200 	bic.w	r2, r2, #536870912	@ 0x20000000
34005f7c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_WDERR);
34005f80:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
34005f84:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_WDG;
34005f88:	68a3      	ldr	r3, [r4, #8]
34005f8a:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
34005f8e:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005f90:	f7ff fcf5 	bl	3400597e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SPKTERR) != 0U)
34005f94:	00f2      	lsls	r2, r6, #3
34005f96:	d513      	bpl.n	34005fc0 <HAL_DCMIPP_CSI_IRQHandler+0x3d4>
    if ((ier0_flags & DCMIPP_CSI_IT_SPKTERR) != 0U)
34005f98:	00eb      	lsls	r3, r5, #3
34005f9a:	d511      	bpl.n	34005fc0 <HAL_DCMIPP_CSI_IRQHandler+0x3d4>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
34005f9c:	4b8e      	ldr	r3, [pc, #568]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005f9e:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
34005fa0:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005fa4:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
34005fa8:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKTERR);
34005fac:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34005fb0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SPKT;
34005fb4:	68a3      	ldr	r3, [r4, #8]
34005fb6:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
34005fba:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005fbc:	f7ff fcdf 	bl	3400597e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_IDERR) != 0U)
34005fc0:	0130      	lsls	r0, r6, #4
34005fc2:	d513      	bpl.n	34005fec <HAL_DCMIPP_CSI_IRQHandler+0x400>
    if ((ier0_flags & DCMIPP_CSI_IT_IDERR) != 0U)
34005fc4:	0129      	lsls	r1, r5, #4
34005fc6:	d511      	bpl.n	34005fec <HAL_DCMIPP_CSI_IRQHandler+0x400>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
34005fc8:	4b83      	ldr	r3, [pc, #524]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005fca:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
34005fcc:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005fd0:	f022 6200 	bic.w	r2, r2, #134217728	@ 0x8000000
34005fd4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_IDERR);
34005fd8:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
34005fdc:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DATA_ID;
34005fe0:	68a3      	ldr	r3, [r4, #8]
34005fe2:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
34005fe6:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005fe8:	f7ff fcc9 	bl	3400597e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_CECCERR) != 0U)
34005fec:	0172      	lsls	r2, r6, #5
34005fee:	d513      	bpl.n	34006018 <HAL_DCMIPP_CSI_IRQHandler+0x42c>
    if ((ier0_flags & DCMIPP_CSI_IT_CECCERR) != 0U)
34005ff0:	016b      	lsls	r3, r5, #5
34005ff2:	d511      	bpl.n	34006018 <HAL_DCMIPP_CSI_IRQHandler+0x42c>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
34005ff4:	4b78      	ldr	r3, [pc, #480]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005ff6:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
34005ff8:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005ffc:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
34006000:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CECCERR);
34006004:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34006008:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CECC;
3400600c:	68a3      	ldr	r3, [r4, #8]
3400600e:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
34006012:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34006014:	f7ff fcb3 	bl	3400597e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_ECCERR) != 0U)
34006018:	01b0      	lsls	r0, r6, #6
3400601a:	d513      	bpl.n	34006044 <HAL_DCMIPP_CSI_IRQHandler+0x458>
    if ((ier0_flags & DCMIPP_CSI_IT_ECCERR) != 0U)
3400601c:	01a9      	lsls	r1, r5, #6
3400601e:	d511      	bpl.n	34006044 <HAL_DCMIPP_CSI_IRQHandler+0x458>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
34006020:	4b6d      	ldr	r3, [pc, #436]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34006022:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
34006024:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34006028:	f022 7200 	bic.w	r2, r2, #33554432	@ 0x2000000
3400602c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECCERR);
34006030:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34006034:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_ECC;
34006038:	68a3      	ldr	r3, [r4, #8]
3400603a:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
3400603e:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34006040:	f7ff fc9d 	bl	3400597e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_CRCERR) != 0U)
34006044:	01f2      	lsls	r2, r6, #7
34006046:	d513      	bpl.n	34006070 <HAL_DCMIPP_CSI_IRQHandler+0x484>
    if ((ier0_flags & DCMIPP_CSI_IT_CRCERR) != 0U)
34006048:	01eb      	lsls	r3, r5, #7
3400604a:	d511      	bpl.n	34006070 <HAL_DCMIPP_CSI_IRQHandler+0x484>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
3400604c:	4b62      	ldr	r3, [pc, #392]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400604e:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
34006050:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34006054:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
34006058:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CRCERR);
3400605c:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34006060:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CRC;
34006064:	68a3      	ldr	r3, [r4, #8]
34006066:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
3400606a:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400606c:	f7ff fc87 	bl	3400597e <HAL_DCMIPP_ErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL0) != 0U)
34006070:	f018 0f01 	tst.w	r8, #1
34006074:	d014      	beq.n	340060a0 <HAL_DCMIPP_CSI_IRQHandler+0x4b4>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL0) != 0U)
34006076:	07f8      	lsls	r0, r7, #31
34006078:	d512      	bpl.n	340060a0 <HAL_DCMIPP_CSI_IRQHandler+0x4b4>
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
3400607a:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
3400607c:	4b56      	ldr	r3, [pc, #344]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3400607e:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
34006080:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34006084:	f022 0201 	bic.w	r2, r2, #1
34006088:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
3400608c:	f8c3 1104 	str.w	r1, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34006090:	68a3      	ldr	r3, [r4, #8]
34006092:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
34006096:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34006098:	2304      	movs	r3, #4
3400609a:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3400609c:	f7ff fd9f 	bl	34005bde <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL0) != 0U)
340060a0:	f018 0f02 	tst.w	r8, #2
340060a4:	d015      	beq.n	340060d2 <HAL_DCMIPP_CSI_IRQHandler+0x4e6>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL0) != 0U)
340060a6:	07b9      	lsls	r1, r7, #30
340060a8:	d513      	bpl.n	340060d2 <HAL_DCMIPP_CSI_IRQHandler+0x4e6>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
340060aa:	4b4b      	ldr	r3, [pc, #300]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340060ac:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
340060ae:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340060b2:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
340060b4:	f022 0202 	bic.w	r2, r2, #2
340060b8:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL0);
340060bc:	2202      	movs	r2, #2
340060be:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
340060c2:	68a3      	ldr	r3, [r4, #8]
340060c4:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
340060c8:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
340060ca:	2304      	movs	r3, #4
340060cc:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340060ce:	f7ff fd86 	bl	34005bde <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL0) != 0U)
340060d2:	f018 0f04 	tst.w	r8, #4
340060d6:	d013      	beq.n	34006100 <HAL_DCMIPP_CSI_IRQHandler+0x514>
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL0) != 0U)
340060d8:	077a      	lsls	r2, r7, #29
340060da:	d511      	bpl.n	34006100 <HAL_DCMIPP_CSI_IRQHandler+0x514>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
340060dc:	4b3e      	ldr	r3, [pc, #248]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340060de:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
340060e0:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340060e4:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
340060e6:	f022 0204 	bic.w	r2, r2, #4
340060ea:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL0);
340060ee:	2204      	movs	r2, #4
340060f0:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
340060f4:	68a3      	ldr	r3, [r4, #8]
340060f6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
340060fa:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340060fc:	f7ff fd6f 	bl	34005bde <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL0) != 0U)
34006100:	f018 0f08 	tst.w	r8, #8
34006104:	d013      	beq.n	3400612e <HAL_DCMIPP_CSI_IRQHandler+0x542>
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL0) != 0U)
34006106:	073b      	lsls	r3, r7, #28
34006108:	d511      	bpl.n	3400612e <HAL_DCMIPP_CSI_IRQHandler+0x542>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
3400610a:	4b33      	ldr	r3, [pc, #204]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3400610c:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
3400610e:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34006112:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
34006114:	f022 0208 	bic.w	r2, r2, #8
34006118:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL0);
3400611c:	2208      	movs	r2, #8
3400611e:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34006122:	68a3      	ldr	r3, [r4, #8]
34006124:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34006128:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3400612a:	f7ff fd58 	bl	34005bde <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ECTRLDL0) != 0U)
3400612e:	f018 0f10 	tst.w	r8, #16
34006132:	d013      	beq.n	3400615c <HAL_DCMIPP_CSI_IRQHandler+0x570>
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL0) != 0U)
34006134:	06f8      	lsls	r0, r7, #27
34006136:	d511      	bpl.n	3400615c <HAL_DCMIPP_CSI_IRQHandler+0x570>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
34006138:	4b27      	ldr	r3, [pc, #156]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3400613a:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
3400613c:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34006140:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
34006142:	f022 0210 	bic.w	r2, r2, #16
34006146:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECTRLDL0);
3400614a:	2210      	movs	r2, #16
3400614c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34006150:	68a3      	ldr	r3, [r4, #8]
34006152:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34006156:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34006158:	f7ff fd41 	bl	34005bde <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL1) != 0U)
3400615c:	f418 7f80 	tst.w	r8, #256	@ 0x100
34006160:	d016      	beq.n	34006190 <HAL_DCMIPP_CSI_IRQHandler+0x5a4>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL1) != 0U)
34006162:	05f9      	lsls	r1, r7, #23
34006164:	d514      	bpl.n	34006190 <HAL_DCMIPP_CSI_IRQHandler+0x5a4>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
34006166:	4b1c      	ldr	r3, [pc, #112]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34006168:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
3400616a:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
3400616e:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
34006170:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
34006174:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL1);
34006178:	f44f 7280 	mov.w	r2, #256	@ 0x100
3400617c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34006180:	68a3      	ldr	r3, [r4, #8]
34006182:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
34006186:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34006188:	2304      	movs	r3, #4
3400618a:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
3400618c:	f7ff fd27 	bl	34005bde <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL1) != 0U)
34006190:	f418 7f00 	tst.w	r8, #512	@ 0x200
34006194:	d016      	beq.n	340061c4 <HAL_DCMIPP_CSI_IRQHandler+0x5d8>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL1) != 0U)
34006196:	05ba      	lsls	r2, r7, #22
34006198:	d514      	bpl.n	340061c4 <HAL_DCMIPP_CSI_IRQHandler+0x5d8>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
3400619a:	4b0f      	ldr	r3, [pc, #60]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
3400619c:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
3400619e:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
340061a2:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
340061a4:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
340061a8:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL1);
340061ac:	f44f 7200 	mov.w	r2, #512	@ 0x200
340061b0:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
340061b4:	68a3      	ldr	r3, [r4, #8]
340061b6:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
340061ba:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
340061bc:	2304      	movs	r3, #4
340061be:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
340061c0:	f7ff fd0d 	bl	34005bde <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL1) != 0U)
340061c4:	f418 6f80 	tst.w	r8, #1024	@ 0x400
340061c8:	d017      	beq.n	340061fa <HAL_DCMIPP_CSI_IRQHandler+0x60e>
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL1) != 0U)
340061ca:	057b      	lsls	r3, r7, #21
340061cc:	d515      	bpl.n	340061fa <HAL_DCMIPP_CSI_IRQHandler+0x60e>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
340061ce:	4b02      	ldr	r3, [pc, #8]	@ (340061d8 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
340061d0:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
340061d2:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
340061d6:	e001      	b.n	340061dc <HAL_DCMIPP_CSI_IRQHandler+0x5f0>
340061d8:	58006000 	.word	0x58006000
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
340061dc:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
340061de:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
340061e2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL1);
340061e6:	f44f 6280 	mov.w	r2, #1024	@ 0x400
340061ea:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
340061ee:	68a3      	ldr	r3, [r4, #8]
340061f0:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
340061f4:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
340061f6:	f7ff fcf2 	bl	34005bde <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL1) != 0U)
340061fa:	f418 6f00 	tst.w	r8, #2048	@ 0x800
340061fe:	d014      	beq.n	3400622a <HAL_DCMIPP_CSI_IRQHandler+0x63e>
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL1) != 0U)
34006200:	0538      	lsls	r0, r7, #20
34006202:	d512      	bpl.n	3400622a <HAL_DCMIPP_CSI_IRQHandler+0x63e>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
34006204:	4b1f      	ldr	r3, [pc, #124]	@ (34006284 <HAL_DCMIPP_CSI_IRQHandler+0x698>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34006206:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
34006208:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
3400620c:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
3400620e:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
34006212:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL1);
34006216:	f44f 6200 	mov.w	r2, #2048	@ 0x800
3400621a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
3400621e:	68a3      	ldr	r3, [r4, #8]
34006220:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34006224:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34006226:	f7ff fcda 	bl	34005bde <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
3400622a:	f418 5f80 	tst.w	r8, #4096	@ 0x1000
3400622e:	d014      	beq.n	3400625a <HAL_DCMIPP_CSI_IRQHandler+0x66e>
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34006230:	04f9      	lsls	r1, r7, #19
34006232:	d512      	bpl.n	3400625a <HAL_DCMIPP_CSI_IRQHandler+0x66e>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34006234:	4b13      	ldr	r3, [pc, #76]	@ (34006284 <HAL_DCMIPP_CSI_IRQHandler+0x698>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34006236:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34006238:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
3400623c:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
3400623e:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
34006242:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34006246:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3400624a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
3400624e:	68a3      	ldr	r3, [r4, #8]
34006250:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34006254:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34006256:	f7ff fcc2 	bl	34005bde <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SPKT) != 0U)
3400625a:	03f2      	lsls	r2, r6, #15
3400625c:	d50f      	bpl.n	3400627e <HAL_DCMIPP_CSI_IRQHandler+0x692>
    if ((ier0_flags & DCMIPP_CSI_IT_SPKT) != 0U)
3400625e:	03eb      	lsls	r3, r5, #15
34006260:	d50d      	bpl.n	3400627e <HAL_DCMIPP_CSI_IRQHandler+0x692>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
34006262:	4b08      	ldr	r3, [pc, #32]	@ (34006284 <HAL_DCMIPP_CSI_IRQHandler+0x698>)
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
34006264:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
34006266:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
3400626a:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
3400626e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKT);
34006272:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34006276:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
3400627a:	f7ff fcb2 	bl	34005be2 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>
}
3400627e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34006282:	bf00      	nop
34006284:	58006000 	.word	0x58006000

34006288 <HAL_DCMIPP_PIPE_SetCropConfig>:
{
34006288:	b570      	push	{r4, r5, r6, lr}
3400628a:	460e      	mov	r6, r1
3400628c:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pCropConfig == NULL))
3400628e:	4605      	mov	r5, r0
34006290:	b908      	cbnz	r0, 34006296 <HAL_DCMIPP_PIPE_SetCropConfig+0xe>
    return HAL_ERROR;
34006292:	2001      	movs	r0, #1
}
34006294:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pCropConfig == NULL))
34006296:	2a00      	cmp	r2, #0
34006298:	d0fb      	beq.n	34006292 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400629a:	2902      	cmp	r1, #2
3400629c:	d904      	bls.n	340062a8 <HAL_DCMIPP_PIPE_SetCropConfig+0x20>
3400629e:	f640 61ef 	movw	r1, #3823	@ 0xeef
340062a2:	484a      	ldr	r0, [pc, #296]	@ (340063cc <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
340062a4:	f7fc fcb4 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_AREA(pCropConfig->PipeArea));
340062a8:	6923      	ldr	r3, [r4, #16]
340062aa:	f033 4380 	bics.w	r3, r3, #1073741824	@ 0x40000000
340062ae:	d004      	beq.n	340062ba <HAL_DCMIPP_PIPE_SetCropConfig+0x32>
340062b0:	f44f 616f 	mov.w	r1, #3824	@ 0xef0
340062b4:	4845      	ldr	r0, [pc, #276]	@ (340063cc <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
340062b6:	f7fc fcab 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_HSTART(pCropConfig->HStart));
340062ba:	6863      	ldr	r3, [r4, #4]
340062bc:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340062c0:	d304      	bcc.n	340062cc <HAL_DCMIPP_PIPE_SetCropConfig+0x44>
340062c2:	f640 61f1 	movw	r1, #3825	@ 0xef1
340062c6:	4841      	ldr	r0, [pc, #260]	@ (340063cc <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
340062c8:	f7fc fca2 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_HSIZE(pCropConfig->HSize));
340062cc:	f640 72fe 	movw	r2, #4094	@ 0xffe
340062d0:	68e3      	ldr	r3, [r4, #12]
340062d2:	3b01      	subs	r3, #1
340062d4:	4293      	cmp	r3, r2
340062d6:	d904      	bls.n	340062e2 <HAL_DCMIPP_PIPE_SetCropConfig+0x5a>
340062d8:	f640 61f2 	movw	r1, #3826	@ 0xef2
340062dc:	483b      	ldr	r0, [pc, #236]	@ (340063cc <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
340062de:	f7fc fc97 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_VSIZE(pCropConfig->VSize));
340062e2:	f640 72fe 	movw	r2, #4094	@ 0xffe
340062e6:	68a3      	ldr	r3, [r4, #8]
340062e8:	3b01      	subs	r3, #1
340062ea:	4293      	cmp	r3, r2
340062ec:	d904      	bls.n	340062f8 <HAL_DCMIPP_PIPE_SetCropConfig+0x70>
340062ee:	f640 61f3 	movw	r1, #3827	@ 0xef3
340062f2:	4836      	ldr	r0, [pc, #216]	@ (340063cc <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
340062f4:	f7fc fc8c 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_VSTART(pCropConfig->VStart));
340062f8:	6823      	ldr	r3, [r4, #0]
340062fa:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340062fe:	d304      	bcc.n	3400630a <HAL_DCMIPP_PIPE_SetCropConfig+0x82>
34006300:	f640 61f4 	movw	r1, #3828	@ 0xef4
34006304:	4831      	ldr	r0, [pc, #196]	@ (340063cc <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34006306:	f7fc fc83 	bl	34002c10 <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
3400630a:	792b      	ldrb	r3, [r5, #4]
3400630c:	2b02      	cmp	r3, #2
3400630e:	d1c0      	bne.n	34006292 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
    if (Pipe == DCMIPP_PIPE0)
34006310:	bb3e      	cbnz	r6, 34006362 <HAL_DCMIPP_PIPE_SetCropConfig+0xda>
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34006312:	682a      	ldr	r2, [r5, #0]
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34006314:	4b2e      	ldr	r3, [pc, #184]	@ (340063d0 <HAL_DCMIPP_PIPE_SetCropConfig+0x148>)
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34006316:	f8d2 1104 	ldr.w	r1, [r2, #260]	@ 0x104
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
3400631a:	400b      	ands	r3, r1
3400631c:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34006320:	d0b7      	beq.n	34006292 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
        MODIFY_REG(hdcmipp->Instance->P0SCSTR, DCMIPP_P0SCSTR_HSTART | DCMIPP_P0SCSTR_VSTART,
34006322:	e9d4 0300 	ldrd	r0, r3, [r4]
34006326:	f8d2 1504 	ldr.w	r1, [r2, #1284]	@ 0x504
3400632a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3400632e:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34006332:	430b      	orrs	r3, r1
34006334:	f8c2 3504 	str.w	r3, [r2, #1284]	@ 0x504
        MODIFY_REG(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_HSIZE | DCMIPP_P0SCSZR_VSIZE | DCMIPP_P0SCSZR_POSNEG,
34006338:	f8d2 1508 	ldr.w	r1, [r2, #1288]	@ 0x508
3400633c:	e9d4 3003 	ldrd	r3, r0, [r4, #12]
34006340:	f021 419f 	bic.w	r1, r1, #1333788672	@ 0x4f800000
34006344:	4303      	orrs	r3, r0
34006346:	f421 01fe 	bic.w	r1, r1, #8323072	@ 0x7f0000
3400634a:	68a0      	ldr	r0, [r4, #8]
3400634c:	f421 617f 	bic.w	r1, r1, #4080	@ 0xff0
34006350:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006354:	f021 010f 	bic.w	r1, r1, #15
34006358:	430b      	orrs	r3, r1
3400635a:	f8c2 3508 	str.w	r3, [r2, #1288]	@ 0x508
  return HAL_OK;
3400635e:	2000      	movs	r0, #0
34006360:	e798      	b.n	34006294 <HAL_DCMIPP_PIPE_SetCropConfig+0xc>
    else if (Pipe == DCMIPP_PIPE1)
34006362:	2e01      	cmp	r6, #1
34006364:	d117      	bne.n	34006396 <HAL_DCMIPP_PIPE_SetCropConfig+0x10e>
      MODIFY_REG(hdcmipp->Instance->P1CRSTR, DCMIPP_P1CRSTR_HSTART | DCMIPP_P1CRSTR_VSTART,
34006366:	e9d4 0300 	ldrd	r0, r3, [r4]
3400636a:	682a      	ldr	r2, [r5, #0]
3400636c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006370:	f8d2 1904 	ldr.w	r1, [r2, #2308]	@ 0x904
34006374:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34006378:	430b      	orrs	r3, r1
3400637a:	f8c2 3904 	str.w	r3, [r2, #2308]	@ 0x904
      MODIFY_REG(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_HSIZE | DCMIPP_P1CRSZR_VSIZE,
3400637e:	f8d2 1908 	ldr.w	r1, [r2, #2312]	@ 0x908
34006382:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
34006386:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
3400638a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3400638e:	430b      	orrs	r3, r1
34006390:	f8c2 3908 	str.w	r3, [r2, #2312]	@ 0x908
34006394:	e7e3      	b.n	3400635e <HAL_DCMIPP_PIPE_SetCropConfig+0xd6>
    else if (Pipe == DCMIPP_PIPE2)
34006396:	2e02      	cmp	r6, #2
34006398:	f47f af7b 	bne.w	34006292 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
      MODIFY_REG(hdcmipp->Instance->P2CRSTR, DCMIPP_P2CRSTR_HSTART | DCMIPP_P2CRSTR_VSTART,
3400639c:	e9d4 0300 	ldrd	r0, r3, [r4]
340063a0:	682a      	ldr	r2, [r5, #0]
340063a2:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
340063a6:	f8d2 1d04 	ldr.w	r1, [r2, #3332]	@ 0xd04
340063aa:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
340063ae:	430b      	orrs	r3, r1
340063b0:	f8c2 3d04 	str.w	r3, [r2, #3332]	@ 0xd04
      MODIFY_REG(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_HSIZE | DCMIPP_P2CRSZR_VSIZE,
340063b4:	f8d2 1d08 	ldr.w	r1, [r2, #3336]	@ 0xd08
340063b8:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
340063bc:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
340063c0:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
340063c4:	430b      	orrs	r3, r1
340063c6:	f8c2 3d08 	str.w	r3, [r2, #3336]	@ 0xd08
340063ca:	e7c8      	b.n	3400635e <HAL_DCMIPP_PIPE_SetCropConfig+0xd6>
340063cc:	3401fd64 	.word	0x3401fd64
340063d0:	00ff4000 	.word	0x00ff4000

340063d4 <HAL_DCMIPP_PIPE_EnableCrop>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
340063d4:	2902      	cmp	r1, #2
{
340063d6:	b538      	push	{r3, r4, r5, lr}
340063d8:	4605      	mov	r5, r0
340063da:	460c      	mov	r4, r1
  assert_param(IS_DCMIPP_PIPE(Pipe));
340063dc:	d904      	bls.n	340063e8 <HAL_DCMIPP_PIPE_EnableCrop+0x14>
340063de:	f640 713f 	movw	r1, #3903	@ 0xf3f
340063e2:	481a      	ldr	r0, [pc, #104]	@ (3400644c <HAL_DCMIPP_PIPE_EnableCrop+0x78>)
340063e4:	f7fc fc14 	bl	34002c10 <assert_failed>
  if (hdcmipp == NULL)
340063e8:	b36d      	cbz	r5, 34006446 <HAL_DCMIPP_PIPE_EnableCrop+0x72>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
340063ea:	792b      	ldrb	r3, [r5, #4]
340063ec:	2b02      	cmp	r3, #2
340063ee:	d12a      	bne.n	34006446 <HAL_DCMIPP_PIPE_EnableCrop+0x72>
    if (Pipe == DCMIPP_PIPE0)
340063f0:	b97c      	cbnz	r4, 34006412 <HAL_DCMIPP_PIPE_EnableCrop+0x3e>
      tmp = READ_REG(hdcmipp->Instance->PRCR);
340063f2:	682b      	ldr	r3, [r5, #0]
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
340063f4:	4a16      	ldr	r2, [pc, #88]	@ (34006450 <HAL_DCMIPP_PIPE_EnableCrop+0x7c>)
      tmp = READ_REG(hdcmipp->Instance->PRCR);
340063f6:	f8d3 1104 	ldr.w	r1, [r3, #260]	@ 0x104
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
340063fa:	400a      	ands	r2, r1
340063fc:	f5b2 4f80 	cmp.w	r2, #16384	@ 0x4000
34006400:	d021      	beq.n	34006446 <HAL_DCMIPP_PIPE_EnableCrop+0x72>
        SET_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
34006402:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34006406:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3400640a:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
  return HAL_OK;
3400640e:	2000      	movs	r0, #0
}
34006410:	bd38      	pop	{r3, r4, r5, pc}
    else if (Pipe == DCMIPP_PIPE1)
34006412:	2c01      	cmp	r4, #1
34006414:	d10d      	bne.n	34006432 <HAL_DCMIPP_PIPE_EnableCrop+0x5e>
      if (hdcmipp->Instance->P1SRCR != DCMIPP_P1SRCR_CROPEN)
34006416:	682b      	ldr	r3, [r5, #0]
    return HAL_ERROR;
34006418:	4620      	mov	r0, r4
      if (hdcmipp->Instance->P1SRCR != DCMIPP_P1SRCR_CROPEN)
3400641a:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
3400641e:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
34006422:	d0f5      	beq.n	34006410 <HAL_DCMIPP_PIPE_EnableCrop+0x3c>
        SET_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34006424:	f8d3 2908 	ldr.w	r2, [r3, #2312]	@ 0x908
34006428:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3400642c:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
34006430:	e7ed      	b.n	3400640e <HAL_DCMIPP_PIPE_EnableCrop+0x3a>
    else if (Pipe == DCMIPP_PIPE2)
34006432:	2c02      	cmp	r4, #2
34006434:	d107      	bne.n	34006446 <HAL_DCMIPP_PIPE_EnableCrop+0x72>
      SET_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34006436:	682a      	ldr	r2, [r5, #0]
34006438:	f8d2 3d08 	ldr.w	r3, [r2, #3336]	@ 0xd08
3400643c:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
34006440:	f8c2 3d08 	str.w	r3, [r2, #3336]	@ 0xd08
34006444:	e7e3      	b.n	3400640e <HAL_DCMIPP_PIPE_EnableCrop+0x3a>
    return HAL_ERROR;
34006446:	2001      	movs	r0, #1
34006448:	e7e2      	b.n	34006410 <HAL_DCMIPP_PIPE_EnableCrop+0x3c>
3400644a:	bf00      	nop
3400644c:	3401fd64 	.word	0x3401fd64
34006450:	00ff4000 	.word	0x00ff4000

34006454 <HAL_DCMIPP_PIPE_DisableCrop>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006454:	2902      	cmp	r1, #2
{
34006456:	b508      	push	{r3, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006458:	d906      	bls.n	34006468 <HAL_DCMIPP_PIPE_DisableCrop+0x14>
3400645a:	f640 717e 	movw	r1, #3966	@ 0xf7e
3400645e:	4810      	ldr	r0, [pc, #64]	@ (340064a0 <HAL_DCMIPP_PIPE_DisableCrop+0x4c>)
34006460:	f7fc fbd6 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
34006464:	2001      	movs	r0, #1
34006466:	e00a      	b.n	3400647e <HAL_DCMIPP_PIPE_DisableCrop+0x2a>
  if (hdcmipp == NULL)
34006468:	2800      	cmp	r0, #0
3400646a:	d0fb      	beq.n	34006464 <HAL_DCMIPP_PIPE_DisableCrop+0x10>
  if (Pipe == DCMIPP_PIPE0)
3400646c:	6803      	ldr	r3, [r0, #0]
3400646e:	b939      	cbnz	r1, 34006480 <HAL_DCMIPP_PIPE_DisableCrop+0x2c>
    CLEAR_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
34006470:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34006474:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34006478:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
  return HAL_OK;
3400647c:	2000      	movs	r0, #0
}
3400647e:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE1)
34006480:	2901      	cmp	r1, #1
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34006482:	bf0b      	itete	eq
34006484:	f8d3 2908 	ldreq.w	r2, [r3, #2312]	@ 0x908
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34006488:	f8d3 2d08 	ldrne.w	r2, [r3, #3336]	@ 0xd08
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
3400648c:	f022 4200 	biceq.w	r2, r2, #2147483648	@ 0x80000000
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34006490:	f022 4200 	bicne.w	r2, r2, #2147483648	@ 0x80000000
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34006494:	bf0c      	ite	eq
34006496:	f8c3 2908 	streq.w	r2, [r3, #2312]	@ 0x908
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
3400649a:	f8c3 2d08 	strne.w	r2, [r3, #3336]	@ 0xd08
3400649e:	e7ed      	b.n	3400647c <HAL_DCMIPP_PIPE_DisableCrop+0x28>
340064a0:	3401fd64 	.word	0x3401fd64

340064a4 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
340064a4:	2902      	cmp	r1, #2
{
340064a6:	b570      	push	{r4, r5, r6, lr}
340064a8:	4605      	mov	r5, r0
340064aa:	460e      	mov	r6, r1
340064ac:	4614      	mov	r4, r2
  assert_param(IS_DCMIPP_PIPE(Pipe));
340064ae:	d904      	bls.n	340064ba <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x16>
340064b0:	f241 0152 	movw	r1, #4178	@ 0x1052
340064b4:	4818      	ldr	r0, [pc, #96]	@ (34006518 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x74>)
340064b6:	f7fc fbab 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
340064ba:	6822      	ldr	r2, [r4, #0]
340064bc:	b152      	cbz	r2, 340064d4 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x30>
340064be:	2a18      	cmp	r2, #24
340064c0:	d803      	bhi.n	340064ca <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x26>
340064c2:	4b16      	ldr	r3, [pc, #88]	@ (3400651c <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x78>)
340064c4:	40d3      	lsrs	r3, r2
340064c6:	07da      	lsls	r2, r3, #31
340064c8:	d404      	bmi.n	340064d4 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x30>
340064ca:	f241 0153 	movw	r1, #4179	@ 0x1053
340064ce:	4812      	ldr	r0, [pc, #72]	@ (34006518 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x74>)
340064d0:	f7fc fb9e 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));
340064d4:	6862      	ldr	r2, [r4, #4]
340064d6:	b152      	cbz	r2, 340064ee <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x4a>
340064d8:	2a06      	cmp	r2, #6
340064da:	d803      	bhi.n	340064e4 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x40>
340064dc:	2354      	movs	r3, #84	@ 0x54
340064de:	40d3      	lsrs	r3, r2
340064e0:	07db      	lsls	r3, r3, #31
340064e2:	d404      	bmi.n	340064ee <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x4a>
340064e4:	f241 0154 	movw	r1, #4180	@ 0x1054
340064e8:	480b      	ldr	r0, [pc, #44]	@ (34006518 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x74>)
340064ea:	f7fc fb91 	bl	34002c10 <assert_failed>
  if ((hdcmipp == NULL) || (pDecConfig == NULL))
340064ee:	b18d      	cbz	r5, 34006514 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x70>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
340064f0:	792b      	ldrb	r3, [r5, #4]
340064f2:	2b02      	cmp	r3, #2
340064f4:	d10e      	bne.n	34006514 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x70>
    if (Pipe == DCMIPP_PIPE1)
340064f6:	2e01      	cmp	r6, #1
340064f8:	d10c      	bne.n	34006514 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x70>
      MODIFY_REG(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_VDEC | DCMIPP_P1DECR_HDEC,
340064fa:	e9d4 3000 	ldrd	r3, r0, [r4]
340064fe:	4303      	orrs	r3, r0
  return HAL_OK;
34006500:	2000      	movs	r0, #0
      MODIFY_REG(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_VDEC | DCMIPP_P1DECR_HDEC,
34006502:	6829      	ldr	r1, [r5, #0]
34006504:	f8d1 2830 	ldr.w	r2, [r1, #2096]	@ 0x830
34006508:	f022 021e 	bic.w	r2, r2, #30
3400650c:	4313      	orrs	r3, r2
3400650e:	f8c1 3830 	str.w	r3, [r1, #2096]	@ 0x830
}
34006512:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
34006514:	2001      	movs	r0, #1
34006516:	e7fc      	b.n	34006512 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x6e>
34006518:	3401fd64 	.word	0x3401fd64
3400651c:	01010100 	.word	0x01010100

34006520 <HAL_DCMIPP_PIPE_EnableISPDecimation>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006520:	2902      	cmp	r1, #2
{
34006522:	b508      	push	{r3, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006524:	d906      	bls.n	34006534 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x14>
34006526:	f241 017a 	movw	r1, #4218	@ 0x107a
3400652a:	4809      	ldr	r0, [pc, #36]	@ (34006550 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x30>)
3400652c:	f7fc fb70 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
34006530:	2001      	movs	r0, #1
}
34006532:	bd08      	pop	{r3, pc}
  if (hdcmipp == NULL)
34006534:	2800      	cmp	r0, #0
34006536:	d0fb      	beq.n	34006530 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x10>
  if (Pipe == DCMIPP_PIPE1)
34006538:	2901      	cmp	r1, #1
3400653a:	d1f9      	bne.n	34006530 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x10>
    SET_BIT(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_ENABLE);
3400653c:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
3400653e:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_ENABLE);
34006540:	f8d2 3830 	ldr.w	r3, [r2, #2096]	@ 0x830
34006544:	f043 0301 	orr.w	r3, r3, #1
34006548:	f8c2 3830 	str.w	r3, [r2, #2096]	@ 0x830
  return HAL_OK;
3400654c:	e7f1      	b.n	34006532 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x12>
3400654e:	bf00      	nop
34006550:	3401fd64 	.word	0x3401fd64

34006554 <HAL_DCMIPP_PIPE_SetDecimationConfig>:
{
34006554:	b570      	push	{r4, r5, r6, lr}
34006556:	460e      	mov	r6, r1
34006558:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
3400655a:	4605      	mov	r5, r0
3400655c:	b908      	cbnz	r0, 34006562 <HAL_DCMIPP_PIPE_SetDecimationConfig+0xe>
    return HAL_ERROR;
3400655e:	2001      	movs	r0, #1
}
34006560:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006562:	2902      	cmp	r1, #2
34006564:	d904      	bls.n	34006570 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x1c>
34006566:	f241 01bc 	movw	r1, #4284	@ 0x10bc
3400656a:	481e      	ldr	r0, [pc, #120]	@ (340065e4 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x90>)
3400656c:	f7fc fb50 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
34006570:	6822      	ldr	r2, [r4, #0]
34006572:	b152      	cbz	r2, 3400658a <HAL_DCMIPP_PIPE_SetDecimationConfig+0x36>
34006574:	2a18      	cmp	r2, #24
34006576:	d803      	bhi.n	34006580 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x2c>
34006578:	4b1b      	ldr	r3, [pc, #108]	@ (340065e8 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x94>)
3400657a:	40d3      	lsrs	r3, r2
3400657c:	07da      	lsls	r2, r3, #31
3400657e:	d404      	bmi.n	3400658a <HAL_DCMIPP_PIPE_SetDecimationConfig+0x36>
34006580:	f241 01bd 	movw	r1, #4285	@ 0x10bd
34006584:	4817      	ldr	r0, [pc, #92]	@ (340065e4 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x90>)
34006586:	f7fc fb43 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));
3400658a:	6862      	ldr	r2, [r4, #4]
3400658c:	b152      	cbz	r2, 340065a4 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x50>
3400658e:	2a06      	cmp	r2, #6
34006590:	d803      	bhi.n	3400659a <HAL_DCMIPP_PIPE_SetDecimationConfig+0x46>
34006592:	2354      	movs	r3, #84	@ 0x54
34006594:	40d3      	lsrs	r3, r2
34006596:	07db      	lsls	r3, r3, #31
34006598:	d404      	bmi.n	340065a4 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x50>
3400659a:	f241 01be 	movw	r1, #4286	@ 0x10be
3400659e:	4811      	ldr	r0, [pc, #68]	@ (340065e4 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x90>)
340065a0:	f7fc fb36 	bl	34002c10 <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
340065a4:	792b      	ldrb	r3, [r5, #4]
340065a6:	2b02      	cmp	r3, #2
340065a8:	d1d9      	bne.n	3400655e <HAL_DCMIPP_PIPE_SetDecimationConfig+0xa>
    if (Pipe == DCMIPP_PIPE1)
340065aa:	2e01      	cmp	r6, #1
340065ac:	d10c      	bne.n	340065c8 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x74>
      MODIFY_REG(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_VDEC | DCMIPP_P1DCCR_HDEC,
340065ae:	e9d4 3000 	ldrd	r3, r0, [r4]
340065b2:	6829      	ldr	r1, [r5, #0]
340065b4:	4303      	orrs	r3, r0
340065b6:	f8d1 290c 	ldr.w	r2, [r1, #2316]	@ 0x90c
340065ba:	f022 021e 	bic.w	r2, r2, #30
340065be:	4313      	orrs	r3, r2
340065c0:	f8c1 390c 	str.w	r3, [r1, #2316]	@ 0x90c
  return HAL_OK;
340065c4:	2000      	movs	r0, #0
340065c6:	e7cb      	b.n	34006560 <HAL_DCMIPP_PIPE_SetDecimationConfig+0xc>
    else if (Pipe == DCMIPP_PIPE2)
340065c8:	2e02      	cmp	r6, #2
340065ca:	d1c8      	bne.n	3400655e <HAL_DCMIPP_PIPE_SetDecimationConfig+0xa>
      MODIFY_REG(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_VDEC | DCMIPP_P2DCCR_HDEC,
340065cc:	e9d4 3000 	ldrd	r3, r0, [r4]
340065d0:	6829      	ldr	r1, [r5, #0]
340065d2:	4303      	orrs	r3, r0
340065d4:	f8d1 2d0c 	ldr.w	r2, [r1, #3340]	@ 0xd0c
340065d8:	f022 021e 	bic.w	r2, r2, #30
340065dc:	4313      	orrs	r3, r2
340065de:	f8c1 3d0c 	str.w	r3, [r1, #3340]	@ 0xd0c
340065e2:	e7ef      	b.n	340065c4 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x70>
340065e4:	3401fd64 	.word	0x3401fd64
340065e8:	01010100 	.word	0x01010100

340065ec <HAL_DCMIPP_PIPE_EnableDecimation>:
{
340065ec:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340065ee:	b130      	cbz	r0, 340065fe <HAL_DCMIPP_PIPE_EnableDecimation+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340065f0:	2902      	cmp	r1, #2
340065f2:	d906      	bls.n	34006602 <HAL_DCMIPP_PIPE_EnableDecimation+0x16>
340065f4:	f241 01e9 	movw	r1, #4329	@ 0x10e9
340065f8:	480c      	ldr	r0, [pc, #48]	@ (3400662c <HAL_DCMIPP_PIPE_EnableDecimation+0x40>)
340065fa:	f7fc fb09 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
340065fe:	2001      	movs	r0, #1
34006600:	e009      	b.n	34006616 <HAL_DCMIPP_PIPE_EnableDecimation+0x2a>
  if (Pipe == DCMIPP_PIPE1)
34006602:	2901      	cmp	r1, #1
34006604:	d108      	bne.n	34006618 <HAL_DCMIPP_PIPE_EnableDecimation+0x2c>
    SET_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
34006606:	6802      	ldr	r2, [r0, #0]
34006608:	f8d2 390c 	ldr.w	r3, [r2, #2316]	@ 0x90c
3400660c:	f043 0301 	orr.w	r3, r3, #1
34006610:	f8c2 390c 	str.w	r3, [r2, #2316]	@ 0x90c
  return HAL_OK;
34006614:	2000      	movs	r0, #0
}
34006616:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
34006618:	2902      	cmp	r1, #2
3400661a:	d1f0      	bne.n	340065fe <HAL_DCMIPP_PIPE_EnableDecimation+0x12>
    SET_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
3400661c:	6802      	ldr	r2, [r0, #0]
3400661e:	f8d2 3d0c 	ldr.w	r3, [r2, #3340]	@ 0xd0c
34006622:	f043 0301 	orr.w	r3, r3, #1
34006626:	f8c2 3d0c 	str.w	r3, [r2, #3340]	@ 0xd0c
3400662a:	e7f3      	b.n	34006614 <HAL_DCMIPP_PIPE_EnableDecimation+0x28>
3400662c:	3401fd64 	.word	0x3401fd64

34006630 <HAL_DCMIPP_PIPE_DisableDecimation>:
{
34006630:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006632:	b130      	cbz	r0, 34006642 <HAL_DCMIPP_PIPE_DisableDecimation+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006634:	2902      	cmp	r1, #2
34006636:	d906      	bls.n	34006646 <HAL_DCMIPP_PIPE_DisableDecimation+0x16>
34006638:	f241 110a 	movw	r1, #4362	@ 0x110a
3400663c:	480c      	ldr	r0, [pc, #48]	@ (34006670 <HAL_DCMIPP_PIPE_DisableDecimation+0x40>)
3400663e:	f7fc fae7 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
34006642:	2001      	movs	r0, #1
34006644:	e009      	b.n	3400665a <HAL_DCMIPP_PIPE_DisableDecimation+0x2a>
  if (Pipe == DCMIPP_PIPE1)
34006646:	2901      	cmp	r1, #1
34006648:	d108      	bne.n	3400665c <HAL_DCMIPP_PIPE_DisableDecimation+0x2c>
    CLEAR_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
3400664a:	6802      	ldr	r2, [r0, #0]
3400664c:	f8d2 390c 	ldr.w	r3, [r2, #2316]	@ 0x90c
34006650:	f023 0301 	bic.w	r3, r3, #1
34006654:	f8c2 390c 	str.w	r3, [r2, #2316]	@ 0x90c
  return HAL_OK;
34006658:	2000      	movs	r0, #0
}
3400665a:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
3400665c:	2902      	cmp	r1, #2
3400665e:	d1f0      	bne.n	34006642 <HAL_DCMIPP_PIPE_DisableDecimation+0x12>
    CLEAR_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
34006660:	6802      	ldr	r2, [r0, #0]
34006662:	f8d2 3d0c 	ldr.w	r3, [r2, #3340]	@ 0xd0c
34006666:	f023 0301 	bic.w	r3, r3, #1
3400666a:	f8c2 3d0c 	str.w	r3, [r2, #3340]	@ 0xd0c
3400666e:	e7f3      	b.n	34006658 <HAL_DCMIPP_PIPE_DisableDecimation+0x28>
34006670:	3401fd64 	.word	0x3401fd64

34006674 <HAL_DCMIPP_PIPE_SetDownsizeConfig>:
{
34006674:	b570      	push	{r4, r5, r6, lr}
34006676:	460e      	mov	r6, r1
34006678:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pDownsizeConfig == NULL))
3400667a:	4605      	mov	r5, r0
3400667c:	b908      	cbnz	r0, 34006682 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xe>
    return HAL_ERROR;
3400667e:	2001      	movs	r0, #1
}
34006680:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pDownsizeConfig == NULL))
34006682:	2a00      	cmp	r2, #0
34006684:	d0fb      	beq.n	3400667e <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006686:	2902      	cmp	r1, #2
34006688:	d904      	bls.n	34006694 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x20>
3400668a:	f241 1134 	movw	r1, #4404	@ 0x1134
3400668e:	483f      	ldr	r0, [pc, #252]	@ (3400678c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
34006690:	f7fc fabe 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_DIV_FACTOR(pDownsizeConfig->HDivFactor));
34006694:	6963      	ldr	r3, [r4, #20]
34006696:	3b80      	subs	r3, #128	@ 0x80
34006698:	f5b3 7f60 	cmp.w	r3, #896	@ 0x380
3400669c:	d304      	bcc.n	340066a8 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x34>
3400669e:	f241 1135 	movw	r1, #4405	@ 0x1135
340066a2:	483a      	ldr	r0, [pc, #232]	@ (3400678c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
340066a4:	f7fc fab4 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_DIV_FACTOR(pDownsizeConfig->VDivFactor));
340066a8:	6923      	ldr	r3, [r4, #16]
340066aa:	3b80      	subs	r3, #128	@ 0x80
340066ac:	f5b3 7f60 	cmp.w	r3, #896	@ 0x380
340066b0:	d304      	bcc.n	340066bc <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x48>
340066b2:	f241 1136 	movw	r1, #4406	@ 0x1136
340066b6:	4835      	ldr	r0, [pc, #212]	@ (3400678c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
340066b8:	f7fc faaa 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->HRatio));
340066bc:	68e3      	ldr	r3, [r4, #12]
340066be:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340066c2:	d304      	bcc.n	340066ce <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x5a>
340066c4:	f241 1137 	movw	r1, #4407	@ 0x1137
340066c8:	4830      	ldr	r0, [pc, #192]	@ (3400678c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
340066ca:	f7fc faa1 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->VRatio));
340066ce:	68a3      	ldr	r3, [r4, #8]
340066d0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340066d4:	d304      	bcc.n	340066e0 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x6c>
340066d6:	f241 1138 	movw	r1, #4408	@ 0x1138
340066da:	482c      	ldr	r0, [pc, #176]	@ (3400678c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
340066dc:	f7fc fa98 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->HSize));
340066e0:	6863      	ldr	r3, [r4, #4]
340066e2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340066e6:	d304      	bcc.n	340066f2 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x7e>
340066e8:	f241 1139 	movw	r1, #4409	@ 0x1139
340066ec:	4827      	ldr	r0, [pc, #156]	@ (3400678c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
340066ee:	f7fc fa8f 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->VSize));
340066f2:	6823      	ldr	r3, [r4, #0]
340066f4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340066f8:	d304      	bcc.n	34006704 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x90>
340066fa:	f241 113a 	movw	r1, #4410	@ 0x113a
340066fe:	4823      	ldr	r0, [pc, #140]	@ (3400678c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
34006700:	f7fc fa86 	bl	34002c10 <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34006704:	792b      	ldrb	r3, [r5, #4]
34006706:	2b02      	cmp	r3, #2
34006708:	d1b9      	bne.n	3400667e <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xa>
    if (Pipe == DCMIPP_PIPE1)
3400670a:	2e01      	cmp	r6, #1
3400670c:	d11e      	bne.n	3400674c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xd8>
      MODIFY_REG(hdcmipp->Instance->P1DSCR, (DCMIPP_P1DSCR_HDIV | DCMIPP_P1DSCR_VDIV),
3400670e:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
34006712:	682b      	ldr	r3, [r5, #0]
34006714:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34006718:	f8d3 1910 	ldr.w	r1, [r3, #2320]	@ 0x910
3400671c:	f001 21fc 	and.w	r1, r1, #4227922944	@ 0xfc00fc00
34006720:	430a      	orrs	r2, r1
34006722:	f8c3 2910 	str.w	r2, [r3, #2320]	@ 0x910
      WRITE_REG(hdcmipp->Instance->P1DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P1DSRTIOR_HRATIO_Pos) | \
34006726:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
3400672a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
3400672e:	f8c3 2914 	str.w	r2, [r3, #2324]	@ 0x914
      MODIFY_REG(hdcmipp->Instance->P1DSSZR, DCMIPP_P1DSSZR_HSIZE | DCMIPP_P1DSSZR_VSIZE,
34006732:	f8d3 1918 	ldr.w	r1, [r3, #2328]	@ 0x918
34006736:	e9d4 0200 	ldrd	r0, r2, [r4]
3400673a:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
3400673e:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34006742:	430a      	orrs	r2, r1
34006744:	f8c3 2918 	str.w	r2, [r3, #2328]	@ 0x918
  return HAL_OK;
34006748:	2000      	movs	r0, #0
3400674a:	e799      	b.n	34006680 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xc>
    else if (Pipe == DCMIPP_PIPE2)
3400674c:	2e02      	cmp	r6, #2
3400674e:	d196      	bne.n	3400667e <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xa>
      MODIFY_REG(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_HDIV | DCMIPP_P2DSCR_VDIV,
34006750:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
34006754:	682b      	ldr	r3, [r5, #0]
34006756:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3400675a:	f8d3 1d10 	ldr.w	r1, [r3, #3344]	@ 0xd10
3400675e:	f001 21fc 	and.w	r1, r1, #4227922944	@ 0xfc00fc00
34006762:	430a      	orrs	r2, r1
34006764:	f8c3 2d10 	str.w	r2, [r3, #3344]	@ 0xd10
      WRITE_REG(hdcmipp->Instance->P2DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P2DSRTIOR_HRATIO_Pos) | \
34006768:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
3400676c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34006770:	f8c3 2d14 	str.w	r2, [r3, #3348]	@ 0xd14
      MODIFY_REG(hdcmipp->Instance->P2DSSZR, DCMIPP_P2DSSZR_HSIZE | DCMIPP_P2DSSZR_VSIZE,
34006774:	f8d3 1d18 	ldr.w	r1, [r3, #3352]	@ 0xd18
34006778:	e9d4 0200 	ldrd	r0, r2, [r4]
3400677c:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34006780:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34006784:	430a      	orrs	r2, r1
34006786:	f8c3 2d18 	str.w	r2, [r3, #3352]	@ 0xd18
3400678a:	e7dd      	b.n	34006748 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xd4>
3400678c:	3401fd64 	.word	0x3401fd64

34006790 <HAL_DCMIPP_PIPE_EnableDownsize>:
{
34006790:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006792:	b130      	cbz	r0, 340067a2 <HAL_DCMIPP_PIPE_EnableDownsize+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006794:	2902      	cmp	r1, #2
34006796:	d906      	bls.n	340067a6 <HAL_DCMIPP_PIPE_EnableDownsize+0x16>
34006798:	f241 117a 	movw	r1, #4474	@ 0x117a
3400679c:	480c      	ldr	r0, [pc, #48]	@ (340067d0 <HAL_DCMIPP_PIPE_EnableDownsize+0x40>)
3400679e:	f7fc fa37 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
340067a2:	2001      	movs	r0, #1
340067a4:	e009      	b.n	340067ba <HAL_DCMIPP_PIPE_EnableDownsize+0x2a>
  if (Pipe == DCMIPP_PIPE1)
340067a6:	2901      	cmp	r1, #1
340067a8:	d108      	bne.n	340067bc <HAL_DCMIPP_PIPE_EnableDownsize+0x2c>
    SET_BIT(hdcmipp->Instance->P1DSCR, DCMIPP_P1DSCR_ENABLE);
340067aa:	6802      	ldr	r2, [r0, #0]
340067ac:	f8d2 3910 	ldr.w	r3, [r2, #2320]	@ 0x910
340067b0:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
340067b4:	f8c2 3910 	str.w	r3, [r2, #2320]	@ 0x910
  return HAL_OK;
340067b8:	2000      	movs	r0, #0
}
340067ba:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
340067bc:	2902      	cmp	r1, #2
340067be:	d1f0      	bne.n	340067a2 <HAL_DCMIPP_PIPE_EnableDownsize+0x12>
    SET_BIT(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_ENABLE);
340067c0:	6802      	ldr	r2, [r0, #0]
340067c2:	f8d2 3d10 	ldr.w	r3, [r2, #3344]	@ 0xd10
340067c6:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
340067ca:	f8c2 3d10 	str.w	r3, [r2, #3344]	@ 0xd10
340067ce:	e7f3      	b.n	340067b8 <HAL_DCMIPP_PIPE_EnableDownsize+0x28>
340067d0:	3401fd64 	.word	0x3401fd64

340067d4 <HAL_DCMIPP_PIPE_EnableGammaConversion>:
{
340067d4:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340067d6:	b130      	cbz	r0, 340067e6 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340067d8:	2902      	cmp	r1, #2
340067da:	d906      	bls.n	340067ea <HAL_DCMIPP_PIPE_EnableGammaConversion+0x16>
340067dc:	f241 11bc 	movw	r1, #4540	@ 0x11bc
340067e0:	480c      	ldr	r0, [pc, #48]	@ (34006814 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x40>)
340067e2:	f7fc fa15 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
340067e6:	2001      	movs	r0, #1
340067e8:	e009      	b.n	340067fe <HAL_DCMIPP_PIPE_EnableGammaConversion+0x2a>
  if (Pipe == DCMIPP_PIPE1)
340067ea:	2901      	cmp	r1, #1
340067ec:	d108      	bne.n	34006800 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x2c>
    SET_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
340067ee:	6802      	ldr	r2, [r0, #0]
340067f0:	f8d2 3970 	ldr.w	r3, [r2, #2416]	@ 0x970
340067f4:	f043 0301 	orr.w	r3, r3, #1
340067f8:	f8c2 3970 	str.w	r3, [r2, #2416]	@ 0x970
  return HAL_OK;
340067fc:	2000      	movs	r0, #0
}
340067fe:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
34006800:	2902      	cmp	r1, #2
34006802:	d1f0      	bne.n	340067e6 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x12>
    SET_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
34006804:	6802      	ldr	r2, [r0, #0]
34006806:	f8d2 3d70 	ldr.w	r3, [r2, #3440]	@ 0xd70
3400680a:	f043 0301 	orr.w	r3, r3, #1
3400680e:	f8c2 3d70 	str.w	r3, [r2, #3440]	@ 0xd70
34006812:	e7f3      	b.n	340067fc <HAL_DCMIPP_PIPE_EnableGammaConversion+0x28>
34006814:	3401fd64 	.word	0x3401fd64

34006818 <HAL_DCMIPP_PIPE_DisableGammaConversion>:
{
34006818:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
3400681a:	b130      	cbz	r0, 3400682a <HAL_DCMIPP_PIPE_DisableGammaConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400681c:	2902      	cmp	r1, #2
3400681e:	d906      	bls.n	3400682e <HAL_DCMIPP_PIPE_DisableGammaConversion+0x16>
34006820:	f241 11dd 	movw	r1, #4573	@ 0x11dd
34006824:	480c      	ldr	r0, [pc, #48]	@ (34006858 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x40>)
34006826:	f7fc f9f3 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
3400682a:	2001      	movs	r0, #1
3400682c:	e009      	b.n	34006842 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x2a>
  if (Pipe == DCMIPP_PIPE1)
3400682e:	2901      	cmp	r1, #1
34006830:	d108      	bne.n	34006844 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x2c>
    CLEAR_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
34006832:	6802      	ldr	r2, [r0, #0]
34006834:	f8d2 3970 	ldr.w	r3, [r2, #2416]	@ 0x970
34006838:	f023 0301 	bic.w	r3, r3, #1
3400683c:	f8c2 3970 	str.w	r3, [r2, #2416]	@ 0x970
  return HAL_OK;
34006840:	2000      	movs	r0, #0
}
34006842:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
34006844:	2902      	cmp	r1, #2
34006846:	d1f0      	bne.n	3400682a <HAL_DCMIPP_PIPE_DisableGammaConversion+0x12>
    CLEAR_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
34006848:	6802      	ldr	r2, [r0, #0]
3400684a:	f8d2 3d70 	ldr.w	r3, [r2, #3440]	@ 0xd70
3400684e:	f023 0301 	bic.w	r3, r3, #1
34006852:	f8c2 3d70 	str.w	r3, [r2, #3440]	@ 0xd70
34006856:	e7f3      	b.n	34006840 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x28>
34006858:	3401fd64 	.word	0x3401fd64

3400685c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>:
{
3400685c:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
3400685e:	4a13      	ldr	r2, [pc, #76]	@ (340068ac <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x50>)
34006860:	6803      	ldr	r3, [r0, #0]
{
34006862:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34006864:	4293      	cmp	r3, r2
{
34006866:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34006868:	d008      	beq.n	3400687c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x20>
3400686a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400686e:	4293      	cmp	r3, r2
34006870:	d004      	beq.n	3400687c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x20>
34006872:	f241 11f8 	movw	r1, #4600	@ 0x11f8
34006876:	480e      	ldr	r0, [pc, #56]	@ (340068b0 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x54>)
34006878:	f7fc f9ca 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400687c:	2d02      	cmp	r5, #2
3400687e:	d906      	bls.n	3400688e <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x32>
34006880:	f241 11f9 	movw	r1, #4601	@ 0x11f9
34006884:	480a      	ldr	r0, [pc, #40]	@ (340068b0 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x54>)
34006886:	f7fc f9c3 	bl	34002c10 <assert_failed>
    return 0;
3400688a:	2000      	movs	r0, #0
}
3400688c:	bd38      	pop	{r3, r4, r5, pc}
  if (Pipe == DCMIPP_PIPE1)
3400688e:	2d01      	cmp	r5, #1
34006890:	d105      	bne.n	3400689e <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x42>
    return ((READ_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE) == DCMIPP_P1GMCR_ENABLE) ? 1U : 0U);
34006892:	6823      	ldr	r3, [r4, #0]
34006894:	f8d3 0970 	ldr.w	r0, [r3, #2416]	@ 0x970
    return ((READ_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE) == DCMIPP_P2GMCR_ENABLE) ? 1U : 0U);
34006898:	f000 0001 	and.w	r0, r0, #1
3400689c:	e7f6      	b.n	3400688c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x30>
  else if (Pipe == DCMIPP_PIPE2)
3400689e:	2d02      	cmp	r5, #2
340068a0:	d1f3      	bne.n	3400688a <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x2e>
    return ((READ_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE) == DCMIPP_P2GMCR_ENABLE) ? 1U : 0U);
340068a2:	6823      	ldr	r3, [r4, #0]
340068a4:	f8d3 0d70 	ldr.w	r0, [r3, #3440]	@ 0xd70
340068a8:	e7f6      	b.n	34006898 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x3c>
340068aa:	bf00      	nop
340068ac:	58002000 	.word	0x58002000
340068b0:	3401fd64 	.word	0x3401fd64

340068b4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>:
{
340068b4:	b570      	push	{r4, r5, r6, lr}
340068b6:	460e      	mov	r6, r1
340068b8:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pRawBayer2RGBConfig == NULL))
340068ba:	4605      	mov	r5, r0
340068bc:	b908      	cbnz	r0, 340068c2 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xe>
    return HAL_ERROR;
340068be:	2001      	movs	r0, #1
}
340068c0:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pRawBayer2RGBConfig == NULL))
340068c2:	2a00      	cmp	r2, #0
340068c4:	d0fb      	beq.n	340068be <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340068c6:	2902      	cmp	r1, #2
340068c8:	d904      	bls.n	340068d4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x20>
340068ca:	f241 211e 	movw	r1, #4638	@ 0x121e
340068ce:	4824      	ldr	r0, [pc, #144]	@ (34006960 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
340068d0:	f7fc f99e 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_RAW_TYPE(pRawBayer2RGBConfig->RawBayerType));
340068d4:	68a2      	ldr	r2, [r4, #8]
340068d6:	b152      	cbz	r2, 340068ee <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x3a>
340068d8:	2a06      	cmp	r2, #6
340068da:	d803      	bhi.n	340068e4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x30>
340068dc:	2354      	movs	r3, #84	@ 0x54
340068de:	40d3      	lsrs	r3, r2
340068e0:	07db      	lsls	r3, r3, #31
340068e2:	d404      	bmi.n	340068ee <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x3a>
340068e4:	f241 211f 	movw	r1, #4639	@ 0x121f
340068e8:	481d      	ldr	r0, [pc, #116]	@ (34006960 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
340068ea:	f7fc f991 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->PeakStrength));
340068ee:	68e3      	ldr	r3, [r4, #12]
340068f0:	2b07      	cmp	r3, #7
340068f2:	d904      	bls.n	340068fe <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x4a>
340068f4:	f44f 5191 	mov.w	r1, #4640	@ 0x1220
340068f8:	4819      	ldr	r0, [pc, #100]	@ (34006960 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
340068fa:	f7fc f989 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->VLineStrength));
340068fe:	6823      	ldr	r3, [r4, #0]
34006900:	2b07      	cmp	r3, #7
34006902:	d904      	bls.n	3400690e <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x5a>
34006904:	f241 2121 	movw	r1, #4641	@ 0x1221
34006908:	4815      	ldr	r0, [pc, #84]	@ (34006960 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
3400690a:	f7fc f981 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->HLineStrength));
3400690e:	6863      	ldr	r3, [r4, #4]
34006910:	2b07      	cmp	r3, #7
34006912:	d904      	bls.n	3400691e <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x6a>
34006914:	f241 ####MQTT_PASS#### 	movw	r1, #4642	@ 0x1222
34006918:	4811      	ldr	r0, [pc, #68]	@ (34006960 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
3400691a:	f7fc f979 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->EdgeStrength));
3400691e:	6923      	ldr	r3, [r4, #16]
34006920:	2b07      	cmp	r3, #7
34006922:	d904      	bls.n	3400692e <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x7a>
34006924:	f241 2123 	movw	r1, #4643	@ 0x1223
34006928:	480d      	ldr	r0, [pc, #52]	@ (34006960 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
3400692a:	f7fc f971 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
3400692e:	2e01      	cmp	r6, #1
34006930:	d1c5      	bne.n	340068be <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xa>
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
34006932:	e9d4 2303 	ldrd	r2, r3, [r4, #12]
34006936:	071b      	lsls	r3, r3, #28
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
34006938:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3400693c:	68a2      	ldr	r2, [r4, #8]
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
3400693e:	6829      	ldr	r1, [r5, #0]
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
34006940:	4313      	orrs	r3, r2
                  (pRawBayer2RGBConfig->VLineStrength << DCMIPP_P1DMCR_LINEV_Pos)   | \
34006942:	6822      	ldr	r2, [r4, #0]
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
34006944:	f8d1 0870 	ldr.w	r0, [r1, #2160]	@ 0x870
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
34006948:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
                  (pRawBayer2RGBConfig->HLineStrength << DCMIPP_P1DMCR_LINEH_Pos));
3400694c:	6862      	ldr	r2, [r4, #4]
    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
3400694e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
34006952:	4a04      	ldr	r2, [pc, #16]	@ (34006964 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xb0>)
34006954:	4002      	ands	r2, r0
34006956:	4313      	orrs	r3, r2
  return HAL_OK;
34006958:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
3400695a:	f8c1 3870 	str.w	r3, [r1, #2160]	@ 0x870
  return HAL_OK;
3400695e:	e7af      	b.n	340068c0 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xc>
34006960:	3401fd64 	.word	0x3401fd64
34006964:	8888fff9 	.word	0x8888fff9

34006968 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>:
{
34006968:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
3400696a:	b130      	cbz	r0, 3400697a <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400696c:	2902      	cmp	r1, #2
3400696e:	d906      	bls.n	3400697e <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x16>
34006970:	f241 214a 	movw	r1, #4682	@ 0x124a
34006974:	4807      	ldr	r0, [pc, #28]	@ (34006994 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x2c>)
34006976:	f7fc f94b 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
3400697a:	2001      	movs	r0, #1
}
3400697c:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
3400697e:	2901      	cmp	r1, #1
34006980:	d1fb      	bne.n	3400697a <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x12>
    SET_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
34006982:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006984:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
34006986:	f8d2 3870 	ldr.w	r3, [r2, #2160]	@ 0x870
3400698a:	f043 0301 	orr.w	r3, r3, #1
3400698e:	f8c2 3870 	str.w	r3, [r2, #2160]	@ 0x870
  return HAL_OK;
34006992:	e7f3      	b.n	3400697c <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x14>
34006994:	3401fd64 	.word	0x3401fd64

34006998 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>:
{
34006998:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
3400699a:	b130      	cbz	r0, 340069aa <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400699c:	2902      	cmp	r1, #2
3400699e:	d906      	bls.n	340069ae <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x16>
340069a0:	f241 2167 	movw	r1, #4711	@ 0x1267
340069a4:	4807      	ldr	r0, [pc, #28]	@ (340069c4 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x2c>)
340069a6:	f7fc f933 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
340069aa:	2001      	movs	r0, #1
}
340069ac:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
340069ae:	2901      	cmp	r1, #1
340069b0:	d1fb      	bne.n	340069aa <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
340069b2:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340069b4:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
340069b6:	f8d2 3870 	ldr.w	r3, [r2, #2160]	@ 0x870
340069ba:	f023 0301 	bic.w	r3, r3, #1
340069be:	f8c2 3870 	str.w	r3, [r2, #2160]	@ 0x870
  return HAL_OK;
340069c2:	e7f3      	b.n	340069ac <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x14>
340069c4:	3401fd64 	.word	0x3401fd64

340069c8 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>:
{
340069c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
340069ca:	460f      	mov	r7, r1
340069cc:	4615      	mov	r5, r2
340069ce:	461c      	mov	r4, r3
  if (hdcmipp == NULL)
340069d0:	4606      	mov	r6, r0
340069d2:	b908      	cbnz	r0, 340069d8 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x10>
    return HAL_ERROR;
340069d4:	2001      	movs	r0, #1
}
340069d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
340069d8:	2902      	cmp	r1, #2
340069da:	d904      	bls.n	340069e6 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x1e>
340069dc:	f241 2189 	movw	r1, #4745	@ 0x1289
340069e0:	480f      	ldr	r0, [pc, #60]	@ (34006a20 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x58>)
340069e2:	f7fc f915 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_NB_FIRST_LINES(NbFirstLines));
340069e6:	2d07      	cmp	r5, #7
340069e8:	d904      	bls.n	340069f4 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x2c>
340069ea:	f241 218a 	movw	r1, #4746	@ 0x128a
340069ee:	480c      	ldr	r0, [pc, #48]	@ (34006a20 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x58>)
340069f0:	f7fc f90e 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_NB_LAST_LINES(NbLastLines));
340069f4:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
340069f8:	d304      	bcc.n	34006a04 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x3c>
340069fa:	f241 218b 	movw	r1, #4747	@ 0x128b
340069fe:	4808      	ldr	r0, [pc, #32]	@ (34006a20 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x58>)
34006a00:	f7fc f906 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006a04:	2f01      	cmp	r7, #1
34006a06:	d1e5      	bne.n	340069d4 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0xc>
    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
34006a08:	6832      	ldr	r2, [r6, #0]
    p1srcr_reg = ((NbFirstLines << DCMIPP_P1SRCR_FIRSTLINEDEL_Pos) | (NbLastLines << DCMIPP_P1SRCR_LASTLINE_Pos));
34006a0a:	ea44 3405 	orr.w	r4, r4, r5, lsl #12
    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
34006a0e:	f8d2 3820 	ldr.w	r3, [r2, #2080]	@ 0x820
  return HAL_OK;
34006a12:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
34006a14:	f36f 030e 	bfc	r3, #0, #15
34006a18:	431c      	orrs	r4, r3
34006a1a:	f8c2 4820 	str.w	r4, [r2, #2080]	@ 0x820
  return HAL_OK;
34006a1e:	e7da      	b.n	340069d6 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0xe>
34006a20:	3401fd64 	.word	0x3401fd64

34006a24 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>:
  if (hdcmipp == NULL)
34006a24:	b150      	cbz	r0, 34006a3c <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x18>
  if (Pipe == DCMIPP_PIPE1)
34006a26:	2901      	cmp	r1, #1
34006a28:	d108      	bne.n	34006a3c <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x18>
    SET_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
34006a2a:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006a2c:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
34006a2e:	f8d2 3820 	ldr.w	r3, [r2, #2080]	@ 0x820
34006a32:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34006a36:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  return HAL_OK;
34006a3a:	4770      	bx	lr
    return HAL_ERROR;
34006a3c:	2001      	movs	r0, #1
}
34006a3e:	4770      	bx	lr

34006a40 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>:
  if (hdcmipp == NULL)
34006a40:	b150      	cbz	r0, 34006a58 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x18>
  if (Pipe == DCMIPP_PIPE1)
34006a42:	2901      	cmp	r1, #1
34006a44:	d108      	bne.n	34006a58 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
34006a46:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006a48:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
34006a4a:	f8d2 3820 	ldr.w	r3, [r2, #2080]	@ 0x820
34006a4e:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
34006a52:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  return HAL_OK;
34006a56:	4770      	bx	lr
    return HAL_ERROR;
34006a58:	2001      	movs	r0, #1
}
34006a5a:	4770      	bx	lr

34006a5c <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>:
{
34006a5c:	b570      	push	{r4, r5, r6, lr}
34006a5e:	460e      	mov	r6, r1
34006a60:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
34006a62:	4605      	mov	r5, r0
34006a64:	b908      	cbnz	r0, 34006a6a <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xe>
    return HAL_ERROR;
34006a66:	2001      	movs	r0, #1
}
34006a68:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006a6a:	2902      	cmp	r1, #2
34006a6c:	d918      	bls.n	34006aa0 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x44>
34006a6e:	f241 21ea 	movw	r1, #4842	@ 0x12ea
34006a72:	480d      	ldr	r0, [pc, #52]	@ (34006aa8 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x4c>)
34006a74:	f7fc f8cc 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_BAD_PXL_REMOVAL_STRENGTH(Strength));
34006a78:	2c07      	cmp	r4, #7
34006a7a:	d9f4      	bls.n	34006a66 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xa>
34006a7c:	f241 21eb 	movw	r1, #4843	@ 0x12eb
34006a80:	4809      	ldr	r0, [pc, #36]	@ (34006aa8 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x4c>)
34006a82:	f7fc f8c5 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006a86:	2e01      	cmp	r6, #1
34006a88:	d1ed      	bne.n	34006a66 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_STRENGTH, Strength << DCMIPP_P1BPRCR_STRENGTH_Pos);
34006a8a:	6829      	ldr	r1, [r5, #0]
  return HAL_OK;
34006a8c:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_STRENGTH, Strength << DCMIPP_P1BPRCR_STRENGTH_Pos);
34006a8e:	f8d1 3824 	ldr.w	r3, [r1, #2084]	@ 0x824
34006a92:	f023 030e 	bic.w	r3, r3, #14
34006a96:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
34006a9a:	f8c1 3824 	str.w	r3, [r1, #2084]	@ 0x824
  return HAL_OK;
34006a9e:	e7e3      	b.n	34006a68 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xc>
  assert_param(IS_DCMIPP_BAD_PXL_REMOVAL_STRENGTH(Strength));
34006aa0:	2a07      	cmp	r2, #7
34006aa2:	d9f0      	bls.n	34006a86 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x2a>
34006aa4:	e7ea      	b.n	34006a7c <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x20>
34006aa6:	bf00      	nop
34006aa8:	3401fd64 	.word	0x3401fd64

34006aac <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>:
{
34006aac:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006aae:	b130      	cbz	r0, 34006abe <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006ab0:	2902      	cmp	r1, #2
34006ab2:	d906      	bls.n	34006ac2 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x16>
34006ab4:	f241 3108 	movw	r1, #4872	@ 0x1308
34006ab8:	4807      	ldr	r0, [pc, #28]	@ (34006ad8 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x2c>)
34006aba:	f7fc f8a9 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
34006abe:	2001      	movs	r0, #1
}
34006ac0:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006ac2:	2901      	cmp	r1, #1
34006ac4:	d1fb      	bne.n	34006abe <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x12>
    SET_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34006ac6:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006ac8:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34006aca:	f8d2 3824 	ldr.w	r3, [r2, #2084]	@ 0x824
34006ace:	f043 0301 	orr.w	r3, r3, #1
34006ad2:	f8c2 3824 	str.w	r3, [r2, #2084]	@ 0x824
  return HAL_OK;
34006ad6:	e7f3      	b.n	34006ac0 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x14>
34006ad8:	3401fd64 	.word	0x3401fd64

34006adc <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>:
{
34006adc:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006ade:	b130      	cbz	r0, 34006aee <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006ae0:	2902      	cmp	r1, #2
34006ae2:	d906      	bls.n	34006af2 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x16>
34006ae4:	f241 3125 	movw	r1, #4901	@ 0x1325
34006ae8:	4807      	ldr	r0, [pc, #28]	@ (34006b08 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x2c>)
34006aea:	f7fc f891 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
34006aee:	2001      	movs	r0, #1
}
34006af0:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006af2:	2901      	cmp	r1, #1
34006af4:	d1fb      	bne.n	34006aee <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34006af6:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006af8:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34006afa:	f8d2 3824 	ldr.w	r3, [r2, #2084]	@ 0x824
34006afe:	f023 0301 	bic.w	r3, r3, #1
34006b02:	f8c2 3824 	str.w	r3, [r2, #2084]	@ 0x824
  return HAL_OK;
34006b06:	e7f3      	b.n	34006af0 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x14>
34006b08:	3401fd64 	.word	0x3401fd64

34006b0c <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006b0c:	2902      	cmp	r1, #2
{
34006b0e:	b510      	push	{r4, lr}
34006b10:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006b12:	d904      	bls.n	34006b1e <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig+0x12>
34006b14:	f241 313b 	movw	r1, #4923	@ 0x133b
34006b18:	4804      	ldr	r0, [pc, #16]	@ (34006b2c <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig+0x20>)
34006b1a:	f7fc f879 	bl	34002c10 <assert_failed>
  return (((READ_REG(hdcmipp->Instance->P1BPRCR)) & DCMIPP_P1BPRCR_STRENGTH) >> DCMIPP_P1BPRCR_STRENGTH_Pos);
34006b1e:	6823      	ldr	r3, [r4, #0]
34006b20:	f8d3 0824 	ldr.w	r0, [r3, #2084]	@ 0x824
}
34006b24:	f3c0 0042 	ubfx	r0, r0, #1, #3
34006b28:	bd10      	pop	{r4, pc}
34006b2a:	bf00      	nop
34006b2c:	3401fd64 	.word	0x3401fd64

34006b30 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>:
{
34006b30:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34006b32:	4a10      	ldr	r2, [pc, #64]	@ (34006b74 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x44>)
34006b34:	6803      	ldr	r3, [r0, #0]
{
34006b36:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34006b38:	4293      	cmp	r3, r2
{
34006b3a:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34006b3c:	d008      	beq.n	34006b50 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x20>
34006b3e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34006b42:	4293      	cmp	r3, r2
34006b44:	d004      	beq.n	34006b50 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x20>
34006b46:	f241 3148 	movw	r1, #4936	@ 0x1348
34006b4a:	480b      	ldr	r0, [pc, #44]	@ (34006b78 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x48>)
34006b4c:	f7fc f860 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006b50:	2d02      	cmp	r5, #2
34006b52:	d906      	bls.n	34006b62 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x32>
34006b54:	f241 3149 	movw	r1, #4937	@ 0x1349
34006b58:	4807      	ldr	r0, [pc, #28]	@ (34006b78 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x48>)
34006b5a:	f7fc f859 	bl	34002c10 <assert_failed>
    return 0;
34006b5e:	2000      	movs	r0, #0
}
34006b60:	bd38      	pop	{r3, r4, r5, pc}
  if (Pipe == DCMIPP_PIPE1)
34006b62:	2d01      	cmp	r5, #1
34006b64:	d1fb      	bne.n	34006b5e <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x2e>
    return ((READ_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE) == DCMIPP_P1BPRCR_ENABLE) ? 1U : 0U);
34006b66:	6823      	ldr	r3, [r4, #0]
34006b68:	f8d3 0824 	ldr.w	r0, [r3, #2084]	@ 0x824
34006b6c:	f000 0001 	and.w	r0, r0, #1
34006b70:	e7f6      	b.n	34006b60 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x30>
34006b72:	bf00      	nop
34006b74:	58002000 	.word	0x58002000
34006b78:	3401fd64 	.word	0x3401fd64

34006b7c <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>:
{
34006b7c:	b538      	push	{r3, r4, r5, lr}
34006b7e:	4615      	mov	r5, r2
  if ((hdcmipp == NULL) || (pCounter == NULL))
34006b80:	4604      	mov	r4, r0
34006b82:	b908      	cbnz	r0, 34006b88 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0xc>
    return HAL_ERROR;
34006b84:	2001      	movs	r0, #1
}
34006b86:	bd38      	pop	{r3, r4, r5, pc}
  if ((hdcmipp == NULL) || (pCounter == NULL))
34006b88:	2a00      	cmp	r2, #0
34006b8a:	d0fb      	beq.n	34006b84 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x8>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006b8c:	2902      	cmp	r1, #2
34006b8e:	d904      	bls.n	34006b9a <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x1e>
34006b90:	f241 3166 	movw	r1, #4966	@ 0x1366
34006b94:	4806      	ldr	r0, [pc, #24]	@ (34006bb0 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x34>)
34006b96:	f7fc f83b 	bl	34002c10 <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34006b9a:	7923      	ldrb	r3, [r4, #4]
34006b9c:	2b02      	cmp	r3, #2
34006b9e:	d1f1      	bne.n	34006b84 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x8>
    *pCounter = READ_REG(hdcmipp->Instance->P1BPRSR & DCMIPP_P1BPRSR_BADCNT);
34006ba0:	6823      	ldr	r3, [r4, #0]
  return HAL_OK;
34006ba2:	2000      	movs	r0, #0
    *pCounter = READ_REG(hdcmipp->Instance->P1BPRSR & DCMIPP_P1BPRSR_BADCNT);
34006ba4:	f8d3 3828 	ldr.w	r3, [r3, #2088]	@ 0x828
34006ba8:	f3c3 030b 	ubfx	r3, r3, #0, #12
34006bac:	602b      	str	r3, [r5, #0]
  return HAL_OK;
34006bae:	e7ea      	b.n	34006b86 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0xa>
34006bb0:	3401fd64 	.word	0x3401fd64

34006bb4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>:
{
34006bb4:	b570      	push	{r4, r5, r6, lr}
34006bb6:	460e      	mov	r6, r1
34006bb8:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pColorConversionConfig == NULL))
34006bba:	4605      	mov	r5, r0
34006bbc:	b908      	cbnz	r0, 34006bc2 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xe>
    return HAL_ERROR;
34006bbe:	2001      	movs	r0, #1
}
34006bc0:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pColorConversionConfig == NULL))
34006bc2:	2a00      	cmp	r2, #0
34006bc4:	d0fb      	beq.n	34006bbe <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006bc6:	2902      	cmp	r1, #2
34006bc8:	d904      	bls.n	34006bd4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x20>
34006bca:	f241 4125 	movw	r1, #5157	@ 0x1425
34006bce:	4898      	ldr	r0, [pc, #608]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006bd0:	f7fc f81e 	bl	34002c10 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(pColorConversionConfig->ClampOutputSamples));
34006bd4:	7823      	ldrb	r3, [r4, #0]
34006bd6:	2b01      	cmp	r3, #1
34006bd8:	d904      	bls.n	34006be4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x30>
34006bda:	f241 4126 	movw	r1, #5158	@ 0x1426
34006bde:	4894      	ldr	r0, [pc, #592]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006be0:	f7fc f816 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_OUTPUT_SAMPLES_TYPES(pColorConversionConfig->OutputSamplesType));
34006be4:	7863      	ldrb	r3, [r4, #1]
34006be6:	f013 0ffd 	tst.w	r3, #253	@ 0xfd
34006bea:	d004      	beq.n	34006bf6 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x42>
34006bec:	f241 4127 	movw	r1, #5159	@ 0x1427
34006bf0:	488f      	ldr	r0, [pc, #572]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006bf2:	f7fc f80d 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RR));
34006bf6:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
34006bfa:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006bfe:	db04      	blt.n	34006c0a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x56>
34006c00:	f241 4128 	movw	r1, #5160	@ 0x1428
34006c04:	488a      	ldr	r0, [pc, #552]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006c06:	f7fc f803 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RG));
34006c0a:	f9b4 3004 	ldrsh.w	r3, [r4, #4]
34006c0e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006c12:	db04      	blt.n	34006c1e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x6a>
34006c14:	f241 4129 	movw	r1, #5161	@ 0x1429
34006c18:	4885      	ldr	r0, [pc, #532]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006c1a:	f7fb fff9 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RB));
34006c1e:	f9b4 3006 	ldrsh.w	r3, [r4, #6]
34006c22:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006c26:	db04      	blt.n	34006c32 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x7e>
34006c28:	f241 412a 	movw	r1, #5162	@ 0x142a
34006c2c:	4880      	ldr	r0, [pc, #512]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006c2e:	f7fb ffef 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RA));
34006c32:	f9b4 3008 	ldrsh.w	r3, [r4, #8]
34006c36:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006c3a:	db04      	blt.n	34006c46 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x92>
34006c3c:	f241 412b 	movw	r1, #5163	@ 0x142b
34006c40:	487b      	ldr	r0, [pc, #492]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006c42:	f7fb ffe5 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GR));
34006c46:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
34006c4a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006c4e:	db04      	blt.n	34006c5a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xa6>
34006c50:	f241 412c 	movw	r1, #5164	@ 0x142c
34006c54:	4876      	ldr	r0, [pc, #472]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006c56:	f7fb ffdb 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GG));
34006c5a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34006c5e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006c62:	db04      	blt.n	34006c6e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xba>
34006c64:	f241 412d 	movw	r1, #5165	@ 0x142d
34006c68:	4871      	ldr	r0, [pc, #452]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006c6a:	f7fb ffd1 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GB));
34006c6e:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
34006c72:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006c76:	db04      	blt.n	34006c82 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xce>
34006c78:	f241 412e 	movw	r1, #5166	@ 0x142e
34006c7c:	486c      	ldr	r0, [pc, #432]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006c7e:	f7fb ffc7 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GA));
34006c82:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
34006c86:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006c8a:	db04      	blt.n	34006c96 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xe2>
34006c8c:	f241 412f 	movw	r1, #5167	@ 0x142f
34006c90:	4867      	ldr	r0, [pc, #412]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006c92:	f7fb ffbd 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BR));
34006c96:	f9b4 3012 	ldrsh.w	r3, [r4, #18]
34006c9a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006c9e:	db04      	blt.n	34006caa <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xf6>
34006ca0:	f241 4130 	movw	r1, #5168	@ 0x1430
34006ca4:	4862      	ldr	r0, [pc, #392]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006ca6:	f7fb ffb3 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BG));
34006caa:	f9b4 3014 	ldrsh.w	r3, [r4, #20]
34006cae:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006cb2:	db04      	blt.n	34006cbe <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x10a>
34006cb4:	f241 4131 	movw	r1, #5169	@ 0x1431
34006cb8:	485d      	ldr	r0, [pc, #372]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006cba:	f7fb ffa9 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BB));
34006cbe:	f9b4 3016 	ldrsh.w	r3, [r4, #22]
34006cc2:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006cc6:	db04      	blt.n	34006cd2 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x11e>
34006cc8:	f241 4132 	movw	r1, #5170	@ 0x1432
34006ccc:	4858      	ldr	r0, [pc, #352]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006cce:	f7fb ff9f 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BA));
34006cd2:	f9b4 3018 	ldrsh.w	r3, [r4, #24]
34006cd6:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006cda:	db04      	blt.n	34006ce6 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x132>
34006cdc:	f241 4133 	movw	r1, #5171	@ 0x1433
34006ce0:	4853      	ldr	r0, [pc, #332]	@ (34006e30 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006ce2:	f7fb ff95 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006ce6:	2e01      	cmp	r6, #1
34006ce8:	f47f af69 	bne.w	34006bbe <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
34006cec:	682b      	ldr	r3, [r5, #0]
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
34006cee:	7820      	ldrb	r0, [r4, #0]
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
34006cf0:	f8d3 1880 	ldr.w	r1, [r3, #2176]	@ 0x880
                 ((uint32_t)pColorConversionConfig->OutputSamplesType);
34006cf4:	7862      	ldrb	r2, [r4, #1]
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
34006cf6:	f021 0106 	bic.w	r1, r1, #6
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
34006cfa:	ea42 0280 	orr.w	r2, r2, r0, lsl #2
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
34006cfe:	430a      	orrs	r2, r1
34006d00:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RR);
34006d04:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
34006d08:	b290      	uxth	r0, r2
34006d0a:	f3c2 010a 	ubfx	r1, r2, #0, #11
34006d0e:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RG);
34006d10:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RR);
34006d14:	bfb8      	it	lt
34006d16:	4608      	movlt	r0, r1
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RG);
34006d18:	f3c2 050a 	ubfx	r5, r2, #0, #11
34006d1c:	2a00      	cmp	r2, #0
34006d1e:	b291      	uxth	r1, r2
34006d20:	bfb8      	it	lt
34006d22:	4629      	movlt	r1, r5
    MODIFY_REG(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR | DCMIPP_P1CCRR1_RG,
34006d24:	f8d3 2884 	ldr.w	r2, [r3, #2180]	@ 0x884
34006d28:	f002 22f8 	and.w	r2, r2, #4160813056	@ 0xf800f800
34006d2c:	4302      	orrs	r2, r0
34006d2e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34006d32:	f8c3 2884 	str.w	r2, [r3, #2180]	@ 0x884
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RB);
34006d36:	f9b4 2006 	ldrsh.w	r2, [r4, #6]
34006d3a:	b295      	uxth	r5, r2
34006d3c:	f3c2 010a 	ubfx	r1, r2, #0, #11
34006d40:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->RA);
34006d42:	f9b4 2008 	ldrsh.w	r2, [r4, #8]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RB);
34006d46:	bfb8      	it	lt
34006d48:	460d      	movlt	r5, r1
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->RA);
34006d4a:	f3c2 0109 	ubfx	r1, r2, #0, #10
34006d4e:	2a00      	cmp	r2, #0
34006d50:	b290      	uxth	r0, r2
34006d52:	bfb8      	it	lt
34006d54:	4608      	movlt	r0, r1
    MODIFY_REG(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB | DCMIPP_P1CCRR2_RA,
34006d56:	f8d3 2888 	ldr.w	r2, [r3, #2184]	@ 0x888
34006d5a:	4936      	ldr	r1, [pc, #216]	@ (34006e34 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x280>)
34006d5c:	400a      	ands	r2, r1
34006d5e:	432a      	orrs	r2, r5
34006d60:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34006d64:	f8c3 2888 	str.w	r2, [r3, #2184]	@ 0x888
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GG);
34006d68:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
34006d6c:	b295      	uxth	r5, r2
34006d6e:	f3c2 000a 	ubfx	r0, r2, #0, #11
34006d72:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GR);
34006d74:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GG);
34006d78:	bfb8      	it	lt
34006d7a:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GR);
34006d7c:	f3c2 060a 	ubfx	r6, r2, #0, #11
34006d80:	2a00      	cmp	r2, #0
34006d82:	b290      	uxth	r0, r2
34006d84:	bfb8      	it	lt
34006d86:	4630      	movlt	r0, r6
    MODIFY_REG(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR | DCMIPP_P1CCGR1_GG,
34006d88:	f8d3 288c 	ldr.w	r2, [r3, #2188]	@ 0x88c
34006d8c:	f002 22f8 	and.w	r2, r2, #4160813056	@ 0xf800f800
34006d90:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
34006d94:	4302      	orrs	r2, r0
34006d96:	f8c3 288c 	str.w	r2, [r3, #2188]	@ 0x88c
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GB);
34006d9a:	f9b4 200e 	ldrsh.w	r2, [r4, #14]
34006d9e:	b295      	uxth	r5, r2
34006da0:	f3c2 000a 	ubfx	r0, r2, #0, #11
34006da4:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->GA);
34006da6:	f9b4 2010 	ldrsh.w	r2, [r4, #16]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GB);
34006daa:	bfb8      	it	lt
34006dac:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->GA);
34006dae:	f3c2 0609 	ubfx	r6, r2, #0, #10
34006db2:	2a00      	cmp	r2, #0
34006db4:	b290      	uxth	r0, r2
34006db6:	bfb8      	it	lt
34006db8:	4630      	movlt	r0, r6
    MODIFY_REG(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB | DCMIPP_P1CCGR2_GA,
34006dba:	f8d3 2890 	ldr.w	r2, [r3, #2192]	@ 0x890
34006dbe:	400a      	ands	r2, r1
34006dc0:	432a      	orrs	r2, r5
34006dc2:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34006dc6:	f8c3 2890 	str.w	r2, [r3, #2192]	@ 0x890
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BR);
34006dca:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
34006dce:	b295      	uxth	r5, r2
34006dd0:	f3c2 000a 	ubfx	r0, r2, #0, #11
34006dd4:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BG);
34006dd6:	f9b4 2014 	ldrsh.w	r2, [r4, #20]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BR);
34006dda:	bfb8      	it	lt
34006ddc:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BG);
34006dde:	f3c2 060a 	ubfx	r6, r2, #0, #11
34006de2:	2a00      	cmp	r2, #0
34006de4:	b290      	uxth	r0, r2
34006de6:	bfb8      	it	lt
34006de8:	4630      	movlt	r0, r6
    MODIFY_REG(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR | DCMIPP_P1CCBR1_BG,
34006dea:	f8d3 2894 	ldr.w	r2, [r3, #2196]	@ 0x894
34006dee:	f002 22f8 	and.w	r2, r2, #4160813056	@ 0xf800f800
34006df2:	432a      	orrs	r2, r5
34006df4:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34006df8:	f8c3 2894 	str.w	r2, [r3, #2196]	@ 0x894
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BB);
34006dfc:	f9b4 2016 	ldrsh.w	r2, [r4, #22]
34006e00:	f3c2 000a 	ubfx	r0, r2, #0, #11
34006e04:	b295      	uxth	r5, r2
34006e06:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
34006e08:	f9b4 2018 	ldrsh.w	r2, [r4, #24]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BB);
34006e0c:	bfb8      	it	lt
34006e0e:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
34006e10:	f3c2 0409 	ubfx	r4, r2, #0, #10
34006e14:	2a00      	cmp	r2, #0
34006e16:	b290      	uxth	r0, r2
34006e18:	bfb8      	it	lt
34006e1a:	4620      	movlt	r0, r4
    MODIFY_REG(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB | DCMIPP_P1CCBR2_BA,
34006e1c:	f8d3 2898 	ldr.w	r2, [r3, #2200]	@ 0x898
34006e20:	400a      	ands	r2, r1
34006e22:	432a      	orrs	r2, r5
34006e24:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34006e28:	f8c3 2898 	str.w	r2, [r3, #2200]	@ 0x898
  return HAL_OK;
34006e2c:	2000      	movs	r0, #0
34006e2e:	e6c7      	b.n	34006bc0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xc>
34006e30:	3401fd64 	.word	0x3401fd64
34006e34:	fc00f800 	.word	0xfc00f800

34006e38 <HAL_DCMIPP_PIPE_EnableISPColorConversion>:
{
34006e38:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006e3a:	b130      	cbz	r0, 34006e4a <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006e3c:	2902      	cmp	r1, #2
34006e3e:	d906      	bls.n	34006e4e <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x16>
34006e40:	f241 417b 	movw	r1, #5243	@ 0x147b
34006e44:	4807      	ldr	r0, [pc, #28]	@ (34006e64 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x2c>)
34006e46:	f7fb fee3 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
34006e4a:	2001      	movs	r0, #1
}
34006e4c:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006e4e:	2901      	cmp	r1, #1
34006e50:	d1fb      	bne.n	34006e4a <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x12>
    SET_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
34006e52:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006e54:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
34006e56:	f8d2 3880 	ldr.w	r3, [r2, #2176]	@ 0x880
34006e5a:	f043 0301 	orr.w	r3, r3, #1
34006e5e:	f8c2 3880 	str.w	r3, [r2, #2176]	@ 0x880
  return HAL_OK;
34006e62:	e7f3      	b.n	34006e4c <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x14>
34006e64:	3401fd64 	.word	0x3401fd64

34006e68 <HAL_DCMIPP_PIPE_DisableISPColorConversion>:
{
34006e68:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006e6a:	b130      	cbz	r0, 34006e7a <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006e6c:	2902      	cmp	r1, #2
34006e6e:	d906      	bls.n	34006e7e <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x16>
34006e70:	f241 4197 	movw	r1, #5271	@ 0x1497
34006e74:	4807      	ldr	r0, [pc, #28]	@ (34006e94 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x2c>)
34006e76:	f7fb fecb 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
34006e7a:	2001      	movs	r0, #1
}
34006e7c:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006e7e:	2901      	cmp	r1, #1
34006e80:	d1fb      	bne.n	34006e7a <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
34006e82:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006e84:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
34006e86:	f8d2 3880 	ldr.w	r3, [r2, #2176]	@ 0x880
34006e8a:	f023 0301 	bic.w	r3, r3, #1
34006e8e:	f8c2 3880 	str.w	r3, [r2, #2176]	@ 0x880
  return HAL_OK;
34006e92:	e7f3      	b.n	34006e7c <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x14>
34006e94:	3401fd64 	.word	0x3401fd64

34006e98 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>:
{
34006e98:	b510      	push	{r4, lr}
  if ((hdcmipp == NULL) || (pBlackLevelConfig == NULL))
34006e9a:	b100      	cbz	r0, 34006e9e <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x6>
34006e9c:	b90a      	cbnz	r2, 34006ea2 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0xa>
    return HAL_ERROR;
34006e9e:	2001      	movs	r0, #1
}
34006ea0:	bd10      	pop	{r4, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006ea2:	2902      	cmp	r1, #2
34006ea4:	d905      	bls.n	34006eb2 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x1a>
34006ea6:	f241 515b 	movw	r1, #5467	@ 0x155b
34006eaa:	480b      	ldr	r0, [pc, #44]	@ (34006ed8 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x40>)
34006eac:	f7fb feb0 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006eb0:	e7f5      	b.n	34006e9e <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x6>
34006eb2:	2901      	cmp	r1, #1
34006eb4:	d1f3      	bne.n	34006e9e <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x6>
    MODIFY_REG(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_BLCR | DCMIPP_P1BLCCR_BLCG | DCMIPP_P1BLCCR_BLCB,
34006eb6:	6800      	ldr	r0, [r0, #0]
34006eb8:	7853      	ldrb	r3, [r2, #1]
34006eba:	7814      	ldrb	r4, [r2, #0]
34006ebc:	f8d0 1840 	ldr.w	r1, [r0, #2112]	@ 0x840
34006ec0:	7892      	ldrb	r2, [r2, #2]
34006ec2:	041b      	lsls	r3, r3, #16
34006ec4:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
34006ec8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
34006ecc:	b2ca      	uxtb	r2, r1
34006ece:	4313      	orrs	r3, r2
34006ed0:	f8c0 3840 	str.w	r3, [r0, #2112]	@ 0x840
  return HAL_OK;
34006ed4:	2000      	movs	r0, #0
34006ed6:	e7e3      	b.n	34006ea0 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x8>
34006ed8:	3401fd64 	.word	0x3401fd64

34006edc <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>:
{
34006edc:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006ede:	b130      	cbz	r0, 34006eee <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006ee0:	2902      	cmp	r1, #2
34006ee2:	d906      	bls.n	34006ef2 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x16>
34006ee4:	f241 517a 	movw	r1, #5498	@ 0x157a
34006ee8:	4807      	ldr	r0, [pc, #28]	@ (34006f08 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x2c>)
34006eea:	f7fb fe91 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
34006eee:	2001      	movs	r0, #1
}
34006ef0:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006ef2:	2901      	cmp	r1, #1
34006ef4:	d1fb      	bne.n	34006eee <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x12>
    SET_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
34006ef6:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006ef8:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
34006efa:	f8d2 3840 	ldr.w	r3, [r2, #2112]	@ 0x840
34006efe:	f043 0301 	orr.w	r3, r3, #1
34006f02:	f8c2 3840 	str.w	r3, [r2, #2112]	@ 0x840
  return HAL_OK;
34006f06:	e7f3      	b.n	34006ef0 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x14>
34006f08:	3401fd64 	.word	0x3401fd64

34006f0c <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>:
{
34006f0c:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006f0e:	b130      	cbz	r0, 34006f1e <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006f10:	2902      	cmp	r1, #2
34006f12:	d906      	bls.n	34006f22 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x16>
34006f14:	f241 5196 	movw	r1, #5526	@ 0x1596
34006f18:	4807      	ldr	r0, [pc, #28]	@ (34006f38 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x2c>)
34006f1a:	f7fb fe79 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
34006f1e:	2001      	movs	r0, #1
}
34006f20:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006f22:	2901      	cmp	r1, #1
34006f24:	d1fb      	bne.n	34006f1e <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
34006f26:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006f28:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
34006f2a:	f8d2 3840 	ldr.w	r3, [r2, #2112]	@ 0x840
34006f2e:	f023 0301 	bic.w	r3, r3, #1
34006f32:	f8c2 3840 	str.w	r3, [r2, #2112]	@ 0x840
  return HAL_OK;
34006f36:	e7f3      	b.n	34006f20 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x14>
34006f38:	3401fd64 	.word	0x3401fd64

34006f3c <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006f3c:	2902      	cmp	r1, #2
34006f3e:	d904      	bls.n	34006f4a <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig+0xe>
34006f40:	f241 51b0 	movw	r1, #5552	@ 0x15b0
34006f44:	4807      	ldr	r0, [pc, #28]	@ (34006f64 <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig+0x28>)
34006f46:	f7fb be63 	b.w	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006f4a:	2901      	cmp	r1, #1
34006f4c:	d108      	bne.n	34006f60 <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig+0x24>
    p1blccr_reg = READ_REG(hdcmipp->Instance->P1BLCCR);
34006f4e:	6803      	ldr	r3, [r0, #0]
34006f50:	f8d3 3840 	ldr.w	r3, [r3, #2112]	@ 0x840
    pBlackLevelConfig->BlueCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCB) >> DCMIPP_P1BLCCR_BLCB_Pos);
34006f54:	0a19      	lsrs	r1, r3, #8
34006f56:	7091      	strb	r1, [r2, #2]
    pBlackLevelConfig->GreenCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCG) >> DCMIPP_P1BLCCR_BLCG_Pos);
34006f58:	0c19      	lsrs	r1, r3, #16
    pBlackLevelConfig->RedCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCR) >> DCMIPP_P1BLCCR_BLCR_Pos);
34006f5a:	0e1b      	lsrs	r3, r3, #24
    pBlackLevelConfig->GreenCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCG) >> DCMIPP_P1BLCCR_BLCG_Pos);
34006f5c:	7051      	strb	r1, [r2, #1]
    pBlackLevelConfig->RedCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCR) >> DCMIPP_P1BLCCR_BLCR_Pos);
34006f5e:	7013      	strb	r3, [r2, #0]
}
34006f60:	4770      	bx	lr
34006f62:	bf00      	nop
34006f64:	3401fd64 	.word	0x3401fd64

34006f68 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration>:
{
34006f68:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34006f6a:	4a10      	ldr	r2, [pc, #64]	@ (34006fac <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x44>)
34006f6c:	6803      	ldr	r3, [r0, #0]
{
34006f6e:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34006f70:	4293      	cmp	r3, r2
{
34006f72:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34006f74:	d008      	beq.n	34006f88 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x20>
34006f76:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34006f7a:	4293      	cmp	r3, r2
34006f7c:	d004      	beq.n	34006f88 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x20>
34006f7e:	f241 51c4 	movw	r1, #5572	@ 0x15c4
34006f82:	480b      	ldr	r0, [pc, #44]	@ (34006fb0 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x48>)
34006f84:	f7fb fe44 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006f88:	2d02      	cmp	r5, #2
34006f8a:	d906      	bls.n	34006f9a <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x32>
34006f8c:	f241 51c5 	movw	r1, #5573	@ 0x15c5
34006f90:	4807      	ldr	r0, [pc, #28]	@ (34006fb0 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x48>)
34006f92:	f7fb fe3d 	bl	34002c10 <assert_failed>
    return 0;
34006f96:	2000      	movs	r0, #0
}
34006f98:	bd38      	pop	{r3, r4, r5, pc}
  if (Pipe == DCMIPP_PIPE1)
34006f9a:	2d01      	cmp	r5, #1
34006f9c:	d1fb      	bne.n	34006f96 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x2e>
    return ((READ_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE) == DCMIPP_P1BLCCR_ENABLE) ? 1U : 0U);
34006f9e:	6823      	ldr	r3, [r4, #0]
34006fa0:	f8d3 0840 	ldr.w	r0, [r3, #2112]	@ 0x840
34006fa4:	f000 0001 	and.w	r0, r0, #1
34006fa8:	e7f6      	b.n	34006f98 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x30>
34006faa:	bf00      	nop
34006fac:	58002000 	.word	0x58002000
34006fb0:	3401fd64 	.word	0x3401fd64

34006fb4 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>:
{
34006fb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34006fb6:	460f      	mov	r7, r1
34006fb8:	4615      	mov	r5, r2
34006fba:	461c      	mov	r4, r3
  if ((hdcmipp == NULL) || (pStatisticExtractionConfig == NULL))
34006fbc:	4606      	mov	r6, r0
34006fbe:	b908      	cbnz	r0, 34006fc4 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x10>
    return HAL_ERROR;
34006fc0:	2001      	movs	r0, #1
}
34006fc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hdcmipp == NULL) || (pStatisticExtractionConfig == NULL))
34006fc4:	2b00      	cmp	r3, #0
34006fc6:	d0fb      	beq.n	34006fc0 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006fc8:	2902      	cmp	r1, #2
34006fca:	d904      	bls.n	34006fd6 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x22>
34006fcc:	f241 51e9 	movw	r1, #5609	@ 0x15e9
34006fd0:	482a      	ldr	r0, [pc, #168]	@ (3400707c <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
34006fd2:	f7fb fe1d 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
34006fd6:	1e6b      	subs	r3, r5, #1
34006fd8:	2b02      	cmp	r3, #2
34006fda:	d904      	bls.n	34006fe6 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x32>
34006fdc:	f241 51ea 	movw	r1, #5610	@ 0x15ea
34006fe0:	4826      	ldr	r0, [pc, #152]	@ (3400707c <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
34006fe2:	f7fb fe15 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_BINS(pStatisticExtractionConfig->Bins));
34006fe6:	68a3      	ldr	r3, [r4, #8]
34006fe8:	b16b      	cbz	r3, 34007006 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x52>
34006fea:	3b04      	subs	r3, #4
34006fec:	2b08      	cmp	r3, #8
34006fee:	d805      	bhi.n	34006ffc <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x48>
34006ff0:	f240 1211 	movw	r2, #273	@ 0x111
34006ff4:	fa22 f303 	lsr.w	r3, r2, r3
34006ff8:	07db      	lsls	r3, r3, #31
34006ffa:	d404      	bmi.n	34007006 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x52>
34006ffc:	f241 51eb 	movw	r1, #5611	@ 0x15eb
34007000:	481e      	ldr	r0, [pc, #120]	@ (3400707c <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
34007002:	f7fb fe05 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_SOURCE(pStatisticExtractionConfig->Source));
34007006:	6863      	ldr	r3, [r4, #4]
34007008:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400700c:	d006      	beq.n	3400701c <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x68>
3400700e:	2b40      	cmp	r3, #64	@ 0x40
34007010:	d004      	beq.n	3400701c <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x68>
34007012:	f241 51ec 	movw	r1, #5612	@ 0x15ec
34007016:	4819      	ldr	r0, [pc, #100]	@ (3400707c <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
34007018:	f7fb fdfa 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODE(pStatisticExtractionConfig->Mode));
3400701c:	6823      	ldr	r3, [r4, #0]
3400701e:	f033 0380 	bics.w	r3, r3, #128	@ 0x80
34007022:	d004      	beq.n	3400702e <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x7a>
34007024:	f241 51ed 	movw	r1, #5613	@ 0x15ed
34007028:	4814      	ldr	r0, [pc, #80]	@ (3400707c <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
3400702a:	f7fb fdf1 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
3400702e:	2f01      	cmp	r7, #1
34007030:	d1c6      	bne.n	34006fc0 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc>
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
34007032:	e9d4 3200 	ldrd	r3, r2, [r4]
34007036:	4313      	orrs	r3, r2
34007038:	68a2      	ldr	r2, [r4, #8]
    switch (ModuleID)
3400703a:	2d01      	cmp	r5, #1
        MODIFY_REG(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_BINS | DCMIPP_P1ST1CR_SRC | \
3400703c:	6831      	ldr	r1, [r6, #0]
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
3400703e:	ea43 0302 	orr.w	r3, r3, r2
    switch (ModuleID)
34007042:	d009      	beq.n	34007058 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xa4>
34007044:	2d02      	cmp	r5, #2
34007046:	d010      	beq.n	3400706a <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xb6>
        MODIFY_REG(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_BINS | DCMIPP_P1ST3CR_SRC | \
34007048:	f8d1 2858 	ldr.w	r2, [r1, #2136]	@ 0x858
3400704c:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
34007050:	4313      	orrs	r3, r2
34007052:	f8c1 3858 	str.w	r3, [r1, #2136]	@ 0x858
        break;
34007056:	e006      	b.n	34007066 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xb2>
        MODIFY_REG(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_BINS | DCMIPP_P1ST1CR_SRC | \
34007058:	f8d1 2850 	ldr.w	r2, [r1, #2128]	@ 0x850
3400705c:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
34007060:	4313      	orrs	r3, r2
34007062:	f8c1 3850 	str.w	r3, [r1, #2128]	@ 0x850
  return HAL_OK;
34007066:	2000      	movs	r0, #0
34007068:	e7ab      	b.n	34006fc2 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xe>
        MODIFY_REG(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_BINS | DCMIPP_P1ST2CR_SRC | \
3400706a:	f8d1 2854 	ldr.w	r2, [r1, #2132]	@ 0x854
3400706e:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
34007072:	4313      	orrs	r3, r2
34007074:	f8c1 3854 	str.w	r3, [r1, #2132]	@ 0x854
        break;
34007078:	e7f5      	b.n	34007066 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xb2>
3400707a:	bf00      	nop
3400707c:	3401fd64 	.word	0x3401fd64

34007080 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>:
{
34007080:	b570      	push	{r4, r5, r6, lr}
34007082:	460e      	mov	r6, r1
34007084:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pStatisticExtractionAreaConfig == NULL))
34007086:	4605      	mov	r5, r0
34007088:	b908      	cbnz	r0, 3400708e <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xe>
    return HAL_ERROR;
3400708a:	2001      	movs	r0, #1
}
3400708c:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pStatisticExtractionAreaConfig == NULL))
3400708e:	2a00      	cmp	r2, #0
34007090:	d0fb      	beq.n	3400708a <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007092:	2902      	cmp	r1, #2
34007094:	d904      	bls.n	340070a0 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x20>
34007096:	f241 611f 	movw	r1, #5663	@ 0x161f
3400709a:	4821      	ldr	r0, [pc, #132]	@ (34007120 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
3400709c:	f7fb fdb8 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->HStart));
340070a0:	6863      	ldr	r3, [r4, #4]
340070a2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340070a6:	d304      	bcc.n	340070b2 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x32>
340070a8:	f44f 51b1 	mov.w	r1, #5664	@ 0x1620
340070ac:	481c      	ldr	r0, [pc, #112]	@ (34007120 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
340070ae:	f7fb fdaf 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->VStart));
340070b2:	6823      	ldr	r3, [r4, #0]
340070b4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340070b8:	d304      	bcc.n	340070c4 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x44>
340070ba:	f241 6121 	movw	r1, #5665	@ 0x1621
340070be:	4818      	ldr	r0, [pc, #96]	@ (34007120 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
340070c0:	f7fb fda6 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->HSize));
340070c4:	68e3      	ldr	r3, [r4, #12]
340070c6:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340070ca:	d304      	bcc.n	340070d6 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x56>
340070cc:	f241 6122 	movw	r1, #5666	@ 0x1622
340070d0:	4813      	ldr	r0, [pc, #76]	@ (34007120 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
340070d2:	f7fb fd9d 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->VSize));
340070d6:	68a3      	ldr	r3, [r4, #8]
340070d8:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340070dc:	d304      	bcc.n	340070e8 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x68>
340070de:	f241 6123 	movw	r1, #5667	@ 0x1623
340070e2:	480f      	ldr	r0, [pc, #60]	@ (34007120 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
340070e4:	f7fb fd94 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
340070e8:	2e01      	cmp	r6, #1
340070ea:	d1ce      	bne.n	3400708a <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1STSTR, DCMIPP_P1STSTR_HSTART | DCMIPP_P1STSTR_VSTART,
340070ec:	e9d4 0300 	ldrd	r0, r3, [r4]
340070f0:	682a      	ldr	r2, [r5, #0]
340070f2:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
340070f6:	f8d2 185c 	ldr.w	r1, [r2, #2140]	@ 0x85c
340070fa:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
340070fe:	430b      	orrs	r3, r1
34007100:	f8c2 385c 	str.w	r3, [r2, #2140]	@ 0x85c
    MODIFY_REG(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_HSIZE | DCMIPP_P1STSZR_VSIZE,
34007104:	f8d2 1860 	ldr.w	r1, [r2, #2144]	@ 0x860
34007108:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
3400710c:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34007110:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34007114:	430b      	orrs	r3, r1
  return HAL_OK;
34007116:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_HSIZE | DCMIPP_P1STSZR_VSIZE,
34007118:	f8c2 3860 	str.w	r3, [r2, #2144]	@ 0x860
  return HAL_OK;
3400711c:	e7b6      	b.n	3400708c <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xc>
3400711e:	bf00      	nop
34007120:	3401fd64 	.word	0x3401fd64

34007124 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>:
{
34007124:	b570      	push	{r4, r5, r6, lr}
34007126:	460e      	mov	r6, r1
34007128:	4615      	mov	r5, r2
  if (hdcmipp == NULL)
3400712a:	4604      	mov	r4, r0
3400712c:	b908      	cbnz	r0, 34007132 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xe>
    return HAL_ERROR;
3400712e:	2001      	movs	r0, #1
}
34007130:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007132:	2902      	cmp	r1, #2
34007134:	d904      	bls.n	34007140 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x1c>
34007136:	f241 6147 	movw	r1, #5703	@ 0x1647
3400713a:	4815      	ldr	r0, [pc, #84]	@ (34007190 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x6c>)
3400713c:	f7fb fd68 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
34007140:	1e6b      	subs	r3, r5, #1
34007142:	2b02      	cmp	r3, #2
34007144:	d90e      	bls.n	34007164 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x40>
34007146:	f241 6148 	movw	r1, #5704	@ 0x1648
3400714a:	4811      	ldr	r0, [pc, #68]	@ (34007190 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x6c>)
3400714c:	f7fb fd60 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34007150:	2e01      	cmp	r6, #1
34007152:	d1ec      	bne.n	3400712e <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xa>
        SET_BIT(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_ENABLE);
34007154:	6822      	ldr	r2, [r4, #0]
34007156:	f8d2 3858 	ldr.w	r3, [r2, #2136]	@ 0x858
3400715a:	f043 0301 	orr.w	r3, r3, #1
3400715e:	f8c2 3858 	str.w	r3, [r2, #2136]	@ 0x858
        break;
34007162:	e013      	b.n	3400718c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x68>
  if (Pipe == DCMIPP_PIPE1)
34007164:	2e01      	cmp	r6, #1
34007166:	d1e2      	bne.n	3400712e <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xa>
    switch (ModuleID)
34007168:	2d01      	cmp	r5, #1
        SET_BIT(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_ENABLE);
3400716a:	6823      	ldr	r3, [r4, #0]
    switch (ModuleID)
3400716c:	d008      	beq.n	34007180 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x5c>
3400716e:	2d02      	cmp	r5, #2
34007170:	d1f0      	bne.n	34007154 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x30>
        SET_BIT(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_ENABLE);
34007172:	f8d3 2854 	ldr.w	r2, [r3, #2132]	@ 0x854
34007176:	f042 0201 	orr.w	r2, r2, #1
3400717a:	f8c3 2854 	str.w	r2, [r3, #2132]	@ 0x854
        break;
3400717e:	e005      	b.n	3400718c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x68>
        SET_BIT(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_ENABLE);
34007180:	f8d3 2850 	ldr.w	r2, [r3, #2128]	@ 0x850
34007184:	f042 0201 	orr.w	r2, r2, #1
34007188:	f8c3 2850 	str.w	r2, [r3, #2128]	@ 0x850
  return HAL_OK;
3400718c:	2000      	movs	r0, #0
3400718e:	e7cf      	b.n	34007130 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xc>
34007190:	3401fd64 	.word	0x3401fd64

34007194 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>:
{
34007194:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34007196:	b130      	cbz	r0, 340071a6 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007198:	2902      	cmp	r1, #2
3400719a:	d906      	bls.n	340071aa <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x16>
3400719c:	f241 619f 	movw	r1, #5791	@ 0x169f
340071a0:	4807      	ldr	r0, [pc, #28]	@ (340071c0 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x2c>)
340071a2:	f7fb fd35 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
340071a6:	2001      	movs	r0, #1
}
340071a8:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
340071aa:	2901      	cmp	r1, #1
340071ac:	d1fb      	bne.n	340071a6 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x12>
    SET_BIT(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_CROPEN);
340071ae:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340071b0:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_CROPEN);
340071b2:	f8d2 3860 	ldr.w	r3, [r2, #2144]	@ 0x860
340071b6:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
340071ba:	f8c2 3860 	str.w	r3, [r2, #2144]	@ 0x860
  return HAL_OK;
340071be:	e7f3      	b.n	340071a8 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x14>
340071c0:	3401fd64 	.word	0x3401fd64

340071c4 <HAL_DCMIPP_PIPE_SetISPExposureConfig>:
{
340071c4:	b570      	push	{r4, r5, r6, lr}
340071c6:	460e      	mov	r6, r1
340071c8:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pExposureConfig == NULL))
340071ca:	4605      	mov	r5, r0
340071cc:	b908      	cbnz	r0, 340071d2 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xe>
    return HAL_ERROR;
340071ce:	2001      	movs	r0, #1
}
340071d0:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pExposureConfig == NULL))
340071d2:	2a00      	cmp	r2, #0
340071d4:	d0fb      	beq.n	340071ce <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340071d6:	2902      	cmp	r1, #2
340071d8:	d904      	bls.n	340071e4 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x20>
340071da:	f241 61db 	movw	r1, #5851	@ 0x16db
340071de:	481c      	ldr	r0, [pc, #112]	@ (34007250 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
340071e0:	f7fb fd16 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftRed));
340071e4:	7823      	ldrb	r3, [r4, #0]
340071e6:	2b07      	cmp	r3, #7
340071e8:	d904      	bls.n	340071f4 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x30>
340071ea:	f241 61dc 	movw	r1, #5852	@ 0x16dc
340071ee:	4818      	ldr	r0, [pc, #96]	@ (34007250 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
340071f0:	f7fb fd0e 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftGreen));
340071f4:	78a3      	ldrb	r3, [r4, #2]
340071f6:	2b07      	cmp	r3, #7
340071f8:	d904      	bls.n	34007204 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x40>
340071fa:	f241 61dd 	movw	r1, #5853	@ 0x16dd
340071fe:	4814      	ldr	r0, [pc, #80]	@ (34007250 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
34007200:	f7fb fd06 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftBlue));
34007204:	7923      	ldrb	r3, [r4, #4]
34007206:	2b07      	cmp	r3, #7
34007208:	d904      	bls.n	34007214 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x50>
3400720a:	f241 61de 	movw	r1, #5854	@ 0x16de
3400720e:	4810      	ldr	r0, [pc, #64]	@ (34007250 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
34007210:	f7fb fcfe 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34007214:	2e01      	cmp	r6, #1
34007216:	d1da      	bne.n	340071ce <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_SHFR | DCMIPP_P1EXCR1_MULTR,
34007218:	682a      	ldr	r2, [r5, #0]
3400721a:	7863      	ldrb	r3, [r4, #1]
3400721c:	7820      	ldrb	r0, [r4, #0]
3400721e:	f8d2 1844 	ldr.w	r1, [r2, #2116]	@ 0x844
34007222:	051b      	lsls	r3, r3, #20
34007224:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
34007228:	f36f 511e 	bfc	r1, #20, #11
3400722c:	430b      	orrs	r3, r1
3400722e:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
    WRITE_REG(hdcmipp->Instance->P1EXCR2, (((uint32_t)pExposureConfig->ShiftGreen << DCMIPP_P1EXCR2_SHFG_Pos) | \
34007232:	78e3      	ldrb	r3, [r4, #3]
34007234:	78a1      	ldrb	r1, [r4, #2]
34007236:	051b      	lsls	r3, r3, #20
34007238:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
3400723c:	7921      	ldrb	r1, [r4, #4]
  return HAL_OK;
3400723e:	2000      	movs	r0, #0
    WRITE_REG(hdcmipp->Instance->P1EXCR2, (((uint32_t)pExposureConfig->ShiftGreen << DCMIPP_P1EXCR2_SHFG_Pos) | \
34007240:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
34007244:	7961      	ldrb	r1, [r4, #5]
34007246:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
3400724a:	f8c2 3848 	str.w	r3, [r2, #2120]	@ 0x848
  return HAL_OK;
3400724e:	e7bf      	b.n	340071d0 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xc>
34007250:	3401fd64 	.word	0x3401fd64

34007254 <HAL_DCMIPP_PIPE_EnableISPExposure>:
{
34007254:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34007256:	b130      	cbz	r0, 34007266 <HAL_DCMIPP_PIPE_EnableISPExposure+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007258:	2902      	cmp	r1, #2
3400725a:	d906      	bls.n	3400726a <HAL_DCMIPP_PIPE_EnableISPExposure+0x16>
3400725c:	f241 7101 	movw	r1, #5889	@ 0x1701
34007260:	4807      	ldr	r0, [pc, #28]	@ (34007280 <HAL_DCMIPP_PIPE_EnableISPExposure+0x2c>)
34007262:	f7fb fcd5 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
34007266:	2001      	movs	r0, #1
}
34007268:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
3400726a:	2901      	cmp	r1, #1
3400726c:	d1fb      	bne.n	34007266 <HAL_DCMIPP_PIPE_EnableISPExposure+0x12>
    SET_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
3400726e:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34007270:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34007272:	f8d2 3844 	ldr.w	r3, [r2, #2116]	@ 0x844
34007276:	f043 0301 	orr.w	r3, r3, #1
3400727a:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
  return HAL_OK;
3400727e:	e7f3      	b.n	34007268 <HAL_DCMIPP_PIPE_EnableISPExposure+0x14>
34007280:	3401fd64 	.word	0x3401fd64

34007284 <HAL_DCMIPP_PIPE_DisableISPExposure>:
{
34007284:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34007286:	b130      	cbz	r0, 34007296 <HAL_DCMIPP_PIPE_DisableISPExposure+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007288:	2902      	cmp	r1, #2
3400728a:	d906      	bls.n	3400729a <HAL_DCMIPP_PIPE_DisableISPExposure+0x16>
3400728c:	f241 711d 	movw	r1, #5917	@ 0x171d
34007290:	4807      	ldr	r0, [pc, #28]	@ (340072b0 <HAL_DCMIPP_PIPE_DisableISPExposure+0x2c>)
34007292:	f7fb fcbd 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
34007296:	2001      	movs	r0, #1
}
34007298:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
3400729a:	2901      	cmp	r1, #1
3400729c:	d1fb      	bne.n	34007296 <HAL_DCMIPP_PIPE_DisableISPExposure+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
3400729e:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340072a0:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
340072a2:	f8d2 3844 	ldr.w	r3, [r2, #2116]	@ 0x844
340072a6:	f023 0301 	bic.w	r3, r3, #1
340072aa:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
  return HAL_OK;
340072ae:	e7f3      	b.n	34007298 <HAL_DCMIPP_PIPE_DisableISPExposure+0x14>
340072b0:	3401fd64 	.word	0x3401fd64

340072b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>:
{
340072b4:	b570      	push	{r4, r5, r6, lr}
340072b6:	460e      	mov	r6, r1
340072b8:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pContrastConfig == NULL))
340072ba:	4605      	mov	r5, r0
340072bc:	b908      	cbnz	r0, 340072c2 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xe>
    return HAL_ERROR;
340072be:	2001      	movs	r0, #1
}
340072c0:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pContrastConfig == NULL))
340072c2:	2a00      	cmp	r2, #0
340072c4:	d0fb      	beq.n	340072be <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340072c6:	2902      	cmp	r1, #2
340072c8:	d904      	bls.n	340072d4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x20>
340072ca:	f241 713b 	movw	r1, #5947	@ 0x173b
340072ce:	4839      	ldr	r0, [pc, #228]	@ (340073b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
340072d0:	f7fb fc9e 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_0));
340072d4:	7823      	ldrb	r3, [r4, #0]
340072d6:	2b3f      	cmp	r3, #63	@ 0x3f
340072d8:	d904      	bls.n	340072e4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x30>
340072da:	f241 713c 	movw	r1, #5948	@ 0x173c
340072de:	4835      	ldr	r0, [pc, #212]	@ (340073b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
340072e0:	f7fb fc96 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_32));
340072e4:	7863      	ldrb	r3, [r4, #1]
340072e6:	2b3f      	cmp	r3, #63	@ 0x3f
340072e8:	d904      	bls.n	340072f4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x40>
340072ea:	f241 713d 	movw	r1, #5949	@ 0x173d
340072ee:	4831      	ldr	r0, [pc, #196]	@ (340073b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
340072f0:	f7fb fc8e 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_64));
340072f4:	78a3      	ldrb	r3, [r4, #2]
340072f6:	2b3f      	cmp	r3, #63	@ 0x3f
340072f8:	d904      	bls.n	34007304 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x50>
340072fa:	f241 713e 	movw	r1, #5950	@ 0x173e
340072fe:	482d      	ldr	r0, [pc, #180]	@ (340073b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34007300:	f7fb fc86 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_96));
34007304:	78e3      	ldrb	r3, [r4, #3]
34007306:	2b3f      	cmp	r3, #63	@ 0x3f
34007308:	d904      	bls.n	34007314 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x60>
3400730a:	f241 713f 	movw	r1, #5951	@ 0x173f
3400730e:	4829      	ldr	r0, [pc, #164]	@ (340073b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34007310:	f7fb fc7e 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_128));
34007314:	7923      	ldrb	r3, [r4, #4]
34007316:	2b3f      	cmp	r3, #63	@ 0x3f
34007318:	d904      	bls.n	34007324 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x70>
3400731a:	f44f 51ba 	mov.w	r1, #5952	@ 0x1740
3400731e:	4825      	ldr	r0, [pc, #148]	@ (340073b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34007320:	f7fb fc76 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_160));
34007324:	7963      	ldrb	r3, [r4, #5]
34007326:	2b3f      	cmp	r3, #63	@ 0x3f
34007328:	d904      	bls.n	34007334 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x80>
3400732a:	f241 7141 	movw	r1, #5953	@ 0x1741
3400732e:	4821      	ldr	r0, [pc, #132]	@ (340073b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34007330:	f7fb fc6e 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_192));
34007334:	79a3      	ldrb	r3, [r4, #6]
34007336:	2b3f      	cmp	r3, #63	@ 0x3f
34007338:	d904      	bls.n	34007344 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x90>
3400733a:	f241 7142 	movw	r1, #5954	@ 0x1742
3400733e:	481d      	ldr	r0, [pc, #116]	@ (340073b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34007340:	f7fb fc66 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_224));
34007344:	79e3      	ldrb	r3, [r4, #7]
34007346:	2b3f      	cmp	r3, #63	@ 0x3f
34007348:	d904      	bls.n	34007354 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xa0>
3400734a:	f241 7143 	movw	r1, #5955	@ 0x1743
3400734e:	4819      	ldr	r0, [pc, #100]	@ (340073b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34007350:	f7fb fc5e 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_256));
34007354:	7a23      	ldrb	r3, [r4, #8]
34007356:	2b3f      	cmp	r3, #63	@ 0x3f
34007358:	d904      	bls.n	34007364 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xb0>
3400735a:	f241 7144 	movw	r1, #5956	@ 0x1744
3400735e:	4815      	ldr	r0, [pc, #84]	@ (340073b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34007360:	f7fb fc56 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34007364:	2e01      	cmp	r6, #1
34007366:	d1aa      	bne.n	340072be <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_LUM0,
34007368:	682a      	ldr	r2, [r5, #0]
3400736a:	7821      	ldrb	r1, [r4, #0]
3400736c:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
  return HAL_OK;
34007370:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_LUM0,
34007372:	f423 43fc 	bic.w	r3, r3, #32256	@ 0x7e00
34007376:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
3400737a:	f8c2 38a0 	str.w	r3, [r2, #2208]	@ 0x8a0
    WRITE_REG(hdcmipp->Instance->P1CTCR2, (((uint32_t)pContrastConfig->LUM_32 << DCMIPP_P1CTCR2_LUM1_Pos) |
3400737e:	78a3      	ldrb	r3, [r4, #2]
34007380:	7861      	ldrb	r1, [r4, #1]
34007382:	045b      	lsls	r3, r3, #17
34007384:	ea43 6341 	orr.w	r3, r3, r1, lsl #25
34007388:	78e1      	ldrb	r1, [r4, #3]
3400738a:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
3400738e:	7921      	ldrb	r1, [r4, #4]
34007390:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
34007394:	f8c2 38a4 	str.w	r3, [r2, #2212]	@ 0x8a4
    WRITE_REG(hdcmipp->Instance->P1CTCR3, (((uint32_t)pContrastConfig->LUM_160 << DCMIPP_P1CTCR3_LUM5_Pos) |
34007398:	79a3      	ldrb	r3, [r4, #6]
3400739a:	7961      	ldrb	r1, [r4, #5]
3400739c:	045b      	lsls	r3, r3, #17
3400739e:	ea43 6341 	orr.w	r3, r3, r1, lsl #25
340073a2:	79e1      	ldrb	r1, [r4, #7]
340073a4:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
340073a8:	7a21      	ldrb	r1, [r4, #8]
340073aa:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
340073ae:	f8c2 38a8 	str.w	r3, [r2, #2216]	@ 0x8a8
  return HAL_OK;
340073b2:	e785      	b.n	340072c0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xc>
340073b4:	3401fd64 	.word	0x3401fd64

340073b8 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>:
{
340073b8:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340073ba:	b130      	cbz	r0, 340073ca <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340073bc:	2902      	cmp	r1, #2
340073be:	d906      	bls.n	340073ce <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x16>
340073c0:	f241 716c 	movw	r1, #5996	@ 0x176c
340073c4:	4807      	ldr	r0, [pc, #28]	@ (340073e4 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x2c>)
340073c6:	f7fb fc23 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
340073ca:	2001      	movs	r0, #1
}
340073cc:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
340073ce:	2901      	cmp	r1, #1
340073d0:	d1fb      	bne.n	340073ca <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x12>
    SET_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
340073d2:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340073d4:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
340073d6:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
340073da:	f043 0301 	orr.w	r3, r3, #1
340073de:	f8c2 38a0 	str.w	r3, [r2, #2208]	@ 0x8a0
  return HAL_OK;
340073e2:	e7f3      	b.n	340073cc <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x14>
340073e4:	3401fd64 	.word	0x3401fd64

340073e8 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>:
{
340073e8:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340073ea:	b130      	cbz	r0, 340073fa <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340073ec:	2902      	cmp	r1, #2
340073ee:	d906      	bls.n	340073fe <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x16>
340073f0:	f241 7188 	movw	r1, #6024	@ 0x1788
340073f4:	4807      	ldr	r0, [pc, #28]	@ (34007414 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x2c>)
340073f6:	f7fb fc0b 	bl	34002c10 <assert_failed>
    return HAL_ERROR;
340073fa:	2001      	movs	r0, #1
}
340073fc:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
340073fe:	2901      	cmp	r1, #1
34007400:	d1fb      	bne.n	340073fa <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34007402:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34007404:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34007406:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
3400740a:	f023 0301 	bic.w	r3, r3, #1
3400740e:	f8c2 38a0 	str.w	r3, [r2, #2208]	@ 0x8a0
  return HAL_OK;
34007412:	e7f3      	b.n	340073fc <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x14>
34007414:	3401fd64 	.word	0x3401fd64

34007418 <HAL_DCMIPP_PIPE_SetPitch>:
{
34007418:	b570      	push	{r4, r5, r6, lr}
3400741a:	460e      	mov	r6, r1
3400741c:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
3400741e:	4605      	mov	r5, r0
34007420:	b908      	cbnz	r0, 34007426 <HAL_DCMIPP_PIPE_SetPitch+0xe>
    return HAL_ERROR;
34007422:	2001      	movs	r0, #1
}
34007424:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007426:	2902      	cmp	r1, #2
34007428:	d904      	bls.n	34007434 <HAL_DCMIPP_PIPE_SetPitch+0x1c>
3400742a:	f241 71d2 	movw	r1, #6098	@ 0x17d2
3400742e:	4812      	ldr	r0, [pc, #72]	@ (34007478 <HAL_DCMIPP_PIPE_SetPitch+0x60>)
34007430:	f7fb fbee 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(LinePitch));
34007434:	0723      	lsls	r3, r4, #28
34007436:	d102      	bne.n	3400743e <HAL_DCMIPP_PIPE_SetPitch+0x26>
34007438:	f5b4 4f00 	cmp.w	r4, #32768	@ 0x8000
3400743c:	d304      	bcc.n	34007448 <HAL_DCMIPP_PIPE_SetPitch+0x30>
3400743e:	f241 71d3 	movw	r1, #6099	@ 0x17d3
34007442:	480d      	ldr	r0, [pc, #52]	@ (34007478 <HAL_DCMIPP_PIPE_SetPitch+0x60>)
34007444:	f7fb fbe4 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34007448:	2e01      	cmp	r6, #1
3400744a:	d109      	bne.n	34007460 <HAL_DCMIPP_PIPE_SetPitch+0x48>
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH, LinePitch << DCMIPP_P1PPM0PR_PITCH_Pos);
3400744c:	682a      	ldr	r2, [r5, #0]
3400744e:	f8d2 39cc 	ldr.w	r3, [r2, #2508]	@ 0x9cc
34007452:	f36f 030e 	bfc	r3, #0, #15
34007456:	4323      	orrs	r3, r4
34007458:	f8c2 39cc 	str.w	r3, [r2, #2508]	@ 0x9cc
  return HAL_OK;
3400745c:	2000      	movs	r0, #0
3400745e:	e7e1      	b.n	34007424 <HAL_DCMIPP_PIPE_SetPitch+0xc>
  else if (Pipe == DCMIPP_PIPE2)
34007460:	2e02      	cmp	r6, #2
34007462:	d1de      	bne.n	34007422 <HAL_DCMIPP_PIPE_SetPitch+0xa>
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH, LinePitch << DCMIPP_P2PPM0PR_PITCH_Pos);
34007464:	682a      	ldr	r2, [r5, #0]
34007466:	f8d2 3dcc 	ldr.w	r3, [r2, #3532]	@ 0xdcc
3400746a:	f36f 030e 	bfc	r3, #0, #15
3400746e:	4323      	orrs	r3, r4
34007470:	f8c2 3dcc 	str.w	r3, [r2, #3532]	@ 0xdcc
34007474:	e7f2      	b.n	3400745c <HAL_DCMIPP_PIPE_SetPitch+0x44>
34007476:	bf00      	nop
34007478:	3401fd64 	.word	0x3401fd64

3400747c <HAL_DCMIPP_PIPE_SetPixelPackerFormat>:
{
3400747c:	b570      	push	{r4, r5, r6, lr}
3400747e:	460e      	mov	r6, r1
34007480:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
34007482:	4605      	mov	r5, r0
34007484:	b908      	cbnz	r0, 3400748a <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xe>
    return HAL_ERROR;
34007486:	2001      	movs	r0, #1
}
34007488:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400748a:	2902      	cmp	r1, #2
3400748c:	d917      	bls.n	340074be <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x42>
3400748e:	f241 71f6 	movw	r1, #6134	@ 0x17f6
34007492:	4812      	ldr	r0, [pc, #72]	@ (340074dc <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x60>)
34007494:	f7fb fbbc 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(PixelPackerFormat));
34007498:	2c0a      	cmp	r4, #10
3400749a:	d9f4      	bls.n	34007486 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xa>
3400749c:	f241 71f7 	movw	r1, #6135	@ 0x17f7
340074a0:	480e      	ldr	r0, [pc, #56]	@ (340074dc <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x60>)
340074a2:	f7fb fbb5 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
340074a6:	2e01      	cmp	r6, #1
340074a8:	d10c      	bne.n	340074c4 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x48>
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, PixelPackerFormat);
340074aa:	682a      	ldr	r2, [r5, #0]
340074ac:	f8d2 39c0 	ldr.w	r3, [r2, #2496]	@ 0x9c0
340074b0:	f023 030f 	bic.w	r3, r3, #15
340074b4:	4323      	orrs	r3, r4
340074b6:	f8c2 39c0 	str.w	r3, [r2, #2496]	@ 0x9c0
  return HAL_OK;
340074ba:	2000      	movs	r0, #0
340074bc:	e7e4      	b.n	34007488 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xc>
  assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(PixelPackerFormat));
340074be:	2a0a      	cmp	r2, #10
340074c0:	d9f1      	bls.n	340074a6 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x2a>
340074c2:	e7eb      	b.n	3400749c <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x20>
  else if (Pipe == DCMIPP_PIPE2)
340074c4:	2e02      	cmp	r6, #2
340074c6:	d1de      	bne.n	34007486 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xa>
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, PixelPackerFormat);
340074c8:	682a      	ldr	r2, [r5, #0]
340074ca:	f8d2 3dc0 	ldr.w	r3, [r2, #3520]	@ 0xdc0
340074ce:	f023 030f 	bic.w	r3, r3, #15
340074d2:	4323      	orrs	r3, r4
340074d4:	f8c2 3dc0 	str.w	r3, [r2, #3520]	@ 0xdc0
340074d8:	e7ef      	b.n	340074ba <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x3e>
340074da:	bf00      	nop
340074dc:	3401fd64 	.word	0x3401fd64

340074e0 <HAL_DCMIPP_PIPE_EnableRedBlueSwap>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
340074e0:	2902      	cmp	r1, #2
{
340074e2:	b538      	push	{r3, r4, r5, lr}
340074e4:	4604      	mov	r4, r0
340074e6:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_PIPE(Pipe));
340074e8:	d904      	bls.n	340074f4 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x14>
340074ea:	f641 1139 	movw	r1, #6457	@ 0x1939
340074ee:	480f      	ldr	r0, [pc, #60]	@ (3400752c <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x4c>)
340074f0:	f7fb fb8e 	bl	34002c10 <assert_failed>
  if (hdcmipp == NULL)
340074f4:	b1bc      	cbz	r4, 34007526 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x46>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
340074f6:	7923      	ldrb	r3, [r4, #4]
340074f8:	2b02      	cmp	r3, #2
340074fa:	d108      	bne.n	3400750e <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x2e>
    if (Pipe == DCMIPP_PIPE1)
340074fc:	2d01      	cmp	r5, #1
340074fe:	d108      	bne.n	34007512 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x32>
      SET_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
34007500:	6822      	ldr	r2, [r4, #0]
34007502:	f8d2 39c0 	ldr.w	r3, [r2, #2496]	@ 0x9c0
34007506:	f043 0310 	orr.w	r3, r3, #16
3400750a:	f8c2 39c0 	str.w	r3, [r2, #2496]	@ 0x9c0
  return HAL_OK;
3400750e:	2000      	movs	r0, #0
}
34007510:	bd38      	pop	{r3, r4, r5, pc}
    else if (Pipe == DCMIPP_PIPE2)
34007512:	2d02      	cmp	r5, #2
34007514:	d107      	bne.n	34007526 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x46>
      SET_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
34007516:	6822      	ldr	r2, [r4, #0]
34007518:	f8d2 3dc0 	ldr.w	r3, [r2, #3520]	@ 0xdc0
3400751c:	f043 0310 	orr.w	r3, r3, #16
34007520:	f8c2 3dc0 	str.w	r3, [r2, #3520]	@ 0xdc0
34007524:	e7f3      	b.n	3400750e <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x2e>
    return HAL_ERROR;
34007526:	2001      	movs	r0, #1
34007528:	e7f2      	b.n	34007510 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x30>
3400752a:	bf00      	nop
3400752c:	3401fd64 	.word	0x3401fd64

34007530 <HAL_DCMIPP_PIPE_DisableRedBlueSwap>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007530:	2902      	cmp	r1, #2
{
34007532:	b538      	push	{r3, r4, r5, lr}
34007534:	4604      	mov	r4, r0
34007536:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007538:	d904      	bls.n	34007544 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x14>
3400753a:	f641 115b 	movw	r1, #6491	@ 0x195b
3400753e:	480f      	ldr	r0, [pc, #60]	@ (3400757c <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x4c>)
34007540:	f7fb fb66 	bl	34002c10 <assert_failed>
  if (hdcmipp == NULL)
34007544:	b1bc      	cbz	r4, 34007576 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x46>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34007546:	7923      	ldrb	r3, [r4, #4]
34007548:	2b02      	cmp	r3, #2
3400754a:	d108      	bne.n	3400755e <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x2e>
    if (Pipe == DCMIPP_PIPE1)
3400754c:	2d01      	cmp	r5, #1
3400754e:	d108      	bne.n	34007562 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x32>
      CLEAR_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
34007550:	6822      	ldr	r2, [r4, #0]
34007552:	f8d2 39c0 	ldr.w	r3, [r2, #2496]	@ 0x9c0
34007556:	f023 0310 	bic.w	r3, r3, #16
3400755a:	f8c2 39c0 	str.w	r3, [r2, #2496]	@ 0x9c0
  return HAL_OK;
3400755e:	2000      	movs	r0, #0
}
34007560:	bd38      	pop	{r3, r4, r5, pc}
    else if (Pipe == DCMIPP_PIPE2)
34007562:	2d02      	cmp	r5, #2
34007564:	d107      	bne.n	34007576 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x46>
      CLEAR_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
34007566:	6822      	ldr	r2, [r4, #0]
34007568:	f8d2 3dc0 	ldr.w	r3, [r2, #3520]	@ 0xdc0
3400756c:	f023 0310 	bic.w	r3, r3, #16
34007570:	f8c2 3dc0 	str.w	r3, [r2, #3520]	@ 0xdc0
34007574:	e7f3      	b.n	3400755e <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x2e>
    return HAL_ERROR;
34007576:	2001      	movs	r0, #1
34007578:	e7f2      	b.n	34007560 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x30>
3400757a:	bf00      	nop
3400757c:	3401fd64 	.word	0x3401fd64

34007580 <HAL_DCMIPP_PIPE_CSI_EnableShare>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007580:	2902      	cmp	r1, #2
{
34007582:	b508      	push	{r3, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007584:	d906      	bls.n	34007594 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x14>
34007586:	f641 217d 	movw	r1, #6781	@ 0x1a7d
3400758a:	480a      	ldr	r0, [pc, #40]	@ (340075b4 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x34>)
3400758c:	f7fb fb40 	bl	34002c10 <assert_failed>
      return HAL_ERROR;
34007590:	2001      	movs	r0, #1
}
34007592:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE2)
34007594:	d1fc      	bne.n	34007590 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x10>
    tmp1 = hdcmipp->Instance->P2FSCR;
34007596:	6803      	ldr	r3, [r0, #0]
34007598:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	@ 0xc04
    tmp2 = hdcmipp->Instance->P1FSCR;
3400759c:	f8d3 1804 	ldr.w	r1, [r3, #2052]	@ 0x804
    if (((tmp1 & DCMIPP_P2FSCR_PIPEN) == DCMIPP_P2FSCR_PIPEN) || ((tmp2 & DCMIPP_P1FSCR_PIPEN) == DCMIPP_P1FSCR_PIPEN))
340075a0:	430a      	orrs	r2, r1
340075a2:	d4f5      	bmi.n	34007590 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x10>
      CLEAR_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
340075a4:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
  return HAL_OK;
340075a8:	2000      	movs	r0, #0
      CLEAR_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
340075aa:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
340075ae:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
  return HAL_OK;
340075b2:	e7ee      	b.n	34007592 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x12>
340075b4:	3401fd64 	.word	0x3401fd64

340075b8 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>:
{
340075b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
340075ba:	460e      	mov	r6, r1
340075bc:	4615      	mov	r5, r2
340075be:	461c      	mov	r4, r3
  if ((hdcmipp == NULL) || (pCounter == NULL))
340075c0:	4607      	mov	r7, r0
340075c2:	b908      	cbnz	r0, 340075c8 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x10>
    return HAL_ERROR;
340075c4:	2001      	movs	r0, #1
}
340075c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hdcmipp == NULL) || (pCounter == NULL))
340075c8:	2b00      	cmp	r3, #0
340075ca:	d0fb      	beq.n	340075c4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xc>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340075cc:	2902      	cmp	r1, #2
340075ce:	d904      	bls.n	340075da <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x22>
340075d0:	f44f 51e0 	mov.w	r1, #7168	@ 0x1c00
340075d4:	4810      	ldr	r0, [pc, #64]	@ (34007618 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x60>)
340075d6:	f7fb fb1b 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
340075da:	1e6b      	subs	r3, r5, #1
340075dc:	2b02      	cmp	r3, #2
340075de:	d908      	bls.n	340075f2 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x3a>
340075e0:	f641 4101 	movw	r1, #7169	@ 0x1c01
340075e4:	480c      	ldr	r0, [pc, #48]	@ (34007618 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x60>)
340075e6:	f7fb fb13 	bl	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
340075ea:	2e01      	cmp	r6, #1
340075ec:	d1ea      	bne.n	340075c4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xc>
  return HAL_OK;
340075ee:	2000      	movs	r0, #0
340075f0:	e7e9      	b.n	340075c6 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xe>
  if (Pipe == DCMIPP_PIPE1)
340075f2:	2e01      	cmp	r6, #1
340075f4:	d1e6      	bne.n	340075c4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xc>
    switch (ModuleID)
340075f6:	2d02      	cmp	r5, #2
340075f8:	683b      	ldr	r3, [r7, #0]
340075fa:	d007      	beq.n	3400760c <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x54>
340075fc:	2d03      	cmp	r5, #3
340075fe:	d008      	beq.n	34007612 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x5a>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST1SR & DCMIPP_P1ST1SR_ACCU));
34007600:	f8d3 3864 	ldr.w	r3, [r3, #2148]	@ 0x864
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST2SR & DCMIPP_P1ST2SR_ACCU));
34007604:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34007608:	6023      	str	r3, [r4, #0]
        break;
3400760a:	e7f0      	b.n	340075ee <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x36>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST2SR & DCMIPP_P1ST2SR_ACCU));
3400760c:	f8d3 3868 	ldr.w	r3, [r3, #2152]	@ 0x868
34007610:	e7f8      	b.n	34007604 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x4c>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST3SR & DCMIPP_P1ST3SR_ACCU));
34007612:	f8d3 386c 	ldr.w	r3, [r3, #2156]	@ 0x86c
34007616:	e7f5      	b.n	34007604 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x4c>
34007618:	3401fd64 	.word	0x3401fd64

3400761c <HAL_DCMIPP_PIPE_GetISPExposureConfig>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400761c:	2902      	cmp	r1, #2
3400761e:	d904      	bls.n	3400762a <HAL_DCMIPP_PIPE_GetISPExposureConfig+0xe>
34007620:	f641 41e6 	movw	r1, #7398	@ 0x1ce6
34007624:	480c      	ldr	r0, [pc, #48]	@ (34007658 <HAL_DCMIPP_PIPE_GetISPExposureConfig+0x3c>)
34007626:	f7fb baf3 	b.w	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
3400762a:	2901      	cmp	r1, #1
3400762c:	d113      	bne.n	34007656 <HAL_DCMIPP_PIPE_GetISPExposureConfig+0x3a>
    tmp = READ_REG(hdcmipp->Instance->P1EXCR2);
3400762e:	6801      	ldr	r1, [r0, #0]
34007630:	f8d1 3848 	ldr.w	r3, [r1, #2120]	@ 0x848
    pExposureConfig->MultiplierBlue  = (uint8_t)((tmp & DCMIPP_P1EXCR2_MULTB) >> DCMIPP_P1EXCR2_MULTB_Pos);
34007634:	0918      	lsrs	r0, r3, #4
34007636:	7150      	strb	r0, [r2, #5]
    pExposureConfig->ShiftBlue       = (uint8_t)((tmp & DCMIPP_P1EXCR2_SHFB) >> DCMIPP_P1EXCR2_SHFB_Pos);
34007638:	f3c3 3002 	ubfx	r0, r3, #12, #3
3400763c:	7110      	strb	r0, [r2, #4]
    pExposureConfig->ShiftGreen      = (uint8_t)((tmp & DCMIPP_P1EXCR2_SHFG) >> DCMIPP_P1EXCR2_SHFG_Pos);
3400763e:	f3c3 7002 	ubfx	r0, r3, #28, #3
    pExposureConfig->MultiplierGreen = (uint8_t)((tmp & DCMIPP_P1EXCR2_MULTG) >> DCMIPP_P1EXCR2_MULTG_Pos);
34007642:	0d1b      	lsrs	r3, r3, #20
    pExposureConfig->ShiftGreen      = (uint8_t)((tmp & DCMIPP_P1EXCR2_SHFG) >> DCMIPP_P1EXCR2_SHFG_Pos);
34007644:	7090      	strb	r0, [r2, #2]
    pExposureConfig->MultiplierGreen = (uint8_t)((tmp & DCMIPP_P1EXCR2_MULTG) >> DCMIPP_P1EXCR2_MULTG_Pos);
34007646:	70d3      	strb	r3, [r2, #3]
    tmp = READ_REG(hdcmipp->Instance->P1EXCR1);
34007648:	f8d1 3844 	ldr.w	r3, [r1, #2116]	@ 0x844
    pExposureConfig->MultiplierRed   = (uint8_t)((tmp & DCMIPP_P1EXCR1_MULTR) >> DCMIPP_P1EXCR1_MULTR_Pos);
3400764c:	0d19      	lsrs	r1, r3, #20
    pExposureConfig->ShiftRed        = (uint8_t)((tmp & DCMIPP_P1EXCR1_SHFR) >> DCMIPP_P1EXCR1_SHFR_Pos);
3400764e:	f3c3 7302 	ubfx	r3, r3, #28, #3
    pExposureConfig->MultiplierRed   = (uint8_t)((tmp & DCMIPP_P1EXCR1_MULTR) >> DCMIPP_P1EXCR1_MULTR_Pos);
34007652:	7051      	strb	r1, [r2, #1]
    pExposureConfig->ShiftRed        = (uint8_t)((tmp & DCMIPP_P1EXCR1_SHFR) >> DCMIPP_P1EXCR1_SHFR_Pos);
34007654:	7013      	strb	r3, [r2, #0]
}
34007656:	4770      	bx	lr
34007658:	3401fd64 	.word	0x3401fd64

3400765c <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400765c:	2902      	cmp	r1, #2
{
3400765e:	b470      	push	{r4, r5, r6}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007660:	d905      	bls.n	3400766e <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x12>
}
34007662:	bc70      	pop	{r4, r5, r6}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007664:	f641 511f 	movw	r1, #7455	@ 0x1d1f
34007668:	484a      	ldr	r0, [pc, #296]	@ (34007794 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x138>)
3400766a:	f7fb bad1 	b.w	34002c10 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
3400766e:	2901      	cmp	r1, #1
34007670:	f040 808d 	bne.w	3400778e <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x132>
    tmp = (uint16_t)READ_REG(hdcmipp->Instance->P1CCCR);
34007674:	6803      	ldr	r3, [r0, #0]
34007676:	f8d3 1880 	ldr.w	r1, [r3, #2176]	@ 0x880
                                                 ? ENABLE : DISABLE;
3400767a:	f3c1 0080 	ubfx	r0, r1, #2, #1
    pColorConversionConfig->OutputSamplesType  = (uint8_t)(tmp & DCMIPP_P1CCCR_TYPE);
3400767e:	f001 0102 	and.w	r1, r1, #2
    pColorConversionConfig->ClampOutputSamples = (((tmp & DCMIPP_P1CCCR_CLAMP) >> DCMIPP_P1YUVCR_CLAMP_Pos) != 0U)
34007682:	7010      	strb	r0, [r2, #0]
    pColorConversionConfig->OutputSamplesType  = (uint8_t)(tmp & DCMIPP_P1CCCR_TYPE);
34007684:	7051      	strb	r1, [r2, #1]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RG) >> DCMIPP_P1CCRR1_RG_Pos);
34007686:	f8d3 4884 	ldr.w	r4, [r3, #2180]	@ 0x884
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
3400768a:	4943      	ldr	r1, [pc, #268]	@ (34007798 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x13c>)
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RG) >> DCMIPP_P1CCRR1_RG_Pos);
3400768c:	f3c4 400a 	ubfx	r0, r4, #16, #11
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
34007690:	ea40 0501 	orr.w	r5, r0, r1
34007694:	f014 6f80 	tst.w	r4, #67108864	@ 0x4000000
34007698:	bf18      	it	ne
3400769a:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR) >> DCMIPP_P1CCRR1_RR_Pos);
3400769c:	f8d3 4884 	ldr.w	r4, [r3, #2180]	@ 0x884
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
340076a0:	8090      	strh	r0, [r2, #4]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR) >> DCMIPP_P1CCRR1_RR_Pos);
340076a2:	f3c4 000a 	ubfx	r0, r4, #0, #11
    pColorConversionConfig->RR = (int16_t)GET_MATRIX_VALUE11(tmp);
340076a6:	ea40 0501 	orr.w	r5, r0, r1
340076aa:	f414 6f80 	tst.w	r4, #1024	@ 0x400
340076ae:	bf18      	it	ne
340076b0:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RA) >> DCMIPP_P1CCRR2_RA_Pos);
340076b2:	f8d3 5888 	ldr.w	r5, [r3, #2184]	@ 0x888
    pColorConversionConfig->RR = (int16_t)GET_MATRIX_VALUE11(tmp);
340076b6:	8050      	strh	r0, [r2, #2]
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
340076b8:	4838      	ldr	r0, [pc, #224]	@ (3400779c <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x140>)
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RA) >> DCMIPP_P1CCRR2_RA_Pos);
340076ba:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
340076be:	ea44 0600 	orr.w	r6, r4, r0
340076c2:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
340076c6:	bf18      	it	ne
340076c8:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB) >> DCMIPP_P1CCRR2_RB_Pos);
340076ca:	f8d3 5888 	ldr.w	r5, [r3, #2184]	@ 0x888
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
340076ce:	8114      	strh	r4, [r2, #8]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB) >> DCMIPP_P1CCRR2_RB_Pos);
340076d0:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->RB = (int16_t)GET_MATRIX_VALUE11(tmp);
340076d4:	ea44 0601 	orr.w	r6, r4, r1
340076d8:	f415 6f80 	tst.w	r5, #1024	@ 0x400
340076dc:	bf18      	it	ne
340076de:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GG) >> DCMIPP_P1CCGR1_GG_Pos);
340076e0:	f8d3 588c 	ldr.w	r5, [r3, #2188]	@ 0x88c
    pColorConversionConfig->RB = (int16_t)GET_MATRIX_VALUE11(tmp);
340076e4:	80d4      	strh	r4, [r2, #6]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GG) >> DCMIPP_P1CCGR1_GG_Pos);
340076e6:	f3c5 440a 	ubfx	r4, r5, #16, #11
    pColorConversionConfig->GG = (int16_t)GET_MATRIX_VALUE11(tmp);
340076ea:	ea44 0601 	orr.w	r6, r4, r1
340076ee:	f015 6f80 	tst.w	r5, #67108864	@ 0x4000000
340076f2:	bf18      	it	ne
340076f4:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR) >> DCMIPP_P1CCGR1_GR_Pos);
340076f6:	f8d3 588c 	ldr.w	r5, [r3, #2188]	@ 0x88c
    pColorConversionConfig->GG = (int16_t)GET_MATRIX_VALUE11(tmp);
340076fa:	8194      	strh	r4, [r2, #12]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR) >> DCMIPP_P1CCGR1_GR_Pos);
340076fc:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->GR = (int16_t)GET_MATRIX_VALUE11(tmp);
34007700:	ea44 0601 	orr.w	r6, r4, r1
34007704:	f415 6f80 	tst.w	r5, #1024	@ 0x400
34007708:	bf18      	it	ne
3400770a:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GA) >> DCMIPP_P1CCGR2_GA_Pos);
3400770c:	f8d3 5890 	ldr.w	r5, [r3, #2192]	@ 0x890
    pColorConversionConfig->GR = (int16_t)GET_MATRIX_VALUE11(tmp);
34007710:	8154      	strh	r4, [r2, #10]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GA) >> DCMIPP_P1CCGR2_GA_Pos);
34007712:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->GA = (int16_t)GET_MATRIX_VALUE10(tmp);
34007716:	ea44 0600 	orr.w	r6, r4, r0
3400771a:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
3400771e:	bf18      	it	ne
34007720:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB) >> DCMIPP_P1CCGR2_GB_Pos);
34007722:	f8d3 5890 	ldr.w	r5, [r3, #2192]	@ 0x890
    pColorConversionConfig->GA = (int16_t)GET_MATRIX_VALUE10(tmp);
34007726:	8214      	strh	r4, [r2, #16]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB) >> DCMIPP_P1CCGR2_GB_Pos);
34007728:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->GB = (int16_t)GET_MATRIX_VALUE11(tmp);
3400772c:	ea44 0601 	orr.w	r6, r4, r1
34007730:	f415 6f80 	tst.w	r5, #1024	@ 0x400
34007734:	bf18      	it	ne
34007736:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BA) >> DCMIPP_P1CCBR2_BA_Pos);
34007738:	f8d3 5898 	ldr.w	r5, [r3, #2200]	@ 0x898
    pColorConversionConfig->GB = (int16_t)GET_MATRIX_VALUE11(tmp);
3400773c:	81d4      	strh	r4, [r2, #14]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BA) >> DCMIPP_P1CCBR2_BA_Pos);
3400773e:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->BA = (int16_t)GET_MATRIX_VALUE10(tmp);
34007742:	4320      	orrs	r0, r4
34007744:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
34007748:	bf18      	it	ne
3400774a:	4604      	movne	r4, r0
3400774c:	8314      	strh	r4, [r2, #24]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB) >> DCMIPP_P1CCBR2_BB_Pos);
3400774e:	f8d3 4898 	ldr.w	r4, [r3, #2200]	@ 0x898
34007752:	f3c4 000a 	ubfx	r0, r4, #0, #11
    pColorConversionConfig->BB = (int16_t)GET_MATRIX_VALUE11(tmp);
34007756:	ea40 0501 	orr.w	r5, r0, r1
3400775a:	f414 6f80 	tst.w	r4, #1024	@ 0x400
3400775e:	bf18      	it	ne
34007760:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BG) >> DCMIPP_P1CCBR1_BG_Pos);
34007762:	f8d3 4894 	ldr.w	r4, [r3, #2196]	@ 0x894
    pColorConversionConfig->BB = (int16_t)GET_MATRIX_VALUE11(tmp);
34007766:	82d0      	strh	r0, [r2, #22]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BG) >> DCMIPP_P1CCBR1_BG_Pos);
34007768:	f3c4 400a 	ubfx	r0, r4, #16, #11
    pColorConversionConfig->BG = (int16_t)GET_MATRIX_VALUE11(tmp);
3400776c:	ea40 0501 	orr.w	r5, r0, r1
34007770:	f014 6f80 	tst.w	r4, #67108864	@ 0x4000000
34007774:	bf18      	it	ne
34007776:	4628      	movne	r0, r5
34007778:	8290      	strh	r0, [r2, #20]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR) >> DCMIPP_P1CCBR1_BR_Pos);
3400777a:	f8d3 0894 	ldr.w	r0, [r3, #2196]	@ 0x894
3400777e:	f3c0 030a 	ubfx	r3, r0, #0, #11
    pColorConversionConfig->BR = (int16_t)GET_MATRIX_VALUE11(tmp);
34007782:	4319      	orrs	r1, r3
34007784:	f410 6f80 	tst.w	r0, #1024	@ 0x400
34007788:	bf18      	it	ne
3400778a:	460b      	movne	r3, r1
3400778c:	8253      	strh	r3, [r2, #18]
}
3400778e:	bc70      	pop	{r4, r5, r6}
34007790:	4770      	bx	lr
34007792:	bf00      	nop
34007794:	3401fd64 	.word	0x3401fd64
34007798:	fffff800 	.word	0xfffff800
3400779c:	fffffc00 	.word	0xfffffc00

340077a0 <HAL_DCMIPP_PIPE_IsEnabledISPExposure>:
{
340077a0:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340077a2:	4a10      	ldr	r2, [pc, #64]	@ (340077e4 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x44>)
340077a4:	6803      	ldr	r3, [r0, #0]
{
340077a6:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340077a8:	4293      	cmp	r3, r2
{
340077aa:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340077ac:	d008      	beq.n	340077c0 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x20>
340077ae:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340077b2:	4293      	cmp	r3, r2
340077b4:	d004      	beq.n	340077c0 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x20>
340077b6:	f641 519b 	movw	r1, #7579	@ 0x1d9b
340077ba:	480b      	ldr	r0, [pc, #44]	@ (340077e8 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x48>)
340077bc:	f7fb fa28 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340077c0:	2d02      	cmp	r5, #2
340077c2:	d906      	bls.n	340077d2 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x32>
340077c4:	f641 519c 	movw	r1, #7580	@ 0x1d9c
340077c8:	4807      	ldr	r0, [pc, #28]	@ (340077e8 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x48>)
340077ca:	f7fb fa21 	bl	34002c10 <assert_failed>
    return 0;
340077ce:	2000      	movs	r0, #0
}
340077d0:	bd38      	pop	{r3, r4, r5, pc}
  if (Pipe == DCMIPP_PIPE1)
340077d2:	2d01      	cmp	r5, #1
340077d4:	d1fb      	bne.n	340077ce <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x2e>
    return ((READ_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE) == DCMIPP_P1EXCR1_ENABLE) ? 1U : 0U);
340077d6:	6823      	ldr	r3, [r4, #0]
340077d8:	f8d3 0844 	ldr.w	r0, [r3, #2116]	@ 0x844
340077dc:	f000 0001 	and.w	r0, r0, #1
340077e0:	e7f6      	b.n	340077d0 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x30>
340077e2:	bf00      	nop
340077e4:	58002000 	.word	0x58002000
340077e8:	3401fd64 	.word	0x3401fd64

340077ec <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>:
{
340077ec:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340077ee:	4a10      	ldr	r2, [pc, #64]	@ (34007830 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x44>)
340077f0:	6803      	ldr	r3, [r0, #0]
{
340077f2:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340077f4:	4293      	cmp	r3, r2
{
340077f6:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340077f8:	d008      	beq.n	3400780c <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x20>
340077fa:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340077fe:	4293      	cmp	r3, r2
34007800:	d004      	beq.n	3400780c <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x20>
34007802:	f641 51c7 	movw	r1, #7623	@ 0x1dc7
34007806:	480b      	ldr	r0, [pc, #44]	@ (34007834 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x48>)
34007808:	f7fb fa02 	bl	34002c10 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400780c:	2d02      	cmp	r5, #2
3400780e:	d906      	bls.n	3400781e <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x32>
34007810:	f641 51c8 	movw	r1, #7624	@ 0x1dc8
34007814:	4807      	ldr	r0, [pc, #28]	@ (34007834 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x48>)
34007816:	f7fb f9fb 	bl	34002c10 <assert_failed>
    return 0;
3400781a:	2000      	movs	r0, #0
}
3400781c:	bd38      	pop	{r3, r4, r5, pc}
  if (Pipe == DCMIPP_PIPE1)
3400781e:	2d01      	cmp	r5, #1
34007820:	d1fb      	bne.n	3400781a <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x2e>
    return ((READ_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE) == DCMIPP_P1CCCR_ENABLE) ? 1U : 0U);
34007822:	6823      	ldr	r3, [r4, #0]
34007824:	f8d3 0880 	ldr.w	r0, [r3, #2176]	@ 0x880
34007828:	f000 0001 	and.w	r0, r0, #1
3400782c:	e7f6      	b.n	3400781c <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x30>
3400782e:	bf00      	nop
34007830:	58002000 	.word	0x58002000
34007834:	3401fd64 	.word	0x3401fd64

34007838 <HAL_DCMIPP_GetState>:
  return hdcmipp->State;
34007838:	7900      	ldrb	r0, [r0, #4]
}
3400783a:	4770      	bx	lr

3400783c <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
3400783c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
3400783e:	6804      	ldr	r4, [r0, #0]
34007840:	9d05      	ldr	r5, [sp, #20]
34007842:	6c66      	ldr	r6, [r4, #68]	@ 0x44
34007844:	ea45 4503 	orr.w	r5, r5, r3, lsl #16

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
34007848:	6843      	ldr	r3, [r0, #4]
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
3400784a:	f006 4640 	and.w	r6, r6, #32####MQTT_PASS####5472	@ 0xc0000000
3400784e:	4335      	orrs	r5, r6
  if (hdma2d->Init.Mode == DMA2D_R2M)
34007850:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
34007854:	6465      	str	r5, [r4, #68]	@ 0x44
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
34007856:	63e2      	str	r2, [r4, #60]	@ 0x3c
  if (hdma2d->Init.Mode == DMA2D_R2M)
34007858:	d12f      	bne.n	340078ba <DMA2D_SetConfig+0x7e>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
3400785a:	6880      	ldr	r0, [r0, #8]
3400785c:	f001 467f 	and.w	r6, r1, #4278190080	@ 0xff000000
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
34007860:	f401 037f 	and.w	r3, r1, #16711680	@ 0xff0000
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
34007864:	f401 427f 	and.w	r2, r1, #65280	@ 0xff00
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
34007868:	b2cd      	uxtb	r5, r1

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
3400786a:	2803      	cmp	r0, #3
3400786c:	d81a      	bhi.n	340078a4 <DMA2D_SetConfig+0x68>
3400786e:	e8df f000 	tbb	[pc, r0]
34007872:	0204      	.short	0x0204
34007874:	0e06      	.short	0x0e06
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
    {
      tmp = (tmp3 | tmp2 | tmp4);
34007876:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
      tmp3 = (tmp3 >> 12U);
      tmp4 = (tmp4 >> 4U);
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
3400787a:	63a1      	str	r1, [r4, #56]	@ 0x38
  else /* M2M, M2M_PFC,M2M_Blending or M2M_blending with fixed color BG DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
3400787c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      tmp2 = (tmp2 >> 19U);
3400787e:	0cd9      	lsrs	r1, r3, #19
      tmp3 = (tmp3 >> 10U);
34007880:	0a92      	lsrs	r2, r2, #10
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
34007882:	02c9      	lsls	r1, r1, #11
34007884:	ea41 1142 	orr.w	r1, r1, r2, lsl #5
34007888:	ea41 01d5 	orr.w	r1, r1, r5, lsr #3
3400788c:	e7f5      	b.n	3400787a <DMA2D_SetConfig+0x3e>
      tmp2 = (tmp2 >> 19U);
3400788e:	0cdb      	lsrs	r3, r3, #19
      tmp3 = (tmp3 >> 11U);
34007890:	0ad2      	lsrs	r2, r2, #11
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
34007892:	029b      	lsls	r3, r3, #10
34007894:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
34007898:	ea43 03d5 	orr.w	r3, r3, r5, lsr #3
      tmp1 = (tmp1 >> 31U);
3400789c:	0ff1      	lsrs	r1, r6, #31
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
3400789e:	ea43 31c1 	orr.w	r1, r3, r1, lsl #15
340078a2:	e7ea      	b.n	3400787a <DMA2D_SetConfig+0x3e>
      tmp2 = (tmp2 >> 20U);
340078a4:	0d1b      	lsrs	r3, r3, #20
      tmp3 = (tmp3 >> 12U);
340078a6:	0b12      	lsrs	r2, r2, #12
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
340078a8:	021b      	lsls	r3, r3, #8
340078aa:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
340078ae:	ea43 1315 	orr.w	r3, r3, r5, lsr #4
      tmp1 = (tmp1 >> 28U);
340078b2:	0f36      	lsrs	r6, r6, #28
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
340078b4:	ea43 3106 	orr.w	r1, r3, r6, lsl #12
340078b8:	e7df      	b.n	3400787a <DMA2D_SetConfig+0x3e>
  else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG) /*M2M_blending with fixed color FG DMA2D Mode selected*/
340078ba:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
    WRITE_REG(hdma2d->Instance->BGMAR, pdata);
340078be:	bf0c      	ite	eq
340078c0:	6161      	streq	r1, [r4, #20]
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
340078c2:	60e1      	strne	r1, [r4, #12]
}
340078c4:	e7da      	b.n	3400787c <DMA2D_SetConfig+0x40>

340078c6 <HAL_DMA2D_MspInit>:
}
340078c6:	4770      	bx	lr

340078c8 <HAL_DMA2D_Init>:
{
340078c8:	b510      	push	{r4, lr}
  if (hdma2d == NULL)
340078ca:	4604      	mov	r4, r0
340078cc:	2800      	cmp	r0, #0
340078ce:	d07d      	beq.n	340079cc <HAL_DMA2D_Init+0x104>
  assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
340078d0:	6803      	ldr	r3, [r0, #0]
340078d2:	4a3f      	ldr	r2, [pc, #252]	@ (340079d0 <HAL_DMA2D_Init+0x108>)
340078d4:	4293      	cmp	r3, r2
340078d6:	d007      	beq.n	340078e8 <HAL_DMA2D_Init+0x20>
340078d8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340078dc:	4293      	cmp	r3, r2
340078de:	d003      	beq.n	340078e8 <HAL_DMA2D_Init+0x20>
340078e0:	21f7      	movs	r1, #247	@ 0xf7
340078e2:	483c      	ldr	r0, [pc, #240]	@ (340079d4 <HAL_DMA2D_Init+0x10c>)
340078e4:	f7fb f994 	bl	34002c10 <assert_failed>
  assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
340078e8:	6863      	ldr	r3, [r4, #4]
340078ea:	f433 3240 	bics.w	r2, r3, #196608	@ 0x30000
340078ee:	d008      	beq.n	34007902 <HAL_DMA2D_Init+0x3a>
340078f0:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
340078f4:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
340078f8:	d003      	beq.n	34007902 <HAL_DMA2D_Init+0x3a>
340078fa:	21f8      	movs	r1, #248	@ 0xf8
340078fc:	4835      	ldr	r0, [pc, #212]	@ (340079d4 <HAL_DMA2D_Init+0x10c>)
340078fe:	f7fb f987 	bl	34002c10 <assert_failed>
  assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
34007902:	68a3      	ldr	r3, [r4, #8]
34007904:	2b04      	cmp	r3, #4
34007906:	d903      	bls.n	34007910 <HAL_DMA2D_Init+0x48>
34007908:	21f9      	movs	r1, #249	@ 0xf9
3400790a:	4832      	ldr	r0, [pc, #200]	@ (340079d4 <HAL_DMA2D_Init+0x10c>)
3400790c:	f7fb f980 	bl	34002c10 <assert_failed>
  assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));
34007910:	68e3      	ldr	r3, [r4, #12]
34007912:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34007916:	d303      	bcc.n	34007920 <HAL_DMA2D_Init+0x58>
34007918:	21fa      	movs	r1, #250	@ 0xfa
3400791a:	482e      	ldr	r0, [pc, #184]	@ (340079d4 <HAL_DMA2D_Init+0x10c>)
3400791c:	f7fb f978 	bl	34002c10 <assert_failed>
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->Init.AlphaInverted));
34007920:	6923      	ldr	r3, [r4, #16]
34007922:	2b01      	cmp	r3, #1
34007924:	d903      	bls.n	3400792e <HAL_DMA2D_Init+0x66>
34007926:	21fb      	movs	r1, #251	@ 0xfb
34007928:	482a      	ldr	r0, [pc, #168]	@ (340079d4 <HAL_DMA2D_Init+0x10c>)
3400792a:	f7fb f971 	bl	34002c10 <assert_failed>
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->Init.RedBlueSwap));
3400792e:	6963      	ldr	r3, [r4, #20]
34007930:	2b01      	cmp	r3, #1
34007932:	d903      	bls.n	3400793c <HAL_DMA2D_Init+0x74>
34007934:	21fc      	movs	r1, #252	@ 0xfc
34007936:	4827      	ldr	r0, [pc, #156]	@ (340079d4 <HAL_DMA2D_Init+0x10c>)
34007938:	f7fb f96a 	bl	34002c10 <assert_failed>
  assert_param(IS_DMA2D_LOM_MODE(hdma2d->Init.LineOffsetMode));
3400793c:	69e3      	ldr	r3, [r4, #28]
3400793e:	f033 0340 	bics.w	r3, r3, #64	@ 0x40
34007942:	d003      	beq.n	3400794c <HAL_DMA2D_Init+0x84>
34007944:	21fd      	movs	r1, #253	@ 0xfd
34007946:	4823      	ldr	r0, [pc, #140]	@ (340079d4 <HAL_DMA2D_Init+0x10c>)
34007948:	f7fb f962 	bl	34002c10 <assert_failed>
  assert_param(IS_DMA2D_BYTES_SWAP(hdma2d->Init.BytesSwap));
3400794c:	69a3      	ldr	r3, [r4, #24]
3400794e:	f433 7380 	bics.w	r3, r3, #256	@ 0x100
34007952:	d003      	beq.n	3400795c <HAL_DMA2D_Init+0x94>
34007954:	21fe      	movs	r1, #254	@ 0xfe
34007956:	481f      	ldr	r0, [pc, #124]	@ (340079d4 <HAL_DMA2D_Init+0x10c>)
34007958:	f7fb f95a 	bl	34002c10 <assert_failed>
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
3400795c:	f894 3061 	ldrb.w	r3, [r4, #97]	@ 0x61
34007960:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
34007964:	b923      	cbnz	r3, 34007970 <HAL_DMA2D_Init+0xa8>
    HAL_DMA2D_MspInit(hdma2d);
34007966:	4620      	mov	r0, r4
    hdma2d->Lock = HAL_UNLOCKED;
34007968:	f884 2060 	strb.w	r2, [r4, #96]	@ 0x60
    HAL_DMA2D_MspInit(hdma2d);
3400796c:	f7ff ffab 	bl	340078c6 <HAL_DMA2D_MspInit>
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34007970:	2302      	movs	r3, #2
34007972:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
34007976:	6823      	ldr	r3, [r4, #0]
34007978:	69e0      	ldr	r0, [r4, #28]
3400797a:	6819      	ldr	r1, [r3, #0]
3400797c:	6862      	ldr	r2, [r4, #4]
3400797e:	f421 21e0 	bic.w	r1, r1, #458752	@ 0x70000
34007982:	4302      	orrs	r2, r0
34007984:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
34007988:	430a      	orrs	r2, r1
3400798a:	601a      	str	r2, [r3, #0]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB,
3400798c:	6b59      	ldr	r1, [r3, #52]	@ 0x34
3400798e:	69a0      	ldr	r0, [r4, #24]
34007990:	68a2      	ldr	r2, [r4, #8]
34007992:	f421 7183 	bic.w	r1, r1, #262	@ 0x106
34007996:	4302      	orrs	r2, r0
34007998:	f021 0101 	bic.w	r1, r1, #1
3400799c:	430a      	orrs	r2, r1
3400799e:	635a      	str	r2, [r3, #52]	@ 0x34
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
340079a0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
340079a2:	68e1      	ldr	r1, [r4, #12]
340079a4:	f36f 020f 	bfc	r2, #0, #16
340079a8:	430a      	orrs	r2, r1
340079aa:	641a      	str	r2, [r3, #64]	@ 0x40
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
340079ac:	6b59      	ldr	r1, [r3, #52]	@ 0x34
340079ae:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
340079b2:	0552      	lsls	r2, r2, #21
340079b4:	ea42 5200 	orr.w	r2, r2, r0, lsl #20
340079b8:	f421 1140 	bic.w	r1, r1, #3145728	@ 0x300000
340079bc:	430a      	orrs	r2, r1
340079be:	635a      	str	r2, [r3, #52]	@ 0x34
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
340079c0:	2000      	movs	r0, #0
  hdma2d->State  = HAL_DMA2D_STATE_READY;
340079c2:	2301      	movs	r3, #1
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
340079c4:	6660      	str	r0, [r4, #100]	@ 0x64
  hdma2d->State  = HAL_DMA2D_STATE_READY;
340079c6:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
}
340079ca:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
340079cc:	2001      	movs	r0, #1
340079ce:	e7fc      	b.n	340079ca <HAL_DMA2D_Init+0x102>
340079d0:	58021000 	.word	0x58021000
340079d4:	3401fe2a 	.word	0x3401fe2a

340079d8 <HAL_DMA2D_Start>:
{
340079d8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
340079dc:	f8dd 8020 	ldr.w	r8, [sp, #32]
340079e0:	4604      	mov	r4, r0
  assert_param(IS_DMA2D_LINE(Height));
340079e2:	f5b8 3f80 	cmp.w	r8, #65536	@ 0x10000
{
340079e6:	460e      	mov	r6, r1
340079e8:	4617      	mov	r7, r2
340079ea:	461d      	mov	r5, r3
  assert_param(IS_DMA2D_LINE(Height));
340079ec:	d304      	bcc.n	340079f8 <HAL_DMA2D_Start+0x20>
340079ee:	f240 21a9 	movw	r1, #681	@ 0x2a9
340079f2:	4813      	ldr	r0, [pc, #76]	@ (34007a40 <HAL_DMA2D_Start+0x68>)
340079f4:	f7fb f90c 	bl	34002c10 <assert_failed>
  assert_param(IS_DMA2D_PIXEL(Width));
340079f8:	f5b5 4f80 	cmp.w	r5, #16384	@ 0x4000
340079fc:	d304      	bcc.n	34007a08 <HAL_DMA2D_Start+0x30>
340079fe:	f240 21aa 	movw	r1, #682	@ 0x2aa
34007a02:	480f      	ldr	r0, [pc, #60]	@ (34007a40 <HAL_DMA2D_Start+0x68>)
34007a04:	f7fb f904 	bl	34002c10 <assert_failed>
  __HAL_LOCK(hdma2d);
34007a08:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
34007a0c:	2002      	movs	r0, #2
34007a0e:	2b01      	cmp	r3, #1
34007a10:	d012      	beq.n	34007a38 <HAL_DMA2D_Start+0x60>
34007a12:	2301      	movs	r3, #1
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34007a14:	f884 0061 	strb.w	r0, [r4, #97]	@ 0x61
  __HAL_LOCK(hdma2d);
34007a18:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
34007a1c:	463a      	mov	r2, r7
34007a1e:	462b      	mov	r3, r5
34007a20:	4620      	mov	r0, r4
34007a22:	4631      	mov	r1, r6
34007a24:	f8cd 8000 	str.w	r8, [sp]
34007a28:	f7ff ff08 	bl	3400783c <DMA2D_SetConfig>
  return HAL_OK;
34007a2c:	2000      	movs	r0, #0
  __HAL_DMA2D_ENABLE(hdma2d);
34007a2e:	6822      	ldr	r2, [r4, #0]
34007a30:	6813      	ldr	r3, [r2, #0]
34007a32:	f043 0301 	orr.w	r3, r3, #1
34007a36:	6013      	str	r3, [r2, #0]
}
34007a38:	b002      	add	sp, #8
34007a3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34007a3e:	bf00      	nop
34007a40:	3401fe2a 	.word	0x3401fe2a

34007a44 <HAL_DMA2D_PollForTransfer>:
  __IO uint32_t isrflags = 0x0U;
34007a44:	2300      	movs	r3, #0
{
34007a46:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __IO uint32_t isrflags = 0x0U;
34007a48:	9301      	str	r3, [sp, #4]
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
34007a4a:	6803      	ldr	r3, [r0, #0]
{
34007a4c:	4604      	mov	r4, r0
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
34007a4e:	681b      	ldr	r3, [r3, #0]
{
34007a50:	460d      	mov	r5, r1
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
34007a52:	07db      	lsls	r3, r3, #31
34007a54:	d418      	bmi.n	34007a88 <HAL_DMA2D_PollForTransfer+0x44>
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
34007a56:	6822      	ldr	r2, [r4, #0]
34007a58:	69d3      	ldr	r3, [r2, #28]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
34007a5a:	6a52      	ldr	r2, [r2, #36]	@ 0x24
34007a5c:	4313      	orrs	r3, r2
  if (layer_start != 0U)
34007a5e:	069e      	lsls	r6, r3, #26
34007a60:	d506      	bpl.n	34007a70 <HAL_DMA2D_PollForTransfer+0x2c>
    tickstart = HAL_GetTick();
34007a62:	f7fd fa0b 	bl	34004e7c <HAL_GetTick>
34007a66:	4606      	mov	r6, r0
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
34007a68:	6823      	ldr	r3, [r4, #0]
34007a6a:	685a      	ldr	r2, [r3, #4]
34007a6c:	06d2      	lsls	r2, r2, #27
34007a6e:	d53f      	bpl.n	34007af0 <HAL_DMA2D_PollForTransfer+0xac>
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
34007a70:	2212      	movs	r2, #18
34007a72:	6823      	ldr	r3, [r4, #0]
  return HAL_OK;
34007a74:	2000      	movs	r0, #0
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
34007a76:	609a      	str	r2, [r3, #8]
  hdma2d->State = HAL_DMA2D_STATE_READY;
34007a78:	2301      	movs	r3, #1
34007a7a:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
        __HAL_UNLOCK(hdma2d);
34007a7e:	2300      	movs	r3, #0
34007a80:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
}
34007a84:	b002      	add	sp, #8
34007a86:	bd70      	pop	{r4, r5, r6, pc}
    tickstart = HAL_GetTick();
34007a88:	f7fd f9f8 	bl	34004e7c <HAL_GetTick>
34007a8c:	4606      	mov	r6, r0
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
34007a8e:	6823      	ldr	r3, [r4, #0]
34007a90:	685a      	ldr	r2, [r3, #4]
34007a92:	0792      	lsls	r2, r2, #30
34007a94:	d4df      	bmi.n	34007a56 <HAL_DMA2D_PollForTransfer+0x12>
      isrflags = READ_REG(hdma2d->Instance->ISR);
34007a96:	685a      	ldr	r2, [r3, #4]
34007a98:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34007a9a:	9a01      	ldr	r2, [sp, #4]
34007a9c:	f012 0f21 	tst.w	r2, #33	@ 0x21
34007aa0:	d014      	beq.n	34007acc <HAL_DMA2D_PollForTransfer+0x88>
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34007aa2:	9a01      	ldr	r2, [sp, #4]
34007aa4:	0695      	lsls	r5, r2, #26
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34007aa6:	bf42      	ittt	mi
34007aa8:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007aaa:	f042 0202 	orrmi.w	r2, r2, #2
34007aae:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34007ab0:	9a01      	ldr	r2, [sp, #4]
34007ab2:	07d0      	lsls	r0, r2, #31
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34007ab4:	bf42      	ittt	mi
34007ab6:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007ab8:	f042 0201 	orrmi.w	r2, r2, #1
34007abc:	6662      	strmi	r2, [r4, #100]	@ 0x64
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34007abe:	2221      	movs	r2, #33	@ 0x21
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34007ac0:	609a      	str	r2, [r3, #8]
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34007ac2:	2304      	movs	r3, #4
        return HAL_ERROR;
34007ac4:	2001      	movs	r0, #1
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34007ac6:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
        return HAL_ERROR;
34007aca:	e7d8      	b.n	34007a7e <HAL_DMA2D_PollForTransfer+0x3a>
      if (Timeout != HAL_MAX_DELAY)
34007acc:	1c69      	adds	r1, r5, #1
34007ace:	d0df      	beq.n	34007a90 <HAL_DMA2D_PollForTransfer+0x4c>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34007ad0:	f7fd f9d4 	bl	34004e7c <HAL_GetTick>
34007ad4:	1b80      	subs	r0, r0, r6
34007ad6:	42a8      	cmp	r0, r5
34007ad8:	d801      	bhi.n	34007ade <HAL_DMA2D_PollForTransfer+0x9a>
34007ada:	2d00      	cmp	r5, #0
34007adc:	d1d7      	bne.n	34007a8e <HAL_DMA2D_PollForTransfer+0x4a>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
34007ade:	6e63      	ldr	r3, [r4, #100]	@ 0x64
          return HAL_TIMEOUT;
34007ae0:	2003      	movs	r0, #3
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
34007ae2:	f043 0320 	orr.w	r3, r3, #32
34007ae6:	6663      	str	r3, [r4, #100]	@ 0x64
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
34007ae8:	2303      	movs	r3, #3
34007aea:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
          return HAL_TIMEOUT;
34007aee:	e7c6      	b.n	34007a7e <HAL_DMA2D_PollForTransfer+0x3a>
      isrflags = READ_REG(hdma2d->Instance->ISR);
34007af0:	685a      	ldr	r2, [r3, #4]
34007af2:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34007af4:	9a01      	ldr	r2, [sp, #4]
34007af6:	f012 0f29 	tst.w	r2, #41	@ 0x29
34007afa:	d016      	beq.n	34007b2a <HAL_DMA2D_PollForTransfer+0xe6>
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
34007afc:	9a01      	ldr	r2, [sp, #4]
34007afe:	0716      	lsls	r6, r2, #28
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
34007b00:	bf42      	ittt	mi
34007b02:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007b04:	f042 0204 	orrmi.w	r2, r2, #4
34007b08:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34007b0a:	9a01      	ldr	r2, [sp, #4]
34007b0c:	0695      	lsls	r5, r2, #26
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34007b0e:	bf42      	ittt	mi
34007b10:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007b12:	f042 0202 	orrmi.w	r2, r2, #2
34007b16:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34007b18:	9a01      	ldr	r2, [sp, #4]
34007b1a:	07d0      	lsls	r0, r2, #31
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34007b1c:	bf42      	ittt	mi
34007b1e:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007b20:	f042 0201 	orrmi.w	r2, r2, #1
34007b24:	6662      	strmi	r2, [r4, #100]	@ 0x64
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34007b26:	2229      	movs	r2, #41	@ 0x29
34007b28:	e7ca      	b.n	34007ac0 <HAL_DMA2D_PollForTransfer+0x7c>
      if (Timeout != HAL_MAX_DELAY)
34007b2a:	1c69      	adds	r1, r5, #1
34007b2c:	d09d      	beq.n	34007a6a <HAL_DMA2D_PollForTransfer+0x26>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34007b2e:	f7fd f9a5 	bl	34004e7c <HAL_GetTick>
34007b32:	1b80      	subs	r0, r0, r6
34007b34:	42a8      	cmp	r0, r5
34007b36:	d8d2      	bhi.n	34007ade <HAL_DMA2D_PollForTransfer+0x9a>
34007b38:	2d00      	cmp	r5, #0
34007b3a:	d195      	bne.n	34007a68 <HAL_DMA2D_PollForTransfer+0x24>
34007b3c:	e7cf      	b.n	34007ade <HAL_DMA2D_PollForTransfer+0x9a>
	...

34007b40 <HAL_DMA2D_ConfigLayer>:
  assert_param(IS_DMA2D_LAYER(LayerIdx));
34007b40:	2901      	cmp	r1, #1
{
34007b42:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34007b44:	4604      	mov	r4, r0
34007b46:	460d      	mov	r5, r1
  assert_param(IS_DMA2D_LAYER(LayerIdx));
34007b48:	d904      	bls.n	34007b54 <HAL_DMA2D_ConfigLayer+0x14>
34007b4a:	f240 61f3 	movw	r1, #1779	@ 0x6f3
34007b4e:	4850      	ldr	r0, [pc, #320]	@ (34007c90 <HAL_DMA2D_ConfigLayer+0x150>)
34007b50:	f7fb f85e 	bl	34002c10 <assert_failed>
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
34007b54:	231c      	movs	r3, #28
34007b56:	fb03 4305 	mla	r3, r3, r5, r4
34007b5a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34007b5c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34007b60:	d304      	bcc.n	34007b6c <HAL_DMA2D_ConfigLayer+0x2c>
34007b62:	f240 61f4 	movw	r1, #1780	@ 0x6f4
34007b66:	484a      	ldr	r0, [pc, #296]	@ (34007c90 <HAL_DMA2D_ConfigLayer+0x150>)
34007b68:	f7fb f852 	bl	34002c10 <assert_failed>
  if (hdma2d->Init.Mode != DMA2D_R2M)
34007b6c:	6863      	ldr	r3, [r4, #4]
34007b6e:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34007b72:	d017      	beq.n	34007ba4 <HAL_DMA2D_ConfigLayer+0x64>
    assert_param(IS_DMA2D_INPUT_COLOR_MODE(hdma2d->LayerCfg[LayerIdx].InputColorMode));
34007b74:	231c      	movs	r3, #28
34007b76:	fb03 4305 	mla	r3, r3, r5, r4
34007b7a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34007b7c:	2b0b      	cmp	r3, #11
34007b7e:	d904      	bls.n	34007b8a <HAL_DMA2D_ConfigLayer+0x4a>
34007b80:	f240 61f7 	movw	r1, #1783	@ 0x6f7
34007b84:	4842      	ldr	r0, [pc, #264]	@ (34007c90 <HAL_DMA2D_ConfigLayer+0x150>)
34007b86:	f7fb f843 	bl	34002c10 <assert_failed>
    if (hdma2d->Init.Mode != DMA2D_M2M)
34007b8a:	6863      	ldr	r3, [r4, #4]
34007b8c:	b153      	cbz	r3, 34007ba4 <HAL_DMA2D_ConfigLayer+0x64>
      assert_param(IS_DMA2D_ALPHA_MODE(hdma2d->LayerCfg[LayerIdx].AlphaMode));
34007b8e:	231c      	movs	r3, #28
34007b90:	fb03 4305 	mla	r3, r3, r5, r4
34007b94:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34007b96:	2b02      	cmp	r3, #2
34007b98:	d904      	bls.n	34007ba4 <HAL_DMA2D_ConfigLayer+0x64>
34007b9a:	f240 61fa 	movw	r1, #1786	@ 0x6fa
34007b9e:	483c      	ldr	r0, [pc, #240]	@ (34007c90 <HAL_DMA2D_ConfigLayer+0x150>)
34007ba0:	f7fb f836 	bl	34002c10 <assert_failed>
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
34007ba4:	261c      	movs	r6, #28
34007ba6:	fb06 4305 	mla	r3, r6, r5, r4
34007baa:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34007bac:	2b01      	cmp	r3, #1
34007bae:	d904      	bls.n	34007bba <HAL_DMA2D_ConfigLayer+0x7a>
34007bb0:	f240 61fd 	movw	r1, #1789	@ 0x6fd
34007bb4:	4836      	ldr	r0, [pc, #216]	@ (34007c90 <HAL_DMA2D_ConfigLayer+0x150>)
34007bb6:	f7fb f82b 	bl	34002c10 <assert_failed>
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));
34007bba:	fb06 4605 	mla	r6, r6, r5, r4
34007bbe:	6bf3      	ldr	r3, [r6, #60]	@ 0x3c
34007bc0:	2b01      	cmp	r3, #1
34007bc2:	d904      	bls.n	34007bce <HAL_DMA2D_ConfigLayer+0x8e>
34007bc4:	f240 61fe 	movw	r1, #1790	@ 0x6fe
34007bc8:	4831      	ldr	r0, [pc, #196]	@ (34007c90 <HAL_DMA2D_ConfigLayer+0x150>)
34007bca:	f7fb f821 	bl	34002c10 <assert_failed>
  if ((LayerIdx == DMA2D_FOREGROUND_LAYER) && (hdma2d->LayerCfg[LayerIdx].InputColorMode == DMA2D_INPUT_YCBCR))
34007bce:	2d01      	cmp	r5, #1
34007bd0:	d10a      	bne.n	34007be8 <HAL_DMA2D_ConfigLayer+0xa8>
34007bd2:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
34007bd4:	2b0b      	cmp	r3, #11
34007bd6:	d107      	bne.n	34007be8 <HAL_DMA2D_ConfigLayer+0xa8>
    assert_param(IS_DMA2D_CHROMA_SUB_SAMPLING(hdma2d->LayerCfg[LayerIdx].ChromaSubSampling));
34007bd8:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
34007bda:	2b02      	cmp	r3, #2
34007bdc:	d904      	bls.n	34007be8 <HAL_DMA2D_ConfigLayer+0xa8>
34007bde:	f240 7102 	movw	r1, #1794	@ 0x702
34007be2:	482b      	ldr	r0, [pc, #172]	@ (34007c90 <HAL_DMA2D_ConfigLayer+0x150>)
34007be4:	f7fb f814 	bl	34002c10 <assert_failed>
  __HAL_LOCK(hdma2d);
34007be8:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
34007bec:	2002      	movs	r0, #2
34007bee:	2b01      	cmp	r3, #1
34007bf0:	d033      	beq.n	34007c5a <HAL_DMA2D_ConfigLayer+0x11a>
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007bf2:	211c      	movs	r1, #28
  __HAL_LOCK(hdma2d);
34007bf4:	2301      	movs	r3, #1
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007bf6:	fb01 4105 	mla	r1, r1, r5, r4
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34007bfa:	f884 0061 	strb.w	r0, [r4, #97]	@ 0x61
  __HAL_LOCK(hdma2d);
34007bfe:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34007c02:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007c04:	e9d1 620b 	ldrd	r6, r2, [r1, #44]	@ 0x2c
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34007c08:	051b      	lsls	r3, r3, #20
34007c0a:	6b4f      	ldr	r7, [r1, #52]	@ 0x34
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007c0c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34007c10:	6bca      	ldr	r2, [r1, #60]	@ 0x3c
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007c12:	4333      	orrs	r3, r6
34007c14:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34007c18:	f1a6 0009 	sub.w	r0, r6, #9
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
34007c1c:	f007 427f 	and.w	r2, r7, #4278190080	@ 0xff000000
34007c20:	431a      	orrs	r2, r3
34007c22:	2801      	cmp	r0, #1
34007c24:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
34007c28:	bf98      	it	ls
34007c2a:	4613      	movls	r3, r2
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
34007c2c:	6822      	ldr	r2, [r4, #0]
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
34007c2e:	b9ad      	cbnz	r5, 34007c5c <HAL_DMA2D_ConfigLayer+0x11c>
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
34007c30:	6a55      	ldr	r5, [r2, #36]	@ 0x24
34007c32:	4918      	ldr	r1, [pc, #96]	@ (34007c94 <HAL_DMA2D_ConfigLayer+0x154>)
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34007c34:	2801      	cmp	r0, #1
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
34007c36:	ea01 0105 	and.w	r1, r1, r5
34007c3a:	ea41 0103 	orr.w	r1, r1, r3
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
34007c3e:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
34007c40:	6251      	str	r1, [r2, #36]	@ 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
34007c42:	6193      	str	r3, [r2, #24]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34007c44:	d803      	bhi.n	34007c4e <HAL_DMA2D_ConfigLayer+0x10e>
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
34007c46:	6b63      	ldr	r3, [r4, #52]	@ 0x34
34007c48:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34007c4c:	6293      	str	r3, [r2, #40]	@ 0x28
  hdma2d->State = HAL_DMA2D_STATE_READY;
34007c4e:	2301      	movs	r3, #1
  __HAL_UNLOCK(hdma2d);
34007c50:	2000      	movs	r0, #0
  hdma2d->State = HAL_DMA2D_STATE_READY;
34007c52:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
  __HAL_UNLOCK(hdma2d);
34007c56:	f884 0060 	strb.w	r0, [r4, #96]	@ 0x60
}
34007c5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (pLayerCfg->InputColorMode == DMA2D_INPUT_YCBCR)
34007c5c:	2e0b      	cmp	r6, #11
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
34007c5e:	bf03      	ittte	eq
34007c60:	6c09      	ldreq	r1, [r1, #64]	@ 0x40
      regMask  |= DMA2D_FGPFCCR_CSS;
34007c62:	4e0d      	ldreq	r6, [pc, #52]	@ (34007c98 <HAL_DMA2D_ConfigLayer+0x158>)
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
34007c64:	ea43 4381 	orreq.w	r3, r3, r1, lsl #18
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
34007c68:	4e0c      	ldrne	r6, [pc, #48]	@ (34007c9c <HAL_DMA2D_ConfigLayer+0x15c>)
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
34007c6a:	69d1      	ldr	r1, [r2, #28]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34007c6c:	2801      	cmp	r0, #1
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
34007c6e:	ea21 0106 	bic.w	r1, r1, r6
34007c72:	ea43 0301 	orr.w	r3, r3, r1
34007c76:	61d3      	str	r3, [r2, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
34007c78:	f04f 031c 	mov.w	r3, #28
34007c7c:	fb03 4505 	mla	r5, r3, r5, r4
34007c80:	6aab      	ldr	r3, [r5, #40]	@ 0x28
34007c82:	6113      	str	r3, [r2, #16]
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
34007c84:	bf9e      	ittt	ls
34007c86:	6b6b      	ldrls	r3, [r5, #52]	@ 0x34
34007c88:	f023 437f 	bicls.w	r3, r3, #4278190080	@ 0xff000000
34007c8c:	6213      	strls	r3, [r2, #32]
34007c8e:	e7de      	b.n	34007c4e <HAL_DMA2D_ConfigLayer+0x10e>
34007c90:	3401fe2a 	.word	0x3401fe2a
34007c94:	00ccfff0 	.word	0x00ccfff0
34007c98:	ff3f000f 	.word	0xff3f000f
34007c9c:	ff33000f 	.word	0xff33000f

34007ca0 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
34007ca0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
  uint32_t iocurrent;
  uint32_t temp;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007ca4:	4b47      	ldr	r3, [pc, #284]	@ (34007dc4 <HAL_GPIO_Init+0x124>)
{
34007ca6:	4604      	mov	r4, r0
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007ca8:	4298      	cmp	r0, r3
{
34007caa:	460e      	mov	r6, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007cac:	d054      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007cae:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007cb2:	4298      	cmp	r0, r3
34007cb4:	d050      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007cb6:	4b44      	ldr	r3, [pc, #272]	@ (34007dc8 <HAL_GPIO_Init+0x128>)
34007cb8:	4298      	cmp	r0, r3
34007cba:	d04d      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007cbc:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007cc0:	4298      	cmp	r0, r3
34007cc2:	d049      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007cc4:	4b41      	ldr	r3, [pc, #260]	@ (34007dcc <HAL_GPIO_Init+0x12c>)
34007cc6:	4298      	cmp	r0, r3
34007cc8:	d046      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007cca:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007cce:	4298      	cmp	r0, r3
34007cd0:	d042      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007cd2:	4b3f      	ldr	r3, [pc, #252]	@ (34007dd0 <HAL_GPIO_Init+0x130>)
34007cd4:	4298      	cmp	r0, r3
34007cd6:	d03f      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007cd8:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007cdc:	4298      	cmp	r0, r3
34007cde:	d03b      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007ce0:	4b3c      	ldr	r3, [pc, #240]	@ (34007dd4 <HAL_GPIO_Init+0x134>)
34007ce2:	4298      	cmp	r0, r3
34007ce4:	d038      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007ce6:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007cea:	4298      	cmp	r0, r3
34007cec:	d034      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007cee:	4b3a      	ldr	r3, [pc, #232]	@ (34007dd8 <HAL_GPIO_Init+0x138>)
34007cf0:	4298      	cmp	r0, r3
34007cf2:	d031      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007cf4:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007cf8:	4298      	cmp	r0, r3
34007cfa:	d02d      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007cfc:	4b37      	ldr	r3, [pc, #220]	@ (34007ddc <HAL_GPIO_Init+0x13c>)
34007cfe:	4298      	cmp	r0, r3
34007d00:	d02a      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d02:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007d06:	4298      	cmp	r0, r3
34007d08:	d026      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d0a:	4b35      	ldr	r3, [pc, #212]	@ (34007de0 <HAL_GPIO_Init+0x140>)
34007d0c:	4298      	cmp	r0, r3
34007d0e:	d023      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d10:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007d14:	4298      	cmp	r0, r3
34007d16:	d01f      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d18:	4b32      	ldr	r3, [pc, #200]	@ (34007de4 <HAL_GPIO_Init+0x144>)
34007d1a:	4298      	cmp	r0, r3
34007d1c:	d01c      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d1e:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007d22:	4298      	cmp	r0, r3
34007d24:	d018      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d26:	4b30      	ldr	r3, [pc, #192]	@ (34007de8 <HAL_GPIO_Init+0x148>)
34007d28:	4298      	cmp	r0, r3
34007d2a:	d015      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d2c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007d30:	4298      	cmp	r0, r3
34007d32:	d011      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d34:	4b2d      	ldr	r3, [pc, #180]	@ (34007dec <HAL_GPIO_Init+0x14c>)
34007d36:	4298      	cmp	r0, r3
34007d38:	d00e      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d3a:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007d3e:	4298      	cmp	r0, r3
34007d40:	d00a      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d42:	4b2b      	ldr	r3, [pc, #172]	@ (34007df0 <HAL_GPIO_Init+0x150>)
34007d44:	4298      	cmp	r0, r3
34007d46:	d007      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d48:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007d4c:	4298      	cmp	r0, r3
34007d4e:	d003      	beq.n	34007d58 <HAL_GPIO_Init+0xb8>
34007d50:	21ad      	movs	r1, #173	@ 0xad
34007d52:	4828      	ldr	r0, [pc, #160]	@ (34007df4 <HAL_GPIO_Init+0x154>)
34007d54:	f7fa ff5c 	bl	34002c10 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
34007d58:	6833      	ldr	r3, [r6, #0]
34007d5a:	b29a      	uxth	r2, r3
34007d5c:	b112      	cbz	r2, 34007d64 <HAL_GPIO_Init+0xc4>
34007d5e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34007d62:	d303      	bcc.n	34007d6c <HAL_GPIO_Init+0xcc>
34007d64:	21ae      	movs	r1, #174	@ 0xae
34007d66:	4823      	ldr	r0, [pc, #140]	@ (34007df4 <HAL_GPIO_Init+0x154>)
34007d68:	f7fa ff52 	bl	34002c10 <assert_failed>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
34007d6c:	6873      	ldr	r3, [r6, #4]
34007d6e:	f5b3 1f04 	cmp.w	r3, #2162688	@ 0x210000
34007d72:	d011      	beq.n	34007d98 <HAL_GPIO_Init+0xf8>
34007d74:	d81d      	bhi.n	34007db2 <HAL_GPIO_Init+0x112>
34007d76:	f5b3 1f88 	cmp.w	r3, #1114112	@ 0x110000
34007d7a:	d00d      	beq.n	34007d98 <HAL_GPIO_Init+0xf8>
34007d7c:	d809      	bhi.n	34007d92 <HAL_GPIO_Init+0xf2>
34007d7e:	2b03      	cmp	r3, #3
34007d80:	d90a      	bls.n	34007d98 <HAL_GPIO_Init+0xf8>
34007d82:	3b11      	subs	r3, #17
34007d84:	2b01      	cmp	r3, #1
34007d86:	d907      	bls.n	34007d98 <HAL_GPIO_Init+0xf8>
34007d88:	21af      	movs	r1, #175	@ 0xaf
34007d8a:	481a      	ldr	r0, [pc, #104]	@ (34007df4 <HAL_GPIO_Init+0x154>)
34007d8c:	f7fa ff40 	bl	34002c10 <assert_failed>
34007d90:	e002      	b.n	34007d98 <HAL_GPIO_Init+0xf8>
34007d92:	f5b3 1f90 	cmp.w	r3, #1179648	@ 0x120000
34007d96:	d1f7      	bne.n	34007d88 <HAL_GPIO_Init+0xe8>
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
      {
        temp = EXTI->EXTICR[position >> 2u];
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007d98:	f04f 0900 	mov.w	r9, #0
34007d9c:	464f      	mov	r7, r9
34007d9e:	f8df 8024 	ldr.w	r8, [pc, #36]	@ 34007dc4 <HAL_GPIO_Init+0x124>
        EXTI->EXTICR[position >> 2u] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
34007da2:	f8df a054 	ldr.w	sl, [pc, #84]	@ 34007df8 <HAL_GPIO_Init+0x158>
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34007da6:	6835      	ldr	r5, [r6, #0]
34007da8:	fa35 f307 	lsrs.w	r3, r5, r7
34007dac:	d126      	bne.n	34007dfc <HAL_GPIO_Init+0x15c>
      }
    }

    position++;
  }
}
34007dae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
34007db2:	f5b3 1f44 	cmp.w	r3, #3211264	@ 0x310000
34007db6:	d0ef      	beq.n	34007d98 <HAL_GPIO_Init+0xf8>
34007db8:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
34007dbc:	f5b3 1f08 	cmp.w	r3, #2228224	@ 0x220000
34007dc0:	e7e9      	b.n	34007d96 <HAL_GPIO_Init+0xf6>
34007dc2:	bf00      	nop
34007dc4:	56020000 	.word	0x56020000
34007dc8:	56020400 	.word	0x56020400
34007dcc:	56020800 	.word	0x56020800
34007dd0:	56020c00 	.word	0x56020c00
34007dd4:	56021000 	.word	0x56021000
34007dd8:	56021400 	.word	0x56021400
34007ddc:	56021800 	.word	0x56021800
34007de0:	56021c00 	.word	0x56021c00
34007de4:	56023400 	.word	0x56023400
34007de8:	56023800 	.word	0x56023800
34007dec:	56023c00 	.word	0x56023c00
34007df0:	56024000 	.word	0x56024000
34007df4:	3401feef 	.word	0x3401feef
34007df8:	56025000 	.word	0x56025000
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
34007dfc:	f04f 0b01 	mov.w	fp, #1
34007e00:	fa0b fb07 	lsl.w	fp, fp, r7
    if (iocurrent != 0x00u)
34007e04:	ea1b 0505 	ands.w	r5, fp, r5
34007e08:	f000 8130 	beq.w	3400806c <HAL_GPIO_Init+0x3cc>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
34007e0c:	6873      	ldr	r3, [r6, #4]
34007e0e:	f003 0303 	and.w	r3, r3, #3
34007e12:	3b01      	subs	r3, #1
34007e14:	2b01      	cmp	r3, #1
34007e16:	d81a      	bhi.n	34007e4e <HAL_GPIO_Init+0x1ae>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
34007e18:	68f3      	ldr	r3, [r6, #12]
34007e1a:	2b03      	cmp	r3, #3
34007e1c:	d903      	bls.n	34007e26 <HAL_GPIO_Init+0x186>
34007e1e:	21be      	movs	r1, #190	@ 0xbe
34007e20:	489e      	ldr	r0, [pc, #632]	@ (3400809c <HAL_GPIO_Init+0x3fc>)
34007e22:	f7fa fef5 	bl	34002c10 <assert_failed>
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34007e26:	2303      	movs	r3, #3
        temp = GPIOx->OSPEEDR;
34007e28:	68a2      	ldr	r2, [r4, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34007e2a:	fa03 f309 	lsl.w	r3, r3, r9
34007e2e:	ea22 0203 	bic.w	r2, r2, r3
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34007e32:	68f3      	ldr	r3, [r6, #12]
34007e34:	fa03 f309 	lsl.w	r3, r3, r9
34007e38:	4313      	orrs	r3, r2
        GPIOx->OSPEEDR = temp;
34007e3a:	60a3      	str	r3, [r4, #8]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34007e3c:	6873      	ldr	r3, [r6, #4]
        temp = GPIOx->OTYPER;
34007e3e:	6862      	ldr	r2, [r4, #4]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34007e40:	f3c3 1300 	ubfx	r3, r3, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
34007e44:	ea22 020b 	bic.w	r2, r2, fp
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34007e48:	40bb      	lsls	r3, r7
34007e4a:	4313      	orrs	r3, r2
        GPIOx->OTYPER = temp;
34007e4c:	6063      	str	r3, [r4, #4]
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34007e4e:	e9d6 3201 	ldrd	r3, r2, [r6, #4]
34007e52:	f003 0303 	and.w	r3, r3, #3
34007e56:	2b03      	cmp	r3, #3
34007e58:	d102      	bne.n	34007e60 <HAL_GPIO_Init+0x1c0>
34007e5a:	2a01      	cmp	r2, #1
34007e5c:	f000 8082 	beq.w	34007f64 <HAL_GPIO_Init+0x2c4>
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
34007e60:	2a02      	cmp	r2, #2
34007e62:	d903      	bls.n	34007e6c <HAL_GPIO_Init+0x1cc>
34007e64:	21d1      	movs	r1, #209	@ 0xd1
34007e66:	488d      	ldr	r0, [pc, #564]	@ (3400809c <HAL_GPIO_Init+0x3fc>)
34007e68:	f7fa fed2 	bl	34002c10 <assert_failed>
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34007e6c:	2303      	movs	r3, #3
        temp = GPIOx->PUPDR;
34007e6e:	68e2      	ldr	r2, [r4, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34007e70:	fa03 f309 	lsl.w	r3, r3, r9
34007e74:	ea22 0203 	bic.w	r2, r2, r3
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
34007e78:	68b3      	ldr	r3, [r6, #8]
34007e7a:	fa03 f309 	lsl.w	r3, r3, r9
34007e7e:	4313      	orrs	r3, r2
        GPIOx->PUPDR = temp;
34007e80:	60e3      	str	r3, [r4, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
34007e82:	6873      	ldr	r3, [r6, #4]
34007e84:	f003 0303 	and.w	r3, r3, #3
34007e88:	2b02      	cmp	r3, #2
34007e8a:	d16b      	bne.n	34007f64 <HAL_GPIO_Init+0x2c4>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
34007e8c:	4544      	cmp	r4, r8
34007e8e:	d053      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007e90:	4b83      	ldr	r3, [pc, #524]	@ (340080a0 <HAL_GPIO_Init+0x400>)
34007e92:	429c      	cmp	r4, r3
34007e94:	d050      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007e96:	4b83      	ldr	r3, [pc, #524]	@ (340080a4 <HAL_GPIO_Init+0x404>)
34007e98:	429c      	cmp	r4, r3
34007e9a:	d04d      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007e9c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007ea0:	429c      	cmp	r4, r3
34007ea2:	d049      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007ea4:	4b80      	ldr	r3, [pc, #512]	@ (340080a8 <HAL_GPIO_Init+0x408>)
34007ea6:	429c      	cmp	r4, r3
34007ea8:	d046      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007eaa:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007eae:	429c      	cmp	r4, r3
34007eb0:	d042      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007eb2:	4b7e      	ldr	r3, [pc, #504]	@ (340080ac <HAL_GPIO_Init+0x40c>)
34007eb4:	429c      	cmp	r4, r3
34007eb6:	d03f      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007eb8:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007ebc:	429c      	cmp	r4, r3
34007ebe:	d03b      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007ec0:	4b7b      	ldr	r3, [pc, #492]	@ (340080b0 <HAL_GPIO_Init+0x410>)
34007ec2:	429c      	cmp	r4, r3
34007ec4:	d038      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007ec6:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007eca:	429c      	cmp	r4, r3
34007ecc:	d034      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007ece:	4b79      	ldr	r3, [pc, #484]	@ (340080b4 <HAL_GPIO_Init+0x414>)
34007ed0:	429c      	cmp	r4, r3
34007ed2:	d031      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007ed4:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007ed8:	429c      	cmp	r4, r3
34007eda:	d02d      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007edc:	4b76      	ldr	r3, [pc, #472]	@ (340080b8 <HAL_GPIO_Init+0x418>)
34007ede:	429c      	cmp	r4, r3
34007ee0:	d02a      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007ee2:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007ee6:	429c      	cmp	r4, r3
34007ee8:	d026      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007eea:	4b74      	ldr	r3, [pc, #464]	@ (340080bc <HAL_GPIO_Init+0x41c>)
34007eec:	429c      	cmp	r4, r3
34007eee:	d023      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007ef0:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007ef4:	429c      	cmp	r4, r3
34007ef6:	d01f      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007ef8:	4b71      	ldr	r3, [pc, #452]	@ (340080c0 <HAL_GPIO_Init+0x420>)
34007efa:	429c      	cmp	r4, r3
34007efc:	d01c      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007efe:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007f02:	429c      	cmp	r4, r3
34007f04:	d018      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007f06:	4b6f      	ldr	r3, [pc, #444]	@ (340080c4 <HAL_GPIO_Init+0x424>)
34007f08:	429c      	cmp	r4, r3
34007f0a:	d015      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007f0c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007f10:	429c      	cmp	r4, r3
34007f12:	d011      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007f14:	4b6c      	ldr	r3, [pc, #432]	@ (340080c8 <HAL_GPIO_Init+0x428>)
34007f16:	429c      	cmp	r4, r3
34007f18:	d00e      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007f1a:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007f1e:	429c      	cmp	r4, r3
34007f20:	d00a      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007f22:	4b6a      	ldr	r3, [pc, #424]	@ (340080cc <HAL_GPIO_Init+0x42c>)
34007f24:	429c      	cmp	r4, r3
34007f26:	d007      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007f28:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007f2c:	429c      	cmp	r4, r3
34007f2e:	d003      	beq.n	34007f38 <HAL_GPIO_Init+0x298>
34007f30:	21de      	movs	r1, #222	@ 0xde
34007f32:	485a      	ldr	r0, [pc, #360]	@ (3400809c <HAL_GPIO_Init+0x3fc>)
34007f34:	f7fa fe6c 	bl	34002c10 <assert_failed>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
34007f38:	6933      	ldr	r3, [r6, #16]
34007f3a:	2b0f      	cmp	r3, #15
34007f3c:	d903      	bls.n	34007f46 <HAL_GPIO_Init+0x2a6>
34007f3e:	21df      	movs	r1, #223	@ 0xdf
34007f40:	4856      	ldr	r0, [pc, #344]	@ (3400809c <HAL_GPIO_Init+0x3fc>)
34007f42:	f7fa fe65 	bl	34002c10 <assert_failed>
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34007f46:	230f      	movs	r3, #15
        temp = GPIOx->AFR[position >> 3u];
34007f48:	08fa      	lsrs	r2, r7, #3
34007f4a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34007f4e:	f007 0107 	and.w	r1, r7, #7
        temp = GPIOx->AFR[position >> 3u];
34007f52:	6a10      	ldr	r0, [r2, #32]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34007f54:	0089      	lsls	r1, r1, #2
34007f56:	408b      	lsls	r3, r1
34007f58:	ea20 0003 	bic.w	r0, r0, r3
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34007f5c:	6933      	ldr	r3, [r6, #16]
34007f5e:	408b      	lsls	r3, r1
34007f60:	4303      	orrs	r3, r0
        GPIOx->AFR[position >> 3u] = temp;
34007f62:	6213      	str	r3, [r2, #32]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34007f64:	2303      	movs	r3, #3
      temp = GPIOx->MODER;
34007f66:	6820      	ldr	r0, [r4, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34007f68:	fa03 f209 	lsl.w	r2, r3, r9
34007f6c:	ea20 0002 	bic.w	r0, r0, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
34007f70:	6872      	ldr	r2, [r6, #4]
34007f72:	ea02 0103 	and.w	r1, r2, r3
34007f76:	fa01 f109 	lsl.w	r1, r1, r9
34007f7a:	4301      	orrs	r1, r0
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34007f7c:	f412 3f40 	tst.w	r2, #196608	@ 0x30000
      GPIOx->MODER = temp;
34007f80:	6021      	str	r1, [r4, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34007f82:	d073      	beq.n	3400806c <HAL_GPIO_Init+0x3cc>
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007f84:	f04f 0e0f 	mov.w	lr, #15
34007f88:	f027 0103 	bic.w	r1, r7, #3
34007f8c:	f101 41ac 	add.w	r1, r1, #1442840576	@ 0x56000000
34007f90:	f501 3114 	add.w	r1, r1, #151552	@ 0x25000
34007f94:	ea07 0003 	and.w	r0, r7, r3
        temp = EXTI->EXTICR[position >> 2u];
34007f98:	f8d1 c060 	ldr.w	ip, [r1, #96]	@ 0x60
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007f9c:	4098      	lsls	r0, r3
34007f9e:	fa0e fe00 	lsl.w	lr, lr, r0
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007fa2:	4544      	cmp	r4, r8
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007fa4:	ea2c 0c0e 	bic.w	ip, ip, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007fa8:	d064      	beq.n	34008074 <HAL_GPIO_Init+0x3d4>
34007faa:	f8df e0f8 	ldr.w	lr, [pc, #248]	@ 340080a4 <HAL_GPIO_Init+0x404>
34007fae:	4574      	cmp	r4, lr
34007fb0:	d062      	beq.n	34008078 <HAL_GPIO_Init+0x3d8>
34007fb2:	f50e 6e80 	add.w	lr, lr, #1024	@ 0x400
34007fb6:	4574      	cmp	r4, lr
34007fb8:	d060      	beq.n	3400807c <HAL_GPIO_Init+0x3dc>
34007fba:	f50e 6e80 	add.w	lr, lr, #1024	@ 0x400
34007fbe:	4574      	cmp	r4, lr
34007fc0:	d020      	beq.n	34008004 <HAL_GPIO_Init+0x364>
34007fc2:	4b3b      	ldr	r3, [pc, #236]	@ (340080b0 <HAL_GPIO_Init+0x410>)
34007fc4:	429c      	cmp	r4, r3
34007fc6:	d05b      	beq.n	34008080 <HAL_GPIO_Init+0x3e0>
34007fc8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007fcc:	429c      	cmp	r4, r3
34007fce:	d059      	beq.n	34008084 <HAL_GPIO_Init+0x3e4>
34007fd0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007fd4:	429c      	cmp	r4, r3
34007fd6:	d057      	beq.n	34008088 <HAL_GPIO_Init+0x3e8>
34007fd8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007fdc:	429c      	cmp	r4, r3
34007fde:	d055      	beq.n	3400808c <HAL_GPIO_Init+0x3ec>
34007fe0:	f503 53c0 	add.w	r3, r3, #6144	@ 0x1800
34007fe4:	429c      	cmp	r4, r3
34007fe6:	d053      	beq.n	34008090 <HAL_GPIO_Init+0x3f0>
34007fe8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007fec:	429c      	cmp	r4, r3
34007fee:	d051      	beq.n	34008094 <HAL_GPIO_Init+0x3f4>
34007ff0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007ff4:	429c      	cmp	r4, r3
34007ff6:	d04f      	beq.n	34008098 <HAL_GPIO_Init+0x3f8>
34007ff8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007ffc:	429c      	cmp	r4, r3
34007ffe:	bf14      	ite	ne
34008000:	2310      	movne	r3, #16
34008002:	230b      	moveq	r3, #11
34008004:	4083      	lsls	r3, r0
34008006:	ea43 030c 	orr.w	r3, r3, ip
        EXTI->EXTICR[position >> 2u] = temp;
3400800a:	660b      	str	r3, [r1, #96]	@ 0x60
        temp = EXTI->IMR1;
3400800c:	f8da 3080 	ldr.w	r3, [sl, #128]	@ 0x80
        temp &= ~(iocurrent);
34008010:	f412 3f80 	tst.w	r2, #65536	@ 0x10000
34008014:	ea23 0105 	bic.w	r1, r3, r5
34008018:	ea43 0305 	orr.w	r3, r3, r5
3400801c:	bf08      	it	eq
3400801e:	460b      	moveq	r3, r1
        EXTI->IMR1 = temp;
34008020:	f8ca 3080 	str.w	r3, [sl, #128]	@ 0x80
        temp = EXTI->EMR1;
34008024:	f8da 3084 	ldr.w	r3, [sl, #132]	@ 0x84
        temp &= ~(iocurrent);
34008028:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
3400802c:	ea23 0105 	bic.w	r1, r3, r5
34008030:	ea43 0305 	orr.w	r3, r3, r5
34008034:	bf08      	it	eq
34008036:	460b      	moveq	r3, r1
        EXTI->EMR1 = temp;
34008038:	f8ca 3084 	str.w	r3, [sl, #132]	@ 0x84
        temp = EXTI->RTSR1;
3400803c:	f8da 3000 	ldr.w	r3, [sl]
        temp &= ~(iocurrent);
34008040:	f412 1f80 	tst.w	r2, #1048576	@ 0x100000
34008044:	ea23 0105 	bic.w	r1, r3, r5
34008048:	ea43 0305 	orr.w	r3, r3, r5
3400804c:	bf08      	it	eq
3400804e:	460b      	moveq	r3, r1
        EXTI->RTSR1 = temp;
34008050:	f8ca 3000 	str.w	r3, [sl]
        temp = EXTI->FTSR1;
34008054:	f8da 3004 	ldr.w	r3, [sl, #4]
        temp &= ~(iocurrent);
34008058:	f412 1f00 	tst.w	r2, #2097152	@ 0x200000
3400805c:	ea23 0105 	bic.w	r1, r3, r5
34008060:	ea45 0503 	orr.w	r5, r5, r3
34008064:	bf08      	it	eq
34008066:	460d      	moveq	r5, r1
        EXTI->FTSR1 = temp;
34008068:	f8ca 5004 	str.w	r5, [sl, #4]
    position++;
3400806c:	3701      	adds	r7, #1
3400806e:	f109 0902 	add.w	r9, r9, #2
34008072:	e698      	b.n	34007da6 <HAL_GPIO_Init+0x106>
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34008074:	2300      	movs	r3, #0
34008076:	e7c5      	b.n	34008004 <HAL_GPIO_Init+0x364>
34008078:	2301      	movs	r3, #1
3400807a:	e7c3      	b.n	34008004 <HAL_GPIO_Init+0x364>
3400807c:	2302      	movs	r3, #2
3400807e:	e7c1      	b.n	34008004 <HAL_GPIO_Init+0x364>
34008080:	2304      	movs	r3, #4
34008082:	e7bf      	b.n	34008004 <HAL_GPIO_Init+0x364>
34008084:	2305      	movs	r3, #5
34008086:	e7bd      	b.n	34008004 <HAL_GPIO_Init+0x364>
34008088:	2306      	movs	r3, #6
3400808a:	e7bb      	b.n	34008004 <HAL_GPIO_Init+0x364>
3400808c:	2307      	movs	r3, #7
3400808e:	e7b9      	b.n	34008004 <HAL_GPIO_Init+0x364>
34008090:	2308      	movs	r3, #8
34008092:	e7b7      	b.n	34008004 <HAL_GPIO_Init+0x364>
34008094:	2309      	movs	r3, #9
34008096:	e7b5      	b.n	34008004 <HAL_GPIO_Init+0x364>
34008098:	230a      	movs	r3, #10
3400809a:	e7b3      	b.n	34008004 <HAL_GPIO_Init+0x364>
3400809c:	3401feef 	.word	0x3401feef
340080a0:	46020000 	.word	0x46020000
340080a4:	56020400 	.word	0x56020400
340080a8:	56020800 	.word	0x56020800
340080ac:	56020c00 	.word	0x56020c00
340080b0:	56021000 	.word	0x56021000
340080b4:	56021400 	.word	0x56021400
340080b8:	56021800 	.word	0x56021800
340080bc:	56021c00 	.word	0x56021c00
340080c0:	56023400 	.word	0x56023400
340080c4:	56023800 	.word	0x56023800
340080c8:	56023c00 	.word	0x56023c00
340080cc:	56024000 	.word	0x56024000

340080d0 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
340080d0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
  uint32_t iocurrent;
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
340080d4:	4b87      	ldr	r3, [pc, #540]	@ (340082f4 <HAL_GPIO_DeInit+0x224>)
{
340080d6:	4604      	mov	r4, r0
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
340080d8:	4298      	cmp	r0, r3
{
340080da:	460d      	mov	r5, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
340080dc:	d055      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
340080de:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340080e2:	4298      	cmp	r0, r3
340080e4:	d051      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
340080e6:	4b84      	ldr	r3, [pc, #528]	@ (340082f8 <HAL_GPIO_DeInit+0x228>)
340080e8:	4298      	cmp	r0, r3
340080ea:	d04e      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
340080ec:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340080f0:	4298      	cmp	r0, r3
340080f2:	d04a      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
340080f4:	4b81      	ldr	r3, [pc, #516]	@ (340082fc <HAL_GPIO_DeInit+0x22c>)
340080f6:	4298      	cmp	r0, r3
340080f8:	d047      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
340080fa:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340080fe:	4298      	cmp	r0, r3
34008100:	d043      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008102:	4b7f      	ldr	r3, [pc, #508]	@ (34008300 <HAL_GPIO_DeInit+0x230>)
34008104:	4298      	cmp	r0, r3
34008106:	d040      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008108:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400810c:	4298      	cmp	r0, r3
3400810e:	d03c      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008110:	4b7c      	ldr	r3, [pc, #496]	@ (34008304 <HAL_GPIO_DeInit+0x234>)
34008112:	4298      	cmp	r0, r3
34008114:	d039      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008116:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400811a:	4298      	cmp	r0, r3
3400811c:	d035      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
3400811e:	4b7a      	ldr	r3, [pc, #488]	@ (34008308 <HAL_GPIO_DeInit+0x238>)
34008120:	4298      	cmp	r0, r3
34008122:	d032      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008124:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34008128:	4298      	cmp	r0, r3
3400812a:	d02e      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
3400812c:	4b77      	ldr	r3, [pc, #476]	@ (3400830c <HAL_GPIO_DeInit+0x23c>)
3400812e:	4298      	cmp	r0, r3
34008130:	d02b      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008132:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34008136:	4298      	cmp	r0, r3
34008138:	d027      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
3400813a:	4b75      	ldr	r3, [pc, #468]	@ (34008310 <HAL_GPIO_DeInit+0x240>)
3400813c:	4298      	cmp	r0, r3
3400813e:	d024      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008140:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34008144:	4298      	cmp	r0, r3
34008146:	d020      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008148:	4b72      	ldr	r3, [pc, #456]	@ (34008314 <HAL_GPIO_DeInit+0x244>)
3400814a:	4298      	cmp	r0, r3
3400814c:	d01d      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
3400814e:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34008152:	4298      	cmp	r0, r3
34008154:	d019      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008156:	4b70      	ldr	r3, [pc, #448]	@ (34008318 <HAL_GPIO_DeInit+0x248>)
34008158:	4298      	cmp	r0, r3
3400815a:	d016      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
3400815c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34008160:	4298      	cmp	r0, r3
34008162:	d012      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008164:	4b6d      	ldr	r3, [pc, #436]	@ (3400831c <HAL_GPIO_DeInit+0x24c>)
34008166:	4298      	cmp	r0, r3
34008168:	d00f      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
3400816a:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400816e:	4298      	cmp	r0, r3
34008170:	d00b      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008172:	4b6b      	ldr	r3, [pc, #428]	@ (34008320 <HAL_GPIO_DeInit+0x250>)
34008174:	4298      	cmp	r0, r3
34008176:	d008      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008178:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400817c:	4298      	cmp	r0, r3
3400817e:	d004      	beq.n	3400818a <HAL_GPIO_DeInit+0xba>
34008180:	f240 112d 	movw	r1, #301	@ 0x12d
34008184:	4867      	ldr	r0, [pc, #412]	@ (34008324 <HAL_GPIO_DeInit+0x254>)
34008186:	f7fa fd43 	bl	34002c10 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
3400818a:	b2ab      	uxth	r3, r5
3400818c:	b113      	cbz	r3, 34008194 <HAL_GPIO_DeInit+0xc4>
3400818e:	f5b5 3f80 	cmp.w	r5, #65536	@ 0x10000
34008192:	d304      	bcc.n	3400819e <HAL_GPIO_DeInit+0xce>
34008194:	f44f 7197 	mov.w	r1, #302	@ 0x12e
34008198:	4862      	ldr	r0, [pc, #392]	@ (34008324 <HAL_GPIO_DeInit+0x254>)
3400819a:	f7fa fd39 	bl	34002c10 <assert_failed>
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = EXTI->EXTICR[position >> 2u];
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
3400819e:	2200      	movs	r2, #0
    iocurrent = (GPIO_Pin) & (1uL << position);
340081a0:	f04f 0a01 	mov.w	sl, #1
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
340081a4:	f04f 080f 	mov.w	r8, #15
        EXTI->EXTICR[position >> 2u] &= ~tmp;
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
340081a8:	f04f 0b03 	mov.w	fp, #3
        EXTI->IMR1 &= ~(iocurrent);
340081ac:	485e      	ldr	r0, [pc, #376]	@ (34008328 <HAL_GPIO_DeInit+0x258>)
  while ((GPIO_Pin >> position) != 0x00u)
340081ae:	fa35 f302 	lsrs.w	r3, r5, r2
340081b2:	d101      	bne.n	340081b8 <HAL_GPIO_DeInit+0xe8>
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
    }

    position++;
  }
}
340081b4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1uL << position);
340081b8:	fa0a fc02 	lsl.w	ip, sl, r2
    if (iocurrent != 0x00u)
340081bc:	ea1c 0605 	ands.w	r6, ip, r5
340081c0:	d07f      	beq.n	340082c2 <HAL_GPIO_DeInit+0x1f2>
      tmp = EXTI->EXTICR[position >> 2u];
340081c2:	f022 0103 	bic.w	r1, r2, #3
340081c6:	f101 41ac 	add.w	r1, r1, #1442840576	@ 0x56000000
340081ca:	f501 3114 	add.w	r1, r1, #151552	@ 0x25000
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
340081ce:	f002 0703 	and.w	r7, r2, #3
      tmp = EXTI->EXTICR[position >> 2u];
340081d2:	6e0b      	ldr	r3, [r1, #96]	@ 0x60
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
340081d4:	00ff      	lsls	r7, r7, #3
340081d6:	fa08 f907 	lsl.w	r9, r8, r7
340081da:	ea09 0e03 	and.w	lr, r9, r3
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
340081de:	4b45      	ldr	r3, [pc, #276]	@ (340082f4 <HAL_GPIO_DeInit+0x224>)
340081e0:	429c      	cmp	r4, r3
340081e2:	d070      	beq.n	340082c6 <HAL_GPIO_DeInit+0x1f6>
340081e4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
340081e8:	429c      	cmp	r4, r3
340081ea:	d06e      	beq.n	340082ca <HAL_GPIO_DeInit+0x1fa>
340081ec:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
340081f0:	429c      	cmp	r4, r3
340081f2:	d06c      	beq.n	340082ce <HAL_GPIO_DeInit+0x1fe>
340081f4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
340081f8:	429c      	cmp	r4, r3
340081fa:	d06a      	beq.n	340082d2 <HAL_GPIO_DeInit+0x202>
340081fc:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008200:	429c      	cmp	r4, r3
34008202:	d068      	beq.n	340082d6 <HAL_GPIO_DeInit+0x206>
34008204:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008208:	429c      	cmp	r4, r3
3400820a:	d066      	beq.n	340082da <HAL_GPIO_DeInit+0x20a>
3400820c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008210:	429c      	cmp	r4, r3
34008212:	d064      	beq.n	340082de <HAL_GPIO_DeInit+0x20e>
34008214:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008218:	429c      	cmp	r4, r3
3400821a:	d062      	beq.n	340082e2 <HAL_GPIO_DeInit+0x212>
3400821c:	f503 53c0 	add.w	r3, r3, #6144	@ 0x1800
34008220:	429c      	cmp	r4, r3
34008222:	d060      	beq.n	340082e6 <HAL_GPIO_DeInit+0x216>
34008224:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008228:	429c      	cmp	r4, r3
3400822a:	d05e      	beq.n	340082ea <HAL_GPIO_DeInit+0x21a>
3400822c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008230:	429c      	cmp	r4, r3
34008232:	d05c      	beq.n	340082ee <HAL_GPIO_DeInit+0x21e>
34008234:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34008238:	429c      	cmp	r4, r3
3400823a:	bf14      	ite	ne
3400823c:	2310      	movne	r3, #16
3400823e:	230b      	moveq	r3, #11
34008240:	40bb      	lsls	r3, r7
34008242:	4573      	cmp	r3, lr
34008244:	d117      	bne.n	34008276 <HAL_GPIO_DeInit+0x1a6>
        EXTI->IMR1 &= ~(iocurrent);
34008246:	f8d0 3080 	ldr.w	r3, [r0, #128]	@ 0x80
3400824a:	ea23 0306 	bic.w	r3, r3, r6
3400824e:	f8c0 3080 	str.w	r3, [r0, #128]	@ 0x80
        EXTI->EMR1 &= ~(iocurrent);
34008252:	f8d0 3084 	ldr.w	r3, [r0, #132]	@ 0x84
34008256:	ea23 0306 	bic.w	r3, r3, r6
3400825a:	f8c0 3084 	str.w	r3, [r0, #132]	@ 0x84
        EXTI->RTSR1 &= ~(iocurrent);
3400825e:	6803      	ldr	r3, [r0, #0]
34008260:	ea23 0306 	bic.w	r3, r3, r6
34008264:	6003      	str	r3, [r0, #0]
        EXTI->FTSR1 &= ~(iocurrent);
34008266:	6843      	ldr	r3, [r0, #4]
34008268:	ea23 0306 	bic.w	r3, r3, r6
3400826c:	6043      	str	r3, [r0, #4]
        EXTI->EXTICR[position >> 2u] &= ~tmp;
3400826e:	6e0b      	ldr	r3, [r1, #96]	@ 0x60
34008270:	ea23 0309 	bic.w	r3, r3, r9
34008274:	660b      	str	r3, [r1, #96]	@ 0x60
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34008276:	6823      	ldr	r3, [r4, #0]
34008278:	0056      	lsls	r6, r2, #1
3400827a:	fa0b f606 	lsl.w	r6, fp, r6
3400827e:	4333      	orrs	r3, r6
34008280:	6023      	str	r3, [r4, #0]
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos)) ;
34008282:	08d3      	lsrs	r3, r2, #3
34008284:	eb04 0383 	add.w	r3, r4, r3, lsl #2
34008288:	f002 0107 	and.w	r1, r2, #7
3400828c:	6a1f      	ldr	r7, [r3, #32]
3400828e:	0089      	lsls	r1, r1, #2
34008290:	fa08 f101 	lsl.w	r1, r8, r1
34008294:	ea27 0701 	bic.w	r7, r7, r1
34008298:	621f      	str	r7, [r3, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
3400829a:	68a7      	ldr	r7, [r4, #8]
3400829c:	ea27 0706 	bic.w	r7, r7, r6
340082a0:	60a7      	str	r7, [r4, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
340082a2:	6867      	ldr	r7, [r4, #4]
340082a4:	ea27 070c 	bic.w	r7, r7, ip
340082a8:	6067      	str	r7, [r4, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
340082aa:	68e7      	ldr	r7, [r4, #12]
340082ac:	ea27 0706 	bic.w	r7, r7, r6
340082b0:	60e7      	str	r7, [r4, #12]
      GPIOx->DELAYR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_DELAYRL_DLY1_Pos)) ;
340082b2:	6c1e      	ldr	r6, [r3, #64]	@ 0x40
340082b4:	ea26 0601 	bic.w	r6, r6, r1
340082b8:	641e      	str	r6, [r3, #64]	@ 0x40
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
340082ba:	6c9e      	ldr	r6, [r3, #72]	@ 0x48
340082bc:	ea26 0101 	bic.w	r1, r6, r1
340082c0:	6499      	str	r1, [r3, #72]	@ 0x48
    position++;
340082c2:	3201      	adds	r2, #1
340082c4:	e773      	b.n	340081ae <HAL_GPIO_DeInit+0xde>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
340082c6:	2300      	movs	r3, #0
340082c8:	e7ba      	b.n	34008240 <HAL_GPIO_DeInit+0x170>
340082ca:	2301      	movs	r3, #1
340082cc:	e7b8      	b.n	34008240 <HAL_GPIO_DeInit+0x170>
340082ce:	2302      	movs	r3, #2
340082d0:	e7b6      	b.n	34008240 <HAL_GPIO_DeInit+0x170>
340082d2:	2303      	movs	r3, #3
340082d4:	e7b4      	b.n	34008240 <HAL_GPIO_DeInit+0x170>
340082d6:	2304      	movs	r3, #4
340082d8:	e7b2      	b.n	34008240 <HAL_GPIO_DeInit+0x170>
340082da:	2305      	movs	r3, #5
340082dc:	e7b0      	b.n	34008240 <HAL_GPIO_DeInit+0x170>
340082de:	2306      	movs	r3, #6
340082e0:	e7ae      	b.n	34008240 <HAL_GPIO_DeInit+0x170>
340082e2:	2307      	movs	r3, #7
340082e4:	e7ac      	b.n	34008240 <HAL_GPIO_DeInit+0x170>
340082e6:	2308      	movs	r3, #8
340082e8:	e7aa      	b.n	34008240 <HAL_GPIO_DeInit+0x170>
340082ea:	2309      	movs	r3, #9
340082ec:	e7a8      	b.n	34008240 <HAL_GPIO_DeInit+0x170>
340082ee:	230a      	movs	r3, #10
340082f0:	e7a6      	b.n	34008240 <HAL_GPIO_DeInit+0x170>
340082f2:	bf00      	nop
340082f4:	56020000 	.word	0x56020000
340082f8:	56020400 	.word	0x56020400
340082fc:	56020800 	.word	0x56020800
34008300:	56020c00 	.word	0x56020c00
34008304:	56021000 	.word	0x56021000
34008308:	56021400 	.word	0x56021400
3400830c:	56021800 	.word	0x56021800
34008310:	56021c00 	.word	0x56021c00
34008314:	56023400 	.word	0x56023400
34008318:	56023800 	.word	0x56023800
3400831c:	56023c00 	.word	0x56023c00
34008320:	56024000 	.word	0x56024000
34008324:	3401feef 	.word	0x3401feef
34008328:	56025000 	.word	0x56025000

3400832c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
3400832c:	b570      	push	{r4, r5, r6, lr}
3400832e:	4605      	mov	r5, r0
34008330:	4616      	mov	r6, r2
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
34008332:	460c      	mov	r4, r1
34008334:	b921      	cbnz	r1, 34008340 <HAL_GPIO_WritePin+0x14>
34008336:	f44f 71d0 	mov.w	r1, #416	@ 0x1a0
3400833a:	4808      	ldr	r0, [pc, #32]	@ (3400835c <HAL_GPIO_WritePin+0x30>)
3400833c:	f7fa fc68 	bl	34002c10 <assert_failed>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
34008340:	2e01      	cmp	r6, #1
34008342:	d906      	bls.n	34008352 <HAL_GPIO_WritePin+0x26>
34008344:	f240 11a1 	movw	r1, #417	@ 0x1a1
34008348:	4804      	ldr	r0, [pc, #16]	@ (3400835c <HAL_GPIO_WritePin+0x30>)
3400834a:	f7fa fc61 	bl	34002c10 <assert_failed>

  if (PinState != GPIO_PIN_RESET)
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
3400834e:	61ac      	str	r4, [r5, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
34008350:	bd70      	pop	{r4, r5, r6, pc}
  if (PinState != GPIO_PIN_RESET)
34008352:	2e00      	cmp	r6, #0
34008354:	d1fb      	bne.n	3400834e <HAL_GPIO_WritePin+0x22>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34008356:	62ac      	str	r4, [r5, #40]	@ 0x28
}
34008358:	e7fa      	b.n	34008350 <HAL_GPIO_WritePin+0x24>
3400835a:	bf00      	nop
3400835c:	3401feef 	.word	0x3401feef

34008360 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
34008360:	6803      	ldr	r3, [r0, #0]
34008362:	699a      	ldr	r2, [r3, #24]
34008364:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
34008366:	bf44      	itt	mi
34008368:	2200      	movmi	r2, #0
3400836a:	629a      	strmi	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
3400836c:	699a      	ldr	r2, [r3, #24]
3400836e:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
34008370:	bf5e      	ittt	pl
34008372:	699a      	ldrpl	r2, [r3, #24]
34008374:	f042 0201 	orrpl.w	r2, r2, #1
34008378:	619a      	strpl	r2, [r3, #24]
  }
}
3400837a:	4770      	bx	lr

3400837c <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
3400837c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34008380:	4614      	mov	r4, r2
34008382:	461f      	mov	r7, r3
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008384:	6802      	ldr	r2, [r0, #0]
34008386:	4b29      	ldr	r3, [pc, #164]	@ (3400842c <I2C_TransferConfig+0xb0>)
{
34008388:	4680      	mov	r8, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
3400838a:	429a      	cmp	r2, r3
{
3400838c:	460e      	mov	r6, r1
3400838e:	9d06      	ldr	r5, [sp, #24]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008390:	d01d      	beq.n	340083ce <I2C_TransferConfig+0x52>
34008392:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34008396:	429a      	cmp	r2, r3
34008398:	d019      	beq.n	340083ce <I2C_TransferConfig+0x52>
3400839a:	4b25      	ldr	r3, [pc, #148]	@ (34008430 <I2C_TransferConfig+0xb4>)
3400839c:	429a      	cmp	r2, r3
3400839e:	d016      	beq.n	340083ce <I2C_TransferConfig+0x52>
340083a0:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340083a4:	429a      	cmp	r2, r3
340083a6:	d012      	beq.n	340083ce <I2C_TransferConfig+0x52>
340083a8:	4b22      	ldr	r3, [pc, #136]	@ (34008434 <I2C_TransferConfig+0xb8>)
340083aa:	429a      	cmp	r2, r3
340083ac:	d00f      	beq.n	340083ce <I2C_TransferConfig+0x52>
340083ae:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340083b2:	429a      	cmp	r2, r3
340083b4:	d00b      	beq.n	340083ce <I2C_TransferConfig+0x52>
340083b6:	4b20      	ldr	r3, [pc, #128]	@ (34008438 <I2C_TransferConfig+0xbc>)
340083b8:	429a      	cmp	r2, r3
340083ba:	d008      	beq.n	340083ce <I2C_TransferConfig+0x52>
340083bc:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340083c0:	429a      	cmp	r2, r3
340083c2:	d004      	beq.n	340083ce <I2C_TransferConfig+0x52>
340083c4:	f641 51c9 	movw	r1, #7625	@ 0x1dc9
340083c8:	481c      	ldr	r0, [pc, #112]	@ (3400843c <I2C_TransferConfig+0xc0>)
340083ca:	f7fa fc21 	bl	34002c10 <assert_failed>
  assert_param(IS_TRANSFER_MODE(Mode));
340083ce:	f037 7380 	bics.w	r3, r7, #16777216	@ 0x1000000
340083d2:	d007      	beq.n	340083e4 <I2C_TransferConfig+0x68>
340083d4:	f1b7 7f00 	cmp.w	r7, #33554432	@ 0x2000000
340083d8:	d004      	beq.n	340083e4 <I2C_TransferConfig+0x68>
340083da:	f641 51ca 	movw	r1, #7626	@ 0x1dca
340083de:	4817      	ldr	r0, [pc, #92]	@ (3400843c <I2C_TransferConfig+0xc0>)
340083e0:	f7fa fc16 	bl	34002c10 <assert_failed>
  assert_param(IS_TRANSFER_REQUEST(Request));
340083e4:	4b16      	ldr	r3, [pc, #88]	@ (34008440 <I2C_TransferConfig+0xc4>)
340083e6:	429d      	cmp	r5, r3
340083e8:	d00b      	beq.n	34008402 <I2C_TransferConfig+0x86>
340083ea:	f425 6280 	bic.w	r2, r5, #1024	@ 0x400
340083ee:	f5a3 5300 	sub.w	r3, r3, #8192	@ 0x2000
340083f2:	429a      	cmp	r2, r3
340083f4:	d005      	beq.n	34008402 <I2C_TransferConfig+0x86>
340083f6:	b125      	cbz	r5, 34008402 <I2C_TransferConfig+0x86>
340083f8:	f641 51cb 	movw	r1, #7627	@ 0x1dcb
340083fc:	480f      	ldr	r0, [pc, #60]	@ (3400843c <I2C_TransferConfig+0xc0>)
340083fe:	f7fa fc07 	bl	34002c10 <assert_failed>
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
34008402:	f8d8 0000 	ldr.w	r0, [r8]
34008406:	490f      	ldr	r1, [pc, #60]	@ (34008444 <I2C_TransferConfig+0xc8>)
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34008408:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
  MODIFY_REG(hi2c->Instance->CR2, \
3400840c:	6842      	ldr	r2, [r0, #4]
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
3400840e:	ea44 0307 	orr.w	r3, r4, r7
34008412:	f3c6 0609 	ubfx	r6, r6, #0, #10
34008416:	4333      	orrs	r3, r6
  MODIFY_REG(hi2c->Instance->CR2, \
34008418:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
3400841c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
  MODIFY_REG(hi2c->Instance->CR2, \
34008420:	ea22 0201 	bic.w	r2, r2, r1
34008424:	4313      	orrs	r3, r2
34008426:	6043      	str	r3, [r0, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
34008428:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3400842c:	50005400 	.word	0x50005400
34008430:	50005800 	.word	0x50005800
34008434:	50005c00 	.word	0x50005c00
34008438:	56001c00 	.word	0x56001c00
3400843c:	3401ffb3 	.word	0x3401ffb3
34008440:	80004000 	.word	0x80004000
34008444:	03ff63ff 	.word	0x03ff63ff

34008448 <I2C_IsErrorOccurred>:
  uint32_t itflag   = hi2c->Instance->ISR;
34008448:	6803      	ldr	r3, [r0, #0]
{
3400844a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t itflag   = hi2c->Instance->ISR;
3400844e:	699c      	ldr	r4, [r3, #24]
{
34008450:	4605      	mov	r5, r0
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
34008452:	f014 0410 	ands.w	r4, r4, #16
{
34008456:	460f      	mov	r7, r1
34008458:	4616      	mov	r6, r2
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
3400845a:	d06f      	beq.n	3400853c <I2C_IsErrorOccurred+0xf4>
  uint32_t error_code = 0;
3400845c:	2400      	movs	r4, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
3400845e:	2210      	movs	r2, #16
  HAL_StatusTypeDef status = HAL_OK;
34008460:	46a0      	mov	r8, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34008462:	61da      	str	r2, [r3, #28]
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
34008464:	682b      	ldr	r3, [r5, #0]
34008466:	699a      	ldr	r2, [r3, #24]
34008468:	0690      	lsls	r0, r2, #26
3400846a:	d461      	bmi.n	34008530 <I2C_IsErrorOccurred+0xe8>
3400846c:	f1b8 0f00 	cmp.w	r8, #0
34008470:	d035      	beq.n	340084de <I2C_IsErrorOccurred+0x96>
    status = HAL_ERROR;
34008472:	2001      	movs	r0, #1
    error_code |= HAL_I2C_ERROR_AF;
34008474:	f044 0404 	orr.w	r4, r4, #4
  itflag = hi2c->Instance->ISR;
34008478:	682e      	ldr	r6, [r5, #0]
3400847a:	69b3      	ldr	r3, [r6, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
3400847c:	05d9      	lsls	r1, r3, #23
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
3400847e:	bf41      	itttt	mi
34008480:	f44f 7280 	movmi.w	r2, #256	@ 0x100
    status = HAL_ERROR;
34008484:	2001      	movmi	r0, #1
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
34008486:	61f2      	strmi	r2, [r6, #28]
    error_code |= HAL_I2C_ERROR_BERR;
34008488:	f044 0401 	orrmi.w	r4, r4, #1
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
3400848c:	055a      	lsls	r2, r3, #21
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
3400848e:	bf41      	itttt	mi
34008490:	f44f 6280 	movmi.w	r2, #1024	@ 0x400
    status = HAL_ERROR;
34008494:	2001      	movmi	r0, #1
    error_code |= HAL_I2C_ERROR_OVR;
34008496:	f044 0408 	orrmi.w	r4, r4, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
3400849a:	61f2      	strmi	r2, [r6, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
3400849c:	059b      	lsls	r3, r3, #22
3400849e:	d54f      	bpl.n	34008540 <I2C_IsErrorOccurred+0xf8>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
340084a0:	f44f 7300 	mov.w	r3, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
340084a4:	f044 0402 	orr.w	r4, r4, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
340084a8:	61f3      	str	r3, [r6, #28]
    I2C_Flush_TXDR(hi2c);
340084aa:	4628      	mov	r0, r5
340084ac:	f7ff ff58 	bl	34008360 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
340084b0:	6873      	ldr	r3, [r6, #4]
    __HAL_UNLOCK(hi2c);
340084b2:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
340084b4:	f023 73ff 	bic.w	r3, r3, #33423360	@ 0x1fe0000
340084b8:	f423 338b 	bic.w	r3, r3, #71168	@ 0x11600
340084bc:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
340084c0:	f023 0301 	bic.w	r3, r3, #1
340084c4:	6073      	str	r3, [r6, #4]
    hi2c->ErrorCode |= error_code;
340084c6:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
340084c8:	4323      	orrs	r3, r4
340084ca:	646b      	str	r3, [r5, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
340084cc:	2320      	movs	r3, #32
340084ce:	f885 3041 	strb.w	r3, [r5, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
340084d2:	2300      	movs	r3, #0
340084d4:	f885 3042 	strb.w	r3, [r5, #66]	@ 0x42
    __HAL_UNLOCK(hi2c);
340084d8:	f885 3040 	strb.w	r3, [r5, #64]	@ 0x40
340084dc:	e032      	b.n	34008544 <I2C_IsErrorOccurred+0xfc>
      if (Timeout != HAL_MAX_DELAY)
340084de:	1c7a      	adds	r2, r7, #1
340084e0:	d0c1      	beq.n	34008466 <I2C_IsErrorOccurred+0x1e>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
340084e2:	f7fc fccb 	bl	34004e7c <HAL_GetTick>
340084e6:	1b80      	subs	r0, r0, r6
340084e8:	42b8      	cmp	r0, r7
340084ea:	d801      	bhi.n	340084f0 <I2C_IsErrorOccurred+0xa8>
340084ec:	2f00      	cmp	r7, #0
340084ee:	d1b9      	bne.n	34008464 <I2C_IsErrorOccurred+0x1c>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
340084f0:	682b      	ldr	r3, [r5, #0]
340084f2:	6859      	ldr	r1, [r3, #4]
          tmp2 = hi2c->Mode;
340084f4:	f895 2042 	ldrb.w	r2, [r5, #66]	@ 0x42
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
340084f8:	6998      	ldr	r0, [r3, #24]
          tmp2 = hi2c->Mode;
340084fa:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
340084fc:	0400      	lsls	r0, r0, #16
340084fe:	d50a      	bpl.n	34008516 <I2C_IsErrorOccurred+0xce>
34008500:	0449      	lsls	r1, r1, #17
34008502:	d408      	bmi.n	34008516 <I2C_IsErrorOccurred+0xce>
              (tmp1 != I2C_CR2_STOP) && \
34008504:	2a20      	cmp	r2, #32
34008506:	d006      	beq.n	34008516 <I2C_IsErrorOccurred+0xce>
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
34008508:	685a      	ldr	r2, [r3, #4]
3400850a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
3400850e:	605a      	str	r2, [r3, #4]
            tickstart = HAL_GetTick();
34008510:	f7fc fcb4 	bl	34004e7c <HAL_GetTick>
34008514:	4606      	mov	r6, r0
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34008516:	682b      	ldr	r3, [r5, #0]
34008518:	699b      	ldr	r3, [r3, #24]
3400851a:	069b      	lsls	r3, r3, #26
3400851c:	d4a2      	bmi.n	34008464 <I2C_IsErrorOccurred+0x1c>
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
3400851e:	f7fc fcad 	bl	34004e7c <HAL_GetTick>
34008522:	1b80      	subs	r0, r0, r6
34008524:	2819      	cmp	r0, #25
34008526:	d9f6      	bls.n	34008516 <I2C_IsErrorOccurred+0xce>
              error_code |= HAL_I2C_ERROR_TIMEOUT;
34008528:	2420      	movs	r4, #32
              status = HAL_ERROR;
3400852a:	f04f 0801 	mov.w	r8, #1
3400852e:	e799      	b.n	34008464 <I2C_IsErrorOccurred+0x1c>
    if (status == HAL_OK)
34008530:	f1b8 0f00 	cmp.w	r8, #0
34008534:	d19d      	bne.n	34008472 <I2C_IsErrorOccurred+0x2a>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34008536:	2220      	movs	r2, #32
34008538:	61da      	str	r2, [r3, #28]
3400853a:	e79a      	b.n	34008472 <I2C_IsErrorOccurred+0x2a>
  HAL_StatusTypeDef status = HAL_OK;
3400853c:	4620      	mov	r0, r4
3400853e:	e79b      	b.n	34008478 <I2C_IsErrorOccurred+0x30>
  if (status != HAL_OK)
34008540:	2800      	cmp	r0, #0
34008542:	d1b2      	bne.n	340084aa <I2C_IsErrorOccurred+0x62>
}
34008544:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

34008548 <I2C_WaitOnTXISFlagUntilTimeout>:
{
34008548:	b570      	push	{r4, r5, r6, lr}
3400854a:	4604      	mov	r4, r0
3400854c:	460d      	mov	r5, r1
3400854e:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
34008550:	6823      	ldr	r3, [r4, #0]
34008552:	699b      	ldr	r3, [r3, #24]
34008554:	079b      	lsls	r3, r3, #30
34008556:	d501      	bpl.n	3400855c <I2C_WaitOnTXISFlagUntilTimeout+0x14>
  return HAL_OK;
34008558:	2000      	movs	r0, #0
3400855a:	e01f      	b.n	3400859c <I2C_WaitOnTXISFlagUntilTimeout+0x54>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
3400855c:	4632      	mov	r2, r6
3400855e:	4629      	mov	r1, r5
34008560:	4620      	mov	r0, r4
34008562:	f7ff ff71 	bl	34008448 <I2C_IsErrorOccurred>
34008566:	b9c0      	cbnz	r0, 3400859a <I2C_WaitOnTXISFlagUntilTimeout+0x52>
    if (Timeout != HAL_MAX_DELAY)
34008568:	1c6a      	adds	r2, r5, #1
3400856a:	d0f1      	beq.n	34008550 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400856c:	f7fc fc86 	bl	34004e7c <HAL_GetTick>
34008570:	1b80      	subs	r0, r0, r6
34008572:	42a8      	cmp	r0, r5
34008574:	d801      	bhi.n	3400857a <I2C_WaitOnTXISFlagUntilTimeout+0x32>
34008576:	2d00      	cmp	r5, #0
34008578:	d1ea      	bne.n	34008550 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
3400857a:	6823      	ldr	r3, [r4, #0]
3400857c:	699b      	ldr	r3, [r3, #24]
3400857e:	f013 0302 	ands.w	r3, r3, #2
34008582:	d1e5      	bne.n	34008550 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34008584:	6c62      	ldr	r2, [r4, #68]	@ 0x44
          __HAL_UNLOCK(hi2c);
34008586:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
3400858a:	f042 0220 	orr.w	r2, r2, #32
3400858e:	6462      	str	r2, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
34008590:	2220      	movs	r2, #32
34008592:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34008596:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      return HAL_ERROR;
3400859a:	2001      	movs	r0, #1
}
3400859c:	bd70      	pop	{r4, r5, r6, pc}

3400859e <I2C_WaitOnFlagUntilTimeout>:
{
3400859e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
340085a2:	4604      	mov	r4, r0
340085a4:	460f      	mov	r7, r1
340085a6:	4616      	mov	r6, r2
340085a8:	461d      	mov	r5, r3
340085aa:	f8dd 8018 	ldr.w	r8, [sp, #24]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
340085ae:	6823      	ldr	r3, [r4, #0]
340085b0:	699b      	ldr	r3, [r3, #24]
340085b2:	ea37 0303 	bics.w	r3, r7, r3
340085b6:	bf0c      	ite	eq
340085b8:	2301      	moveq	r3, #1
340085ba:	2300      	movne	r3, #0
340085bc:	42b3      	cmp	r3, r6
340085be:	d001      	beq.n	340085c4 <I2C_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
340085c0:	2000      	movs	r0, #0
340085c2:	e025      	b.n	34008610 <I2C_WaitOnFlagUntilTimeout+0x72>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
340085c4:	4642      	mov	r2, r8
340085c6:	4629      	mov	r1, r5
340085c8:	4620      	mov	r0, r4
340085ca:	f7ff ff3d 	bl	34008448 <I2C_IsErrorOccurred>
340085ce:	b9f0      	cbnz	r0, 3400860e <I2C_WaitOnFlagUntilTimeout+0x70>
    if (Timeout != HAL_MAX_DELAY)
340085d0:	1c6b      	adds	r3, r5, #1
340085d2:	d0ec      	beq.n	340085ae <I2C_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
340085d4:	f7fc fc52 	bl	34004e7c <HAL_GetTick>
340085d8:	eba0 0008 	sub.w	r0, r0, r8
340085dc:	42a8      	cmp	r0, r5
340085de:	d801      	bhi.n	340085e4 <I2C_WaitOnFlagUntilTimeout+0x46>
340085e0:	2d00      	cmp	r5, #0
340085e2:	d1e4      	bne.n	340085ae <I2C_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
340085e4:	6823      	ldr	r3, [r4, #0]
340085e6:	699b      	ldr	r3, [r3, #24]
340085e8:	ea37 0303 	bics.w	r3, r7, r3
340085ec:	bf0c      	ite	eq
340085ee:	2301      	moveq	r3, #1
340085f0:	2300      	movne	r3, #0
340085f2:	42b3      	cmp	r3, r6
340085f4:	d1db      	bne.n	340085ae <I2C_WaitOnFlagUntilTimeout+0x10>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
340085f6:	6c63      	ldr	r3, [r4, #68]	@ 0x44
340085f8:	f043 0320 	orr.w	r3, r3, #32
340085fc:	6463      	str	r3, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
340085fe:	2320      	movs	r3, #32
34008600:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34008604:	2300      	movs	r3, #0
34008606:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
          __HAL_UNLOCK(hi2c);
3400860a:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
3400860e:	2001      	movs	r0, #1
}
34008610:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

34008614 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
34008614:	b570      	push	{r4, r5, r6, lr}
34008616:	4604      	mov	r4, r0
34008618:	460d      	mov	r5, r1
3400861a:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3400861c:	6823      	ldr	r3, [r4, #0]
3400861e:	699b      	ldr	r3, [r3, #24]
34008620:	069b      	lsls	r3, r3, #26
34008622:	d501      	bpl.n	34008628 <I2C_WaitOnSTOPFlagUntilTimeout+0x14>
  return HAL_OK;
34008624:	2000      	movs	r0, #0
34008626:	e01d      	b.n	34008664 <I2C_WaitOnSTOPFlagUntilTimeout+0x50>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
34008628:	4632      	mov	r2, r6
3400862a:	4629      	mov	r1, r5
3400862c:	4620      	mov	r0, r4
3400862e:	f7ff ff0b 	bl	34008448 <I2C_IsErrorOccurred>
34008632:	b9b0      	cbnz	r0, 34008662 <I2C_WaitOnSTOPFlagUntilTimeout+0x4e>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34008634:	f7fc fc22 	bl	34004e7c <HAL_GetTick>
34008638:	1b80      	subs	r0, r0, r6
3400863a:	42a8      	cmp	r0, r5
3400863c:	d801      	bhi.n	34008642 <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
3400863e:	2d00      	cmp	r5, #0
34008640:	d1ec      	bne.n	3400861c <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34008642:	6823      	ldr	r3, [r4, #0]
34008644:	699b      	ldr	r3, [r3, #24]
34008646:	f013 0320 	ands.w	r3, r3, #32
3400864a:	d1e7      	bne.n	3400861c <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
3400864c:	6c62      	ldr	r2, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
3400864e:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34008652:	f042 0220 	orr.w	r2, r2, #32
34008656:	6462      	str	r2, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
34008658:	2220      	movs	r2, #32
3400865a:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
3400865e:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      return HAL_ERROR;
34008662:	2001      	movs	r0, #1
}
34008664:	bd70      	pop	{r4, r5, r6, pc}

34008666 <HAL_I2C_MspInit>:
}
34008666:	4770      	bx	lr

34008668 <HAL_I2C_Init>:
{
34008668:	b510      	push	{r4, lr}
  if (hi2c == NULL)
3400866a:	4604      	mov	r4, r0
3400866c:	2800      	cmp	r0, #0
3400866e:	f000 80af 	beq.w	340087d0 <HAL_I2C_Init+0x168>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008672:	6803      	ldr	r3, [r0, #0]
34008674:	4a57      	ldr	r2, [pc, #348]	@ (340087d4 <HAL_I2C_Init+0x16c>)
34008676:	4293      	cmp	r3, r2
34008678:	d01d      	beq.n	340086b6 <HAL_I2C_Init+0x4e>
3400867a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400867e:	4293      	cmp	r3, r2
34008680:	d019      	beq.n	340086b6 <HAL_I2C_Init+0x4e>
34008682:	4a55      	ldr	r2, [pc, #340]	@ (340087d8 <HAL_I2C_Init+0x170>)
34008684:	4293      	cmp	r3, r2
34008686:	d016      	beq.n	340086b6 <HAL_I2C_Init+0x4e>
34008688:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400868c:	4293      	cmp	r3, r2
3400868e:	d012      	beq.n	340086b6 <HAL_I2C_Init+0x4e>
34008690:	4a52      	ldr	r2, [pc, #328]	@ (340087dc <HAL_I2C_Init+0x174>)
34008692:	4293      	cmp	r3, r2
34008694:	d00f      	beq.n	340086b6 <HAL_I2C_Init+0x4e>
34008696:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400869a:	4293      	cmp	r3, r2
3400869c:	d00b      	beq.n	340086b6 <HAL_I2C_Init+0x4e>
3400869e:	4a50      	ldr	r2, [pc, #320]	@ (340087e0 <HAL_I2C_Init+0x178>)
340086a0:	4293      	cmp	r3, r2
340086a2:	d008      	beq.n	340086b6 <HAL_I2C_Init+0x4e>
340086a4:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340086a8:	4293      	cmp	r3, r2
340086aa:	d004      	beq.n	340086b6 <HAL_I2C_Init+0x4e>
340086ac:	f240 2126 	movw	r1, #550	@ 0x226
340086b0:	484c      	ldr	r0, [pc, #304]	@ (340087e4 <HAL_I2C_Init+0x17c>)
340086b2:	f7fa faad 	bl	34002c10 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
340086b6:	68a3      	ldr	r3, [r4, #8]
340086b8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
340086bc:	d304      	bcc.n	340086c8 <HAL_I2C_Init+0x60>
340086be:	f240 2127 	movw	r1, #551	@ 0x227
340086c2:	4848      	ldr	r0, [pc, #288]	@ (340087e4 <HAL_I2C_Init+0x17c>)
340086c4:	f7fa faa4 	bl	34002c10 <assert_failed>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
340086c8:	68e3      	ldr	r3, [r4, #12]
340086ca:	3b01      	subs	r3, #1
340086cc:	2b01      	cmp	r3, #1
340086ce:	d904      	bls.n	340086da <HAL_I2C_Init+0x72>
340086d0:	f44f 710a 	mov.w	r1, #552	@ 0x228
340086d4:	4843      	ldr	r0, [pc, #268]	@ (340087e4 <HAL_I2C_Init+0x17c>)
340086d6:	f7fa fa9b 	bl	34002c10 <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
340086da:	6923      	ldr	r3, [r4, #16]
340086dc:	f433 4300 	bics.w	r3, r3, #32768	@ 0x8000
340086e0:	d004      	beq.n	340086ec <HAL_I2C_Init+0x84>
340086e2:	f240 2129 	movw	r1, #553	@ 0x229
340086e6:	483f      	ldr	r0, [pc, #252]	@ (340087e4 <HAL_I2C_Init+0x17c>)
340086e8:	f7fa fa92 	bl	34002c10 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
340086ec:	6963      	ldr	r3, [r4, #20]
340086ee:	2bff      	cmp	r3, #255	@ 0xff
340086f0:	d904      	bls.n	340086fc <HAL_I2C_Init+0x94>
340086f2:	f240 212a 	movw	r1, #554	@ 0x22a
340086f6:	483b      	ldr	r0, [pc, #236]	@ (340087e4 <HAL_I2C_Init+0x17c>)
340086f8:	f7fa fa8a 	bl	34002c10 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
340086fc:	69a3      	ldr	r3, [r4, #24]
340086fe:	2b07      	cmp	r3, #7
34008700:	d904      	bls.n	3400870c <HAL_I2C_Init+0xa4>
34008702:	f240 212b 	movw	r1, #555	@ 0x22b
34008706:	4837      	ldr	r0, [pc, #220]	@ (340087e4 <HAL_I2C_Init+0x17c>)
34008708:	f7fa fa82 	bl	34002c10 <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
3400870c:	69e3      	ldr	r3, [r4, #28]
3400870e:	f433 2300 	bics.w	r3, r3, #524288	@ 0x80000
34008712:	d004      	beq.n	3400871e <HAL_I2C_Init+0xb6>
34008714:	f44f 710b 	mov.w	r1, #556	@ 0x22c
34008718:	4832      	ldr	r0, [pc, #200]	@ (340087e4 <HAL_I2C_Init+0x17c>)
3400871a:	f7fa fa79 	bl	34002c10 <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
3400871e:	6a23      	ldr	r3, [r4, #32]
34008720:	f433 3300 	bics.w	r3, r3, #131072	@ 0x20000
34008724:	d004      	beq.n	34008730 <HAL_I2C_Init+0xc8>
34008726:	f240 212d 	movw	r1, #557	@ 0x22d
3400872a:	482e      	ldr	r0, [pc, #184]	@ (340087e4 <HAL_I2C_Init+0x17c>)
3400872c:	f7fa fa70 	bl	34002c10 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_RESET)
34008730:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
34008734:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
34008738:	b923      	cbnz	r3, 34008744 <HAL_I2C_Init+0xdc>
    HAL_I2C_MspInit(hi2c);
3400873a:	4620      	mov	r0, r4
    hi2c->Lock = HAL_UNLOCKED;
3400873c:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
    HAL_I2C_MspInit(hi2c);
34008740:	f7ff ff91 	bl	34008666 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
34008744:	2324      	movs	r3, #36	@ 0x24
34008746:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
3400874a:	6823      	ldr	r3, [r4, #0]
3400874c:	681a      	ldr	r2, [r3, #0]
3400874e:	f022 0201 	bic.w	r2, r2, #1
34008752:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
34008754:	6862      	ldr	r2, [r4, #4]
34008756:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
3400875a:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
3400875c:	689a      	ldr	r2, [r3, #8]
3400875e:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34008762:	609a      	str	r2, [r3, #8]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
34008764:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
34008768:	2901      	cmp	r1, #1
3400876a:	d106      	bne.n	3400877a <HAL_I2C_Init+0x112>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
3400876c:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34008770:	609a      	str	r2, [r3, #8]
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
34008772:	685a      	ldr	r2, [r3, #4]
34008774:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
34008778:	e007      	b.n	3400878a <HAL_I2C_Init+0x122>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
3400877a:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
3400877e:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
34008780:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
34008782:	d1f6      	bne.n	34008772 <HAL_I2C_Init+0x10a>
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
34008784:	685a      	ldr	r2, [r3, #4]
34008786:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
3400878a:	605a      	str	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
3400878c:	685a      	ldr	r2, [r3, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3400878e:	2000      	movs	r0, #0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
34008790:	f042 7200 	orr.w	r2, r2, #33554432	@ 0x2000000
34008794:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34008798:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
3400879a:	68da      	ldr	r2, [r3, #12]
3400879c:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340087a0:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
340087a2:	e9d4 2104 	ldrd	r2, r1, [r4, #16]
340087a6:	430a      	orrs	r2, r1
                          (hi2c->Init.OwnAddress2Masks << 8));
340087a8:	69a1      	ldr	r1, [r4, #24]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
340087aa:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
340087ae:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
340087b0:	e9d4 2107 	ldrd	r2, r1, [r4, #28]
340087b4:	430a      	orrs	r2, r1
340087b6:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
340087b8:	681a      	ldr	r2, [r3, #0]
340087ba:	f042 0201 	orr.w	r2, r2, #1
340087be:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
340087c0:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
340087c2:	6460      	str	r0, [r4, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
340087c4:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
340087c8:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
340087ca:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
340087ce:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
340087d0:	2001      	movs	r0, #1
340087d2:	e7fc      	b.n	340087ce <HAL_I2C_Init+0x166>
340087d4:	50005400 	.word	0x50005400
340087d8:	50005800 	.word	0x50005800
340087dc:	50005c00 	.word	0x50005c00
340087e0:	56001c00 	.word	0x56001c00
340087e4:	3401ffb3 	.word	0x3401ffb3

340087e8 <HAL_I2C_MspDeInit>:
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
340087e8:	4770      	bx	lr
	...

340087ec <HAL_I2C_DeInit>:
{
340087ec:	b510      	push	{r4, lr}
  if (hi2c == NULL)
340087ee:	4604      	mov	r4, r0
340087f0:	2800      	cmp	r0, #0
340087f2:	d036      	beq.n	34008862 <HAL_I2C_DeInit+0x76>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
340087f4:	6803      	ldr	r3, [r0, #0]
340087f6:	4a1c      	ldr	r2, [pc, #112]	@ (34008868 <HAL_I2C_DeInit+0x7c>)
340087f8:	4293      	cmp	r3, r2
340087fa:	d01d      	beq.n	34008838 <HAL_I2C_DeInit+0x4c>
340087fc:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008800:	4293      	cmp	r3, r2
34008802:	d019      	beq.n	34008838 <HAL_I2C_DeInit+0x4c>
34008804:	4a19      	ldr	r2, [pc, #100]	@ (3400886c <HAL_I2C_DeInit+0x80>)
34008806:	4293      	cmp	r3, r2
34008808:	d016      	beq.n	34008838 <HAL_I2C_DeInit+0x4c>
3400880a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400880e:	4293      	cmp	r3, r2
34008810:	d012      	beq.n	34008838 <HAL_I2C_DeInit+0x4c>
34008812:	4a17      	ldr	r2, [pc, #92]	@ (34008870 <HAL_I2C_DeInit+0x84>)
34008814:	4293      	cmp	r3, r2
34008816:	d00f      	beq.n	34008838 <HAL_I2C_DeInit+0x4c>
34008818:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400881c:	4293      	cmp	r3, r2
3400881e:	d00b      	beq.n	34008838 <HAL_I2C_DeInit+0x4c>
34008820:	4a14      	ldr	r2, [pc, #80]	@ (34008874 <HAL_I2C_DeInit+0x88>)
34008822:	4293      	cmp	r3, r2
34008824:	d008      	beq.n	34008838 <HAL_I2C_DeInit+0x4c>
34008826:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400882a:	4293      	cmp	r3, r2
3400882c:	d004      	beq.n	34008838 <HAL_I2C_DeInit+0x4c>
3400882e:	f240 2199 	movw	r1, #665	@ 0x299
34008832:	4811      	ldr	r0, [pc, #68]	@ (34008878 <HAL_I2C_DeInit+0x8c>)
34008834:	f7fa f9ec 	bl	34002c10 <assert_failed>
  hi2c->State = HAL_I2C_STATE_BUSY;
34008838:	2324      	movs	r3, #36	@ 0x24
  __HAL_I2C_DISABLE(hi2c);
3400883a:	6822      	ldr	r2, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
3400883c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
34008840:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
34008842:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE(hi2c);
34008844:	f023 0301 	bic.w	r3, r3, #1
34008848:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
3400884a:	f7ff ffcd 	bl	340087e8 <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3400884e:	2000      	movs	r0, #0
34008850:	6460      	str	r0, [r4, #68]	@ 0x44
  __HAL_UNLOCK(hi2c);
34008852:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
34008856:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
3400885a:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
3400885c:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
34008860:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34008862:	2001      	movs	r0, #1
34008864:	e7fc      	b.n	34008860 <HAL_I2C_DeInit+0x74>
34008866:	bf00      	nop
34008868:	50005400 	.word	0x50005400
3400886c:	50005800 	.word	0x50005800
34008870:	50005c00 	.word	0x50005c00
34008874:	56001c00 	.word	0x56001c00
34008878:	3401ffb3 	.word	0x3401ffb3

3400887c <HAL_I2C_Mem_Write>:
{
3400887c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
34008880:	4699      	mov	r9, r3
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
34008882:	3b01      	subs	r3, #1
34008884:	2b01      	cmp	r3, #1
{
34008886:	4604      	mov	r4, r0
34008888:	460f      	mov	r7, r1
3400888a:	4616      	mov	r6, r2
3400888c:	f8bd a034 	ldrh.w	sl, [sp, #52]	@ 0x34
34008890:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
34008894:	d904      	bls.n	340088a0 <HAL_I2C_Mem_Write+0x24>
34008896:	f640 2138 	movw	r1, #2616	@ 0xa38
3400889a:	4868      	ldr	r0, [pc, #416]	@ (34008a3c <HAL_I2C_Mem_Write+0x1c0>)
3400889c:	f7fa f9b8 	bl	34002c10 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_READY)
340088a0:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
340088a4:	2b20      	cmp	r3, #32
340088a6:	f040 80c6 	bne.w	34008a36 <HAL_I2C_Mem_Write+0x1ba>
    if ((pData == NULL) || (Size == 0U))
340088aa:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
340088ac:	b113      	cbz	r3, 340088b4 <HAL_I2C_Mem_Write+0x38>
340088ae:	f1ba 0f00 	cmp.w	sl, #0
340088b2:	d106      	bne.n	340088c2 <HAL_I2C_Mem_Write+0x46>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
340088b4:	f44f 7300 	mov.w	r3, #512	@ 0x200
340088b8:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
340088ba:	2001      	movs	r0, #1
}
340088bc:	b003      	add	sp, #12
340088be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
340088c2:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
340088c6:	2b01      	cmp	r3, #1
340088c8:	f000 80b5 	beq.w	34008a36 <HAL_I2C_Mem_Write+0x1ba>
340088cc:	f04f 0b01 	mov.w	fp, #1
340088d0:	f884 b040 	strb.w	fp, [r4, #64]	@ 0x40
    tickstart = HAL_GetTick();
340088d4:	f7fc fad2 	bl	34004e7c <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
340088d8:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
340088da:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
340088dc:	9000      	str	r0, [sp, #0]
340088de:	465a      	mov	r2, fp
340088e0:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
340088e4:	4620      	mov	r0, r4
340088e6:	f7ff fe5a 	bl	3400859e <I2C_WaitOnFlagUntilTimeout>
340088ea:	2800      	cmp	r0, #0
340088ec:	d1e5      	bne.n	340088ba <HAL_I2C_Mem_Write+0x3e>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
340088ee:	2321      	movs	r3, #33	@ 0x21
340088f0:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
340088f4:	2340      	movs	r3, #64	@ 0x40
340088f6:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->pBuffPtr  = pData;
340088fa:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
340088fc:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->pBuffPtr  = pData;
340088fe:	6263      	str	r3, [r4, #36]	@ 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
34008900:	4b4f      	ldr	r3, [pc, #316]	@ (34008a40 <HAL_I2C_Mem_Write+0x1c4>)
    hi2c->XferISR   = NULL;
34008902:	6360      	str	r0, [r4, #52]	@ 0x34
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
34008904:	4639      	mov	r1, r7
34008906:	4620      	mov	r0, r4
    hi2c->XferCount = Size;
34008908:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
3400890c:	fa5f f289 	uxtb.w	r2, r9
34008910:	9300      	str	r3, [sp, #0]
34008912:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34008916:	f7ff fd31 	bl	3400837c <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3400891a:	462a      	mov	r2, r5
3400891c:	4641      	mov	r1, r8
3400891e:	4620      	mov	r0, r4
34008920:	f7ff fe12 	bl	34008548 <I2C_WaitOnTXISFlagUntilTimeout>
34008924:	bb18      	cbnz	r0, 3400896e <HAL_I2C_Mem_Write+0xf2>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
34008926:	f1b9 0f01 	cmp.w	r9, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3400892a:	6823      	ldr	r3, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
3400892c:	d115      	bne.n	3400895a <HAL_I2C_Mem_Write+0xde>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3400892e:	b2f6      	uxtb	r6, r6
34008930:	629e      	str	r6, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
34008932:	2200      	movs	r2, #0
34008934:	4643      	mov	r3, r8
34008936:	2180      	movs	r1, #128	@ 0x80
34008938:	4620      	mov	r0, r4
3400893a:	9500      	str	r5, [sp, #0]
3400893c:	f7ff fe2f 	bl	3400859e <I2C_WaitOnFlagUntilTimeout>
34008940:	b9a8      	cbnz	r0, 3400896e <HAL_I2C_Mem_Write+0xf2>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
34008942:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34008944:	b29b      	uxth	r3, r3
34008946:	2bff      	cmp	r3, #255	@ 0xff
34008948:	d815      	bhi.n	34008976 <HAL_I2C_Mem_Write+0xfa>
      hi2c->XferSize = hi2c->XferCount;
3400894a:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
3400894c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
34008950:	b292      	uxth	r2, r2
34008952:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
34008954:	9000      	str	r0, [sp, #0]
34008956:	b2d2      	uxtb	r2, r2
34008958:	e012      	b.n	34008980 <HAL_I2C_Mem_Write+0x104>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
3400895a:	0a32      	lsrs	r2, r6, #8
3400895c:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3400895e:	4641      	mov	r1, r8
34008960:	462a      	mov	r2, r5
34008962:	4620      	mov	r0, r4
34008964:	f7ff fdf0 	bl	34008548 <I2C_WaitOnTXISFlagUntilTimeout>
34008968:	b908      	cbnz	r0, 3400896e <HAL_I2C_Mem_Write+0xf2>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3400896a:	6823      	ldr	r3, [r4, #0]
3400896c:	e7df      	b.n	3400892e <HAL_I2C_Mem_Write+0xb2>
      __HAL_UNLOCK(hi2c);
3400896e:	2300      	movs	r3, #0
34008970:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
34008974:	e7a1      	b.n	340088ba <HAL_I2C_Mem_Write+0x3e>
      hi2c->XferSize = MAX_NBYTE_SIZE;
34008976:	22ff      	movs	r2, #255	@ 0xff
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
34008978:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
      hi2c->XferSize = MAX_NBYTE_SIZE;
3400897c:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
3400897e:	9000      	str	r0, [sp, #0]
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
34008980:	4639      	mov	r1, r7
34008982:	4620      	mov	r0, r4
34008984:	f7ff fcfa 	bl	3400837c <I2C_TransferConfig>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
34008988:	462a      	mov	r2, r5
3400898a:	4641      	mov	r1, r8
3400898c:	4620      	mov	r0, r4
3400898e:	f7ff fddb 	bl	34008548 <I2C_WaitOnTXISFlagUntilTimeout>
34008992:	2800      	cmp	r0, #0
34008994:	d191      	bne.n	340088ba <HAL_I2C_Mem_Write+0x3e>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
34008996:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34008998:	6822      	ldr	r2, [r4, #0]
3400899a:	f813 1b01 	ldrb.w	r1, [r3], #1
3400899e:	6291      	str	r1, [r2, #40]	@ 0x28
      hi2c->pBuffPtr++;
340089a0:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
340089a2:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
340089a4:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->XferCount--;
340089a6:	3b01      	subs	r3, #1
340089a8:	b29b      	uxth	r3, r3
340089aa:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340089ac:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
340089ae:	3a01      	subs	r2, #1
340089b0:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340089b2:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
340089b4:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340089b6:	b1b3      	cbz	r3, 340089e6 <HAL_I2C_Mem_Write+0x16a>
340089b8:	b9aa      	cbnz	r2, 340089e6 <HAL_I2C_Mem_Write+0x16a>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
340089ba:	4643      	mov	r3, r8
340089bc:	2180      	movs	r1, #128	@ 0x80
340089be:	4620      	mov	r0, r4
340089c0:	9500      	str	r5, [sp, #0]
340089c2:	f7ff fdec 	bl	3400859e <I2C_WaitOnFlagUntilTimeout>
340089c6:	2800      	cmp	r0, #0
340089c8:	f47f af77 	bne.w	340088ba <HAL_I2C_Mem_Write+0x3e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
340089cc:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
340089ce:	b29b      	uxth	r3, r3
340089d0:	2bff      	cmp	r3, #255	@ 0xff
340089d2:	d928      	bls.n	34008a26 <HAL_I2C_Mem_Write+0x1aa>
          hi2c->XferSize = MAX_NBYTE_SIZE;
340089d4:	22ff      	movs	r2, #255	@ 0xff
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
340089d6:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
340089da:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
340089dc:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
340089de:	4639      	mov	r1, r7
340089e0:	4620      	mov	r0, r4
340089e2:	f7ff fccb 	bl	3400837c <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
340089e6:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
340089e8:	b29b      	uxth	r3, r3
340089ea:	2b00      	cmp	r3, #0
340089ec:	d1cc      	bne.n	34008988 <HAL_I2C_Mem_Write+0x10c>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
340089ee:	462a      	mov	r2, r5
340089f0:	4641      	mov	r1, r8
340089f2:	4620      	mov	r0, r4
340089f4:	f7ff fe0e 	bl	34008614 <I2C_WaitOnSTOPFlagUntilTimeout>
340089f8:	2800      	cmp	r0, #0
340089fa:	f47f af5e 	bne.w	340088ba <HAL_I2C_Mem_Write+0x3e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
340089fe:	2120      	movs	r1, #32
34008a00:	6823      	ldr	r3, [r4, #0]
34008a02:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
34008a04:	685a      	ldr	r2, [r3, #4]
34008a06:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
34008a0a:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
34008a0e:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
34008a12:	f022 0201 	bic.w	r2, r2, #1
34008a16:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
34008a18:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
34008a1c:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
34008a20:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
34008a24:	e74a      	b.n	340088bc <HAL_I2C_Mem_Write+0x40>
          hi2c->XferSize = hi2c->XferCount;
34008a26:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008a28:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
          hi2c->XferSize = hi2c->XferCount;
34008a2c:	b292      	uxth	r2, r2
34008a2e:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008a30:	9000      	str	r0, [sp, #0]
34008a32:	b2d2      	uxtb	r2, r2
34008a34:	e7d3      	b.n	340089de <HAL_I2C_Mem_Write+0x162>
    __HAL_LOCK(hi2c);
34008a36:	2002      	movs	r0, #2
34008a38:	e740      	b.n	340088bc <HAL_I2C_Mem_Write+0x40>
34008a3a:	bf00      	nop
34008a3c:	3401ffb3 	.word	0x3401ffb3
34008a40:	80002000 	.word	0x80002000

34008a44 <HAL_I2C_Mem_Read>:
{
34008a44:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
34008a48:	4699      	mov	r9, r3
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
34008a4a:	3b01      	subs	r3, #1
34008a4c:	2b01      	cmp	r3, #1
{
34008a4e:	4604      	mov	r4, r0
34008a50:	460f      	mov	r7, r1
34008a52:	4616      	mov	r6, r2
34008a54:	f8bd a034 	ldrh.w	sl, [sp, #52]	@ 0x34
34008a58:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
34008a5c:	d904      	bls.n	34008a68 <HAL_I2C_Mem_Read+0x24>
34008a5e:	f640 21c1 	movw	r1, #2753	@ 0xac1
34008a62:	4869      	ldr	r0, [pc, #420]	@ (34008c08 <HAL_I2C_Mem_Read+0x1c4>)
34008a64:	f7fa f8d4 	bl	34002c10 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_READY)
34008a68:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
34008a6c:	2b20      	cmp	r3, #32
34008a6e:	f040 80c9 	bne.w	34008c04 <HAL_I2C_Mem_Read+0x1c0>
    if ((pData == NULL) || (Size == 0U))
34008a72:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
34008a74:	b113      	cbz	r3, 34008a7c <HAL_I2C_Mem_Read+0x38>
34008a76:	f1ba 0f00 	cmp.w	sl, #0
34008a7a:	d106      	bne.n	34008a8a <HAL_I2C_Mem_Read+0x46>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
34008a7c:	f44f 7300 	mov.w	r3, #512	@ 0x200
34008a80:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
34008a82:	2001      	movs	r0, #1
}
34008a84:	b003      	add	sp, #12
34008a86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
34008a8a:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
34008a8e:	2b01      	cmp	r3, #1
34008a90:	f000 80b8 	beq.w	34008c04 <HAL_I2C_Mem_Read+0x1c0>
34008a94:	f04f 0b01 	mov.w	fp, #1
34008a98:	f884 b040 	strb.w	fp, [r4, #64]	@ 0x40
    tickstart = HAL_GetTick();
34008a9c:	f7fc f9ee 	bl	34004e7c <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34008aa0:	2319      	movs	r3, #25
34008aa2:	9000      	str	r0, [sp, #0]
    tickstart = HAL_GetTick();
34008aa4:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34008aa6:	465a      	mov	r2, fp
34008aa8:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34008aac:	4620      	mov	r0, r4
34008aae:	f7ff fd76 	bl	3400859e <I2C_WaitOnFlagUntilTimeout>
34008ab2:	4603      	mov	r3, r0
34008ab4:	2800      	cmp	r0, #0
34008ab6:	d1e4      	bne.n	34008a82 <HAL_I2C_Mem_Read+0x3e>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
34008ab8:	2222      	movs	r2, #34	@ 0x22
34008aba:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
34008abe:	2240      	movs	r2, #64	@ 0x40
34008ac0:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
    hi2c->pBuffPtr  = pData;
34008ac4:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34008ac6:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->pBuffPtr  = pData;
34008ac8:	6262      	str	r2, [r4, #36]	@ 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
34008aca:	4a50      	ldr	r2, [pc, #320]	@ (34008c0c <HAL_I2C_Mem_Read+0x1c8>)
    hi2c->XferISR   = NULL;
34008acc:	6360      	str	r0, [r4, #52]	@ 0x34
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
34008ace:	4639      	mov	r1, r7
34008ad0:	4620      	mov	r0, r4
    hi2c->XferCount = Size;
34008ad2:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
34008ad6:	9200      	str	r2, [sp, #0]
34008ad8:	fa5f f289 	uxtb.w	r2, r9
34008adc:	f7ff fc4e 	bl	3400837c <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34008ae0:	462a      	mov	r2, r5
34008ae2:	4641      	mov	r1, r8
34008ae4:	4620      	mov	r0, r4
34008ae6:	f7ff fd2f 	bl	34008548 <I2C_WaitOnTXISFlagUntilTimeout>
34008aea:	bb20      	cbnz	r0, 34008b36 <HAL_I2C_Mem_Read+0xf2>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
34008aec:	f1b9 0f01 	cmp.w	r9, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34008af0:	6823      	ldr	r3, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
34008af2:	d116      	bne.n	34008b22 <HAL_I2C_Mem_Read+0xde>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34008af4:	b2f6      	uxtb	r6, r6
34008af6:	629e      	str	r6, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
34008af8:	2200      	movs	r2, #0
34008afa:	4643      	mov	r3, r8
34008afc:	2140      	movs	r1, #64	@ 0x40
34008afe:	4620      	mov	r0, r4
34008b00:	9500      	str	r5, [sp, #0]
34008b02:	f7ff fd4c 	bl	3400859e <I2C_WaitOnFlagUntilTimeout>
34008b06:	b9b0      	cbnz	r0, 34008b36 <HAL_I2C_Mem_Read+0xf2>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
34008b08:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34008b0a:	b29b      	uxth	r3, r3
34008b0c:	2bff      	cmp	r3, #255	@ 0xff
34008b0e:	4b40      	ldr	r3, [pc, #256]	@ (34008c10 <HAL_I2C_Mem_Read+0x1cc>)
34008b10:	d815      	bhi.n	34008b3e <HAL_I2C_Mem_Read+0xfa>
      hi2c->XferSize = hi2c->XferCount;
34008b12:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
34008b14:	b292      	uxth	r2, r2
34008b16:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008b18:	9300      	str	r3, [sp, #0]
34008b1a:	b2d2      	uxtb	r2, r2
34008b1c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34008b20:	e012      	b.n	34008b48 <HAL_I2C_Mem_Read+0x104>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
34008b22:	0a32      	lsrs	r2, r6, #8
34008b24:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34008b26:	4641      	mov	r1, r8
34008b28:	462a      	mov	r2, r5
34008b2a:	4620      	mov	r0, r4
34008b2c:	f7ff fd0c 	bl	34008548 <I2C_WaitOnTXISFlagUntilTimeout>
34008b30:	b908      	cbnz	r0, 34008b36 <HAL_I2C_Mem_Read+0xf2>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34008b32:	6823      	ldr	r3, [r4, #0]
34008b34:	e7de      	b.n	34008af4 <HAL_I2C_Mem_Read+0xb0>
      __HAL_UNLOCK(hi2c);
34008b36:	2300      	movs	r3, #0
34008b38:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
34008b3c:	e7a1      	b.n	34008a82 <HAL_I2C_Mem_Read+0x3e>
      hi2c->XferSize = MAX_NBYTE_SIZE;
34008b3e:	22ff      	movs	r2, #255	@ 0xff
34008b40:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
34008b42:	9300      	str	r3, [sp, #0]
34008b44:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008b48:	4639      	mov	r1, r7
34008b4a:	4620      	mov	r0, r4
34008b4c:	f7ff fc16 	bl	3400837c <I2C_TransferConfig>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
34008b50:	4643      	mov	r3, r8
34008b52:	2200      	movs	r2, #0
34008b54:	2104      	movs	r1, #4
34008b56:	4620      	mov	r0, r4
34008b58:	9500      	str	r5, [sp, #0]
34008b5a:	f7ff fd20 	bl	3400859e <I2C_WaitOnFlagUntilTimeout>
34008b5e:	2800      	cmp	r0, #0
34008b60:	d18f      	bne.n	34008a82 <HAL_I2C_Mem_Read+0x3e>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
34008b62:	6823      	ldr	r3, [r4, #0]
34008b64:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34008b66:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34008b68:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
34008b6a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
      hi2c->XferSize--;
34008b6c:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->pBuffPtr++;
34008b6e:	3301      	adds	r3, #1
34008b70:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
34008b72:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
34008b74:	3a01      	subs	r2, #1
      hi2c->XferCount--;
34008b76:	3b01      	subs	r3, #1
34008b78:	b29b      	uxth	r3, r3
34008b7a:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34008b7c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
34008b7e:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34008b80:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
34008b82:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34008b84:	b1b3      	cbz	r3, 34008bb4 <HAL_I2C_Mem_Read+0x170>
34008b86:	b9aa      	cbnz	r2, 34008bb4 <HAL_I2C_Mem_Read+0x170>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
34008b88:	4643      	mov	r3, r8
34008b8a:	2180      	movs	r1, #128	@ 0x80
34008b8c:	4620      	mov	r0, r4
34008b8e:	9500      	str	r5, [sp, #0]
34008b90:	f7ff fd05 	bl	3400859e <I2C_WaitOnFlagUntilTimeout>
34008b94:	2800      	cmp	r0, #0
34008b96:	f47f af74 	bne.w	34008a82 <HAL_I2C_Mem_Read+0x3e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
34008b9a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34008b9c:	b29b      	uxth	r3, r3
34008b9e:	2bff      	cmp	r3, #255	@ 0xff
34008ba0:	d928      	bls.n	34008bf4 <HAL_I2C_Mem_Read+0x1b0>
          hi2c->XferSize = MAX_NBYTE_SIZE;
34008ba2:	22ff      	movs	r2, #255	@ 0xff
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
34008ba4:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
34008ba8:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
34008baa:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008bac:	4639      	mov	r1, r7
34008bae:	4620      	mov	r0, r4
34008bb0:	f7ff fbe4 	bl	3400837c <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
34008bb4:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34008bb6:	b29b      	uxth	r3, r3
34008bb8:	2b00      	cmp	r3, #0
34008bba:	d1c9      	bne.n	34008b50 <HAL_I2C_Mem_Read+0x10c>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
34008bbc:	462a      	mov	r2, r5
34008bbe:	4641      	mov	r1, r8
34008bc0:	4620      	mov	r0, r4
34008bc2:	f7ff fd27 	bl	34008614 <I2C_WaitOnSTOPFlagUntilTimeout>
34008bc6:	2800      	cmp	r0, #0
34008bc8:	f47f af5b 	bne.w	34008a82 <HAL_I2C_Mem_Read+0x3e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34008bcc:	2120      	movs	r1, #32
34008bce:	6823      	ldr	r3, [r4, #0]
34008bd0:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
34008bd2:	685a      	ldr	r2, [r3, #4]
34008bd4:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
34008bd8:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
34008bdc:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
34008be0:	f022 0201 	bic.w	r2, r2, #1
34008be4:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
34008be6:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
34008bea:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
34008bee:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
34008bf2:	e747      	b.n	34008a84 <HAL_I2C_Mem_Read+0x40>
          hi2c->XferSize = hi2c->XferCount;
34008bf4:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008bf6:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
          hi2c->XferSize = hi2c->XferCount;
34008bfa:	b292      	uxth	r2, r2
34008bfc:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008bfe:	9000      	str	r0, [sp, #0]
34008c00:	b2d2      	uxtb	r2, r2
34008c02:	e7d3      	b.n	34008bac <HAL_I2C_Mem_Read+0x168>
    __HAL_LOCK(hi2c);
34008c04:	2002      	movs	r0, #2
34008c06:	e73d      	b.n	34008a84 <HAL_I2C_Mem_Read+0x40>
34008c08:	3401ffb3 	.word	0x3401ffb3
34008c0c:	80002000 	.word	0x80002000
34008c10:	80002400 	.word	0x80002400

34008c14 <HAL_I2C_GetState>:
  return hi2c->State;
34008c14:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
}
34008c18:	4770      	bx	lr

34008c1a <HAL_I2C_GetError>:
  return hi2c->ErrorCode;
34008c1a:	6c40      	ldr	r0, [r0, #68]	@ 0x44
}
34008c1c:	4770      	bx	lr
	...

34008c20 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
34008c20:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008c22:	4a27      	ldr	r2, [pc, #156]	@ (34008cc0 <HAL_I2CEx_ConfigAnalogFilter+0xa0>)
34008c24:	6803      	ldr	r3, [r0, #0]
{
34008c26:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008c28:	4293      	cmp	r3, r2
{
34008c2a:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008c2c:	d01c      	beq.n	34008c68 <HAL_I2CEx_ConfigAnalogFilter+0x48>
34008c2e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008c32:	4293      	cmp	r3, r2
34008c34:	d018      	beq.n	34008c68 <HAL_I2CEx_ConfigAnalogFilter+0x48>
34008c36:	4a23      	ldr	r2, [pc, #140]	@ (34008cc4 <HAL_I2CEx_ConfigAnalogFilter+0xa4>)
34008c38:	4293      	cmp	r3, r2
34008c3a:	d015      	beq.n	34008c68 <HAL_I2CEx_ConfigAnalogFilter+0x48>
34008c3c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008c40:	4293      	cmp	r3, r2
34008c42:	d011      	beq.n	34008c68 <HAL_I2CEx_ConfigAnalogFilter+0x48>
34008c44:	4a20      	ldr	r2, [pc, #128]	@ (34008cc8 <HAL_I2CEx_ConfigAnalogFilter+0xa8>)
34008c46:	4293      	cmp	r3, r2
34008c48:	d00e      	beq.n	34008c68 <HAL_I2CEx_ConfigAnalogFilter+0x48>
34008c4a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008c4e:	4293      	cmp	r3, r2
34008c50:	d00a      	beq.n	34008c68 <HAL_I2CEx_ConfigAnalogFilter+0x48>
34008c52:	4a1e      	ldr	r2, [pc, #120]	@ (34008ccc <HAL_I2CEx_ConfigAnalogFilter+0xac>)
34008c54:	4293      	cmp	r3, r2
34008c56:	d007      	beq.n	34008c68 <HAL_I2CEx_ConfigAnalogFilter+0x48>
34008c58:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008c5c:	4293      	cmp	r3, r2
34008c5e:	d003      	beq.n	34008c68 <HAL_I2CEx_ConfigAnalogFilter+0x48>
34008c60:	2162      	movs	r1, #98	@ 0x62
34008c62:	481b      	ldr	r0, [pc, #108]	@ (34008cd0 <HAL_I2CEx_ConfigAnalogFilter+0xb0>)
34008c64:	f7f9 ffd4 	bl	34002c10 <assert_failed>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
34008c68:	f435 5380 	bics.w	r3, r5, #4096	@ 0x1000
34008c6c:	d003      	beq.n	34008c76 <HAL_I2CEx_ConfigAnalogFilter+0x56>
34008c6e:	2163      	movs	r1, #99	@ 0x63
34008c70:	4817      	ldr	r0, [pc, #92]	@ (34008cd0 <HAL_I2CEx_ConfigAnalogFilter+0xb0>)
34008c72:	f7f9 ffcd 	bl	34002c10 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
34008c76:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
34008c7a:	2b20      	cmp	r3, #32
34008c7c:	b2d9      	uxtb	r1, r3
34008c7e:	d11c      	bne.n	34008cba <HAL_I2CEx_ConfigAnalogFilter+0x9a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
34008c80:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
34008c84:	2b01      	cmp	r3, #1
34008c86:	d018      	beq.n	34008cba <HAL_I2CEx_ConfigAnalogFilter+0x9a>

    hi2c->State = HAL_I2C_STATE_BUSY;
34008c88:	2324      	movs	r3, #36	@ 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34008c8a:	2000      	movs	r0, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
34008c8c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    __HAL_I2C_DISABLE(hi2c);
34008c90:	6823      	ldr	r3, [r4, #0]
34008c92:	681a      	ldr	r2, [r3, #0]
34008c94:	f022 0201 	bic.w	r2, r2, #1
34008c98:	601a      	str	r2, [r3, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
34008c9a:	681a      	ldr	r2, [r3, #0]
34008c9c:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
34008ca0:	601a      	str	r2, [r3, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
34008ca2:	681a      	ldr	r2, [r3, #0]
34008ca4:	432a      	orrs	r2, r5
34008ca6:	601a      	str	r2, [r3, #0]
    __HAL_I2C_ENABLE(hi2c);
34008ca8:	681a      	ldr	r2, [r3, #0]
34008caa:	f042 0201 	orr.w	r2, r2, #1
34008cae:	601a      	str	r2, [r3, #0]
    hi2c->State = HAL_I2C_STATE_READY;
34008cb0:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
34008cb4:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
34008cb8:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_LOCK(hi2c);
34008cba:	2002      	movs	r0, #2
34008cbc:	e7fc      	b.n	34008cb8 <HAL_I2CEx_ConfigAnalogFilter+0x98>
34008cbe:	bf00      	nop
34008cc0:	50005400 	.word	0x50005400
34008cc4:	50005800 	.word	0x50005800
34008cc8:	50005c00 	.word	0x50005c00
34008ccc:	56001c00 	.word	0x56001c00
34008cd0:	34020076 	.word	0x34020076

34008cd4 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
34008cd4:	b538      	push	{r3, r4, r5, lr}
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008cd6:	4a26      	ldr	r2, [pc, #152]	@ (34008d70 <HAL_I2CEx_ConfigDigitalFilter+0x9c>)
34008cd8:	6803      	ldr	r3, [r0, #0]
{
34008cda:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008cdc:	4293      	cmp	r3, r2
{
34008cde:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008ce0:	d01c      	beq.n	34008d1c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008ce2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008ce6:	4293      	cmp	r3, r2
34008ce8:	d018      	beq.n	34008d1c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008cea:	4a22      	ldr	r2, [pc, #136]	@ (34008d74 <HAL_I2CEx_ConfigDigitalFilter+0xa0>)
34008cec:	4293      	cmp	r3, r2
34008cee:	d015      	beq.n	34008d1c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008cf0:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008cf4:	4293      	cmp	r3, r2
34008cf6:	d011      	beq.n	34008d1c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008cf8:	4a1f      	ldr	r2, [pc, #124]	@ (34008d78 <HAL_I2CEx_ConfigDigitalFilter+0xa4>)
34008cfa:	4293      	cmp	r3, r2
34008cfc:	d00e      	beq.n	34008d1c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008cfe:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008d02:	4293      	cmp	r3, r2
34008d04:	d00a      	beq.n	34008d1c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008d06:	4a1d      	ldr	r2, [pc, #116]	@ (34008d7c <HAL_I2CEx_ConfigDigitalFilter+0xa8>)
34008d08:	4293      	cmp	r3, r2
34008d0a:	d007      	beq.n	34008d1c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008d0c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008d10:	4293      	cmp	r3, r2
34008d12:	d003      	beq.n	34008d1c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008d14:	2190      	movs	r1, #144	@ 0x90
34008d16:	481a      	ldr	r0, [pc, #104]	@ (34008d80 <HAL_I2CEx_ConfigDigitalFilter+0xac>)
34008d18:	f7f9 ff7a 	bl	34002c10 <assert_failed>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
34008d1c:	2d0f      	cmp	r5, #15
34008d1e:	d903      	bls.n	34008d28 <HAL_I2CEx_ConfigDigitalFilter+0x54>
34008d20:	2191      	movs	r1, #145	@ 0x91
34008d22:	4817      	ldr	r0, [pc, #92]	@ (34008d80 <HAL_I2CEx_ConfigDigitalFilter+0xac>)
34008d24:	f7f9 ff74 	bl	34002c10 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
34008d28:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
34008d2c:	2b20      	cmp	r3, #32
34008d2e:	b2d8      	uxtb	r0, r3
34008d30:	d11b      	bne.n	34008d6a <HAL_I2CEx_ConfigDigitalFilter+0x96>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
34008d32:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
34008d36:	2b01      	cmp	r3, #1
34008d38:	d017      	beq.n	34008d6a <HAL_I2CEx_ConfigDigitalFilter+0x96>

    hi2c->State = HAL_I2C_STATE_BUSY;
34008d3a:	2324      	movs	r3, #36	@ 0x24
34008d3c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
34008d40:	6823      	ldr	r3, [r4, #0]
34008d42:	681a      	ldr	r2, [r3, #0]
34008d44:	f022 0201 	bic.w	r2, r2, #1
34008d48:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
34008d4a:	681a      	ldr	r2, [r3, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
34008d4c:	f422 6270 	bic.w	r2, r2, #3840	@ 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
34008d50:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
34008d54:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
34008d56:	681a      	ldr	r2, [r3, #0]
34008d58:	f042 0201 	orr.w	r2, r2, #1
34008d5c:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
34008d5e:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34008d62:	2000      	movs	r0, #0
34008d64:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
34008d68:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_LOCK(hi2c);
34008d6a:	2002      	movs	r0, #2
34008d6c:	e7fc      	b.n	34008d68 <HAL_I2CEx_ConfigDigitalFilter+0x94>
34008d6e:	bf00      	nop
34008d70:	50005400 	.word	0x50005400
34008d74:	50005800 	.word	0x50005800
34008d78:	50005c00 	.word	0x50005c00
34008d7c:	56001c00 	.word	0x56001c00
34008d80:	34020076 	.word	0x34020076

34008d84 <LTDC_SetConfig>:
  *       This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, uint32_t Aux0Addr, uint32_t Aux1Addr, uint32_t Mirror,
                           uint32_t LayerIdx)
{
34008d84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t stride;
  uint32_t tmp;

  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
34008d88:	2634      	movs	r6, #52	@ 0x34
{
34008d8a:	b087      	sub	sp, #28
34008d8c:	f8dd c040 	ldr.w	ip, [sp, #64]	@ 0x40
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
34008d90:	6804      	ldr	r4, [r0, #0]
34008d92:	fb06 060c 	mla	r6, r6, ip, r0

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008d96:	f8d6 e048 	ldr.w	lr, [r6, #72]	@ 0x48
{
34008d9a:	e9cd 2302 	strd	r2, r3, [sp, #8]
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
34008d9e:	6e75      	ldr	r5, [r6, #100]	@ 0x64
34008da0:	f10c 0301 	add.w	r3, ip, #1
34008da4:	eb04 2303 	add.w	r3, r4, r3, lsl #8
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008da8:	f1be 0f03 	cmp.w	lr, #3
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
34008dac:	63dd      	str	r5, [r3, #60]	@ 0x3c
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008dae:	d84c      	bhi.n	34008e4a <LTDC_SetConfig+0xc6>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
34008db0:	2604      	movs	r6, #4
      stride = 1U;
      break;
  }

  /* Configure the horizontal start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34008db2:	2734      	movs	r7, #52	@ 0x34
34008db4:	fb07 000c 	mla	r0, r7, ip, r0
34008db8:	f8d4 c00c 	ldr.w	ip, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
34008dbc:	f8d0 b038 	ldr.w	fp, [r0, #56]	@ 0x38
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34008dc0:	68e7      	ldr	r7, [r4, #12]
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34008dc2:	f8d0 803c 	ldr.w	r8, [r0, #60]	@ 0x3c
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34008dc6:	f10b 0901 	add.w	r9, fp, #1
34008dca:	f3c7 470b 	ubfx	r7, r7, #16, #12
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34008dce:	f3cc 4c0b 	ubfx	ip, ip, #16, #12
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34008dd2:	444f      	add	r7, r9
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34008dd4:	44c4      	add	ip, r8
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34008dd6:	ea47 470c 	orr.w	r7, r7, ip, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
34008dda:	611f      	str	r7, [r3, #16]

  /* Configure the vertical start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34008ddc:	6c47      	ldr	r7, [r0, #68]	@ 0x44
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
34008dde:	6c02      	ldr	r2, [r0, #64]	@ 0x40
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34008de0:	9704      	str	r7, [sp, #16]
34008de2:	68e7      	ldr	r7, [r4, #12]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008de4:	68e4      	ldr	r4, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
34008de6:	9205      	str	r2, [sp, #20]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008de8:	f3c4 0c0b 	ubfx	ip, r4, #0, #12
34008dec:	1c54      	adds	r4, r2, #1
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34008dee:	9a04      	ldr	r2, [sp, #16]
34008df0:	f3c7 070b 	ubfx	r7, r7, #0, #12
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008df4:	4464      	add	r4, ip
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34008df6:	4417      	add	r7, r2
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008df8:	ea44 4407 	orr.w	r4, r4, r7, lsl #16

  if (Mirror == LTDC_MIRROR_NONE)
  {
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34008dfc:	6dc2      	ldr	r2, [r0, #92]	@ 0x5c
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
34008dfe:	615c      	str	r4, [r3, #20]
        /* Configure the auxiliary frame buffer address 1 */
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;

        /* Configure the buffer length */
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34008e00:	eba8 040b 	sub.w	r4, r8, fp
        break;
    }

    /* Configure the color frame buffer pitch in byte */
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0) *
34008e04:	fb04 f906 	mul.w	r9, r4, r6
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34008e08:	9201      	str	r2, [sp, #4]
  if (Mirror == LTDC_MIRROR_NONE)
34008e0a:	9a03      	ldr	r2, [sp, #12]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34008e0c:	6e00      	ldr	r0, [r0, #96]	@ 0x60
  if (Mirror == LTDC_MIRROR_NONE)
34008e0e:	2a03      	cmp	r2, #3
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34008e10:	fb00 fc06 	mul.w	ip, r0, r6
                                            stride)  + 7U));
34008e14:	f109 0a07 	add.w	sl, r9, #7
  if (Mirror == LTDC_MIRROR_NONE)
34008e18:	d145      	bne.n	34008ea6 <LTDC_SetConfig+0x122>
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008e1a:	f240 160d 	movw	r6, #269	@ 0x10d
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34008e1e:	9a01      	ldr	r2, [sp, #4]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008e20:	45b6      	cmp	lr, r6
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34008e22:	635a      	str	r2, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008e24:	d02a      	beq.n	34008e7c <LTDC_SetConfig+0xf8>
34008e26:	f240 260d 	movw	r6, #525	@ 0x20d
34008e2a:	45b6      	cmp	lr, r6
34008e2c:	d031      	beq.n	34008e92 <LTDC_SetConfig+0x10e>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34008e2e:	ea4a 420c 	orr.w	r2, sl, ip, lsl #16
34008e32:	639a      	str	r2, [r3, #56]	@ 0x38
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable LTDC_Layer by setting LEN bit */
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
34008e34:	68da      	ldr	r2, [r3, #12]
34008e36:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
34008e3a:	f022 0201 	bic.w	r2, r2, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable horizontal mirroring bit & LTDC_Layer by setting LEN bit */
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
34008e3e:	f042 0201 	orr.w	r2, r2, #1
34008e42:	60da      	str	r2, [r3, #12]
  }
}
34008e44:	b007      	add	sp, #28
34008e46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008e4a:	f1ae 0704 	sub.w	r7, lr, #4
34008e4e:	2f09      	cmp	r7, #9
34008e50:	f04f 0601 	mov.w	r6, #1
34008e54:	d8ad      	bhi.n	34008db2 <LTDC_SetConfig+0x2e>
34008e56:	f240 299b 	movw	r9, #667	@ 0x29b
34008e5a:	fa06 f807 	lsl.w	r8, r6, r7
34008e5e:	ea18 0f09 	tst.w	r8, r9
34008e62:	d107      	bne.n	34008e74 <LTDC_SetConfig+0xf0>
34008e64:	2f02      	cmp	r7, #2
34008e66:	d007      	beq.n	34008e78 <LTDC_SetConfig+0xf4>
34008e68:	2f08      	cmp	r7, #8
34008e6a:	d1a2      	bne.n	34008db2 <LTDC_SetConfig+0x2e>
      stride = (((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos);
34008e6c:	6f9e      	ldr	r6, [r3, #120]	@ 0x78
34008e6e:	f3c6 4682 	ubfx	r6, r6, #18, #3
      break;
34008e72:	e79e      	b.n	34008db2 <LTDC_SetConfig+0x2e>
      stride = 2U;
34008e74:	2602      	movs	r6, #2
34008e76:	e79c      	b.n	34008db2 <LTDC_SetConfig+0x2e>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008e78:	2603      	movs	r6, #3
34008e7a:	e79a      	b.n	34008db2 <LTDC_SetConfig+0x2e>
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
34008e7c:	f108 0207 	add.w	r2, r8, #7
34008e80:	eba2 020b 	sub.w	r2, r2, fp
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34008e84:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
34008e88:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34008e8a:	649a      	str	r2, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
34008e8c:	086d      	lsrs	r5, r5, #1
34008e8e:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34008e90:	e7cd      	b.n	34008e2e <LTDC_SetConfig+0xaa>
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34008e92:	0864      	lsrs	r4, r4, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
34008e94:	9a02      	ldr	r2, [sp, #8]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008e96:	0840      	lsrs	r0, r0, #1
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34008e98:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008e9a:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
34008e9e:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
34008ea0:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008ea2:	649c      	str	r4, [r3, #72]	@ 0x48
34008ea4:	e7f2      	b.n	34008e8c <LTDC_SetConfig+0x108>
  else if (Mirror == LTDC_MIRROR_HORIZONTAL)
34008ea6:	9a03      	ldr	r2, [sp, #12]
34008ea8:	bb3a      	cbnz	r2, 34008efa <LTDC_SetConfig+0x176>
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
34008eaa:	9a01      	ldr	r2, [sp, #4]
34008eac:	1e57      	subs	r7, r2, #1
34008eae:	444f      	add	r7, r9
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34008eb0:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008eb2:	f240 170d 	movw	r7, #269	@ 0x10d
34008eb6:	45be      	cmp	lr, r7
34008eb8:	d00a      	beq.n	34008ed0 <LTDC_SetConfig+0x14c>
34008eba:	f240 270d 	movw	r7, #525	@ 0x20d
34008ebe:	45be      	cmp	lr, r7
34008ec0:	d010      	beq.n	34008ee4 <LTDC_SetConfig+0x160>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34008ec2:	ea4a 420c 	orr.w	r2, sl, ip, lsl #16
34008ec6:	639a      	str	r2, [r3, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
34008ec8:	68da      	ldr	r2, [r3, #12]
34008eca:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
34008ece:	e7b6      	b.n	34008e3e <LTDC_SetConfig+0xba>
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
34008ed0:	3901      	subs	r1, #1
34008ed2:	4449      	add	r1, r9
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34008ed4:	6419      	str	r1, [r3, #64]	@ 0x40
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34008ed6:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008ed8:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34008edc:	086d      	lsrs	r5, r5, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008ede:	649c      	str	r4, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34008ee0:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34008ee2:	e7ee      	b.n	34008ec2 <LTDC_SetConfig+0x13e>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008ee4:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34008ee6:	4366      	muls	r6, r4
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008ee8:	9a02      	ldr	r2, [sp, #8]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008eea:	3901      	subs	r1, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008eec:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008eee:	4431      	add	r1, r6
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008ef0:	4432      	add	r2, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34008ef2:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008ef4:	0840      	lsrs	r0, r0, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34008ef6:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008ef8:	e7ed      	b.n	34008ed6 <LTDC_SetConfig+0x152>
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34008efa:	e9dd 2704 	ldrd	r2, r7, [sp, #16]
34008efe:	eba2 0807 	sub.w	r8, r2, r7
  else if (Mirror == LTDC_MIRROR_VERTICAL)
34008f02:	9a03      	ldr	r2, [sp, #12]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34008f04:	f5cc 4c00 	rsb	ip, ip, #32768	@ 0x8000
  else if (Mirror == LTDC_MIRROR_VERTICAL)
34008f08:	2a01      	cmp	r2, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34008f0a:	ea4a 4c0c 	orr.w	ip, sl, ip, lsl #16
  else if (Mirror == LTDC_MIRROR_VERTICAL)
34008f0e:	d131      	bne.n	34008f74 <LTDC_SetConfig+0x1f0>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34008f10:	9a01      	ldr	r2, [sp, #4]
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
34008f12:	f108 3aff 	add.w	sl, r8, #4294967295
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34008f16:	fb09 270a 	mla	r7, r9, sl, r2
34008f1a:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008f1c:	f240 170d 	movw	r7, #269	@ 0x10d
34008f20:	45be      	cmp	lr, r7
34008f22:	d006      	beq.n	34008f32 <LTDC_SetConfig+0x1ae>
34008f24:	f240 270d 	movw	r7, #525	@ 0x20d
34008f28:	45be      	cmp	lr, r7
34008f2a:	d00d      	beq.n	34008f48 <LTDC_SetConfig+0x1c4>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
34008f2c:	f8c3 c038 	str.w	ip, [r3, #56]	@ 0x38
34008f30:	e780      	b.n	34008e34 <LTDC_SetConfig+0xb0>
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008f32:	ea4f 0258 	mov.w	r2, r8, lsr #1
34008f36:	3a01      	subs	r2, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34008f38:	fb09 1202 	mla	r2, r9, r2, r1
34008f3c:	641a      	str	r2, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34008f3e:	f8c3 c048 	str.w	ip, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34008f42:	086d      	lsrs	r5, r5, #1
34008f44:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34008f46:	e7f1      	b.n	34008f2c <LTDC_SetConfig+0x1a8>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34008f48:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34008f4a:	4374      	muls	r4, r6
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008f4c:	ea4f 0858 	mov.w	r8, r8, lsr #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34008f50:	0840      	lsrs	r0, r0, #1
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008f52:	f108 38ff 	add.w	r8, r8, #4294967295
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34008f56:	f5c0 4000 	rsb	r0, r0, #32768	@ 0x8000
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34008f5a:	fb04 f808 	mul.w	r8, r4, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34008f5e:	4370      	muls	r0, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34008f60:	9a02      	ldr	r2, [sp, #8]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34008f62:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34008f64:	4441      	add	r1, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34008f66:	4442      	add	r2, r8
                                               stride) << 16U) |
34008f68:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34008f6c:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34008f6e:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34008f70:	649c      	str	r4, [r3, #72]	@ 0x48
34008f72:	e7e6      	b.n	34008f42 <LTDC_SetConfig+0x1be>
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
34008f74:	9a01      	ldr	r2, [sp, #4]
34008f76:	1e57      	subs	r7, r2, #1
34008f78:	fb09 7708 	mla	r7, r9, r8, r7
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34008f7c:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008f7e:	f240 170d 	movw	r7, #269	@ 0x10d
34008f82:	45be      	cmp	lr, r7
34008f84:	d006      	beq.n	34008f94 <LTDC_SetConfig+0x210>
34008f86:	f240 270d 	movw	r7, #525	@ 0x20d
34008f8a:	45be      	cmp	lr, r7
34008f8c:	d00d      	beq.n	34008faa <LTDC_SetConfig+0x226>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
34008f8e:	f8c3 c038 	str.w	ip, [r3, #56]	@ 0x38
34008f92:	e799      	b.n	34008ec8 <LTDC_SetConfig+0x144>
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008f94:	ea4f 0858 	mov.w	r8, r8, lsr #1
34008f98:	3901      	subs	r1, #1
34008f9a:	fb09 1108 	mla	r1, r9, r8, r1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34008f9e:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34008fa0:	f8c3 c048 	str.w	ip, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34008fa4:	086d      	lsrs	r5, r5, #1
34008fa6:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34008fa8:	e7f1      	b.n	34008f8e <LTDC_SetConfig+0x20a>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34008faa:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34008fac:	4374      	muls	r4, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34008fae:	0840      	lsrs	r0, r0, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008fb0:	ea4f 0858 	mov.w	r8, r8, lsr #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34008fb4:	f5c0 4000 	rsb	r0, r0, #32768	@ 0x8000
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34008fb8:	fb04 f808 	mul.w	r8, r4, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34008fbc:	4370      	muls	r0, r6
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008fbe:	9a02      	ldr	r2, [sp, #8]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008fc0:	3901      	subs	r1, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008fc2:	3a01      	subs	r2, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34008fc4:	3407      	adds	r4, #7
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008fc6:	4442      	add	r2, r8
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008fc8:	4441      	add	r1, r8
                                              << 16U) |
34008fca:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34008fce:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34008fd0:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34008fd2:	649c      	str	r4, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR &= ~(LTDC_L1AFBLNR_AFBLNBR);
34008fd4:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
34008fd6:	f36f 020f 	bfc	r2, #0, #16
34008fda:	64da      	str	r2, [r3, #76]	@ 0x4c
34008fdc:	e7e2      	b.n	34008fa4 <LTDC_SetConfig+0x220>
	...

34008fe0 <LTDC_SetCompositionConfig>:

  /* Configure the default color values */
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34008fe0:	6802      	ldr	r2, [r0, #0]
34008fe2:	1c4b      	adds	r3, r1, #1
34008fe4:	eb02 2203 	add.w	r2, r2, r3, lsl #8
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
34008fe8:	2334      	movs	r3, #52	@ 0x34
34008fea:	fb03 0101 	mla	r1, r3, r1, r0
34008fee:	6d08      	ldr	r0, [r1, #80]	@ 0x50
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34008ff0:	f891 3068 	ldrb.w	r3, [r1, #104]	@ 0x68
34008ff4:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
34008ff8:	f891 0069 	ldrb.w	r0, [r1, #105]	@ 0x69
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34008ffc:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
34009000:	f891 006a 	ldrb.w	r0, [r1, #106]	@ 0x6a
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34009004:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34009008:	6253      	str	r3, [r2, #36]	@ 0x24

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
3400900a:	6a13      	ldr	r3, [r2, #32]
3400900c:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
34009010:	6213      	str	r3, [r2, #32]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (hltdc->LayerCfg[LayerIdx].Alpha);
34009012:	6ccb      	ldr	r3, [r1, #76]	@ 0x4c
34009014:	6213      	str	r3, [r2, #32]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BOR | LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
34009016:	6a90      	ldr	r0, [r2, #40]	@ 0x28
34009018:	4b05      	ldr	r3, [pc, #20]	@ (34009030 <LTDC_SetCompositionConfig+0x50>)
3400901a:	4003      	ands	r3, r0
3400901c:	6293      	str	r3, [r2, #40]	@ 0x28
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
3400901e:	6a90      	ldr	r0, [r2, #40]	@ 0x28
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
34009020:	e9d1 3115 	ldrd	r3, r1, [r1, #84]	@ 0x54
34009024:	430b      	orrs	r3, r1
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
34009026:	f400 3180 	and.w	r1, r0, #65536	@ 0x10000
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
3400902a:	430b      	orrs	r3, r1
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3400902c:	6293      	str	r3, [r2, #40]	@ 0x28
}
3400902e:	4770      	bx	lr
34009030:	fffef8f8 	.word	0xfffef8f8

34009034 <LTDC_SetPredefFormat>:
  uint32_t BPOS = 0U;
  uint32_t GLEN = 0U;
  uint32_t GPOS = 0U;

  /* Specify Flex ARGB parameters according to pixel format */
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34009034:	2334      	movs	r3, #52	@ 0x34
34009036:	fb03 0301 	mla	r3, r3, r1, r0
3400903a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
{
3400903c:	b5f0      	push	{r4, r5, r6, r7, lr}
3400903e:	1fd4      	subs	r4, r2, #7
34009040:	2c04      	cmp	r4, #4
34009042:	d823      	bhi.n	3400908c <LTDC_SetPredefFormat+0x58>
34009044:	4a16      	ldr	r2, [pc, #88]	@ (340090a0 <LTDC_SetPredefFormat+0x6c>)
34009046:	f8df c06c 	ldr.w	ip, [pc, #108]	@ 340090b4 <LTDC_SetPredefFormat+0x80>
3400904a:	5d16      	ldrb	r6, [r2, r4]
3400904c:	4a15      	ldr	r2, [pc, #84]	@ (340090a4 <LTDC_SetPredefFormat+0x70>)
3400904e:	4b16      	ldr	r3, [pc, #88]	@ (340090a8 <LTDC_SetPredefFormat+0x74>)
34009050:	5d17      	ldrb	r7, [r2, r4]
34009052:	4a16      	ldr	r2, [pc, #88]	@ (340090ac <LTDC_SetPredefFormat+0x78>)
34009054:	5d1b      	ldrb	r3, [r3, r4]
34009056:	5d15      	ldrb	r5, [r2, r4]
34009058:	4a15      	ldr	r2, [pc, #84]	@ (340090b0 <LTDC_SetPredefFormat+0x7c>)
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
                                           APOS;
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3400905a:	049b      	lsls	r3, r3, #18
3400905c:	5d12      	ldrb	r2, [r2, r4]
3400905e:	f81c 4004 	ldrb.w	r4, [ip, r4]
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
34009062:	f101 0c01 	add.w	ip, r1, #1
34009066:	6801      	ldr	r1, [r0, #0]
34009068:	2007      	movs	r0, #7
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
3400906a:	0252      	lsls	r2, r2, #9
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3400906c:	eb02 3285 	add.w	r2, r2, r5, lsl #14
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
34009070:	443a      	add	r2, r7
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
34009072:	eb03 3385 	add.w	r3, r3, r5, lsl #14
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
34009076:	eb01 210c 	add.w	r1, r1, ip, lsl #8
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
3400907a:	eb02 1246 	add.w	r2, r2, r6, lsl #5
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
3400907e:	4423      	add	r3, r4
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
34009080:	61c8      	str	r0, [r1, #28]
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
34009082:	eb03 1345 	add.w	r3, r3, r5, lsl #5
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34009086:	674a      	str	r2, [r1, #116]	@ 0x74
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = 0U;
34009088:	678b      	str	r3, [r1, #120]	@ 0x78
                                           GPOS;
      break;
    default:
      break;
  }
}
3400908a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400908c:	2a06      	cmp	r2, #6
3400908e:	d8fc      	bhi.n	3400908a <LTDC_SetPredefFormat+0x56>
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
34009090:	6803      	ldr	r3, [r0, #0]
34009092:	3101      	adds	r1, #1
34009094:	eb03 2101 	add.w	r1, r3, r1, lsl #8
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
34009098:	2300      	movs	r3, #0
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
3400909a:	61ca      	str	r2, [r1, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
3400909c:	674b      	str	r3, [r1, #116]	@ 0x74
3400909e:	e7f3      	b.n	34009088 <LTDC_SetPredefFormat+0x54>
340090a0:	340a6dc4 	.word	0x340a6dc4
340090a4:	340a6dbf 	.word	0x340a6dbf
340090a8:	340a6dc9 	.word	0x340a6dc9
340090ac:	340a6dba 	.word	0x340a6dba
340090b0:	340a6db5 	.word	0x340a6db5
340090b4:	340a6db0 	.word	0x340a6db0

340090b8 <LTDC_RetrieveUserConfig.constprop.0>:
static void LTDC_RetrieveUserConfig(LTDC_HandleTypeDef *hltdc, uint32_t *Mirror, uint32_t *Aux0Addr,
340090b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
340090bc:	468c      	mov	ip, r1
340090be:	9907      	ldr	r1, [sp, #28]
  const uint32_t hmirror = ((LTDC_LAYER(hltdc, LayerIdx)->CR) & LTDC_LxCR_HMEN_Msk);
340090c0:	6805      	ldr	r5, [r0, #0]
340090c2:	1c4c      	adds	r4, r1, #1
340090c4:	eb05 2504 	add.w	r5, r5, r4, lsl #8
340090c8:	68ec      	ldr	r4, [r5, #12]
340090ca:	f404 7e80 	and.w	lr, r4, #256	@ 0x100
  const uint32_t pitchSign = (LTDC_LAYER(hltdc, LayerIdx)->CFBLR & LTDC_LxCFBLR_CFBP) & LTDC_PITCH_SIGN_MSK;
340090ce:	6bac      	ldr	r4, [r5, #56]	@ 0x38
340090d0:	f004 4880 	and.w	r8, r4, #1073741824	@ 0x40000000
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340090d4:	2434      	movs	r4, #52	@ 0x34
340090d6:	fb04 0401 	mla	r4, r4, r1, r0
340090da:	6ca6      	ldr	r6, [r4, #72]	@ 0x48
340090dc:	2e03      	cmp	r6, #3
340090de:	d813      	bhi.n	34009108 <LTDC_RetrieveUserConfig.constprop.0+0x50>
      stride = 4U;
340090e0:	2404      	movs	r4, #4
  if ((pitchSign == 0U) && (hmirror == 0U))
340090e2:	f1b8 0f00 	cmp.w	r8, #0
340090e6:	d153      	bne.n	34009190 <LTDC_RetrieveUserConfig.constprop.0+0xd8>
340090e8:	2734      	movs	r7, #52	@ 0x34
340090ea:	f1be 0f00 	cmp.w	lr, #0
340090ee:	d123      	bne.n	34009138 <LTDC_RetrieveUserConfig.constprop.0+0x80>
    *Mirror = LTDC_MIRROR_NONE;
340090f0:	2403      	movs	r4, #3
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
340090f2:	fb07 0701 	mla	r7, r7, r1, r0
    *Mirror = LTDC_MIRROR_NONE;
340090f6:	f8cc 4000 	str.w	r4, [ip]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
340090fa:	6b6c      	ldr	r4, [r5, #52]	@ 0x34
    *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R;
340090fc:	6c29      	ldr	r1, [r5, #64]	@ 0x40
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
340090fe:	65fc      	str	r4, [r7, #92]	@ 0x5c
    *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R;
34009100:	6011      	str	r1, [r2, #0]
    *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R;
34009102:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34009104:	601a      	str	r2, [r3, #0]
}
34009106:	e02d      	b.n	34009164 <LTDC_RetrieveUserConfig.constprop.0+0xac>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34009108:	3e04      	subs	r6, #4
3400910a:	2e09      	cmp	r6, #9
3400910c:	f04f 0401 	mov.w	r4, #1
34009110:	d8e7      	bhi.n	340090e2 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
34009112:	f240 299b 	movw	r9, #667	@ 0x29b
34009116:	fa04 f706 	lsl.w	r7, r4, r6
3400911a:	ea17 0f09 	tst.w	r7, r9
3400911e:	d107      	bne.n	34009130 <LTDC_RetrieveUserConfig.constprop.0+0x78>
34009120:	2e02      	cmp	r6, #2
34009122:	d007      	beq.n	34009134 <LTDC_RetrieveUserConfig.constprop.0+0x7c>
34009124:	2e08      	cmp	r6, #8
34009126:	d1dc      	bne.n	340090e2 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
      stride = ((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos;
34009128:	6fac      	ldr	r4, [r5, #120]	@ 0x78
3400912a:	f3c4 4482 	ubfx	r4, r4, #18, #3
      break;
3400912e:	e7d8      	b.n	340090e2 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
      stride = 2U;
34009130:	2402      	movs	r4, #2
34009132:	e7d6      	b.n	340090e2 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34009134:	2403      	movs	r4, #3
34009136:	e7d4      	b.n	340090e2 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
    *Mirror = LTDC_MIRROR_HORIZONTAL;
34009138:	f8cc 8000 	str.w	r8, [ip]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400913c:	f240 1c0d 	movw	ip, #269	@ 0x10d
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34009140:	fb07 0001 	mla	r0, r7, r1, r0
34009144:	e9d0 710e 	ldrd	r7, r1, [r0, #56]	@ 0x38
34009148:	1bc9      	subs	r1, r1, r7
3400914a:	fb04 f701 	mul.w	r7, r4, r1
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3400914e:	6b6e      	ldr	r6, [r5, #52]	@ 0x34
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
34009150:	3601      	adds	r6, #1
34009152:	1bf6      	subs	r6, r6, r7
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34009154:	65c6      	str	r6, [r0, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34009156:	6c86      	ldr	r6, [r0, #72]	@ 0x48
34009158:	4566      	cmp	r6, ip
3400915a:	d005      	beq.n	34009168 <LTDC_RetrieveUserConfig.constprop.0+0xb0>
3400915c:	f240 270d 	movw	r7, #525	@ 0x20d
34009160:	42be      	cmp	r6, r7
34009162:	d006      	beq.n	34009172 <LTDC_RetrieveUserConfig.constprop.0+0xba>
}
34009164:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34009168:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                               hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
3400916a:	3301      	adds	r3, #1
3400916c:	1bdb      	subs	r3, r3, r7
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400916e:	6013      	str	r3, [r2, #0]
        break;
34009170:	e7f8      	b.n	34009164 <LTDC_RetrieveUserConfig.constprop.0+0xac>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34009172:	6c2e      	ldr	r6, [r5, #64]	@ 0x40
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34009174:	0849      	lsrs	r1, r1, #1
34009176:	3601      	adds	r6, #1
34009178:	fb04 6111 	mls	r1, r4, r1, r6
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
3400917c:	6011      	str	r1, [r2, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - \
3400917e:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34009180:	e9d0 010e 	ldrd	r0, r1, [r0, #56]	@ 0x38
34009184:	1a09      	subs	r1, r1, r0
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34009186:	3201      	adds	r2, #1
34009188:	0849      	lsrs	r1, r1, #1
3400918a:	fb04 2211 	mls	r2, r4, r1, r2
3400918e:	e7b9      	b.n	34009104 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
  else if ((pitchSign != 0U) && (hmirror == 0U))
34009190:	2634      	movs	r6, #52	@ 0x34
34009192:	f1be 0f00 	cmp.w	lr, #0
34009196:	d138      	bne.n	3400920a <LTDC_RetrieveUserConfig.constprop.0+0x152>
    *Mirror = LTDC_MIRROR_VERTICAL;
34009198:	2701      	movs	r7, #1
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400919a:	fb06 0601 	mla	r6, r6, r1, r0
    *Mirror = LTDC_MIRROR_VERTICAL;
3400919e:	f8cc 7000 	str.w	r7, [ip]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
340091a2:	e9d6 100e 	ldrd	r1, r0, [r6, #56]	@ 0x38
340091a6:	1a40      	subs	r0, r0, r1
340091a8:	fb00 fc04 	mul.w	ip, r0, r4
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
340091ac:	e9d6 1710 	ldrd	r1, r7, [r6, #64]	@ 0x40
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
340091b0:	f8d5 8034 	ldr.w	r8, [r5, #52]	@ 0x34
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
340091b4:	1a79      	subs	r1, r7, r1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
340091b6:	f101 3eff 	add.w	lr, r1, #4294967295
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
340091ba:	fb0c 871e 	mls	r7, ip, lr, r8
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340091be:	f240 1e0d 	movw	lr, #269	@ 0x10d
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
340091c2:	65f7      	str	r7, [r6, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340091c4:	6cb7      	ldr	r7, [r6, #72]	@ 0x48
340091c6:	4577      	cmp	r7, lr
340091c8:	d019      	beq.n	340091fe <LTDC_RetrieveUserConfig.constprop.0+0x146>
340091ca:	f240 2c0d 	movw	ip, #525	@ 0x20d
340091ce:	4567      	cmp	r7, ip
340091d0:	d1c8      	bne.n	34009164 <LTDC_RetrieveUserConfig.constprop.0+0xac>
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340091d2:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
340091d4:	0840      	lsrs	r0, r0, #1
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340091d6:	3901      	subs	r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
340091d8:	4341      	muls	r1, r0
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
340091da:	6c2f      	ldr	r7, [r5, #64]	@ 0x40
340091dc:	fb04 7111 	mls	r1, r4, r1, r7
340091e0:	6011      	str	r1, [r2, #0]
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
340091e2:	e9d6 1210 	ldrd	r1, r2, [r6, #64]	@ 0x40
340091e6:	1a52      	subs	r2, r2, r1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
340091e8:	6c68      	ldr	r0, [r5, #68]	@ 0x44
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340091ea:	0852      	lsrs	r2, r2, #1
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
340091ec:	e9d6 510e 	ldrd	r5, r1, [r6, #56]	@ 0x38
340091f0:	1b49      	subs	r1, r1, r5
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340091f2:	3a01      	subs	r2, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
340091f4:	0849      	lsrs	r1, r1, #1
340091f6:	434a      	muls	r2, r1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
340091f8:	fb04 0212 	mls	r2, r4, r2, r0
340091fc:	e782      	b.n	34009104 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
340091fe:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34009200:	0849      	lsrs	r1, r1, #1
34009202:	3901      	subs	r1, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34009204:	fb0c 3311 	mls	r3, ip, r1, r3
34009208:	e7b1      	b.n	3400916e <LTDC_RetrieveUserConfig.constprop.0+0xb6>
    *Mirror = LTDC_MIRROR_HORIZONTAL_VERTICAL;
3400920a:	2702      	movs	r7, #2
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400920c:	fb06 0001 	mla	r0, r6, r1, r0
    *Mirror = LTDC_MIRROR_HORIZONTAL_VERTICAL;
34009210:	f8cc 7000 	str.w	r7, [ip]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34009214:	f8d5 e034 	ldr.w	lr, [r5, #52]	@ 0x34
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34009218:	e9d0 610e 	ldrd	r6, r1, [r0, #56]	@ 0x38
3400921c:	1b89      	subs	r1, r1, r6
                                               (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400921e:	e9d0 7610 	ldrd	r7, r6, [r0, #64]	@ 0x40
34009222:	1bf7      	subs	r7, r6, r7
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
34009224:	f10e 0601 	add.w	r6, lr, #1
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34009228:	f240 1e0d 	movw	lr, #269	@ 0x10d
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400922c:	fb01 fc04 	mul.w	ip, r1, r4
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
34009230:	fb07 661c 	mls	r6, r7, ip, r6
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34009234:	65c6      	str	r6, [r0, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34009236:	6c86      	ldr	r6, [r0, #72]	@ 0x48
34009238:	4576      	cmp	r6, lr
3400923a:	d019      	beq.n	34009270 <LTDC_RetrieveUserConfig.constprop.0+0x1b8>
3400923c:	f240 2c0d 	movw	ip, #525	@ 0x20d
34009240:	4566      	cmp	r6, ip
34009242:	d18f      	bne.n	34009164 <LTDC_RetrieveUserConfig.constprop.0+0xac>
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34009244:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34009246:	087f      	lsrs	r7, r7, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34009248:	4379      	muls	r1, r7
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400924a:	6c2e      	ldr	r6, [r5, #64]	@ 0x40
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3400924c:	3601      	adds	r6, #1
3400924e:	fb04 6111 	mls	r1, r4, r1, r6
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34009252:	6011      	str	r1, [r2, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34009254:	6c69      	ldr	r1, [r5, #68]	@ 0x44
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34009256:	e9d0 520e 	ldrd	r5, r2, [r0, #56]	@ 0x38
3400925a:	1b52      	subs	r2, r2, r5
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400925c:	e9d0 0510 	ldrd	r0, r5, [r0, #64]	@ 0x40
34009260:	1a28      	subs	r0, r5, r0
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34009262:	0852      	lsrs	r2, r2, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34009264:	0840      	lsrs	r0, r0, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34009266:	4342      	muls	r2, r0
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34009268:	3101      	adds	r1, #1
3400926a:	fb04 1212 	mls	r2, r4, r2, r1
3400926e:	e749      	b.n	34009104 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34009270:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34009272:	087f      	lsrs	r7, r7, #1
34009274:	3301      	adds	r3, #1
34009276:	fb0c 3317 	mls	r3, ip, r7, r3
3400927a:	e778      	b.n	3400916e <LTDC_RetrieveUserConfig.constprop.0+0xb6>

3400927c <HAL_LTDC_MspInit>:
}
3400927c:	4770      	bx	lr
	...

34009280 <HAL_LTDC_Init>:
{
34009280:	b538      	push	{r3, r4, r5, lr}
  if (hltdc == NULL)
34009282:	4604      	mov	r4, r0
34009284:	2800      	cmp	r0, #0
34009286:	f000 80c6 	beq.w	34009416 <HAL_LTDC_Init+0x196>
  assert_param(IS_LTDC_ALL_INSTANCE(hltdc->Instance));
3400928a:	6803      	ldr	r3, [r0, #0]
3400928c:	4a63      	ldr	r2, [pc, #396]	@ (3400941c <HAL_LTDC_Init+0x19c>)
3400928e:	4293      	cmp	r3, r2
34009290:	d007      	beq.n	340092a2 <HAL_LTDC_Init+0x22>
34009292:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34009296:	4293      	cmp	r3, r2
34009298:	d003      	beq.n	340092a2 <HAL_LTDC_Init+0x22>
3400929a:	21f8      	movs	r1, #248	@ 0xf8
3400929c:	4860      	ldr	r0, [pc, #384]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
3400929e:	f7f9 fcb7 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_HSYNC(hltdc->Init.HorizontalSync));
340092a2:	6963      	ldr	r3, [r4, #20]
340092a4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340092a8:	d303      	bcc.n	340092b2 <HAL_LTDC_Init+0x32>
340092aa:	21f9      	movs	r1, #249	@ 0xf9
340092ac:	485c      	ldr	r0, [pc, #368]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
340092ae:	f7f9 fcaf 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_VSYNC(hltdc->Init.VerticalSync));
340092b2:	69a3      	ldr	r3, [r4, #24]
340092b4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340092b8:	d303      	bcc.n	340092c2 <HAL_LTDC_Init+0x42>
340092ba:	21fa      	movs	r1, #250	@ 0xfa
340092bc:	4858      	ldr	r0, [pc, #352]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
340092be:	f7f9 fca7 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_AHBP(hltdc->Init.AccumulatedHBP));
340092c2:	69e3      	ldr	r3, [r4, #28]
340092c4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340092c8:	d303      	bcc.n	340092d2 <HAL_LTDC_Init+0x52>
340092ca:	21fb      	movs	r1, #251	@ 0xfb
340092cc:	4854      	ldr	r0, [pc, #336]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
340092ce:	f7f9 fc9f 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_AVBP(hltdc->Init.AccumulatedVBP));
340092d2:	6a23      	ldr	r3, [r4, #32]
340092d4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340092d8:	d303      	bcc.n	340092e2 <HAL_LTDC_Init+0x62>
340092da:	21fc      	movs	r1, #252	@ 0xfc
340092dc:	4850      	ldr	r0, [pc, #320]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
340092de:	f7f9 fc97 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_AAH(hltdc->Init.AccumulatedActiveH));
340092e2:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
340092e4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340092e8:	d303      	bcc.n	340092f2 <HAL_LTDC_Init+0x72>
340092ea:	21fd      	movs	r1, #253	@ 0xfd
340092ec:	484c      	ldr	r0, [pc, #304]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
340092ee:	f7f9 fc8f 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_AAW(hltdc->Init.AccumulatedActiveW));
340092f2:	6a63      	ldr	r3, [r4, #36]	@ 0x24
340092f4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340092f8:	d303      	bcc.n	34009302 <HAL_LTDC_Init+0x82>
340092fa:	21fe      	movs	r1, #254	@ 0xfe
340092fc:	4848      	ldr	r0, [pc, #288]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
340092fe:	f7f9 fc87 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_TOTALH(hltdc->Init.TotalHeigh));
34009302:	6b23      	ldr	r3, [r4, #48]	@ 0x30
34009304:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009308:	d303      	bcc.n	34009312 <HAL_LTDC_Init+0x92>
3400930a:	21ff      	movs	r1, #255	@ 0xff
3400930c:	4844      	ldr	r0, [pc, #272]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
3400930e:	f7f9 fc7f 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_TOTALW(hltdc->Init.TotalWidth));
34009312:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34009314:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009318:	d304      	bcc.n	34009324 <HAL_LTDC_Init+0xa4>
3400931a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400931e:	4840      	ldr	r0, [pc, #256]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
34009320:	f7f9 fc76 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_HSPOL(hltdc->Init.HSPolarity));
34009324:	6863      	ldr	r3, [r4, #4]
34009326:	f033 4300 	bics.w	r3, r3, #2147483648	@ 0x80000000
3400932a:	d004      	beq.n	34009336 <HAL_LTDC_Init+0xb6>
3400932c:	f240 1101 	movw	r1, #257	@ 0x101
34009330:	483b      	ldr	r0, [pc, #236]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
34009332:	f7f9 fc6d 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_VSPOL(hltdc->Init.VSPolarity));
34009336:	68a3      	ldr	r3, [r4, #8]
34009338:	f033 4380 	bics.w	r3, r3, #1073741824	@ 0x40000000
3400933c:	d004      	beq.n	34009348 <HAL_LTDC_Init+0xc8>
3400933e:	f44f 7181 	mov.w	r1, #258	@ 0x102
34009342:	4837      	ldr	r0, [pc, #220]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
34009344:	f7f9 fc64 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_DEPOL(hltdc->Init.DEPolarity));
34009348:	68e3      	ldr	r3, [r4, #12]
3400934a:	f033 5300 	bics.w	r3, r3, #536870912	@ 0x20000000
3400934e:	d004      	beq.n	3400935a <HAL_LTDC_Init+0xda>
34009350:	f240 1103 	movw	r1, #259	@ 0x103
34009354:	4832      	ldr	r0, [pc, #200]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
34009356:	f7f9 fc5b 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_PCPOL(hltdc->Init.PCPolarity));
3400935a:	6923      	ldr	r3, [r4, #16]
3400935c:	f033 5380 	bics.w	r3, r3, #268435456	@ 0x10000000
34009360:	d004      	beq.n	3400936c <HAL_LTDC_Init+0xec>
34009362:	f44f 7182 	mov.w	r1, #260	@ 0x104
34009366:	482e      	ldr	r0, [pc, #184]	@ (34009420 <HAL_LTDC_Init+0x1a0>)
34009368:	f7f9 fc52 	bl	34002c10 <assert_failed>
  if (hltdc->State == HAL_LTDC_STATE_RESET)
3400936c:	f894 30a1 	ldrb.w	r3, [r4, #161]	@ 0xa1
34009370:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
34009374:	b923      	cbnz	r3, 34009380 <HAL_LTDC_Init+0x100>
    HAL_LTDC_MspInit(hltdc);
34009376:	4620      	mov	r0, r4
    hltdc->Lock = HAL_UNLOCKED;
34009378:	f884 20a0 	strb.w	r2, [r4, #160]	@ 0xa0
    HAL_LTDC_MspInit(hltdc);
3400937c:	f7ff ff7e 	bl	3400927c <HAL_LTDC_MspInit>
  hltdc->State = HAL_LTDC_STATE_BUSY;
34009380:	2302      	movs	r3, #2
34009382:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
34009386:	6823      	ldr	r3, [r4, #0]
34009388:	699a      	ldr	r2, [r3, #24]
3400938a:	f022 4270 	bic.w	r2, r2, #4026531840	@ 0xf0000000
3400938e:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34009390:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
34009394:	4302      	orrs	r2, r0
34009396:	68e0      	ldr	r0, [r4, #12]
34009398:	6999      	ldr	r1, [r3, #24]
3400939a:	4302      	orrs	r2, r0
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
3400939c:	6920      	ldr	r0, [r4, #16]
3400939e:	4302      	orrs	r2, r0
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
340093a0:	430a      	orrs	r2, r1
340093a2:	619a      	str	r2, [r3, #24]
  WRITE_REG(hltdc->Instance->SSCR, (tmp | hltdc->Init.VerticalSync));
340093a4:	e9d4 1205 	ldrd	r1, r2, [r4, #20]
340093a8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
340093ac:	609a      	str	r2, [r3, #8]
  WRITE_REG(hltdc->Instance->BPCR, (tmp | hltdc->Init.AccumulatedVBP));
340093ae:	e9d4 1207 	ldrd	r1, r2, [r4, #28]
340093b2:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
340093b6:	60da      	str	r2, [r3, #12]
  WRITE_REG(hltdc->Instance->AWCR, (tmp | hltdc->Init.AccumulatedActiveH));
340093b8:	e9d4 1209 	ldrd	r1, r2, [r4, #36]	@ 0x24
340093bc:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
340093c0:	611a      	str	r2, [r3, #16]
  WRITE_REG(hltdc->Instance->TWCR, (tmp | hltdc->Init.TotalHeigh));
340093c2:	e9d4 120b 	ldrd	r1, r2, [r4, #44]	@ 0x2c
340093c6:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
340093ca:	615a      	str	r2, [r3, #20]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
340093cc:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
340093ce:	f894 0035 	ldrb.w	r0, [r4, #53]	@ 0x35
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
340093d2:	f002 427f 	and.w	r2, r2, #4278190080	@ 0xff000000
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
340093d6:	f894 1036 	ldrb.w	r1, [r4, #54]	@ 0x36
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
340093da:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
340093dc:	6add      	ldr	r5, [r3, #44]	@ 0x2c
340093de:	f894 2034 	ldrb.w	r2, [r4, #52]	@ 0x34
340093e2:	432a      	orrs	r2, r5
340093e4:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
340093e8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
340093ec:	62da      	str	r2, [r3, #44]	@ 0x2c
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_1)->RCR, LTDC_LxRCR_GRMSK);
340093ee:	2204      	movs	r2, #4
340093f0:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_2)->RCR, LTDC_LxRCR_GRMSK);
340093f4:	f8c3 2208 	str.w	r2, [r3, #520]	@ 0x208
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
340093f8:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
340093fa:	2000      	movs	r0, #0
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
340093fc:	f042 0244 	orr.w	r2, r2, #68	@ 0x44
34009400:	665a      	str	r2, [r3, #100]	@ 0x64
  __HAL_LTDC_ENABLE(hltdc);
34009402:	699a      	ldr	r2, [r3, #24]
34009404:	f042 0201 	orr.w	r2, r2, #1
34009408:	619a      	str	r2, [r3, #24]
  hltdc->State = HAL_LTDC_STATE_READY;
3400940a:	2301      	movs	r3, #1
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
3400940c:	f8c4 00a4 	str.w	r0, [r4, #164]	@ 0xa4
  hltdc->State = HAL_LTDC_STATE_READY;
34009410:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
}
34009414:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
34009416:	2001      	movs	r0, #1
34009418:	e7fc      	b.n	34009414 <HAL_LTDC_Init+0x194>
3400941a:	bf00      	nop
3400941c:	58001000 	.word	0x58001000
34009420:	3402013c 	.word	0x3402013c

34009424 <HAL_LTDC_ConfigLayer>:
  assert_param(IS_LTDC_LAYER(LayerIdx));
34009424:	2a01      	cmp	r2, #1
{
34009426:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34009428:	4606      	mov	r6, r0
3400942a:	460c      	mov	r4, r1
3400942c:	4617      	mov	r7, r2
  assert_param(IS_LTDC_LAYER(LayerIdx));
3400942e:	d904      	bls.n	3400943a <HAL_LTDC_ConfigLayer+0x16>
34009430:	f240 4104 	movw	r1, #1028	@ 0x404
34009434:	484d      	ldr	r0, [pc, #308]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
34009436:	f7f9 fbeb 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
3400943a:	6823      	ldr	r3, [r4, #0]
3400943c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009440:	d304      	bcc.n	3400944c <HAL_LTDC_ConfigLayer+0x28>
34009442:	f240 4105 	movw	r1, #1029	@ 0x405
34009446:	4849      	ldr	r0, [pc, #292]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
34009448:	f7f9 fbe2 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
3400944c:	6863      	ldr	r3, [r4, #4]
3400944e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009452:	d304      	bcc.n	3400945e <HAL_LTDC_ConfigLayer+0x3a>
34009454:	f240 4106 	movw	r1, #1030	@ 0x406
34009458:	4844      	ldr	r0, [pc, #272]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
3400945a:	f7f9 fbd9 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
3400945e:	68a3      	ldr	r3, [r4, #8]
34009460:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009464:	d304      	bcc.n	34009470 <HAL_LTDC_ConfigLayer+0x4c>
34009466:	f240 4107 	movw	r1, #1031	@ 0x407
3400946a:	4840      	ldr	r0, [pc, #256]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
3400946c:	f7f9 fbd0 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
34009470:	68e3      	ldr	r3, [r4, #12]
34009472:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009476:	d304      	bcc.n	34009482 <HAL_LTDC_ConfigLayer+0x5e>
34009478:	f44f 6181 	mov.w	r1, #1032	@ 0x408
3400947c:	483b      	ldr	r0, [pc, #236]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
3400947e:	f7f9 fbc7 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_PIXEL_FORMAT(pLayerCfg->PixelFormat));
34009482:	6923      	ldr	r3, [r4, #16]
34009484:	2b0b      	cmp	r3, #11
34009486:	d904      	bls.n	34009492 <HAL_LTDC_ConfigLayer+0x6e>
34009488:	f240 4109 	movw	r1, #1033	@ 0x409
3400948c:	4837      	ldr	r0, [pc, #220]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
3400948e:	f7f9 fbbf 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha));
34009492:	6963      	ldr	r3, [r4, #20]
34009494:	2bff      	cmp	r3, #255	@ 0xff
34009496:	d904      	bls.n	340094a2 <HAL_LTDC_ConfigLayer+0x7e>
34009498:	f240 410a 	movw	r1, #1034	@ 0x40a
3400949c:	4833      	ldr	r0, [pc, #204]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
3400949e:	f7f9 fbb7 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha0));
340094a2:	69a3      	ldr	r3, [r4, #24]
340094a4:	2bff      	cmp	r3, #255	@ 0xff
340094a6:	d904      	bls.n	340094b2 <HAL_LTDC_ConfigLayer+0x8e>
340094a8:	f240 410b 	movw	r1, #1035	@ 0x40b
340094ac:	482f      	ldr	r0, [pc, #188]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
340094ae:	f7f9 fbaf 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_BLENDING_FACTOR1(pLayerCfg->BlendingFactor1));
340094b2:	69e3      	ldr	r3, [r4, #28]
340094b4:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
340094b8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
340094bc:	d004      	beq.n	340094c8 <HAL_LTDC_ConfigLayer+0xa4>
340094be:	f240 410c 	movw	r1, #1036	@ 0x40c
340094c2:	482a      	ldr	r0, [pc, #168]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
340094c4:	f7f9 fba4 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
340094c8:	6a23      	ldr	r3, [r4, #32]
340094ca:	f023 0302 	bic.w	r3, r3, #2
340094ce:	2b05      	cmp	r3, #5
340094d0:	d004      	beq.n	340094dc <HAL_LTDC_ConfigLayer+0xb8>
340094d2:	f240 410d 	movw	r1, #1037	@ 0x40d
340094d6:	4825      	ldr	r0, [pc, #148]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
340094d8:	f7f9 fb9a 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
340094dc:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
340094de:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
340094e2:	d304      	bcc.n	340094ee <HAL_LTDC_ConfigLayer+0xca>
340094e4:	f240 410e 	movw	r1, #1038	@ 0x40e
340094e8:	4820      	ldr	r0, [pc, #128]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
340094ea:	f7f9 fb91 	bl	34002c10 <assert_failed>
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));
340094ee:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
340094f0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340094f4:	d304      	bcc.n	34009500 <HAL_LTDC_ConfigLayer+0xdc>
340094f6:	f240 410f 	movw	r1, #1039	@ 0x40f
340094fa:	481c      	ldr	r0, [pc, #112]	@ (3400956c <HAL_LTDC_ConfigLayer+0x148>)
340094fc:	f7f9 fb88 	bl	34002c10 <assert_failed>
  __HAL_LOCK(hltdc);
34009500:	f896 30a0 	ldrb.w	r3, [r6, #160]	@ 0xa0
34009504:	2002      	movs	r0, #2
34009506:	2b01      	cmp	r3, #1
34009508:	d02d      	beq.n	34009566 <HAL_LTDC_ConfigLayer+0x142>
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
3400950a:	2534      	movs	r5, #52	@ 0x34
3400950c:	fb05 6507 	mla	r5, r5, r7, r6
  hltdc->State = HAL_LTDC_STATE_BUSY;
34009510:	f886 00a1 	strb.w	r0, [r6, #161]	@ 0xa1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34009514:	3538      	adds	r5, #56	@ 0x38
34009516:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34009518:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3400951a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
3400951c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3400951e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34009520:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34009522:	6823      	ldr	r3, [r4, #0]
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34009524:	4639      	mov	r1, r7
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34009526:	602b      	str	r3, [r5, #0]
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34009528:	4630      	mov	r0, r6
3400952a:	f7ff fd83 	bl	34009034 <LTDC_SetPredefFormat>
  LTDC_SetCompositionConfig(hltdc, LayerIdx);
3400952e:	4639      	mov	r1, r7
34009530:	4630      	mov	r0, r6
34009532:	f7ff fd55 	bl	34008fe0 <LTDC_SetCompositionConfig>
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34009536:	2200      	movs	r2, #0
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34009538:	6834      	ldr	r4, [r6, #0]
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
3400953a:	4630      	mov	r0, r6
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
3400953c:	f504 7480 	add.w	r4, r4, #256	@ 0x100
34009540:	eb04 2407 	add.w	r4, r4, r7, lsl #8
34009544:	6b23      	ldr	r3, [r4, #48]	@ 0x30
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34009546:	4611      	mov	r1, r2
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34009548:	f023 0308 	bic.w	r3, r3, #8
3400954c:	6323      	str	r3, [r4, #48]	@ 0x30
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
3400954e:	2303      	movs	r3, #3
34009550:	9700      	str	r7, [sp, #0]
34009552:	f7ff fc17 	bl	34008d84 <LTDC_SetConfig>
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34009556:	2305      	movs	r3, #5
  __HAL_UNLOCK(hltdc);
34009558:	2000      	movs	r0, #0
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
3400955a:	60a3      	str	r3, [r4, #8]
  hltdc->State  = HAL_LTDC_STATE_READY;
3400955c:	2301      	movs	r3, #1
  __HAL_UNLOCK(hltdc);
3400955e:	f886 00a0 	strb.w	r0, [r6, #160]	@ 0xa0
  hltdc->State  = HAL_LTDC_STATE_READY;
34009562:	f886 30a1 	strb.w	r3, [r6, #161]	@ 0xa1
}
34009566:	b003      	add	sp, #12
34009568:	bdf0      	pop	{r4, r5, r6, r7, pc}
3400956a:	bf00      	nop
3400956c:	3402013c 	.word	0x3402013c

34009570 <HAL_LTDC_ReloadLayer>:
  assert_param(IS_LTDC_RELOAD(ReloadType));
34009570:	1e4b      	subs	r3, r1, #1
34009572:	2b01      	cmp	r3, #1
{
34009574:	b570      	push	{r4, r5, r6, lr}
34009576:	4604      	mov	r4, r0
34009578:	460d      	mov	r5, r1
3400957a:	4616      	mov	r6, r2
  assert_param(IS_LTDC_RELOAD(ReloadType));
3400957c:	d904      	bls.n	34009588 <HAL_LTDC_ReloadLayer+0x18>
3400957e:	f640 0119 	movw	r1, #2073	@ 0x819
34009582:	480e      	ldr	r0, [pc, #56]	@ (340095bc <HAL_LTDC_ReloadLayer+0x4c>)
34009584:	f7f9 fb44 	bl	34002c10 <assert_failed>
  __HAL_LOCK(hltdc);
34009588:	f894 30a0 	ldrb.w	r3, [r4, #160]	@ 0xa0
3400958c:	2002      	movs	r0, #2
3400958e:	2b01      	cmp	r3, #1
34009590:	d012      	beq.n	340095b8 <HAL_LTDC_ReloadLayer+0x48>
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
34009592:	6823      	ldr	r3, [r4, #0]
  hltdc->State = HAL_LTDC_STATE_BUSY;
34009594:	f884 00a1 	strb.w	r0, [r4, #161]	@ 0xa1
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
34009598:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, ReloadType | LTDC_LxRCR_GRMSK);
3400959a:	3601      	adds	r6, #1
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
3400959c:	f042 0208 	orr.w	r2, r2, #8
340095a0:	665a      	str	r2, [r3, #100]	@ 0x64
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, ReloadType | LTDC_LxRCR_GRMSK);
340095a2:	f045 0504 	orr.w	r5, r5, #4
340095a6:	eb03 2306 	add.w	r3, r3, r6, lsl #8
340095aa:	609d      	str	r5, [r3, #8]
  __HAL_UNLOCK(hltdc);
340095ac:	2000      	movs	r0, #0
  hltdc->State = HAL_LTDC_STATE_READY;
340095ae:	2301      	movs	r3, #1
  __HAL_UNLOCK(hltdc);
340095b0:	f884 00a0 	strb.w	r0, [r4, #160]	@ 0xa0
  hltdc->State = HAL_LTDC_STATE_READY;
340095b4:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
}
340095b8:	bd70      	pop	{r4, r5, r6, pc}
340095ba:	bf00      	nop
340095bc:	3402013c 	.word	0x3402013c

340095c0 <HAL_LTDC_SetAddress_NoReload>:
  uint32_t aux0Addr = 0U;
340095c0:	2300      	movs	r3, #0
{
340095c2:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_LTDC_LAYER(LayerIdx));
340095c4:	2a01      	cmp	r2, #1
{
340095c6:	b086      	sub	sp, #24
340095c8:	4604      	mov	r4, r0
340095ca:	460e      	mov	r6, r1
340095cc:	4615      	mov	r5, r2
  uint32_t aux1Addr = 0U;
340095ce:	e9cd 3303 	strd	r3, r3, [sp, #12]
  uint32_t mirror = 0U;
340095d2:	9305      	str	r3, [sp, #20]
  assert_param(IS_LTDC_LAYER(LayerIdx));
340095d4:	d904      	bls.n	340095e0 <HAL_LTDC_SetAddress_NoReload+0x20>
340095d6:	f640 1165 	movw	r1, #2405	@ 0x965
340095da:	4812      	ldr	r0, [pc, #72]	@ (34009624 <HAL_LTDC_SetAddress_NoReload+0x64>)
340095dc:	f7f9 fb18 	bl	34002c10 <assert_failed>
  __HAL_LOCK(hltdc);
340095e0:	f894 30a0 	ldrb.w	r3, [r4, #160]	@ 0xa0
340095e4:	2002      	movs	r0, #2
340095e6:	2b01      	cmp	r3, #1
340095e8:	d019      	beq.n	3400961e <HAL_LTDC_SetAddress_NoReload+0x5e>
  hltdc->State = HAL_LTDC_STATE_BUSY;
340095ea:	f884 00a1 	strb.w	r0, [r4, #161]	@ 0xa1
  LTDC_RetrieveUserConfig(hltdc, &mirror, &aux0Addr, &aux1Addr, LayerIdx);
340095ee:	ab04      	add	r3, sp, #16
340095f0:	4620      	mov	r0, r4
340095f2:	aa03      	add	r2, sp, #12
340095f4:	a905      	add	r1, sp, #20
340095f6:	9500      	str	r5, [sp, #0]
340095f8:	f7ff fd5e 	bl	340090b8 <LTDC_RetrieveUserConfig.constprop.0>
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
340095fc:	2334      	movs	r3, #52	@ 0x34
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
340095fe:	2200      	movs	r2, #0
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
34009600:	fb03 4305 	mla	r3, r3, r5, r4
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
34009604:	4620      	mov	r0, r4
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
34009606:	65de      	str	r6, [r3, #92]	@ 0x5c
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
34009608:	4611      	mov	r1, r2
3400960a:	9b05      	ldr	r3, [sp, #20]
3400960c:	9500      	str	r5, [sp, #0]
3400960e:	f7ff fbb9 	bl	34008d84 <LTDC_SetConfig>
  hltdc->State = HAL_LTDC_STATE_READY;
34009612:	2301      	movs	r3, #1
  __HAL_UNLOCK(hltdc);
34009614:	2000      	movs	r0, #0
  hltdc->State = HAL_LTDC_STATE_READY;
34009616:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
  __HAL_UNLOCK(hltdc);
3400961a:	f884 00a0 	strb.w	r0, [r4, #160]	@ 0xa0
}
3400961e:	b006      	add	sp, #24
34009620:	bd70      	pop	{r4, r5, r6, pc}
34009622:	bf00      	nop
34009624:	3402013c 	.word	0x3402013c

34009628 <HAL_PWREx_ConfigVddIORange>:
  * @retval None.
  */
void HAL_PWREx_ConfigVddIORange(uint32_t VddIOPort, uint32_t VoltageRange)
{
  /* Check the parameters */
  assert_param(IS_PWR_VDDIO(VddIOPort));
34009628:	2804      	cmp	r0, #4
{
3400962a:	b538      	push	{r3, r4, r5, lr}
3400962c:	4605      	mov	r5, r0
3400962e:	460c      	mov	r4, r1
  assert_param(IS_PWR_VDDIO(VddIOPort));
34009630:	d912      	bls.n	34009658 <HAL_PWREx_ConfigVddIORange+0x30>
34009632:	f240 316a 	movw	r1, #874	@ 0x36a
34009636:	481d      	ldr	r0, [pc, #116]	@ (340096ac <HAL_PWREx_ConfigVddIORange+0x84>)
34009638:	f7f9 faea 	bl	34002c10 <assert_failed>
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));
3400963c:	2c01      	cmp	r4, #1
3400963e:	d915      	bls.n	3400966c <HAL_PWREx_ConfigVddIORange+0x44>
34009640:	f240 316b 	movw	r1, #875	@ 0x36b
34009644:	4819      	ldr	r0, [pc, #100]	@ (340096ac <HAL_PWREx_ConfigVddIORange+0x84>)
34009646:	f7f9 fae3 	bl	34002c10 <assert_failed>

  switch (VddIOPort)
3400964a:	2d04      	cmp	r5, #4
3400964c:	d80e      	bhi.n	3400966c <HAL_PWREx_ConfigVddIORange+0x44>
3400964e:	e8df f005 	tbb	[pc, r5]
34009652:	0e06      	.short	0x0e06
34009654:	1c15      	.short	0x1c15
34009656:	24          	.byte	0x24
34009657:	00          	.byte	0x00
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));
34009658:	2901      	cmp	r1, #1
3400965a:	d9f6      	bls.n	3400964a <HAL_PWREx_ConfigVddIORange+0x22>
3400965c:	e7f0      	b.n	34009640 <HAL_PWREx_ConfigVddIORange+0x18>
  {
    case PWR_VDDIO:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIOVRSEL, VoltageRange << PWR_SVMCR3_VDDIOVRSEL_Pos);
3400965e:	4a14      	ldr	r2, [pc, #80]	@ (340096b0 <HAL_PWREx_ConfigVddIORange+0x88>)
34009660:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34009662:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34009666:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
    case PWR_VDDIO2:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
      break;

    case PWR_VDDIO3:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
3400966a:	63d3      	str	r3, [r2, #60]	@ 0x3c
      break;

    default:
      break;
  }
}
3400966c:	bd38      	pop	{r3, r4, r5, pc}
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
3400966e:	4a10      	ldr	r2, [pc, #64]	@ (340096b0 <HAL_PWREx_ConfigVddIORange+0x88>)
34009670:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34009672:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
34009676:	ea43 6344 	orr.w	r3, r3, r4, lsl #25
3400967a:	e7f6      	b.n	3400966a <HAL_PWREx_ConfigVddIORange+0x42>
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
3400967c:	4a0c      	ldr	r2, [pc, #48]	@ (340096b0 <HAL_PWREx_ConfigVddIORange+0x88>)
3400967e:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34009680:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
34009684:	ea43 6384 	orr.w	r3, r3, r4, lsl #26
34009688:	e7ef      	b.n	3400966a <HAL_PWREx_ConfigVddIORange+0x42>
      MODIFY_REG(PWR->SVMCR1, PWR_SVMCR1_VDDIO4VRSEL, VoltageRange << PWR_SVMCR1_VDDIO4VRSEL_Pos);
3400968a:	4a09      	ldr	r2, [pc, #36]	@ (340096b0 <HAL_PWREx_ConfigVddIORange+0x88>)
3400968c:	6b53      	ldr	r3, [r2, #52]	@ 0x34
3400968e:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34009692:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
34009696:	6353      	str	r3, [r2, #52]	@ 0x34
      break;
34009698:	e7e8      	b.n	3400966c <HAL_PWREx_ConfigVddIORange+0x44>
      MODIFY_REG(PWR->SVMCR2, PWR_SVMCR2_VDDIO5VRSEL, VoltageRange << PWR_SVMCR2_VDDIO5VRSEL_Pos);
3400969a:	4a05      	ldr	r2, [pc, #20]	@ (340096b0 <HAL_PWREx_ConfigVddIORange+0x88>)
3400969c:	6b93      	ldr	r3, [r2, #56]	@ 0x38
3400969e:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
340096a2:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
340096a6:	6393      	str	r3, [r2, #56]	@ 0x38
}
340096a8:	e7e0      	b.n	3400966c <HAL_PWREx_ConfigVddIORange+0x44>
340096aa:	bf00      	nop
340096ac:	34020200 	.word	0x34020200
340096b0:	56024800 	.word	0x56024800

340096b4 <HAL_PWREx_EnableVddIO2>:
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
340096b4:	4a02      	ldr	r2, [pc, #8]	@ (340096c0 <HAL_PWREx_EnableVddIO2+0xc>)
340096b6:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
340096b8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
340096bc:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
340096be:	4770      	bx	lr
340096c0:	56024800 	.word	0x56024800

340096c4 <HAL_PWREx_EnableVddIO3>:
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
340096c4:	4a02      	ldr	r2, [pc, #8]	@ (340096d0 <HAL_PWREx_EnableVddIO3+0xc>)
340096c6:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
340096c8:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
340096cc:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
340096ce:	4770      	bx	lr
340096d0:	56024800 	.word	0x56024800

340096d4 <HAL_PWREx_EnableVddIO4>:
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
340096d4:	4a02      	ldr	r2, [pc, #8]	@ (340096e0 <HAL_PWREx_EnableVddIO4+0xc>)
340096d6:	6b53      	ldr	r3, [r2, #52]	@ 0x34
340096d8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
340096dc:	6353      	str	r3, [r2, #52]	@ 0x34
}
340096de:	4770      	bx	lr
340096e0:	56024800 	.word	0x56024800

340096e4 <HAL_RAMCFG_EnableAXISRAM>:
  * @retval None.
  */
void HAL_RAMCFG_EnableAXISRAM(const RAMCFG_HandleTypeDef *hramcfg)
{
  /* Check the parameters */
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));
340096e4:	6803      	ldr	r3, [r0, #0]
340096e6:	4a1c      	ldr	r2, [pc, #112]	@ (34009758 <HAL_RAMCFG_EnableAXISRAM+0x74>)
{
340096e8:	b510      	push	{r4, lr}
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));
340096ea:	4293      	cmp	r3, r2
{
340096ec:	4604      	mov	r4, r0
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));
340096ee:	d02c      	beq.n	3400974a <HAL_RAMCFG_EnableAXISRAM+0x66>
340096f0:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340096f4:	4293      	cmp	r3, r2
340096f6:	d028      	beq.n	3400974a <HAL_RAMCFG_EnableAXISRAM+0x66>
340096f8:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
340096fc:	3280      	adds	r2, #128	@ 0x80
340096fe:	4293      	cmp	r3, r2
34009700:	d023      	beq.n	3400974a <HAL_RAMCFG_EnableAXISRAM+0x66>
34009702:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34009706:	4293      	cmp	r3, r2
34009708:	d01f      	beq.n	3400974a <HAL_RAMCFG_EnableAXISRAM+0x66>
3400970a:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
3400970e:	3280      	adds	r2, #128	@ 0x80
34009710:	4293      	cmp	r3, r2
34009712:	d01a      	beq.n	3400974a <HAL_RAMCFG_EnableAXISRAM+0x66>
34009714:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34009718:	4293      	cmp	r3, r2
3400971a:	d016      	beq.n	3400974a <HAL_RAMCFG_EnableAXISRAM+0x66>
3400971c:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
34009720:	3280      	adds	r2, #128	@ 0x80
34009722:	4293      	cmp	r3, r2
34009724:	d011      	beq.n	3400974a <HAL_RAMCFG_EnableAXISRAM+0x66>
34009726:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400972a:	4293      	cmp	r3, r2
3400972c:	d00d      	beq.n	3400974a <HAL_RAMCFG_EnableAXISRAM+0x66>
3400972e:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
34009732:	3280      	adds	r2, #128	@ 0x80
34009734:	4293      	cmp	r3, r2
34009736:	d008      	beq.n	3400974a <HAL_RAMCFG_EnableAXISRAM+0x66>
34009738:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400973c:	4293      	cmp	r3, r2
3400973e:	d004      	beq.n	3400974a <HAL_RAMCFG_EnableAXISRAM+0x66>
34009740:	f240 4107 	movw	r1, #1031	@ 0x407
34009744:	4805      	ldr	r0, [pc, #20]	@ (3400975c <HAL_RAMCFG_EnableAXISRAM+0x78>)
34009746:	f7f9 fa63 	bl	34002c10 <assert_failed>

  /* AXISRAMi power on */
  CLEAR_BIT(hramcfg->Instance->CR, RAMCFG_AXISRAM_POWERDOWN);
3400974a:	6822      	ldr	r2, [r4, #0]
3400974c:	6813      	ldr	r3, [r2, #0]
3400974e:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
34009752:	6013      	str	r3, [r2, #0]
}
34009754:	bd10      	pop	{r4, pc}
34009756:	bf00      	nop
34009758:	52023080 	.word	0x52023080
3400975c:	340202c6 	.word	0x340202c6

34009760 <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
34009760:	4b02      	ldr	r3, [pc, #8]	@ (3400976c <LL_RCC_HSI_IsReady+0xc>)
34009762:	6858      	ldr	r0, [r3, #4]
}
34009764:	f3c0 00c0 	ubfx	r0, r0, #3, #1
34009768:	4770      	bx	lr
3400976a:	bf00      	nop
3400976c:	56028000 	.word	0x56028000

34009770 <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
34009770:	4b02      	ldr	r3, [pc, #8]	@ (3400977c <LL_RCC_MSI_IsReady+0xc>)
34009772:	6858      	ldr	r0, [r3, #4]
}
34009774:	f3c0 0080 	ubfx	r0, r0, #2, #1
34009778:	4770      	bx	lr
3400977a:	bf00      	nop
3400977c:	56028000 	.word	0x56028000

34009780 <LL_RCC_PLL1_IsReady>:
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
34009780:	4b02      	ldr	r3, [pc, #8]	@ (3400978c <LL_RCC_PLL1_IsReady+0xc>)
34009782:	6858      	ldr	r0, [r3, #4]
}
34009784:	f3c0 2000 	ubfx	r0, r0, #8, #1
34009788:	4770      	bx	lr
3400978a:	bf00      	nop
3400978c:	56028000 	.word	0x56028000

34009790 <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
34009790:	b570      	push	{r4, r5, r6, lr}
  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
34009792:	690b      	ldr	r3, [r1, #16]
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
34009794:	4d1b      	ldr	r5, [pc, #108]	@ (34009804 <RCC_PLL_IsNewConfig+0x74>)
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
34009796:	688e      	ldr	r6, [r1, #8]
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
34009798:	0104      	lsls	r4, r0, #4
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3400979a:	5962      	ldr	r2, [r4, r5]
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
3400979c:	021b      	lsls	r3, r3, #8
3400979e:	ea43 5306 	orr.w	r3, r3, r6, lsl #20
340097a2:	684e      	ldr	r6, [r1, #4]
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
340097a4:	f022 420c 	bic.w	r2, r2, #2348810240	@ 0x8c000000
340097a8:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
340097ac:	4333      	orrs	r3, r6
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
340097ae:	429a      	cmp	r2, r3
340097b0:	d126      	bne.n	34009800 <RCC_PLL_IsNewConfig+0x70>
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
340097b2:	4b15      	ldr	r3, [pc, #84]	@ (34009808 <RCC_PLL_IsNewConfig+0x78>)
  {
    ret = 1U; /* New PLL configuration */
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
340097b4:	68ca      	ldr	r2, [r1, #12]
340097b6:	58e3      	ldr	r3, [r4, r3]
340097b8:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
340097bc:	4293      	cmp	r3, r2
340097be:	d11f      	bne.n	34009800 <RCC_PLL_IsNewConfig+0x70>
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
340097c0:	4b12      	ldr	r3, [pc, #72]	@ (3400980c <RCC_PLL_IsNewConfig+0x7c>)
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
  {
    ret = 1U; /* New PLL configuration */
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
340097c2:	58e2      	ldr	r2, [r4, r3]
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
340097c4:	e9d1 6305 	ldrd	r6, r3, [r1, #20]
340097c8:	061b      	lsls	r3, r3, #24
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
340097ca:	f002 527c 	and.w	r2, r2, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
340097ce:	ea43 63c6 	orr.w	r3, r3, r6, lsl #27
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
340097d2:	429a      	cmp	r2, r3
340097d4:	d114      	bne.n	34009800 <RCC_PLL_IsNewConfig+0x70>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
340097d6:	4b0e      	ldr	r3, [pc, #56]	@ (34009810 <RCC_PLL_IsNewConfig+0x80>)
340097d8:	685a      	ldr	r2, [r3, #4]
340097da:	f44f 7380 	mov.w	r3, #256	@ 0x100
340097de:	fa03 f000 	lsl.w	r0, r3, r0
340097e2:	4390      	bics	r0, r2
340097e4:	d00a      	beq.n	340097fc <RCC_PLL_IsNewConfig+0x6c>
    {
      pllState = RCC_PLL_ON;
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
340097e6:	5963      	ldr	r3, [r4, r5]
      {
        pllState = RCC_PLL_BYPASS;
340097e8:	f013 6f00 	tst.w	r3, #134217728	@ 0x8000000
340097ec:	bf0c      	ite	eq
340097ee:	2301      	moveq	r3, #1
340097f0:	2303      	movne	r3, #3
        pllState = RCC_PLL_OFF;
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
340097f2:	6808      	ldr	r0, [r1, #0]
340097f4:	1ac0      	subs	r0, r0, r3
340097f6:	bf18      	it	ne
340097f8:	2001      	movne	r0, #1
      ret = 1U; /* New PLL configuration */
    }
  }

  return ret;
}
340097fa:	bd70      	pop	{r4, r5, r6, pc}
      pllState = RCC_PLL_ON;
340097fc:	2302      	movs	r3, #2
340097fe:	e7f8      	b.n	340097f2 <RCC_PLL_IsNewConfig+0x62>
    ret = 1U; /* New PLL configuration */
34009800:	2001      	movs	r0, #1
  return ret;
34009802:	e7fa      	b.n	340097fa <RCC_PLL_IsNewConfig+0x6a>
34009804:	56028080 	.word	0x56028080
34009808:	56028084 	.word	0x56028084
3400980c:	56028088 	.word	0x56028088
34009810:	56028000 	.word	0x56028000

34009814 <RCC_PLL_Enable>:
{
34009814:	b570      	push	{r4, r5, r6, lr}
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
34009816:	f44f 7480 	mov.w	r4, #256	@ 0x100
3400981a:	4e09      	ldr	r6, [pc, #36]	@ (34009840 <RCC_PLL_Enable+0x2c>)
3400981c:	4084      	lsls	r4, r0
3400981e:	f8c6 4800 	str.w	r4, [r6, #2048]	@ 0x800
  tickstart = HAL_GetTick();
34009822:	f7fb fb2b 	bl	34004e7c <HAL_GetTick>
34009826:	4605      	mov	r5, r0
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
34009828:	6873      	ldr	r3, [r6, #4]
3400982a:	421c      	tst	r4, r3
3400982c:	d001      	beq.n	34009832 <RCC_PLL_Enable+0x1e>
  return ret;
3400982e:	2000      	movs	r0, #0
}
34009830:	bd70      	pop	{r4, r5, r6, pc}
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34009832:	f7fb fb23 	bl	34004e7c <HAL_GetTick>
34009836:	1b40      	subs	r0, r0, r5
34009838:	2801      	cmp	r0, #1
3400983a:	d9f5      	bls.n	34009828 <RCC_PLL_Enable+0x14>
      return HAL_TIMEOUT;
3400983c:	2003      	movs	r0, #3
3400983e:	e7f7      	b.n	34009830 <RCC_PLL_Enable+0x1c>
34009840:	56028000 	.word	0x56028000

34009844 <RCC_PLL_Config>:
  if (pPLLInit->PLLState == RCC_PLL_ON)
34009844:	680b      	ldr	r3, [r1, #0]
{
34009846:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (pPLLInit->PLLState == RCC_PLL_ON)
3400984a:	2b02      	cmp	r3, #2
{
3400984c:	4681      	mov	r9, r0
3400984e:	460d      	mov	r5, r1
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
34009850:	4f83      	ldr	r7, [pc, #524]	@ (34009a60 <RCC_PLL_Config+0x21c>)
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
34009852:	4e84      	ldr	r6, [pc, #528]	@ (34009a64 <RCC_PLL_Config+0x220>)
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
34009854:	ea4f 1400 	mov.w	r4, r0, lsl #4
  if (pPLLInit->PLLState == RCC_PLL_ON)
34009858:	f040 8099 	bne.w	3400998e <RCC_PLL_Config+0x14a>
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));
3400985c:	684b      	ldr	r3, [r1, #4]
3400985e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
34009862:	d004      	beq.n	3400986e <RCC_PLL_Config+0x2a>
34009864:	f640 0144 	movw	r1, #2116	@ 0x844
34009868:	487f      	ldr	r0, [pc, #508]	@ (34009a68 <RCC_PLL_Config+0x224>)
3400986a:	f7f9 f9d1 	bl	34002c10 <assert_failed>
    assert_param(IS_RCC_PLLFRACN_VALUE(pPLLInit->PLLFractional));
3400986e:	68eb      	ldr	r3, [r5, #12]
34009870:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34009874:	d304      	bcc.n	34009880 <RCC_PLL_Config+0x3c>
34009876:	f640 0145 	movw	r1, #2117	@ 0x845
3400987a:	487b      	ldr	r0, [pc, #492]	@ (34009a68 <RCC_PLL_Config+0x224>)
3400987c:	f7f9 f9c8 	bl	34002c10 <assert_failed>
    assert_param(IS_RCC_PLLM_VALUE(pPLLInit->PLLM));
34009880:	68ab      	ldr	r3, [r5, #8]
34009882:	3b01      	subs	r3, #1
34009884:	2b3e      	cmp	r3, #62	@ 0x3e
34009886:	d904      	bls.n	34009892 <RCC_PLL_Config+0x4e>
34009888:	f640 0146 	movw	r1, #2118	@ 0x846
3400988c:	4876      	ldr	r0, [pc, #472]	@ (34009a68 <RCC_PLL_Config+0x224>)
3400988e:	f7f9 f9bf 	bl	34002c10 <assert_failed>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
34009892:	f640 12ba 	movw	r2, #2490	@ 0x9ba
34009896:	692b      	ldr	r3, [r5, #16]
34009898:	3b0a      	subs	r3, #10
3400989a:	4293      	cmp	r3, r2
3400989c:	d904      	bls.n	340098a8 <RCC_PLL_Config+0x64>
3400989e:	f640 0147 	movw	r1, #2119	@ 0x847
340098a2:	4871      	ldr	r0, [pc, #452]	@ (34009a68 <RCC_PLL_Config+0x224>)
340098a4:	f7f9 f9b4 	bl	34002c10 <assert_failed>
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
340098a8:	696b      	ldr	r3, [r5, #20]
340098aa:	3b01      	subs	r3, #1
340098ac:	2b06      	cmp	r3, #6
340098ae:	d904      	bls.n	340098ba <RCC_PLL_Config+0x76>
340098b0:	f640 0148 	movw	r1, #2120	@ 0x848
340098b4:	486c      	ldr	r0, [pc, #432]	@ (34009a68 <RCC_PLL_Config+0x224>)
340098b6:	f7f9 f9ab 	bl	34002c10 <assert_failed>
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));
340098ba:	69ab      	ldr	r3, [r5, #24]
340098bc:	3b01      	subs	r3, #1
340098be:	2b06      	cmp	r3, #6
340098c0:	d904      	bls.n	340098cc <RCC_PLL_Config+0x88>
340098c2:	f640 0149 	movw	r1, #2121	@ 0x849
340098c6:	4868      	ldr	r0, [pc, #416]	@ (34009a68 <RCC_PLL_Config+0x224>)
340098c8:	f7f9 f9a2 	bl	34002c10 <assert_failed>
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
340098cc:	f44f 7880 	mov.w	r8, #256	@ 0x100
340098d0:	4b66      	ldr	r3, [pc, #408]	@ (34009a6c <RCC_PLL_Config+0x228>)
340098d2:	fa08 f809 	lsl.w	r8, r8, r9
340098d6:	f8c3 8000 	str.w	r8, [r3]
    tickstart = HAL_GetTick();
340098da:	f7fb facf 	bl	34004e7c <HAL_GetTick>
340098de:	4681      	mov	r9, r0
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
340098e0:	f8df a194 	ldr.w	sl, [pc, #404]	@ 34009a78 <RCC_PLL_Config+0x234>
340098e4:	f8da 3004 	ldr.w	r3, [sl, #4]
340098e8:	ea38 0303 	bics.w	r3, r8, r3
340098ec:	d040      	beq.n	34009970 <RCC_PLL_Config+0x12c>
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
340098ee:	59a3      	ldr	r3, [r4, r6]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
340098f0:	495f      	ldr	r1, [pc, #380]	@ (34009a70 <RCC_PLL_Config+0x22c>)
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
340098f2:	f043 0304 	orr.w	r3, r3, #4
340098f6:	51a3      	str	r3, [r4, r6]
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
340098f8:	59e3      	ldr	r3, [r4, r7]
340098fa:	f023 6300 	bic.w	r3, r3, #134217728	@ 0x8000000
340098fe:	51e3      	str	r3, [r4, r7]
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
34009900:	692b      	ldr	r3, [r5, #16]
34009902:	68aa      	ldr	r2, [r5, #8]
34009904:	021b      	lsls	r3, r3, #8
34009906:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
3400990a:	686a      	ldr	r2, [r5, #4]
3400990c:	59e0      	ldr	r0, [r4, r7]
3400990e:	4313      	orrs	r3, r2
34009910:	4a58      	ldr	r2, [pc, #352]	@ (34009a74 <RCC_PLL_Config+0x230>)
34009912:	4002      	ands	r2, r0
34009914:	4313      	orrs	r3, r2
34009916:	51e3      	str	r3, [r4, r7]
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
34009918:	59a2      	ldr	r2, [r4, r6]
3400991a:	e9d5 0305 	ldrd	r0, r3, [r5, #20]
3400991e:	061b      	lsls	r3, r3, #24
34009920:	f022 527c 	bic.w	r2, r2, #1056964608	@ 0x3f000000
34009924:	ea43 63c0 	orr.w	r3, r3, r0, lsl #27
34009928:	4313      	orrs	r3, r2
3400992a:	51a3      	str	r3, [r4, r6]
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
3400992c:	5863      	ldr	r3, [r4, r1]
3400992e:	68ea      	ldr	r2, [r5, #12]
34009930:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
34009934:	4313      	orrs	r3, r2
34009936:	5063      	str	r3, [r4, r1]
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
34009938:	59a3      	ldr	r3, [r4, r6]
3400993a:	f023 0308 	bic.w	r3, r3, #8
3400993e:	51a3      	str	r3, [r4, r6]
    if (pPLLInit->PLLFractional != 0U)
34009940:	68eb      	ldr	r3, [r5, #12]
34009942:	b11b      	cbz	r3, 3400994c <RCC_PLL_Config+0x108>
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
34009944:	59a3      	ldr	r3, [r4, r6]
34009946:	f043 030a 	orr.w	r3, r3, #10
3400994a:	51a3      	str	r3, [r4, r6]
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
3400994c:	59a3      	ldr	r3, [r4, r6]
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3400994e:	4d4a      	ldr	r5, [pc, #296]	@ (34009a78 <RCC_PLL_Config+0x234>)
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
34009950:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34009954:	f043 0301 	orr.w	r3, r3, #1
34009958:	51a3      	str	r3, [r4, r6]
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3400995a:	f8c5 8800 	str.w	r8, [r5, #2048]	@ 0x800
    tickstart = HAL_GetTick();
3400995e:	f7fb fa8d 	bl	34004e7c <HAL_GetTick>
34009962:	4604      	mov	r4, r0
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
34009964:	686b      	ldr	r3, [r5, #4]
34009966:	ea18 0f03 	tst.w	r8, r3
3400996a:	d00a      	beq.n	34009982 <RCC_PLL_Config+0x13e>
  HAL_StatusTypeDef ret = HAL_OK;
3400996c:	2000      	movs	r0, #0
3400996e:	e006      	b.n	3400997e <RCC_PLL_Config+0x13a>
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34009970:	f7fb fa84 	bl	34004e7c <HAL_GetTick>
34009974:	eba0 0009 	sub.w	r0, r0, r9
34009978:	2801      	cmp	r0, #1
3400997a:	d9b3      	bls.n	340098e4 <RCC_PLL_Config+0xa0>
        return HAL_TIMEOUT;
3400997c:	2003      	movs	r0, #3
}
3400997e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34009982:	f7fb fa7b 	bl	34004e7c <HAL_GetTick>
34009986:	1b00      	subs	r0, r0, r4
34009988:	2801      	cmp	r0, #1
3400998a:	d9eb      	bls.n	34009964 <RCC_PLL_Config+0x120>
3400998c:	e7f6      	b.n	3400997c <RCC_PLL_Config+0x138>
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
3400998e:	2b03      	cmp	r3, #3
34009990:	d146      	bne.n	34009a20 <RCC_PLL_Config+0x1dc>
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));
34009992:	684b      	ldr	r3, [r1, #4]
34009994:	b37b      	cbz	r3, 340099f6 <RCC_PLL_Config+0x1b2>
34009996:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400999a:	d032      	beq.n	34009a02 <RCC_PLL_Config+0x1be>
3400999c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340099a0:	d032      	beq.n	34009a08 <RCC_PLL_Config+0x1c4>
340099a2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340099a6:	d00d      	beq.n	340099c4 <RCC_PLL_Config+0x180>
340099a8:	f640 0189 	movw	r1, #2185	@ 0x889
340099ac:	482e      	ldr	r0, [pc, #184]	@ (34009a68 <RCC_PLL_Config+0x224>)
340099ae:	f7f9 f92f 	bl	34002c10 <assert_failed>
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
340099b2:	686b      	ldr	r3, [r5, #4]
{
  uint32_t ret = 1U;

  /* No assert since done in calling function */

  switch (PLLSource)
340099b4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340099b8:	d026      	beq.n	34009a08 <RCC_PLL_Config+0x1c4>
340099ba:	d803      	bhi.n	340099c4 <RCC_PLL_Config+0x180>
340099bc:	b1db      	cbz	r3, 340099f6 <RCC_PLL_Config+0x1b2>
340099be:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340099c2:	d01e      	beq.n	34009a02 <RCC_PLL_Config+0x1be>
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
340099c4:	f44f 7680 	mov.w	r6, #256	@ 0x100
340099c8:	4b28      	ldr	r3, [pc, #160]	@ (34009a6c <RCC_PLL_Config+0x228>)
340099ca:	fa06 f609 	lsl.w	r6, r6, r9
340099ce:	601e      	str	r6, [r3, #0]
      tickstart = HAL_GetTick();
340099d0:	f7fb fa54 	bl	34004e7c <HAL_GetTick>
340099d4:	4680      	mov	r8, r0
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
340099d6:	f8df 90a0 	ldr.w	r9, [pc, #160]	@ 34009a78 <RCC_PLL_Config+0x234>
340099da:	f8d9 3004 	ldr.w	r3, [r9, #4]
340099de:	ea36 0303 	bics.w	r3, r6, r3
340099e2:	d016      	beq.n	34009a12 <RCC_PLL_Config+0x1ce>
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
340099e4:	59e3      	ldr	r3, [r4, r7]
340099e6:	686a      	ldr	r2, [r5, #4]
340099e8:	f023 43f0 	bic.w	r3, r3, #2013265920	@ 0x78000000
340099ec:	4313      	orrs	r3, r2
340099ee:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
340099f2:	51e3      	str	r3, [r4, r7]
340099f4:	e7ba      	b.n	3400996c <RCC_PLL_Config+0x128>
  {
    case RCC_PLLSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() == 0U)
340099f6:	f7ff feb3 	bl	34009760 <LL_RCC_HSI_IsReady>
340099fa:	2800      	cmp	r0, #0
340099fc:	d1e2      	bne.n	340099c4 <RCC_PLL_Config+0x180>
      ret = HAL_ERROR;
340099fe:	2001      	movs	r0, #1
34009a00:	e7bd      	b.n	3400997e <RCC_PLL_Config+0x13a>
      {
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() == 0U)
34009a02:	f7ff feb5 	bl	34009770 <LL_RCC_MSI_IsReady>
34009a06:	e7f8      	b.n	340099fa <RCC_PLL_Config+0x1b6>
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34009a08:	4b1b      	ldr	r3, [pc, #108]	@ (34009a78 <RCC_PLL_Config+0x234>)
34009a0a:	685b      	ldr	r3, [r3, #4]
34009a0c:	06db      	lsls	r3, r3, #27
34009a0e:	d5f6      	bpl.n	340099fe <RCC_PLL_Config+0x1ba>
34009a10:	e7d8      	b.n	340099c4 <RCC_PLL_Config+0x180>
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34009a12:	f7fb fa33 	bl	34004e7c <HAL_GetTick>
34009a16:	eba0 0008 	sub.w	r0, r0, r8
34009a1a:	2801      	cmp	r0, #1
34009a1c:	d9dd      	bls.n	340099da <RCC_PLL_Config+0x196>
34009a1e:	e7ad      	b.n	3400997c <RCC_PLL_Config+0x138>
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
34009a20:	2b01      	cmp	r3, #1
34009a22:	d1a3      	bne.n	3400996c <RCC_PLL_Config+0x128>
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34009a24:	f44f 7580 	mov.w	r5, #256	@ 0x100
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
34009a28:	59a3      	ldr	r3, [r4, r6]
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34009a2a:	4085      	lsls	r5, r0
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
34009a2c:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
34009a30:	51a3      	str	r3, [r4, r6]
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34009a32:	4b0e      	ldr	r3, [pc, #56]	@ (34009a6c <RCC_PLL_Config+0x228>)
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34009a34:	f8df 8040 	ldr.w	r8, [pc, #64]	@ 34009a78 <RCC_PLL_Config+0x234>
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34009a38:	601d      	str	r5, [r3, #0]
    tickstart = HAL_GetTick();
34009a3a:	f7fb fa1f 	bl	34004e7c <HAL_GetTick>
34009a3e:	4606      	mov	r6, r0
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34009a40:	f8d8 3004 	ldr.w	r3, [r8, #4]
34009a44:	ea35 0303 	bics.w	r3, r5, r3
34009a48:	d003      	beq.n	34009a52 <RCC_PLL_Config+0x20e>
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
34009a4a:	59e3      	ldr	r3, [r4, r7]
34009a4c:	f023 6300 	bic.w	r3, r3, #134217728	@ 0x8000000
34009a50:	e7cf      	b.n	340099f2 <RCC_PLL_Config+0x1ae>
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34009a52:	f7fb fa13 	bl	34004e7c <HAL_GetTick>
34009a56:	1b80      	subs	r0, r0, r6
34009a58:	2801      	cmp	r0, #1
34009a5a:	d9f1      	bls.n	34009a40 <RCC_PLL_Config+0x1fc>
34009a5c:	e78e      	b.n	3400997c <RCC_PLL_Config+0x138>
34009a5e:	bf00      	nop
34009a60:	56028080 	.word	0x56028080
34009a64:	56028088 	.word	0x56028088
34009a68:	3402038c 	.word	0x3402038c
34009a6c:	56029000 	.word	0x56029000
34009a70:	56028084 	.word	0x56028084
34009a74:	8c0000ff 	.word	0x8c0000ff
34009a78:	56028000 	.word	0x56028000

34009a7c <RCC_GetSysClockFreq>:
{
34009a7c:	b510      	push	{r4, lr}
34009a7e:	460c      	mov	r4, r1
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
34009a80:	4919      	ldr	r1, [pc, #100]	@ (34009ae8 <RCC_GetSysClockFreq+0x6c>)
34009a82:	6a0a      	ldr	r2, [r1, #32]
34009a84:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
  switch (LL_RCC_GetSysClkSource())
34009a88:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
34009a8c:	d02a      	beq.n	34009ae4 <RCC_GetSysClockFreq+0x68>
34009a8e:	d806      	bhi.n	34009a9e <RCC_GetSysClockFreq+0x22>
34009a90:	b952      	cbnz	r2, 34009aa8 <RCC_GetSysClockFreq+0x2c>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34009a92:	6c8b      	ldr	r3, [r1, #72]	@ 0x48
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34009a94:	4815      	ldr	r0, [pc, #84]	@ (34009aec <RCC_GetSysClockFreq+0x70>)
34009a96:	f3c3 13c1 	ubfx	r3, r3, #7, #2
34009a9a:	40d8      	lsrs	r0, r3
}
34009a9c:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSysClkSource())
34009a9e:	f1b2 5f40 	cmp.w	r2, #805306368	@ 0x30000000
34009aa2:	d009      	beq.n	34009ab8 <RCC_GetSysClockFreq+0x3c>
      switch (icx_source)
34009aa4:	2000      	movs	r0, #0
34009aa6:	e7f9      	b.n	34009a9c <RCC_GetSysClockFreq+0x20>
      frequency = RCC_GET_MSI_FREQUENCY();
34009aa8:	6c4b      	ldr	r3, [r1, #68]	@ 0x44
34009aaa:	4811      	ldr	r0, [pc, #68]	@ (34009af0 <RCC_GetSysClockFreq+0x74>)
34009aac:	f413 7f00 	tst.w	r3, #512	@ 0x200
34009ab0:	4b10      	ldr	r3, [pc, #64]	@ (34009af4 <RCC_GetSysClockFreq+0x78>)
34009ab2:	bf18      	it	ne
34009ab4:	4618      	movne	r0, r3
34009ab6:	e7f1      	b.n	34009a9c <RCC_GetSysClockFreq+0x20>
      switch (icx_source)
34009ab8:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
34009abc:	d00f      	beq.n	34009ade <RCC_GetSysClockFreq+0x62>
34009abe:	d805      	bhi.n	34009acc <RCC_GetSysClockFreq+0x50>
34009ac0:	b950      	cbnz	r0, 34009ad8 <RCC_GetSysClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009ac2:	f003 ffd1 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
          frequency = frequency / icx_divider;
34009ac6:	fbb0 f0f4 	udiv	r0, r0, r4
          break;
34009aca:	e7e7      	b.n	34009a9c <RCC_GetSysClockFreq+0x20>
      switch (icx_source)
34009acc:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
34009ad0:	d1e8      	bne.n	34009aa4 <RCC_GetSysClockFreq+0x28>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
34009ad2:	f004 f889 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
34009ad6:	e7f6      	b.n	34009ac6 <RCC_GetSysClockFreq+0x4a>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009ad8:	f004 f806 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
34009adc:	e7f3      	b.n	34009ac6 <RCC_GetSysClockFreq+0x4a>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009ade:	f004 f843 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
34009ae2:	e7f0      	b.n	34009ac6 <RCC_GetSysClockFreq+0x4a>
  switch (LL_RCC_GetSysClkSource())
34009ae4:	4804      	ldr	r0, [pc, #16]	@ (34009af8 <RCC_GetSysClockFreq+0x7c>)
34009ae6:	e7d9      	b.n	34009a9c <RCC_GetSysClockFreq+0x20>
34009ae8:	56028000 	.word	0x56028000
34009aec:	03d09000 	.word	0x03d09000
34009af0:	003d0900 	.word	0x003d0900
34009af4:	00f42400 	.word	0x00f42400
34009af8:	02dc6c00 	.word	0x02dc6c00

34009afc <RCC_IC_CheckPLLSources>:
  uint32_t ret = 1U;

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
34009afc:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
{
34009b00:	b508      	push	{r3, lr}
  switch (PLLSource1)
34009b02:	d021      	beq.n	34009b48 <RCC_IC_CheckPLLSources+0x4c>
34009b04:	d805      	bhi.n	34009b12 <RCC_IC_CheckPLLSources+0x16>
34009b06:	b9c0      	cbnz	r0, 34009b3a <RCC_IC_CheckPLLSources+0x3e>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
34009b08:	f7ff fe3a 	bl	34009780 <LL_RCC_PLL1_IsReady>
34009b0c:	b178      	cbz	r0, 34009b2e <RCC_IC_CheckPLLSources+0x32>
  uint32_t ret = 1U;
34009b0e:	2201      	movs	r2, #1
34009b10:	e003      	b.n	34009b1a <RCC_IC_CheckPLLSources+0x1e>
  switch (PLLSource1)
34009b12:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
34009b16:	d01e      	beq.n	34009b56 <RCC_IC_CheckPLLSources+0x5a>
34009b18:	2200      	movs	r2, #0
      ret = 0U;
      break;
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
34009b1a:	f1b1 5f00 	cmp.w	r1, #536870912	@ 0x20000000
34009b1e:	d03c      	beq.n	34009b9a <RCC_IC_CheckPLLSources+0x9e>
34009b20:	d820      	bhi.n	34009b64 <RCC_IC_CheckPLLSources+0x68>
34009b22:	b349      	cbz	r1, 34009b78 <RCC_IC_CheckPLLSources+0x7c>
34009b24:	f1b1 5f80 	cmp.w	r1, #268435456	@ 0x10000000
34009b28:	d030      	beq.n	34009b8c <RCC_IC_CheckPLLSources+0x90>
        }
      }
      break;
    default:
      /* Unexpected */
      ret = 0U;
34009b2a:	2200      	movs	r2, #0
34009b2c:	e02c      	b.n	34009b88 <RCC_IC_CheckPLLSources+0x8c>
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
34009b2e:	4b1e      	ldr	r3, [pc, #120]	@ (34009ba8 <RCC_IC_CheckPLLSources+0xac>)
34009b30:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34009b34:	f3c2 62c0 	ubfx	r2, r2, #27, #1
34009b38:	e7ef      	b.n	34009b1a <RCC_IC_CheckPLLSources+0x1e>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34009b3a:	4b1b      	ldr	r3, [pc, #108]	@ (34009ba8 <RCC_IC_CheckPLLSources+0xac>)
34009b3c:	685a      	ldr	r2, [r3, #4]
34009b3e:	0592      	lsls	r2, r2, #22
34009b40:	d4e5      	bmi.n	34009b0e <RCC_IC_CheckPLLSources+0x12>
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34009b42:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34009b46:	e7f5      	b.n	34009b34 <RCC_IC_CheckPLLSources+0x38>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
34009b48:	4b17      	ldr	r3, [pc, #92]	@ (34009ba8 <RCC_IC_CheckPLLSources+0xac>)
34009b4a:	685a      	ldr	r2, [r3, #4]
34009b4c:	0550      	lsls	r0, r2, #21
34009b4e:	d4de      	bmi.n	34009b0e <RCC_IC_CheckPLLSources+0x12>
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
34009b50:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34009b54:	e7ee      	b.n	34009b34 <RCC_IC_CheckPLLSources+0x38>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34009b56:	4b14      	ldr	r3, [pc, #80]	@ (34009ba8 <RCC_IC_CheckPLLSources+0xac>)
34009b58:	685a      	ldr	r2, [r3, #4]
34009b5a:	0512      	lsls	r2, r2, #20
34009b5c:	d4d7      	bmi.n	34009b0e <RCC_IC_CheckPLLSources+0x12>
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34009b5e:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34009b62:	e7e7      	b.n	34009b34 <RCC_IC_CheckPLLSources+0x38>
  switch (PLLSource2)
34009b64:	f1b1 5f40 	cmp.w	r1, #805306368	@ 0x30000000
34009b68:	d1df      	bne.n	34009b2a <RCC_IC_CheckPLLSources+0x2e>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34009b6a:	4b0f      	ldr	r3, [pc, #60]	@ (34009ba8 <RCC_IC_CheckPLLSources+0xac>)
34009b6c:	6859      	ldr	r1, [r3, #4]
34009b6e:	0509      	lsls	r1, r1, #20
34009b70:	d40a      	bmi.n	34009b88 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34009b72:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34009b76:	e005      	b.n	34009b84 <RCC_IC_CheckPLLSources+0x88>
      if (LL_RCC_PLL1_IsReady() == 0U)
34009b78:	f7ff fe02 	bl	34009780 <LL_RCC_PLL1_IsReady>
34009b7c:	b920      	cbnz	r0, 34009b88 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
34009b7e:	4b0a      	ldr	r3, [pc, #40]	@ (34009ba8 <RCC_IC_CheckPLLSources+0xac>)
34009b80:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34009b84:	0118      	lsls	r0, r3, #4
34009b86:	d5d0      	bpl.n	34009b2a <RCC_IC_CheckPLLSources+0x2e>
      break;
  }

  return ret;
}
34009b88:	4610      	mov	r0, r2
34009b8a:	bd08      	pop	{r3, pc}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34009b8c:	4b06      	ldr	r3, [pc, #24]	@ (34009ba8 <RCC_IC_CheckPLLSources+0xac>)
34009b8e:	6859      	ldr	r1, [r3, #4]
34009b90:	0589      	lsls	r1, r1, #22
34009b92:	d4f9      	bmi.n	34009b88 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34009b94:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34009b98:	e7f4      	b.n	34009b84 <RCC_IC_CheckPLLSources+0x88>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
34009b9a:	4b03      	ldr	r3, [pc, #12]	@ (34009ba8 <RCC_IC_CheckPLLSources+0xac>)
34009b9c:	6859      	ldr	r1, [r3, #4]
34009b9e:	0548      	lsls	r0, r1, #21
34009ba0:	d4f2      	bmi.n	34009b88 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
34009ba2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34009ba6:	e7ed      	b.n	34009b84 <RCC_IC_CheckPLLSources+0x88>
34009ba8:	56028000 	.word	0x56028000

34009bac <HAL_RCC_OscConfig>:
{
34009bac:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (pRCC_OscInitStruct == NULL)
34009bb0:	4604      	mov	r4, r0
34009bb2:	b918      	cbnz	r0, 34009bbc <HAL_RCC_OscConfig+0x10>
    return HAL_ERROR;
34009bb4:	2001      	movs	r0, #1
}
34009bb6:	b003      	add	sp, #12
34009bb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));
34009bbc:	6803      	ldr	r3, [r0, #0]
34009bbe:	b133      	cbz	r3, 34009bce <HAL_RCC_OscConfig+0x22>
34009bc0:	06dd      	lsls	r5, r3, #27
34009bc2:	d104      	bne.n	34009bce <HAL_RCC_OscConfig+0x22>
34009bc4:	f240 1175 	movw	r1, #373	@ 0x175
34009bc8:	4893      	ldr	r0, [pc, #588]	@ (34009e18 <HAL_RCC_OscConfig+0x26c>)
34009bca:	f7f9 f821 	bl	34002c10 <assert_failed>
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
34009bce:	4b93      	ldr	r3, [pc, #588]	@ (34009e1c <HAL_RCC_OscConfig+0x270>)
34009bd0:	6a1e      	ldr	r6, [r3, #32]
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
34009bd2:	6a1d      	ldr	r5, [r3, #32]
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
34009bd4:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
34009bd8:	f406 1640 	and.w	r6, r6, #3145728	@ 0x300000
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
34009bdc:	f002 4be0 	and.w	fp, r2, #1879048192	@ 0x70000000
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
34009be0:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
34009be4:	f005 5540 	and.w	r5, r5, #805306368	@ 0x30000000
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
34009be8:	f002 4ae0 	and.w	sl, r2, #1879048192	@ 0x70000000
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
34009bec:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34009bf0:	f002 49e0 	and.w	r9, r2, #1879048192	@ 0x70000000
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
34009bf4:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
  rccsr = RCC->SR;
34009bf8:	685f      	ldr	r7, [r3, #4]
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
34009bfa:	6823      	ldr	r3, [r4, #0]
34009bfc:	f002 48e0 	and.w	r8, r2, #1879048192	@ 0x70000000
34009c00:	07d8      	lsls	r0, r3, #31
34009c02:	d463      	bmi.n	34009ccc <HAL_RCC_OscConfig+0x120>
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
34009c04:	6823      	ldr	r3, [r4, #0]
34009c06:	0799      	lsls	r1, r3, #30
34009c08:	f100 80d4 	bmi.w	34009db4 <HAL_RCC_OscConfig+0x208>
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
34009c0c:	6823      	ldr	r3, [r4, #0]
34009c0e:	06d8      	lsls	r0, r3, #27
34009c10:	d522      	bpl.n	34009c58 <HAL_RCC_OscConfig+0xac>
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));
34009c12:	69e3      	ldr	r3, [r4, #28]
34009c14:	2b00      	cmp	r3, #0
34009c16:	f000 8347 	beq.w	3400a2a8 <HAL_RCC_OscConfig+0x6fc>
34009c1a:	2b04      	cmp	r3, #4
34009c1c:	f000 834d 	beq.w	3400a2ba <HAL_RCC_OscConfig+0x70e>
34009c20:	f44f 7102 	mov.w	r1, #520	@ 0x208
34009c24:	487c      	ldr	r0, [pc, #496]	@ (34009e18 <HAL_RCC_OscConfig+0x26c>)
34009c26:	f7f8 fff3 	bl	34002c10 <assert_failed>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
34009c2a:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
34009c2e:	f040 8148 	bne.w	34009ec2 <HAL_RCC_OscConfig+0x316>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
34009c32:	69e3      	ldr	r3, [r4, #28]
34009c34:	2b00      	cmp	r3, #0
34009c36:	d0bd      	beq.n	34009bb4 <HAL_RCC_OscConfig+0x8>
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
34009c38:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34009c3a:	2b1f      	cmp	r3, #31
34009c3c:	d904      	bls.n	34009c48 <HAL_RCC_OscConfig+0x9c>
34009c3e:	f240 211b 	movw	r1, #539	@ 0x21b
34009c42:	4875      	ldr	r0, [pc, #468]	@ (34009e18 <HAL_RCC_OscConfig+0x26c>)
34009c44:	f7f8 ffe4 	bl	34002c10 <assert_failed>
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
34009c48:	4a74      	ldr	r2, [pc, #464]	@ (34009e1c <HAL_RCC_OscConfig+0x270>)
34009c4a:	6a61      	ldr	r1, [r4, #36]	@ 0x24
34009c4c:	6c53      	ldr	r3, [r2, #68]	@ 0x44
34009c4e:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
34009c52:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34009c56:	6453      	str	r3, [r2, #68]	@ 0x44
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
34009c58:	6823      	ldr	r3, [r4, #0]
34009c5a:	0718      	lsls	r0, r3, #28
34009c5c:	f100 8189 	bmi.w	34009f72 <HAL_RCC_OscConfig+0x3c6>
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
34009c60:	6823      	ldr	r3, [r4, #0]
34009c62:	0759      	lsls	r1, r3, #29
34009c64:	f100 81b4 	bmi.w	34009fd0 <HAL_RCC_OscConfig+0x424>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));
34009c68:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34009c6a:	2b03      	cmp	r3, #3
34009c6c:	d904      	bls.n	34009c78 <HAL_RCC_OscConfig+0xcc>
34009c6e:	f44f 712a 	mov.w	r1, #680	@ 0x2a8
34009c72:	4869      	ldr	r0, [pc, #420]	@ (34009e18 <HAL_RCC_OscConfig+0x26c>)
34009c74:	f7f8 ffcc 	bl	34002c10 <assert_failed>
  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
34009c78:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
34009c7a:	2f00      	cmp	r7, #0
34009c7c:	f040 8210 	bne.w	3400a0a0 <HAL_RCC_OscConfig+0x4f4>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));
34009c80:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34009c82:	2b03      	cmp	r3, #3
34009c84:	d904      	bls.n	34009c90 <HAL_RCC_OscConfig+0xe4>
34009c86:	f240 21d6 	movw	r1, #726	@ 0x2d6
34009c8a:	4863      	ldr	r0, [pc, #396]	@ (34009e18 <HAL_RCC_OscConfig+0x26c>)
34009c8c:	f7f8 ffc0 	bl	34002c10 <assert_failed>
  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
34009c90:	6c67      	ldr	r7, [r4, #68]	@ 0x44
34009c92:	2f00      	cmp	r7, #0
34009c94:	f040 8246 	bne.w	3400a124 <HAL_RCC_OscConfig+0x578>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));
34009c98:	6e23      	ldr	r3, [r4, #96]	@ 0x60
34009c9a:	2b03      	cmp	r3, #3
34009c9c:	d904      	bls.n	34009ca8 <HAL_RCC_OscConfig+0xfc>
34009c9e:	f44f 7141 	mov.w	r1, #772	@ 0x304
34009ca2:	485d      	ldr	r0, [pc, #372]	@ (34009e18 <HAL_RCC_OscConfig+0x26c>)
34009ca4:	f7f8 ffb4 	bl	34002c10 <assert_failed>
  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
34009ca8:	6e27      	ldr	r7, [r4, #96]	@ 0x60
34009caa:	2f00      	cmp	r7, #0
34009cac:	f040 827a 	bne.w	3400a1a4 <HAL_RCC_OscConfig+0x5f8>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));
34009cb0:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
34009cb2:	2b03      	cmp	r3, #3
34009cb4:	d904      	bls.n	34009cc0 <HAL_RCC_OscConfig+0x114>
34009cb6:	f240 3131 	movw	r1, #817	@ 0x331
34009cba:	4857      	ldr	r0, [pc, #348]	@ (34009e18 <HAL_RCC_OscConfig+0x26c>)
34009cbc:	f7f8 ffa8 	bl	34002c10 <assert_failed>
  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
34009cc0:	6fe7      	ldr	r7, [r4, #124]	@ 0x7c
34009cc2:	2f00      	cmp	r7, #0
34009cc4:	f040 82b0 	bne.w	3400a228 <HAL_RCC_OscConfig+0x67c>
  return HAL_OK;
34009cc8:	2000      	movs	r0, #0
34009cca:	e774      	b.n	34009bb6 <HAL_RCC_OscConfig+0xa>
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));
34009ccc:	6863      	ldr	r3, [r4, #4]
34009cce:	2b00      	cmp	r3, #0
34009cd0:	f000 8313 	beq.w	3400a2fa <HAL_RCC_OscConfig+0x74e>
34009cd4:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
34009cd8:	2a10      	cmp	r2, #16
34009cda:	f000 8305 	beq.w	3400a2e8 <HAL_RCC_OscConfig+0x73c>
34009cde:	4a50      	ldr	r2, [pc, #320]	@ (34009e20 <HAL_RCC_OscConfig+0x274>)
34009ce0:	4293      	cmp	r3, r2
34009ce2:	f000 8301 	beq.w	3400a2e8 <HAL_RCC_OscConfig+0x73c>
34009ce6:	f240 1183 	movw	r1, #387	@ 0x183
34009cea:	484b      	ldr	r0, [pc, #300]	@ (34009e18 <HAL_RCC_OscConfig+0x26c>)
34009cec:	f7f8 ff90 	bl	34002c10 <assert_failed>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
34009cf0:	f5b6 1f00 	cmp.w	r6, #2097152	@ 0x200000
34009cf4:	d103      	bne.n	34009cfe <HAL_RCC_OscConfig+0x152>
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
34009cf6:	6863      	ldr	r3, [r4, #4]
34009cf8:	2b00      	cmp	r3, #0
34009cfa:	d183      	bne.n	34009c04 <HAL_RCC_OscConfig+0x58>
34009cfc:	e75a      	b.n	34009bb4 <HAL_RCC_OscConfig+0x8>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
34009cfe:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
34009d02:	d0f8      	beq.n	34009cf6 <HAL_RCC_OscConfig+0x14a>
34009d04:	f1bb 5f00 	cmp.w	fp, #536870912	@ 0x20000000
34009d08:	d101      	bne.n	34009d0e <HAL_RCC_OscConfig+0x162>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
34009d0a:	05fa      	lsls	r2, r7, #23
34009d0c:	d4f3      	bmi.n	34009cf6 <HAL_RCC_OscConfig+0x14a>
34009d0e:	f1ba 5f00 	cmp.w	sl, #536870912	@ 0x20000000
34009d12:	d101      	bne.n	34009d18 <HAL_RCC_OscConfig+0x16c>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34009d14:	05bb      	lsls	r3, r7, #22
34009d16:	d4ee      	bmi.n	34009cf6 <HAL_RCC_OscConfig+0x14a>
34009d18:	f1b9 5f00 	cmp.w	r9, #536870912	@ 0x20000000
34009d1c:	d101      	bne.n	34009d22 <HAL_RCC_OscConfig+0x176>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
34009d1e:	0578      	lsls	r0, r7, #21
34009d20:	d4e9      	bmi.n	34009cf6 <HAL_RCC_OscConfig+0x14a>
34009d22:	f1b8 5f00 	cmp.w	r8, #536870912	@ 0x20000000
34009d26:	d101      	bne.n	34009d2c <HAL_RCC_OscConfig+0x180>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34009d28:	0539      	lsls	r1, r7, #20
34009d2a:	d4e4      	bmi.n	34009cf6 <HAL_RCC_OscConfig+0x14a>
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
34009d2c:	6862      	ldr	r2, [r4, #4]
34009d2e:	4b3b      	ldr	r3, [pc, #236]	@ (34009e1c <HAL_RCC_OscConfig+0x270>)
34009d30:	2a10      	cmp	r2, #16
34009d32:	d114      	bne.n	34009d5e <HAL_RCC_OscConfig+0x1b2>
34009d34:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
      tickstart = HAL_GetTick();
34009d38:	f7fb f8a0 	bl	34004e7c <HAL_GetTick>
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
34009d3c:	6863      	ldr	r3, [r4, #4]
      tickstart = HAL_GetTick();
34009d3e:	9001      	str	r0, [sp, #4]
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
34009d40:	b35b      	cbz	r3, 34009d9a <HAL_RCC_OscConfig+0x1ee>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
34009d42:	4b36      	ldr	r3, [pc, #216]	@ (34009e1c <HAL_RCC_OscConfig+0x270>)
34009d44:	685a      	ldr	r2, [r3, #4]
34009d46:	06d2      	lsls	r2, r2, #27
34009d48:	f53f af5c 	bmi.w	34009c04 <HAL_RCC_OscConfig+0x58>
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34009d4c:	f7fb f896 	bl	34004e7c <HAL_GetTick>
34009d50:	9b01      	ldr	r3, [sp, #4]
34009d52:	1ac0      	subs	r0, r0, r3
34009d54:	2864      	cmp	r0, #100	@ 0x64
34009d56:	4b31      	ldr	r3, [pc, #196]	@ (34009e1c <HAL_RCC_OscConfig+0x270>)
34009d58:	d9f4      	bls.n	34009d44 <HAL_RCC_OscConfig+0x198>
            return HAL_TIMEOUT;
34009d5a:	2003      	movs	r0, #3
34009d5c:	e72b      	b.n	34009bb6 <HAL_RCC_OscConfig+0xa>
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
34009d5e:	b93a      	cbnz	r2, 34009d70 <HAL_RCC_OscConfig+0x1c4>
34009d60:	2110      	movs	r1, #16
34009d62:	4a30      	ldr	r2, [pc, #192]	@ (34009e24 <HAL_RCC_OscConfig+0x278>)
34009d64:	6011      	str	r1, [r2, #0]
34009d66:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
34009d68:	f422 32c0 	bic.w	r2, r2, #98304	@ 0x18000
34009d6c:	655a      	str	r2, [r3, #84]	@ 0x54
34009d6e:	e7e3      	b.n	34009d38 <HAL_RCC_OscConfig+0x18c>
34009d70:	f248 0110 	movw	r1, #32784	@ 0x8010
34009d74:	428a      	cmp	r2, r1
34009d76:	d109      	bne.n	34009d8c <HAL_RCC_OscConfig+0x1e0>
34009d78:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
34009d7a:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34009d7e:	655a      	str	r2, [r3, #84]	@ 0x54
34009d80:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
34009d82:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
34009d86:	655a      	str	r2, [r3, #84]	@ 0x54
34009d88:	2210      	movs	r2, #16
34009d8a:	e7d3      	b.n	34009d34 <HAL_RCC_OscConfig+0x188>
34009d8c:	4924      	ldr	r1, [pc, #144]	@ (34009e20 <HAL_RCC_OscConfig+0x274>)
34009d8e:	428a      	cmp	r2, r1
34009d90:	d1e6      	bne.n	34009d60 <HAL_RCC_OscConfig+0x1b4>
34009d92:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
34009d94:	f442 32c0 	orr.w	r2, r2, #98304	@ 0x18000
34009d98:	e7f5      	b.n	34009d86 <HAL_RCC_OscConfig+0x1da>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
34009d9a:	4b20      	ldr	r3, [pc, #128]	@ (34009e1c <HAL_RCC_OscConfig+0x270>)
34009d9c:	685a      	ldr	r2, [r3, #4]
34009d9e:	06d3      	lsls	r3, r2, #27
34009da0:	f57f af30 	bpl.w	34009c04 <HAL_RCC_OscConfig+0x58>
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34009da4:	f7fb f86a 	bl	34004e7c <HAL_GetTick>
34009da8:	9b01      	ldr	r3, [sp, #4]
34009daa:	1ac0      	subs	r0, r0, r3
34009dac:	2864      	cmp	r0, #100	@ 0x64
34009dae:	4b1b      	ldr	r3, [pc, #108]	@ (34009e1c <HAL_RCC_OscConfig+0x270>)
34009db0:	d9f4      	bls.n	34009d9c <HAL_RCC_OscConfig+0x1f0>
34009db2:	e7d2      	b.n	34009d5a <HAL_RCC_OscConfig+0x1ae>
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));
34009db4:	68e3      	ldr	r3, [r4, #12]
34009db6:	2b00      	cmp	r3, #0
34009db8:	f000 8288 	beq.w	3400a2cc <HAL_RCC_OscConfig+0x720>
34009dbc:	2b08      	cmp	r3, #8
34009dbe:	f000 828c 	beq.w	3400a2da <HAL_RCC_OscConfig+0x72e>
34009dc2:	f44f 71dc 	mov.w	r1, #440	@ 0x1b8
34009dc6:	4814      	ldr	r0, [pc, #80]	@ (34009e18 <HAL_RCC_OscConfig+0x26c>)
34009dc8:	f7f8 ff22 	bl	34002c10 <assert_failed>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
34009dcc:	bb66      	cbnz	r6, 34009e28 <HAL_RCC_OscConfig+0x27c>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
34009dce:	68e3      	ldr	r3, [r4, #12]
34009dd0:	2b00      	cmp	r3, #0
34009dd2:	f43f aeef 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
34009dd6:	6923      	ldr	r3, [r4, #16]
34009dd8:	f433 73c0 	bics.w	r3, r3, #384	@ 0x180
34009ddc:	d004      	beq.n	34009de8 <HAL_RCC_OscConfig+0x23c>
34009dde:	f44f 71e5 	mov.w	r1, #458	@ 0x1ca
34009de2:	480d      	ldr	r0, [pc, #52]	@ (34009e18 <HAL_RCC_OscConfig+0x26c>)
34009de4:	f7f8 ff14 	bl	34002c10 <assert_failed>
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));
34009de8:	6963      	ldr	r3, [r4, #20]
34009dea:	2b7f      	cmp	r3, #127	@ 0x7f
34009dec:	d904      	bls.n	34009df8 <HAL_RCC_OscConfig+0x24c>
34009dee:	f240 11cb 	movw	r1, #459	@ 0x1cb
34009df2:	4809      	ldr	r0, [pc, #36]	@ (34009e18 <HAL_RCC_OscConfig+0x26c>)
34009df4:	f7f8 ff0c 	bl	34002c10 <assert_failed>
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
34009df8:	4a08      	ldr	r2, [pc, #32]	@ (34009e1c <HAL_RCC_OscConfig+0x270>)
34009dfa:	6921      	ldr	r1, [r4, #16]
34009dfc:	6c93      	ldr	r3, [r2, #72]	@ 0x48
34009dfe:	f423 73c0 	bic.w	r3, r3, #384	@ 0x180
34009e02:	430b      	orrs	r3, r1
34009e04:	6493      	str	r3, [r2, #72]	@ 0x48
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
34009e06:	6c93      	ldr	r3, [r2, #72]	@ 0x48
34009e08:	6961      	ldr	r1, [r4, #20]
34009e0a:	f423 03fe 	bic.w	r3, r3, #8323072	@ 0x7f0000
34009e0e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34009e12:	6493      	str	r3, [r2, #72]	@ 0x48
}
34009e14:	e6fa      	b.n	34009c0c <HAL_RCC_OscConfig+0x60>
34009e16:	bf00      	nop
34009e18:	3402038c 	.word	0x3402038c
34009e1c:	56028000 	.word	0x56028000
34009e20:	00018010 	.word	0x00018010
34009e24:	56029000 	.word	0x56029000
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
34009e28:	2d00      	cmp	r5, #0
34009e2a:	d0d0      	beq.n	34009dce <HAL_RCC_OscConfig+0x222>
34009e2c:	f1bb 0f00 	cmp.w	fp, #0
34009e30:	d101      	bne.n	34009e36 <HAL_RCC_OscConfig+0x28a>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
34009e32:	05f8      	lsls	r0, r7, #23
34009e34:	d4cb      	bmi.n	34009dce <HAL_RCC_OscConfig+0x222>
34009e36:	f1ba 0f00 	cmp.w	sl, #0
34009e3a:	d101      	bne.n	34009e40 <HAL_RCC_OscConfig+0x294>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34009e3c:	05b9      	lsls	r1, r7, #22
34009e3e:	d4c6      	bmi.n	34009dce <HAL_RCC_OscConfig+0x222>
34009e40:	f1b9 0f00 	cmp.w	r9, #0
34009e44:	d101      	bne.n	34009e4a <HAL_RCC_OscConfig+0x29e>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
34009e46:	057a      	lsls	r2, r7, #21
34009e48:	d4c1      	bmi.n	34009dce <HAL_RCC_OscConfig+0x222>
34009e4a:	f1b8 0f00 	cmp.w	r8, #0
34009e4e:	d101      	bne.n	34009e54 <HAL_RCC_OscConfig+0x2a8>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34009e50:	053b      	lsls	r3, r7, #20
34009e52:	d4bc      	bmi.n	34009dce <HAL_RCC_OscConfig+0x222>
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
34009e54:	68e3      	ldr	r3, [r4, #12]
34009e56:	b313      	cbz	r3, 34009e9e <HAL_RCC_OscConfig+0x2f2>
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
34009e58:	6923      	ldr	r3, [r4, #16]
34009e5a:	f433 73c0 	bics.w	r3, r3, #384	@ 0x180
34009e5e:	d004      	beq.n	34009e6a <HAL_RCC_OscConfig+0x2be>
34009e60:	f240 11d9 	movw	r1, #473	@ 0x1d9
34009e64:	48ab      	ldr	r0, [pc, #684]	@ (3400a114 <HAL_RCC_OscConfig+0x568>)
34009e66:	f7f8 fed3 	bl	34002c10 <assert_failed>
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));
34009e6a:	6963      	ldr	r3, [r4, #20]
34009e6c:	2b7f      	cmp	r3, #127	@ 0x7f
34009e6e:	d904      	bls.n	34009e7a <HAL_RCC_OscConfig+0x2ce>
34009e70:	f44f 71ed 	mov.w	r1, #474	@ 0x1da
34009e74:	48a7      	ldr	r0, [pc, #668]	@ (3400a114 <HAL_RCC_OscConfig+0x568>)
34009e76:	f7f8 fecb 	bl	34002c10 <assert_failed>
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
34009e7a:	2208      	movs	r2, #8
34009e7c:	4ba6      	ldr	r3, [pc, #664]	@ (3400a118 <HAL_RCC_OscConfig+0x56c>)
34009e7e:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
        tickstart = HAL_GetTick();
34009e82:	f7fa fffb 	bl	34004e7c <HAL_GetTick>
34009e86:	9001      	str	r0, [sp, #4]
        while (LL_RCC_HSI_IsReady() == 0U)
34009e88:	f7ff fc6a 	bl	34009760 <LL_RCC_HSI_IsReady>
34009e8c:	2800      	cmp	r0, #0
34009e8e:	d1b3      	bne.n	34009df8 <HAL_RCC_OscConfig+0x24c>
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
34009e90:	f7fa fff4 	bl	34004e7c <HAL_GetTick>
34009e94:	9b01      	ldr	r3, [sp, #4]
34009e96:	1ac0      	subs	r0, r0, r3
34009e98:	2801      	cmp	r0, #1
34009e9a:	d9f5      	bls.n	34009e88 <HAL_RCC_OscConfig+0x2dc>
34009e9c:	e75d      	b.n	34009d5a <HAL_RCC_OscConfig+0x1ae>
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
34009e9e:	2208      	movs	r2, #8
34009ea0:	4b9e      	ldr	r3, [pc, #632]	@ (3400a11c <HAL_RCC_OscConfig+0x570>)
34009ea2:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
34009ea4:	f7fa ffea 	bl	34004e7c <HAL_GetTick>
34009ea8:	9001      	str	r0, [sp, #4]
        while (LL_RCC_HSI_IsReady() != 0U)
34009eaa:	f7ff fc59 	bl	34009760 <LL_RCC_HSI_IsReady>
34009eae:	2800      	cmp	r0, #0
34009eb0:	f43f aeac 	beq.w	34009c0c <HAL_RCC_OscConfig+0x60>
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
34009eb4:	f7fa ffe2 	bl	34004e7c <HAL_GetTick>
34009eb8:	9b01      	ldr	r3, [sp, #4]
34009eba:	1ac0      	subs	r0, r0, r3
34009ebc:	2801      	cmp	r0, #1
34009ebe:	d9f4      	bls.n	34009eaa <HAL_RCC_OscConfig+0x2fe>
34009ec0:	e74b      	b.n	34009d5a <HAL_RCC_OscConfig+0x1ae>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
34009ec2:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
34009ec6:	f43f aeb4 	beq.w	34009c32 <HAL_RCC_OscConfig+0x86>
34009eca:	f1bb 5f80 	cmp.w	fp, #268435456	@ 0x10000000
34009ece:	d102      	bne.n	34009ed6 <HAL_RCC_OscConfig+0x32a>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
34009ed0:	05f9      	lsls	r1, r7, #23
34009ed2:	f53f aeae 	bmi.w	34009c32 <HAL_RCC_OscConfig+0x86>
34009ed6:	f1ba 5f80 	cmp.w	sl, #268435456	@ 0x10000000
34009eda:	d102      	bne.n	34009ee2 <HAL_RCC_OscConfig+0x336>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34009edc:	05ba      	lsls	r2, r7, #22
34009ede:	f53f aea8 	bmi.w	34009c32 <HAL_RCC_OscConfig+0x86>
34009ee2:	f1b9 5f80 	cmp.w	r9, #268435456	@ 0x10000000
34009ee6:	d102      	bne.n	34009eee <HAL_RCC_OscConfig+0x342>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
34009ee8:	057b      	lsls	r3, r7, #21
34009eea:	f53f aea2 	bmi.w	34009c32 <HAL_RCC_OscConfig+0x86>
34009eee:	f1b8 5f80 	cmp.w	r8, #268435456	@ 0x10000000
34009ef2:	d102      	bne.n	34009efa <HAL_RCC_OscConfig+0x34e>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34009ef4:	053f      	lsls	r7, r7, #20
34009ef6:	f53f ae9c 	bmi.w	34009c32 <HAL_RCC_OscConfig+0x86>
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
34009efa:	69e3      	ldr	r3, [r4, #28]
34009efc:	b343      	cbz	r3, 34009f50 <HAL_RCC_OscConfig+0x3a4>
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
34009efe:	6a23      	ldr	r3, [r4, #32]
34009f00:	f433 7300 	bics.w	r3, r3, #512	@ 0x200
34009f04:	d004      	beq.n	34009f10 <HAL_RCC_OscConfig+0x364>
34009f06:	f240 2127 	movw	r1, #551	@ 0x227
34009f0a:	4882      	ldr	r0, [pc, #520]	@ (3400a114 <HAL_RCC_OscConfig+0x568>)
34009f0c:	f7f8 fe80 	bl	34002c10 <assert_failed>
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
34009f10:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34009f12:	2b1f      	cmp	r3, #31
34009f14:	d904      	bls.n	34009f20 <HAL_RCC_OscConfig+0x374>
34009f16:	f44f 710a 	mov.w	r1, #552	@ 0x228
34009f1a:	487e      	ldr	r0, [pc, #504]	@ (3400a114 <HAL_RCC_OscConfig+0x568>)
34009f1c:	f7f8 fe78 	bl	34002c10 <assert_failed>
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
34009f20:	4a7d      	ldr	r2, [pc, #500]	@ (3400a118 <HAL_RCC_OscConfig+0x56c>)
34009f22:	6a21      	ldr	r1, [r4, #32]
34009f24:	6c53      	ldr	r3, [r2, #68]	@ 0x44
34009f26:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
34009f2a:	430b      	orrs	r3, r1
34009f2c:	6453      	str	r3, [r2, #68]	@ 0x44
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
34009f2e:	2304      	movs	r3, #4
34009f30:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800
        tickstart = HAL_GetTick();
34009f34:	f7fa ffa2 	bl	34004e7c <HAL_GetTick>
34009f38:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() == 0U)
34009f3a:	f7ff fc19 	bl	34009770 <LL_RCC_MSI_IsReady>
34009f3e:	2800      	cmp	r0, #0
34009f40:	f47f ae82 	bne.w	34009c48 <HAL_RCC_OscConfig+0x9c>
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34009f44:	f7fa ff9a 	bl	34004e7c <HAL_GetTick>
34009f48:	1bc0      	subs	r0, r0, r7
34009f4a:	2801      	cmp	r0, #1
34009f4c:	d9f5      	bls.n	34009f3a <HAL_RCC_OscConfig+0x38e>
34009f4e:	e704      	b.n	34009d5a <HAL_RCC_OscConfig+0x1ae>
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
34009f50:	2204      	movs	r2, #4
34009f52:	4b72      	ldr	r3, [pc, #456]	@ (3400a11c <HAL_RCC_OscConfig+0x570>)
34009f54:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
34009f56:	f7fa ff91 	bl	34004e7c <HAL_GetTick>
34009f5a:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() != 0U)
34009f5c:	f7ff fc08 	bl	34009770 <LL_RCC_MSI_IsReady>
34009f60:	2800      	cmp	r0, #0
34009f62:	f43f ae79 	beq.w	34009c58 <HAL_RCC_OscConfig+0xac>
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34009f66:	f7fa ff89 	bl	34004e7c <HAL_GetTick>
34009f6a:	1bc0      	subs	r0, r0, r7
34009f6c:	2801      	cmp	r0, #1
34009f6e:	d9f5      	bls.n	34009f5c <HAL_RCC_OscConfig+0x3b0>
34009f70:	e6f3      	b.n	34009d5a <HAL_RCC_OscConfig+0x1ae>
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));
34009f72:	69a3      	ldr	r3, [r4, #24]
34009f74:	2b01      	cmp	r3, #1
34009f76:	d904      	bls.n	34009f82 <HAL_RCC_OscConfig+0x3d6>
34009f78:	f44f 7116 	mov.w	r1, #600	@ 0x258
34009f7c:	4865      	ldr	r0, [pc, #404]	@ (3400a114 <HAL_RCC_OscConfig+0x568>)
34009f7e:	f7f8 fe47 	bl	34002c10 <assert_failed>
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
34009f82:	69a2      	ldr	r2, [r4, #24]
34009f84:	2301      	movs	r3, #1
34009f86:	b18a      	cbz	r2, 34009fac <HAL_RCC_OscConfig+0x400>
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
34009f88:	f8df 818c 	ldr.w	r8, [pc, #396]	@ 3400a118 <HAL_RCC_OscConfig+0x56c>
34009f8c:	f8c8 3800 	str.w	r3, [r8, #2048]	@ 0x800
      tickstart = HAL_GetTick();
34009f90:	f7fa ff74 	bl	34004e7c <HAL_GetTick>
34009f94:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
34009f96:	f8d8 3004 	ldr.w	r3, [r8, #4]
      while (LL_RCC_LSI_IsReady() == 0U)
34009f9a:	07da      	lsls	r2, r3, #31
34009f9c:	f53f ae60 	bmi.w	34009c60 <HAL_RCC_OscConfig+0xb4>
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
34009fa0:	f7fa ff6c 	bl	34004e7c <HAL_GetTick>
34009fa4:	1bc0      	subs	r0, r0, r7
34009fa6:	2801      	cmp	r0, #1
34009fa8:	d9f5      	bls.n	34009f96 <HAL_RCC_OscConfig+0x3ea>
34009faa:	e6d6      	b.n	34009d5a <HAL_RCC_OscConfig+0x1ae>
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
34009fac:	4a5b      	ldr	r2, [pc, #364]	@ (3400a11c <HAL_RCC_OscConfig+0x570>)
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
34009fae:	f8df 8168 	ldr.w	r8, [pc, #360]	@ 3400a118 <HAL_RCC_OscConfig+0x56c>
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
34009fb2:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
34009fb4:	f7fa ff62 	bl	34004e7c <HAL_GetTick>
34009fb8:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
34009fba:	f8d8 3004 	ldr.w	r3, [r8, #4]
      while (LL_RCC_LSI_IsReady() != 0U)
34009fbe:	07db      	lsls	r3, r3, #31
34009fc0:	f57f ae4e 	bpl.w	34009c60 <HAL_RCC_OscConfig+0xb4>
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
34009fc4:	f7fa ff5a 	bl	34004e7c <HAL_GetTick>
34009fc8:	1bc0      	subs	r0, r0, r7
34009fca:	2801      	cmp	r0, #1
34009fcc:	d9f5      	bls.n	34009fba <HAL_RCC_OscConfig+0x40e>
34009fce:	e6c4      	b.n	34009d5a <HAL_RCC_OscConfig+0x1ae>
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));
34009fd0:	68a3      	ldr	r3, [r4, #8]
34009fd2:	f033 0202 	bics.w	r2, r3, #2
34009fd6:	d00a      	beq.n	34009fee <HAL_RCC_OscConfig+0x442>
34009fd8:	f248 0202 	movw	r2, #32770	@ 0x8002
34009fdc:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34009fe0:	4293      	cmp	r3, r2
34009fe2:	d004      	beq.n	34009fee <HAL_RCC_OscConfig+0x442>
34009fe4:	f240 2183 	movw	r1, #643	@ 0x283
34009fe8:	484a      	ldr	r0, [pc, #296]	@ (3400a114 <HAL_RCC_OscConfig+0x568>)
34009fea:	f7f8 fe11 	bl	34002c10 <assert_failed>
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
34009fee:	68a3      	ldr	r3, [r4, #8]
34009ff0:	4f49      	ldr	r7, [pc, #292]	@ (3400a118 <HAL_RCC_OscConfig+0x56c>)
34009ff2:	2b02      	cmp	r3, #2
34009ff4:	d113      	bne.n	3400a01e <HAL_RCC_OscConfig+0x472>
34009ff6:	f8c7 3800 	str.w	r3, [r7, #2048]	@ 0x800
      tickstart = HAL_GetTick();
34009ffa:	f7fa ff3f 	bl	34004e7c <HAL_GetTick>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
34009ffe:	f241 3888 	movw	r8, #5000	@ 0x1388
      tickstart = HAL_GetTick();
3400a002:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3400a004:	f8df 9110 	ldr.w	r9, [pc, #272]	@ 3400a118 <HAL_RCC_OscConfig+0x56c>
3400a008:	f8d9 3004 	ldr.w	r3, [r9, #4]
3400a00c:	0798      	lsls	r0, r3, #30
3400a00e:	f53f ae2b 	bmi.w	34009c68 <HAL_RCC_OscConfig+0xbc>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400a012:	f7fa ff33 	bl	34004e7c <HAL_GetTick>
3400a016:	1bc3      	subs	r3, r0, r7
3400a018:	4543      	cmp	r3, r8
3400a01a:	d9f5      	bls.n	3400a008 <HAL_RCC_OscConfig+0x45c>
3400a01c:	e69d      	b.n	34009d5a <HAL_RCC_OscConfig+0x1ae>
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
3400a01e:	b9d3      	cbnz	r3, 3400a056 <HAL_RCC_OscConfig+0x4aa>
3400a020:	2202      	movs	r2, #2
3400a022:	4b3e      	ldr	r3, [pc, #248]	@ (3400a11c <HAL_RCC_OscConfig+0x570>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400a024:	f241 3988 	movw	r9, #5000	@ 0x1388
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
3400a028:	601a      	str	r2, [r3, #0]
3400a02a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400a02c:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400a030:	643b      	str	r3, [r7, #64]	@ 0x40
3400a032:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400a034:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3400a038:	643b      	str	r3, [r7, #64]	@ 0x40
      tickstart = HAL_GetTick();
3400a03a:	f7fa ff1f 	bl	34004e7c <HAL_GetTick>
3400a03e:	4680      	mov	r8, r0
3400a040:	687b      	ldr	r3, [r7, #4]
3400a042:	0799      	lsls	r1, r3, #30
3400a044:	f57f ae10 	bpl.w	34009c68 <HAL_RCC_OscConfig+0xbc>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400a048:	f7fa ff18 	bl	34004e7c <HAL_GetTick>
3400a04c:	eba0 0308 	sub.w	r3, r0, r8
3400a050:	454b      	cmp	r3, r9
3400a052:	d9f5      	bls.n	3400a040 <HAL_RCC_OscConfig+0x494>
3400a054:	e681      	b.n	34009d5a <HAL_RCC_OscConfig+0x1ae>
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
3400a056:	f248 0202 	movw	r2, #32770	@ 0x8002
3400a05a:	4293      	cmp	r3, r2
3400a05c:	d109      	bne.n	3400a072 <HAL_RCC_OscConfig+0x4c6>
3400a05e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400a060:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400a064:	643b      	str	r3, [r7, #64]	@ 0x40
3400a066:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400a068:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400a06c:	643b      	str	r3, [r7, #64]	@ 0x40
3400a06e:	2302      	movs	r3, #2
3400a070:	e7c1      	b.n	34009ff6 <HAL_RCC_OscConfig+0x44a>
3400a072:	4a2b      	ldr	r2, [pc, #172]	@ (3400a120 <HAL_RCC_OscConfig+0x574>)
3400a074:	4293      	cmp	r3, r2
3400a076:	d107      	bne.n	3400a088 <HAL_RCC_OscConfig+0x4dc>
3400a078:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400a07a:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400a07e:	643b      	str	r3, [r7, #64]	@ 0x40
3400a080:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400a082:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3400a086:	e7f1      	b.n	3400a06c <HAL_RCC_OscConfig+0x4c0>
3400a088:	2202      	movs	r2, #2
3400a08a:	4b24      	ldr	r3, [pc, #144]	@ (3400a11c <HAL_RCC_OscConfig+0x570>)
3400a08c:	601a      	str	r2, [r3, #0]
3400a08e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400a090:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3400a094:	643b      	str	r3, [r7, #64]	@ 0x40
3400a096:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400a098:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400a09c:	643b      	str	r3, [r7, #64]	@ 0x40
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
3400a09e:	e7ac      	b.n	34009ffa <HAL_RCC_OscConfig+0x44e>
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
3400a0a0:	2000      	movs	r0, #0
3400a0a2:	f104 0128 	add.w	r1, r4, #40	@ 0x28
3400a0a6:	f7ff fb73 	bl	34009790 <RCC_PLL_IsNewConfig>
3400a0aa:	4602      	mov	r2, r0
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
3400a0ac:	f7ff fb68 	bl	34009780 <LL_RCC_PLL1_IsReady>
    if (new_pll_config == 1U)
3400a0b0:	2a01      	cmp	r2, #1
3400a0b2:	d125      	bne.n	3400a100 <HAL_RCC_OscConfig+0x554>
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400a0b4:	4b18      	ldr	r3, [pc, #96]	@ (3400a118 <HAL_RCC_OscConfig+0x56c>)
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
3400a0b6:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
3400a0ba:	f8d3 70c4 	ldr.w	r7, [r3, #196]	@ 0xc4
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a0be:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400a0c2:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3400a0c6:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3400a0ca:	d103      	bne.n	3400a0d4 <HAL_RCC_OscConfig+0x528>
3400a0cc:	f017 5f40 	tst.w	r7, #805306368	@ 0x30000000
3400a0d0:	f43f ad70 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
3400a0d4:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
3400a0d8:	d10b      	bne.n	3400a0f2 <HAL_RCC_OscConfig+0x546>
3400a0da:	f010 5f40 	tst.w	r0, #805306368	@ 0x30000000
3400a0de:	f43f ad69 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
3400a0e2:	f012 5f40 	tst.w	r2, #805306368	@ 0x30000000
3400a0e6:	f43f ad65 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
3400a0ea:	f013 5f40 	tst.w	r3, #805306368	@ 0x30000000
3400a0ee:	f43f ad61 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
3400a0f2:	2000      	movs	r0, #0
3400a0f4:	f7ff fba6 	bl	34009844 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
3400a0f8:	2800      	cmp	r0, #0
3400a0fa:	f43f adc1 	beq.w	34009c80 <HAL_RCC_OscConfig+0xd4>
3400a0fe:	e559      	b.n	34009bb4 <HAL_RCC_OscConfig+0x8>
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
3400a100:	2f02      	cmp	r7, #2
3400a102:	f47f adbd 	bne.w	34009c80 <HAL_RCC_OscConfig+0xd4>
3400a106:	2800      	cmp	r0, #0
3400a108:	f47f adba 	bne.w	34009c80 <HAL_RCC_OscConfig+0xd4>
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
3400a10c:	f7ff fb82 	bl	34009814 <RCC_PLL_Enable>
3400a110:	e7f2      	b.n	3400a0f8 <HAL_RCC_OscConfig+0x54c>
3400a112:	bf00      	nop
3400a114:	3402038c 	.word	0x3402038c
3400a118:	56028000 	.word	0x56028000
3400a11c:	56029000 	.word	0x56029000
3400a120:	00018002 	.word	0x00018002
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
3400a124:	2001      	movs	r0, #1
3400a126:	f104 0144 	add.w	r1, r4, #68	@ 0x44
3400a12a:	f7ff fb31 	bl	34009790 <RCC_PLL_IsNewConfig>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3400a12e:	4b77      	ldr	r3, [pc, #476]	@ (3400a30c <HAL_RCC_OscConfig+0x760>)
    if (new_pll_config == 1U)
3400a130:	2801      	cmp	r0, #1
3400a132:	685a      	ldr	r2, [r3, #4]
3400a134:	d12c      	bne.n	3400a190 <HAL_RCC_OscConfig+0x5e4>
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
3400a136:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400a13a:	f8d3 70c4 	ldr.w	r7, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a13e:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400a142:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3400a146:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3400a14a:	d105      	bne.n	3400a158 <HAL_RCC_OscConfig+0x5ac>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400a14c:	f007 5740 	and.w	r7, r7, #805306368	@ 0x30000000
3400a150:	f1b7 5f80 	cmp.w	r7, #268435456	@ 0x10000000
3400a154:	f43f ad2e 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
3400a158:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
3400a15c:	d111      	bne.n	3400a182 <HAL_RCC_OscConfig+0x5d6>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a15e:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400a162:	f1b0 5f80 	cmp.w	r0, #268435456	@ 0x10000000
3400a166:	f43f ad25 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400a16a:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
3400a16e:	f1b2 5f80 	cmp.w	r2, #268435456	@ 0x10000000
3400a172:	f43f ad1f 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3400a176:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
3400a17a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400a17e:	f43f ad19 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
3400a182:	2001      	movs	r0, #1
3400a184:	f7ff fb5e 	bl	34009844 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
3400a188:	2800      	cmp	r0, #0
3400a18a:	f43f ad85 	beq.w	34009c98 <HAL_RCC_OscConfig+0xec>
3400a18e:	e511      	b.n	34009bb4 <HAL_RCC_OscConfig+0x8>
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
3400a190:	2f02      	cmp	r7, #2
3400a192:	f47f ad81 	bne.w	34009c98 <HAL_RCC_OscConfig+0xec>
3400a196:	0592      	lsls	r2, r2, #22
3400a198:	f53f ad7e 	bmi.w	34009c98 <HAL_RCC_OscConfig+0xec>
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
3400a19c:	2001      	movs	r0, #1
3400a19e:	f7ff fb39 	bl	34009814 <RCC_PLL_Enable>
3400a1a2:	e7f1      	b.n	3400a188 <HAL_RCC_OscConfig+0x5dc>
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
3400a1a4:	2002      	movs	r0, #2
3400a1a6:	f104 0160 	add.w	r1, r4, #96	@ 0x60
3400a1aa:	f7ff faf1 	bl	34009790 <RCC_PLL_IsNewConfig>
3400a1ae:	4602      	mov	r2, r0
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
3400a1b0:	f7ff fae6 	bl	34009780 <LL_RCC_PLL1_IsReady>
    if (new_pll_config == 1U)
3400a1b4:	2a01      	cmp	r2, #1
3400a1b6:	d12d      	bne.n	3400a214 <HAL_RCC_OscConfig+0x668>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400a1b8:	4b54      	ldr	r3, [pc, #336]	@ (3400a30c <HAL_RCC_OscConfig+0x760>)
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
3400a1ba:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
3400a1be:	f8d3 70c4 	ldr.w	r7, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a1c2:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400a1c6:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3400a1ca:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3400a1ce:	d105      	bne.n	3400a1dc <HAL_RCC_OscConfig+0x630>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400a1d0:	f007 5740 	and.w	r7, r7, #805306368	@ 0x30000000
3400a1d4:	f1b7 5f00 	cmp.w	r7, #536870912	@ 0x20000000
3400a1d8:	f43f acec 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
3400a1dc:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
3400a1e0:	d111      	bne.n	3400a206 <HAL_RCC_OscConfig+0x65a>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a1e2:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400a1e6:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
3400a1ea:	f43f ace3 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400a1ee:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
3400a1f2:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
3400a1f6:	f43f acdd 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3400a1fa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
3400a1fe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a202:	f43f acd7 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
3400a206:	2002      	movs	r0, #2
3400a208:	f7ff fb1c 	bl	34009844 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
3400a20c:	2800      	cmp	r0, #0
3400a20e:	f43f ad4f 	beq.w	34009cb0 <HAL_RCC_OscConfig+0x104>
3400a212:	e4cf      	b.n	34009bb4 <HAL_RCC_OscConfig+0x8>
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
3400a214:	2f02      	cmp	r7, #2
3400a216:	f47f ad4b 	bne.w	34009cb0 <HAL_RCC_OscConfig+0x104>
3400a21a:	2800      	cmp	r0, #0
3400a21c:	f47f ad48 	bne.w	34009cb0 <HAL_RCC_OscConfig+0x104>
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
3400a220:	4638      	mov	r0, r7
3400a222:	f7ff faf7 	bl	34009814 <RCC_PLL_Enable>
3400a226:	e7f1      	b.n	3400a20c <HAL_RCC_OscConfig+0x660>
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
3400a228:	2003      	movs	r0, #3
3400a22a:	f104 017c 	add.w	r1, r4, #124	@ 0x7c
3400a22e:	f7ff faaf 	bl	34009790 <RCC_PLL_IsNewConfig>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3400a232:	4b36      	ldr	r3, [pc, #216]	@ (3400a30c <HAL_RCC_OscConfig+0x760>)
    if (new_pll_config == 1U)
3400a234:	2801      	cmp	r0, #1
3400a236:	685a      	ldr	r2, [r3, #4]
3400a238:	d12c      	bne.n	3400a294 <HAL_RCC_OscConfig+0x6e8>
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
3400a23a:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400a23e:	f8d3 40c4 	ldr.w	r4, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a242:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400a246:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3400a24a:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3400a24e:	d105      	bne.n	3400a25c <HAL_RCC_OscConfig+0x6b0>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400a250:	f004 5640 	and.w	r6, r4, #805306368	@ 0x30000000
3400a254:	f1b6 5f40 	cmp.w	r6, #805306368	@ 0x30000000
3400a258:	f43f acac 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
3400a25c:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
3400a260:	d111      	bne.n	3400a286 <HAL_RCC_OscConfig+0x6da>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a262:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400a266:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
3400a26a:	f43f aca3 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400a26e:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
3400a272:	f1b2 5f40 	cmp.w	r2, #805306368	@ 0x30000000
3400a276:	f43f ac9d 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3400a27a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
3400a27e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a282:	f43f ac97 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
3400a286:	2003      	movs	r0, #3
3400a288:	f7ff fadc 	bl	34009844 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
3400a28c:	3800      	subs	r0, #0
3400a28e:	bf18      	it	ne
3400a290:	2001      	movne	r0, #1
3400a292:	e490      	b.n	34009bb6 <HAL_RCC_OscConfig+0xa>
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
3400a294:	2f02      	cmp	r7, #2
3400a296:	f47f ad17 	bne.w	34009cc8 <HAL_RCC_OscConfig+0x11c>
3400a29a:	0513      	lsls	r3, r2, #20
3400a29c:	f53f ad14 	bmi.w	34009cc8 <HAL_RCC_OscConfig+0x11c>
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
3400a2a0:	2003      	movs	r0, #3
3400a2a2:	f7ff fab7 	bl	34009814 <RCC_PLL_Enable>
3400a2a6:	e7f1      	b.n	3400a28c <HAL_RCC_OscConfig+0x6e0>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
3400a2a8:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
3400a2ac:	f43f ac82 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
3400a2b0:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
3400a2b4:	f47f ae09 	bne.w	34009eca <HAL_RCC_OscConfig+0x31e>
3400a2b8:	e47c      	b.n	34009bb4 <HAL_RCC_OscConfig+0x8>
3400a2ba:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
3400a2be:	f43f acbb 	beq.w	34009c38 <HAL_RCC_OscConfig+0x8c>
3400a2c2:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
3400a2c6:	f47f ae00 	bne.w	34009eca <HAL_RCC_OscConfig+0x31e>
3400a2ca:	e4b5      	b.n	34009c38 <HAL_RCC_OscConfig+0x8c>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
3400a2cc:	2e00      	cmp	r6, #0
3400a2ce:	f43f ac71 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
3400a2d2:	2d00      	cmp	r5, #0
3400a2d4:	f47f adaa 	bne.w	34009e2c <HAL_RCC_OscConfig+0x280>
3400a2d8:	e46c      	b.n	34009bb4 <HAL_RCC_OscConfig+0x8>
3400a2da:	2e00      	cmp	r6, #0
3400a2dc:	f43f ad7b 	beq.w	34009dd6 <HAL_RCC_OscConfig+0x22a>
3400a2e0:	2d00      	cmp	r5, #0
3400a2e2:	f43f ad78 	beq.w	34009dd6 <HAL_RCC_OscConfig+0x22a>
3400a2e6:	e5a1      	b.n	34009e2c <HAL_RCC_OscConfig+0x280>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
3400a2e8:	f5b6 1f00 	cmp.w	r6, #2097152	@ 0x200000
3400a2ec:	f43f ac8a 	beq.w	34009c04 <HAL_RCC_OscConfig+0x58>
3400a2f0:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
3400a2f4:	f47f ad06 	bne.w	34009d04 <HAL_RCC_OscConfig+0x158>
3400a2f8:	e484      	b.n	34009c04 <HAL_RCC_OscConfig+0x58>
3400a2fa:	f5b6 1f00 	cmp.w	r6, #2097152	@ 0x200000
3400a2fe:	f43f ac59 	beq.w	34009bb4 <HAL_RCC_OscConfig+0x8>
3400a302:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
3400a306:	f47f acfd 	bne.w	34009d04 <HAL_RCC_OscConfig+0x158>
3400a30a:	e453      	b.n	34009bb4 <HAL_RCC_OscConfig+0x8>
3400a30c:	56028000 	.word	0x56028000

3400a310 <HAL_RCC_GetCpuClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
3400a310:	4b1f      	ldr	r3, [pc, #124]	@ (3400a390 <HAL_RCC_GetCpuClockFreq+0x80>)
{
3400a312:	b510      	push	{r4, lr}
3400a314:	6a1a      	ldr	r2, [r3, #32]
3400a316:	f402 1240 	and.w	r2, r2, #3145728	@ 0x300000
  switch (LL_RCC_GetCpuClkSource())
3400a31a:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
3400a31e:	d034      	beq.n	3400a38a <HAL_RCC_GetCpuClockFreq+0x7a>
3400a320:	d806      	bhi.n	3400a330 <HAL_RCC_GetCpuClockFreq+0x20>
3400a322:	b952      	cbnz	r2, 3400a33a <HAL_RCC_GetCpuClockFreq+0x2a>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400a324:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400a326:	481b      	ldr	r0, [pc, #108]	@ (3400a394 <HAL_RCC_GetCpuClockFreq+0x84>)
3400a328:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400a32c:	40d8      	lsrs	r0, r3
}
3400a32e:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetCpuClkSource())
3400a330:	f5b2 1f40 	cmp.w	r2, #3145728	@ 0x300000
3400a334:	d009      	beq.n	3400a34a <HAL_RCC_GetCpuClockFreq+0x3a>
      switch (LL_RCC_IC1_GetSource())
3400a336:	2000      	movs	r0, #0
3400a338:	e7f9      	b.n	3400a32e <HAL_RCC_GetCpuClockFreq+0x1e>
      frequency = RCC_GET_MSI_FREQUENCY();
3400a33a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400a33c:	4816      	ldr	r0, [pc, #88]	@ (3400a398 <HAL_RCC_GetCpuClockFreq+0x88>)
3400a33e:	f413 7f00 	tst.w	r3, #512	@ 0x200
3400a342:	4b16      	ldr	r3, [pc, #88]	@ (3400a39c <HAL_RCC_GetCpuClockFreq+0x8c>)
3400a344:	bf18      	it	ne
3400a346:	4618      	movne	r0, r3
3400a348:	e7f1      	b.n	3400a32e <HAL_RCC_GetCpuClockFreq+0x1e>
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
3400a34a:	f8d3 00c4 	ldr.w	r0, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400a34e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
3400a352:	f3c0 4007 	ubfx	r0, r0, #16, #8
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400a356:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
      switch (LL_RCC_IC1_GetSource())
3400a35a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
3400a35e:	f100 0401 	add.w	r4, r0, #1
3400a362:	d00f      	beq.n	3400a384 <HAL_RCC_GetCpuClockFreq+0x74>
3400a364:	d805      	bhi.n	3400a372 <HAL_RCC_GetCpuClockFreq+0x62>
3400a366:	b953      	cbnz	r3, 3400a37e <HAL_RCC_GetCpuClockFreq+0x6e>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400a368:	f003 fb7e 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
          frequency = frequency / ic_divider;
3400a36c:	fbb0 f0f4 	udiv	r0, r0, r4
          break;
3400a370:	e7dd      	b.n	3400a32e <HAL_RCC_GetCpuClockFreq+0x1e>
      switch (LL_RCC_IC1_GetSource())
3400a372:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a376:	d1de      	bne.n	3400a336 <HAL_RCC_GetCpuClockFreq+0x26>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a378:	f003 fc36 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400a37c:	e7f6      	b.n	3400a36c <HAL_RCC_GetCpuClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400a37e:	f003 fbb3 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400a382:	e7f3      	b.n	3400a36c <HAL_RCC_GetCpuClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400a384:	f003 fbf0 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400a388:	e7f0      	b.n	3400a36c <HAL_RCC_GetCpuClockFreq+0x5c>
  switch (LL_RCC_GetCpuClkSource())
3400a38a:	4805      	ldr	r0, [pc, #20]	@ (3400a3a0 <HAL_RCC_GetCpuClockFreq+0x90>)
3400a38c:	e7cf      	b.n	3400a32e <HAL_RCC_GetCpuClockFreq+0x1e>
3400a38e:	bf00      	nop
3400a390:	56028000 	.word	0x56028000
3400a394:	03d09000 	.word	0x03d09000
3400a398:	003d0900 	.word	0x003d0900
3400a39c:	00f42400 	.word	0x00f42400
3400a3a0:	02dc6c00 	.word	0x02dc6c00

3400a3a4 <HAL_RCC_ClockConfig>:
{
3400a3a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (pRCC_ClkInitStruct == NULL)
3400a3a8:	4604      	mov	r4, r0
3400a3aa:	b910      	cbnz	r0, 3400a3b2 <HAL_RCC_ClockConfig+0xe>
    return HAL_ERROR;
3400a3ac:	2001      	movs	r0, #1
}
3400a3ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));
3400a3b2:	6803      	ldr	r3, [r0, #0]
3400a3b4:	2b7f      	cmp	r3, #127	@ 0x7f
3400a3b6:	d904      	bls.n	3400a3c2 <HAL_RCC_ClockConfig+0x1e>
3400a3b8:	f240 3181 	movw	r1, #897	@ 0x381
3400a3bc:	4893      	ldr	r0, [pc, #588]	@ (3400a60c <HAL_RCC_ClockConfig+0x268>)
3400a3be:	f7f8 fc27 	bl	34002c10 <assert_failed>
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3400a3c2:	6823      	ldr	r3, [r4, #0]
3400a3c4:	071f      	lsls	r7, r3, #28
3400a3c6:	d513      	bpl.n	3400a3f0 <HAL_RCC_ClockConfig+0x4c>
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
3400a3c8:	6923      	ldr	r3, [r4, #16]
3400a3ca:	2b07      	cmp	r3, #7
3400a3cc:	d904      	bls.n	3400a3d8 <HAL_RCC_ClockConfig+0x34>
3400a3ce:	f44f 7162 	mov.w	r1, #904	@ 0x388
3400a3d2:	488e      	ldr	r0, [pc, #568]	@ (3400a60c <HAL_RCC_ClockConfig+0x268>)
3400a3d4:	f7f8 fc1c 	bl	34002c10 <assert_failed>
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3400a3d8:	4a8d      	ldr	r2, [pc, #564]	@ (3400a610 <HAL_RCC_ClockConfig+0x26c>)
3400a3da:	6921      	ldr	r1, [r4, #16]
3400a3dc:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a3de:	f003 0307 	and.w	r3, r3, #7
3400a3e2:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3400a3e4:	bf81      	itttt	hi
3400a3e6:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
3400a3e8:	f023 0307 	bichi.w	r3, r3, #7
3400a3ec:	430b      	orrhi	r3, r1
3400a3ee:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3400a3f0:	6823      	ldr	r3, [r4, #0]
3400a3f2:	06de      	lsls	r6, r3, #27
3400a3f4:	d516      	bpl.n	3400a424 <HAL_RCC_ClockConfig+0x80>
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
3400a3f6:	6963      	ldr	r3, [r4, #20]
3400a3f8:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400a3fc:	d006      	beq.n	3400a40c <HAL_RCC_ClockConfig+0x68>
3400a3fe:	2b40      	cmp	r3, #64	@ 0x40
3400a400:	d004      	beq.n	3400a40c <HAL_RCC_ClockConfig+0x68>
3400a402:	f240 3192 	movw	r1, #914	@ 0x392
3400a406:	4881      	ldr	r0, [pc, #516]	@ (3400a60c <HAL_RCC_ClockConfig+0x268>)
3400a408:	f7f8 fc02 	bl	34002c10 <assert_failed>
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3400a40c:	4a80      	ldr	r2, [pc, #512]	@ (3400a610 <HAL_RCC_ClockConfig+0x26c>)
3400a40e:	6961      	ldr	r1, [r4, #20]
3400a410:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a412:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3400a416:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3400a418:	bf81      	itttt	hi
3400a41a:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
3400a41c:	f023 0370 	bichi.w	r3, r3, #112	@ 0x70
3400a420:	430b      	orrhi	r3, r1
3400a422:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3400a424:	6823      	ldr	r3, [r4, #0]
3400a426:	069d      	lsls	r5, r3, #26
3400a428:	d517      	bpl.n	3400a45a <HAL_RCC_ClockConfig+0xb6>
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
3400a42a:	69a3      	ldr	r3, [r4, #24]
3400a42c:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
3400a430:	d007      	beq.n	3400a442 <HAL_RCC_ClockConfig+0x9e>
3400a432:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3400a436:	d004      	beq.n	3400a442 <HAL_RCC_ClockConfig+0x9e>
3400a438:	f44f 7167 	mov.w	r1, #924	@ 0x39c
3400a43c:	4873      	ldr	r0, [pc, #460]	@ (3400a60c <HAL_RCC_ClockConfig+0x268>)
3400a43e:	f7f8 fbe7 	bl	34002c10 <assert_failed>
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3400a442:	4a73      	ldr	r2, [pc, #460]	@ (3400a610 <HAL_RCC_ClockConfig+0x26c>)
3400a444:	69a1      	ldr	r1, [r4, #24]
3400a446:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a448:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3400a44c:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3400a44e:	bf81      	itttt	hi
3400a450:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
3400a452:	f423 43e0 	bichi.w	r3, r3, #28672	@ 0x7000
3400a456:	430b      	orrhi	r3, r1
3400a458:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3400a45a:	6823      	ldr	r3, [r4, #0]
3400a45c:	0658      	lsls	r0, r3, #25
3400a45e:	d517      	bpl.n	3400a490 <HAL_RCC_ClockConfig+0xec>
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
3400a460:	69e3      	ldr	r3, [r4, #28]
3400a462:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
3400a466:	d007      	beq.n	3400a478 <HAL_RCC_ClockConfig+0xd4>
3400a468:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400a46c:	d004      	beq.n	3400a478 <HAL_RCC_ClockConfig+0xd4>
3400a46e:	f240 31a6 	movw	r1, #934	@ 0x3a6
3400a472:	4866      	ldr	r0, [pc, #408]	@ (3400a60c <HAL_RCC_ClockConfig+0x268>)
3400a474:	f7f8 fbcc 	bl	34002c10 <assert_failed>
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3400a478:	4a65      	ldr	r2, [pc, #404]	@ (3400a610 <HAL_RCC_ClockConfig+0x26c>)
3400a47a:	69e1      	ldr	r1, [r4, #28]
3400a47c:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a47e:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3400a482:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3400a484:	bf81      	itttt	hi
3400a486:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
3400a488:	f423 23e0 	bichi.w	r3, r3, #458752	@ 0x70000
3400a48c:	430b      	orrhi	r3, r1
3400a48e:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3400a490:	6823      	ldr	r3, [r4, #0]
3400a492:	0759      	lsls	r1, r3, #29
3400a494:	d517      	bpl.n	3400a4c6 <HAL_RCC_ClockConfig+0x122>
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
3400a496:	68e3      	ldr	r3, [r4, #12]
3400a498:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
3400a49c:	d007      	beq.n	3400a4ae <HAL_RCC_ClockConfig+0x10a>
3400a49e:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
3400a4a2:	d004      	beq.n	3400a4ae <HAL_RCC_ClockConfig+0x10a>
3400a4a4:	f44f 716c 	mov.w	r1, #944	@ 0x3b0
3400a4a8:	4858      	ldr	r0, [pc, #352]	@ (3400a60c <HAL_RCC_ClockConfig+0x268>)
3400a4aa:	f7f8 fbb1 	bl	34002c10 <assert_failed>
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
3400a4ae:	4a58      	ldr	r2, [pc, #352]	@ (3400a610 <HAL_RCC_ClockConfig+0x26c>)
3400a4b0:	68e1      	ldr	r1, [r4, #12]
3400a4b2:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a4b4:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3400a4b8:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3400a4ba:	bf81      	itttt	hi
3400a4bc:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
3400a4be:	f423 03e0 	bichi.w	r3, r3, #7340032	@ 0x700000
3400a4c2:	430b      	orrhi	r3, r1
3400a4c4:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
3400a4c6:	6823      	ldr	r3, [r4, #0]
3400a4c8:	07da      	lsls	r2, r3, #31
3400a4ca:	d52a      	bpl.n	3400a522 <HAL_RCC_ClockConfig+0x17e>
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));
3400a4cc:	6863      	ldr	r3, [r4, #4]
3400a4ce:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
3400a4d2:	d004      	beq.n	3400a4de <HAL_RCC_ClockConfig+0x13a>
3400a4d4:	f240 31bb 	movw	r1, #955	@ 0x3bb
3400a4d8:	484c      	ldr	r0, [pc, #304]	@ (3400a60c <HAL_RCC_ClockConfig+0x268>)
3400a4da:	f7f8 fb99 	bl	34002c10 <assert_failed>
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
3400a4de:	6863      	ldr	r3, [r4, #4]
3400a4e0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400a4e4:	f040 809a 	bne.w	3400a61c <HAL_RCC_ClockConfig+0x278>
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3400a4e8:	4b49      	ldr	r3, [pc, #292]	@ (3400a610 <HAL_RCC_ClockConfig+0x26c>)
3400a4ea:	685b      	ldr	r3, [r3, #4]
3400a4ec:	06db      	lsls	r3, r3, #27
3400a4ee:	f57f af5d 	bpl.w	3400a3ac <HAL_RCC_ClockConfig+0x8>
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
3400a4f2:	4d47      	ldr	r5, [pc, #284]	@ (3400a610 <HAL_RCC_ClockConfig+0x26c>)
3400a4f4:	6862      	ldr	r2, [r4, #4]
3400a4f6:	6a2b      	ldr	r3, [r5, #32]
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3400a4f8:	f241 3788 	movw	r7, #5000	@ 0x1388
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
3400a4fc:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400a500:	4313      	orrs	r3, r2
3400a502:	622b      	str	r3, [r5, #32]
    tickstart = HAL_GetTick();
3400a504:	f7fa fcba 	bl	34004e7c <HAL_GetTick>
3400a508:	4606      	mov	r6, r0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
3400a50a:	6a2b      	ldr	r3, [r5, #32]
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3400a50c:	6862      	ldr	r2, [r4, #4]
3400a50e:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
3400a512:	ebb3 1f02 	cmp.w	r3, r2, lsl #4
3400a516:	f040 80b7 	bne.w	3400a688 <HAL_RCC_ClockConfig+0x2e4>
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
3400a51a:	f7ff fef9 	bl	3400a310 <HAL_RCC_GetCpuClockFreq>
3400a51e:	4b3d      	ldr	r3, [pc, #244]	@ (3400a614 <HAL_RCC_ClockConfig+0x270>)
3400a520:	6018      	str	r0, [r3, #0]
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
3400a522:	6823      	ldr	r3, [r4, #0]
3400a524:	079f      	lsls	r7, r3, #30
3400a526:	f100 80b7 	bmi.w	3400a698 <HAL_RCC_ClockConfig+0x2f4>
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3400a52a:	6823      	ldr	r3, [r4, #0]
3400a52c:	075e      	lsls	r6, r3, #29
3400a52e:	f100 815c 	bmi.w	3400a7ea <HAL_RCC_ClockConfig+0x446>
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3400a532:	6823      	ldr	r3, [r4, #0]
3400a534:	0718      	lsls	r0, r3, #28
3400a536:	d513      	bpl.n	3400a560 <HAL_RCC_ClockConfig+0x1bc>
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
3400a538:	6923      	ldr	r3, [r4, #16]
3400a53a:	2b07      	cmp	r3, #7
3400a53c:	d904      	bls.n	3400a548 <HAL_RCC_ClockConfig+0x1a4>
3400a53e:	f240 4166 	movw	r1, #1126	@ 0x466
3400a542:	4832      	ldr	r0, [pc, #200]	@ (3400a60c <HAL_RCC_ClockConfig+0x268>)
3400a544:	f7f8 fb64 	bl	34002c10 <assert_failed>
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3400a548:	4a31      	ldr	r2, [pc, #196]	@ (3400a610 <HAL_RCC_ClockConfig+0x26c>)
3400a54a:	6921      	ldr	r1, [r4, #16]
3400a54c:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a54e:	f003 0307 	and.w	r3, r3, #7
3400a552:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3400a554:	bf3f      	itttt	cc
3400a556:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
3400a558:	f023 0307 	biccc.w	r3, r3, #7
3400a55c:	430b      	orrcc	r3, r1
3400a55e:	6253      	strcc	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3400a560:	6823      	ldr	r3, [r4, #0]
3400a562:	06d9      	lsls	r1, r3, #27
3400a564:	d516      	bpl.n	3400a594 <HAL_RCC_ClockConfig+0x1f0>
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
3400a566:	6963      	ldr	r3, [r4, #20]
3400a568:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400a56c:	d006      	beq.n	3400a57c <HAL_RCC_ClockConfig+0x1d8>
3400a56e:	2b40      	cmp	r3, #64	@ 0x40
3400a570:	d004      	beq.n	3400a57c <HAL_RCC_ClockConfig+0x1d8>
3400a572:	f44f 618e 	mov.w	r1, #1136	@ 0x470
3400a576:	4825      	ldr	r0, [pc, #148]	@ (3400a60c <HAL_RCC_ClockConfig+0x268>)
3400a578:	f7f8 fb4a 	bl	34002c10 <assert_failed>
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3400a57c:	4a24      	ldr	r2, [pc, #144]	@ (3400a610 <HAL_RCC_ClockConfig+0x26c>)
3400a57e:	6961      	ldr	r1, [r4, #20]
3400a580:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a582:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3400a586:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3400a588:	bf3f      	itttt	cc
3400a58a:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
3400a58c:	f023 0370 	biccc.w	r3, r3, #112	@ 0x70
3400a590:	430b      	orrcc	r3, r1
3400a592:	6253      	strcc	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3400a594:	6823      	ldr	r3, [r4, #0]
3400a596:	069a      	lsls	r2, r3, #26
3400a598:	d517      	bpl.n	3400a5ca <HAL_RCC_ClockConfig+0x226>
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
3400a59a:	69a3      	ldr	r3, [r4, #24]
3400a59c:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
3400a5a0:	d007      	beq.n	3400a5b2 <HAL_RCC_ClockConfig+0x20e>
3400a5a2:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3400a5a6:	d004      	beq.n	3400a5b2 <HAL_RCC_ClockConfig+0x20e>
3400a5a8:	f240 417a 	movw	r1, #1146	@ 0x47a
3400a5ac:	4817      	ldr	r0, [pc, #92]	@ (3400a60c <HAL_RCC_ClockConfig+0x268>)
3400a5ae:	f7f8 fb2f 	bl	34002c10 <assert_failed>
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3400a5b2:	4a17      	ldr	r2, [pc, #92]	@ (3400a610 <HAL_RCC_ClockConfig+0x26c>)
3400a5b4:	69a1      	ldr	r1, [r4, #24]
3400a5b6:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a5b8:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3400a5bc:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3400a5be:	bf3f      	itttt	cc
3400a5c0:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
3400a5c2:	f423 43e0 	biccc.w	r3, r3, #28672	@ 0x7000
3400a5c6:	430b      	orrcc	r3, r1
3400a5c8:	6253      	strcc	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3400a5ca:	6823      	ldr	r3, [r4, #0]
3400a5cc:	065b      	lsls	r3, r3, #25
3400a5ce:	d517      	bpl.n	3400a600 <HAL_RCC_ClockConfig+0x25c>
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
3400a5d0:	69e3      	ldr	r3, [r4, #28]
3400a5d2:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
3400a5d6:	d007      	beq.n	3400a5e8 <HAL_RCC_ClockConfig+0x244>
3400a5d8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400a5dc:	d004      	beq.n	3400a5e8 <HAL_RCC_ClockConfig+0x244>
3400a5de:	f240 4184 	movw	r1, #1156	@ 0x484
3400a5e2:	480a      	ldr	r0, [pc, #40]	@ (3400a60c <HAL_RCC_ClockConfig+0x268>)
3400a5e4:	f7f8 fb14 	bl	34002c10 <assert_failed>
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3400a5e8:	4a09      	ldr	r2, [pc, #36]	@ (3400a610 <HAL_RCC_ClockConfig+0x26c>)
3400a5ea:	69e1      	ldr	r1, [r4, #28]
3400a5ec:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a5ee:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3400a5f2:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3400a5f4:	bf3f      	itttt	cc
3400a5f6:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
3400a5f8:	f423 23e0 	biccc.w	r3, r3, #458752	@ 0x70000
3400a5fc:	430b      	orrcc	r3, r1
3400a5fe:	6253      	strcc	r3, [r2, #36]	@ 0x24
  return HAL_InitTick(uwTickPrio);
3400a600:	4b05      	ldr	r3, [pc, #20]	@ (3400a618 <HAL_RCC_ClockConfig+0x274>)
}
3400a602:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return HAL_InitTick(uwTickPrio);
3400a606:	6818      	ldr	r0, [r3, #0]
3400a608:	f7fa bbf4 	b.w	34004df4 <HAL_InitTick>
3400a60c:	3402038c 	.word	0x3402038c
3400a610:	56028000 	.word	0x56028000
3400a614:	340b0f2c 	.word	0x340b0f2c
3400a618:	340b0f34 	.word	0x340b0f34
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
3400a61c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400a620:	d126      	bne.n	3400a670 <HAL_RCC_ClockConfig+0x2cc>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
3400a622:	6a23      	ldr	r3, [r4, #32]
3400a624:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a628:	d004      	beq.n	3400a634 <HAL_RCC_ClockConfig+0x290>
3400a62a:	f240 31ca 	movw	r1, #970	@ 0x3ca
3400a62e:	487b      	ldr	r0, [pc, #492]	@ (3400a81c <HAL_RCC_ClockConfig+0x478>)
3400a630:	f7f8 faee 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));
3400a634:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400a636:	3b01      	subs	r3, #1
3400a638:	2bff      	cmp	r3, #255	@ 0xff
3400a63a:	d904      	bls.n	3400a646 <HAL_RCC_ClockConfig+0x2a2>
3400a63c:	f240 31cb 	movw	r1, #971	@ 0x3cb
3400a640:	4876      	ldr	r0, [pc, #472]	@ (3400a81c <HAL_RCC_ClockConfig+0x478>)
3400a642:	f7f8 fae5 	bl	34002c10 <assert_failed>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400a646:	4e76      	ldr	r6, [pc, #472]	@ (3400a820 <HAL_RCC_ClockConfig+0x47c>)
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
3400a648:	6a25      	ldr	r5, [r4, #32]
3400a64a:	f8d6 00c4 	ldr.w	r0, [r6, #196]	@ 0xc4
3400a64e:	4629      	mov	r1, r5
3400a650:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400a654:	f7ff fa52 	bl	34009afc <RCC_IC_CheckPLLSources>
3400a658:	2801      	cmp	r0, #1
3400a65a:	f47f aea7 	bne.w	3400a3ac <HAL_RCC_ClockConfig+0x8>
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
3400a65e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400a660:	3b01      	subs	r3, #1
3400a662:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
3400a666:	f8c6 50c4 	str.w	r5, [r6, #196]	@ 0xc4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
3400a66a:	f8c6 0a40 	str.w	r0, [r6, #2624]	@ 0xa40
}
3400a66e:	e740      	b.n	3400a4f2 <HAL_RCC_ClockConfig+0x14e>
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
3400a670:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400a674:	d105      	bne.n	3400a682 <HAL_RCC_ClockConfig+0x2de>
      if (LL_RCC_MSI_IsReady() == 0U)
3400a676:	f7ff f87b 	bl	34009770 <LL_RCC_MSI_IsReady>
      if (LL_RCC_HSI_IsReady() == 0U)
3400a67a:	2800      	cmp	r0, #0
3400a67c:	f47f af39 	bne.w	3400a4f2 <HAL_RCC_ClockConfig+0x14e>
3400a680:	e694      	b.n	3400a3ac <HAL_RCC_ClockConfig+0x8>
3400a682:	f7ff f86d 	bl	34009760 <LL_RCC_HSI_IsReady>
3400a686:	e7f8      	b.n	3400a67a <HAL_RCC_ClockConfig+0x2d6>
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3400a688:	f7fa fbf8 	bl	34004e7c <HAL_GetTick>
3400a68c:	1b80      	subs	r0, r0, r6
3400a68e:	42b8      	cmp	r0, r7
3400a690:	f67f af3b 	bls.w	3400a50a <HAL_RCC_ClockConfig+0x166>
        return HAL_TIMEOUT;
3400a694:	2003      	movs	r0, #3
3400a696:	e68a      	b.n	3400a3ae <HAL_RCC_ClockConfig+0xa>
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));
3400a698:	68a3      	ldr	r3, [r4, #8]
3400a69a:	f033 7340 	bics.w	r3, r3, #50331648	@ 0x3000000
3400a69e:	d004      	beq.n	3400a6aa <HAL_RCC_ClockConfig+0x306>
3400a6a0:	f240 4104 	movw	r1, #1028	@ 0x404
3400a6a4:	485d      	ldr	r0, [pc, #372]	@ (3400a81c <HAL_RCC_ClockConfig+0x478>)
3400a6a6:	f7f8 fab3 	bl	34002c10 <assert_failed>
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
3400a6aa:	68a3      	ldr	r3, [r4, #8]
3400a6ac:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400a6b0:	d11e      	bne.n	3400a6f0 <HAL_RCC_ClockConfig+0x34c>
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3400a6b2:	4b5b      	ldr	r3, [pc, #364]	@ (3400a820 <HAL_RCC_ClockConfig+0x47c>)
3400a6b4:	685b      	ldr	r3, [r3, #4]
3400a6b6:	06dd      	lsls	r5, r3, #27
3400a6b8:	f57f ae78 	bpl.w	3400a3ac <HAL_RCC_ClockConfig+0x8>
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
3400a6bc:	4d58      	ldr	r5, [pc, #352]	@ (3400a820 <HAL_RCC_ClockConfig+0x47c>)
3400a6be:	68a2      	ldr	r2, [r4, #8]
3400a6c0:	6a2b      	ldr	r3, [r5, #32]
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3400a6c2:	f241 3788 	movw	r7, #5000	@ 0x1388
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
3400a6c6:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
3400a6ca:	4313      	orrs	r3, r2
3400a6cc:	622b      	str	r3, [r5, #32]
    tickstart = HAL_GetTick();
3400a6ce:	f7fa fbd5 	bl	34004e7c <HAL_GetTick>
3400a6d2:	4606      	mov	r6, r0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
3400a6d4:	6a2b      	ldr	r3, [r5, #32]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3400a6d6:	68a2      	ldr	r2, [r4, #8]
3400a6d8:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
3400a6dc:	ebb3 1f02 	cmp.w	r3, r2, lsl #4
3400a6e0:	f43f af23 	beq.w	3400a52a <HAL_RCC_ClockConfig+0x186>
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3400a6e4:	f7fa fbca 	bl	34004e7c <HAL_GetTick>
3400a6e8:	1b80      	subs	r0, r0, r6
3400a6ea:	42b8      	cmp	r0, r7
3400a6ec:	d9f2      	bls.n	3400a6d4 <HAL_RCC_ClockConfig+0x330>
3400a6ee:	e7d1      	b.n	3400a694 <HAL_RCC_ClockConfig+0x2f0>
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
3400a6f0:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3400a6f4:	d16f      	bne.n	3400a7d6 <HAL_RCC_ClockConfig+0x432>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC2Selection.ClockSelection));
3400a6f6:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400a6f8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a6fc:	d004      	beq.n	3400a708 <HAL_RCC_ClockConfig+0x364>
3400a6fe:	f240 4113 	movw	r1, #1043	@ 0x413
3400a702:	4846      	ldr	r0, [pc, #280]	@ (3400a81c <HAL_RCC_ClockConfig+0x478>)
3400a704:	f7f8 fa84 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC2Selection.ClockDivider));
3400a708:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400a70a:	3b01      	subs	r3, #1
3400a70c:	2bff      	cmp	r3, #255	@ 0xff
3400a70e:	d904      	bls.n	3400a71a <HAL_RCC_ClockConfig+0x376>
3400a710:	f240 4114 	movw	r1, #1044	@ 0x414
3400a714:	4841      	ldr	r0, [pc, #260]	@ (3400a81c <HAL_RCC_ClockConfig+0x478>)
3400a716:	f7f8 fa7b 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC6Selection.ClockSelection));
3400a71a:	6b23      	ldr	r3, [r4, #48]	@ 0x30
3400a71c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a720:	d004      	beq.n	3400a72c <HAL_RCC_ClockConfig+0x388>
3400a722:	f240 4115 	movw	r1, #1045	@ 0x415
3400a726:	483d      	ldr	r0, [pc, #244]	@ (3400a81c <HAL_RCC_ClockConfig+0x478>)
3400a728:	f7f8 fa72 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC6Selection.ClockDivider));
3400a72c:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3400a72e:	3b01      	subs	r3, #1
3400a730:	2bff      	cmp	r3, #255	@ 0xff
3400a732:	d904      	bls.n	3400a73e <HAL_RCC_ClockConfig+0x39a>
3400a734:	f240 4116 	movw	r1, #1046	@ 0x416
3400a738:	4838      	ldr	r0, [pc, #224]	@ (3400a81c <HAL_RCC_ClockConfig+0x478>)
3400a73a:	f7f8 fa69 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
3400a73e:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400a740:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a744:	d004      	beq.n	3400a750 <HAL_RCC_ClockConfig+0x3ac>
3400a746:	f240 4117 	movw	r1, #1047	@ 0x417
3400a74a:	4834      	ldr	r0, [pc, #208]	@ (3400a81c <HAL_RCC_ClockConfig+0x478>)
3400a74c:	f7f8 fa60 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));
3400a750:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400a752:	3b01      	subs	r3, #1
3400a754:	2bff      	cmp	r3, #255	@ 0xff
3400a756:	d904      	bls.n	3400a762 <HAL_RCC_ClockConfig+0x3be>
3400a758:	f44f 6183 	mov.w	r1, #1048	@ 0x418
3400a75c:	482f      	ldr	r0, [pc, #188]	@ (3400a81c <HAL_RCC_ClockConfig+0x478>)
3400a75e:	f7f8 fa57 	bl	34002c10 <assert_failed>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a762:	4d2f      	ldr	r5, [pc, #188]	@ (3400a820 <HAL_RCC_ClockConfig+0x47c>)
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
3400a764:	f8d4 8028 	ldr.w	r8, [r4, #40]	@ 0x28
3400a768:	f8d5 00c8 	ldr.w	r0, [r5, #200]	@ 0xc8
3400a76c:	4641      	mov	r1, r8
3400a76e:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400a772:	f7ff f9c3 	bl	34009afc <RCC_IC_CheckPLLSources>
3400a776:	2801      	cmp	r0, #1
3400a778:	f47f ae18 	bne.w	3400a3ac <HAL_RCC_ClockConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400a77c:	f8d5 00d8 	ldr.w	r0, [r5, #216]	@ 0xd8
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
3400a780:	6b27      	ldr	r7, [r4, #48]	@ 0x30
3400a782:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400a786:	4639      	mov	r1, r7
3400a788:	f7ff f9b8 	bl	34009afc <RCC_IC_CheckPLLSources>
3400a78c:	2801      	cmp	r0, #1
3400a78e:	f47f ae0d 	bne.w	3400a3ac <HAL_RCC_ClockConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3400a792:	f8d5 00ec 	ldr.w	r0, [r5, #236]	@ 0xec
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
3400a796:	6ba6      	ldr	r6, [r4, #56]	@ 0x38
3400a798:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400a79c:	4631      	mov	r1, r6
3400a79e:	f7ff f9ad 	bl	34009afc <RCC_IC_CheckPLLSources>
3400a7a2:	2801      	cmp	r0, #1
3400a7a4:	f47f ae02 	bne.w	3400a3ac <HAL_RCC_ClockConfig+0x8>
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
3400a7a8:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400a7aa:	3b01      	subs	r3, #1
3400a7ac:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
3400a7b0:	f8c5 30c8 	str.w	r3, [r5, #200]	@ 0xc8
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
3400a7b4:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3400a7b6:	3b01      	subs	r3, #1
3400a7b8:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
3400a7bc:	f8c5 70d8 	str.w	r7, [r5, #216]	@ 0xd8
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
3400a7c0:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400a7c2:	3b01      	subs	r3, #1
3400a7c4:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
3400a7c8:	f240 4322 	movw	r3, #1058	@ 0x422
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
3400a7cc:	f8c5 60ec 	str.w	r6, [r5, #236]	@ 0xec
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
3400a7d0:	f8c5 3a40 	str.w	r3, [r5, #2624]	@ 0xa40
3400a7d4:	e772      	b.n	3400a6bc <HAL_RCC_ClockConfig+0x318>
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
3400a7d6:	b92b      	cbnz	r3, 3400a7e4 <HAL_RCC_ClockConfig+0x440>
      if (LL_RCC_HSI_IsReady() == 0U)
3400a7d8:	f7fe ffc2 	bl	34009760 <LL_RCC_HSI_IsReady>
      if (LL_RCC_MSI_IsReady() == 0U)
3400a7dc:	2800      	cmp	r0, #0
3400a7de:	f47f af6d 	bne.w	3400a6bc <HAL_RCC_ClockConfig+0x318>
3400a7e2:	e5e3      	b.n	3400a3ac <HAL_RCC_ClockConfig+0x8>
3400a7e4:	f7fe ffc4 	bl	34009770 <LL_RCC_MSI_IsReady>
3400a7e8:	e7f8      	b.n	3400a7dc <HAL_RCC_ClockConfig+0x438>
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
3400a7ea:	68e3      	ldr	r3, [r4, #12]
3400a7ec:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
3400a7f0:	d007      	beq.n	3400a802 <HAL_RCC_ClockConfig+0x45e>
3400a7f2:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
3400a7f6:	d004      	beq.n	3400a802 <HAL_RCC_ClockConfig+0x45e>
3400a7f8:	f240 415b 	movw	r1, #1115	@ 0x45b
3400a7fc:	4807      	ldr	r0, [pc, #28]	@ (3400a81c <HAL_RCC_ClockConfig+0x478>)
3400a7fe:	f7f8 fa07 	bl	34002c10 <assert_failed>
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
3400a802:	4a07      	ldr	r2, [pc, #28]	@ (3400a820 <HAL_RCC_ClockConfig+0x47c>)
3400a804:	68e1      	ldr	r1, [r4, #12]
3400a806:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a808:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3400a80c:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3400a80e:	bf3f      	itttt	cc
3400a810:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
3400a812:	f423 03e0 	biccc.w	r3, r3, #7340032	@ 0x700000
3400a816:	430b      	orrcc	r3, r1
3400a818:	6253      	strcc	r3, [r2, #36]	@ 0x24
3400a81a:	e68a      	b.n	3400a532 <HAL_RCC_ClockConfig+0x18e>
3400a81c:	3402038c 	.word	0x3402038c
3400a820:	56028000 	.word	0x56028000

3400a824 <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a824:	4b05      	ldr	r3, [pc, #20]	@ (3400a83c <HAL_RCC_GetSysClockFreq+0x18>)
3400a826:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3400a82a:	f8d3 10c8 	ldr.w	r1, [r3, #200]	@ 0xc8
  return RCC_GetSysClockFreq(LL_RCC_IC2_GetSource(), LL_RCC_IC2_GetDivider());
3400a82e:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400a832:	f3c1 4107 	ubfx	r1, r1, #16, #8
3400a836:	3101      	adds	r1, #1
3400a838:	f7ff b920 	b.w	34009a7c <RCC_GetSysClockFreq>
3400a83c:	56028000 	.word	0x56028000

3400a840 <HAL_RCC_GetPCLK1Freq>:
{
3400a840:	b508      	push	{r3, lr}
  return LL_RCC_CALC_PCLK1_FREQ(LL_RCC_CALC_HCLK_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler()),
3400a842:	f7ff ffef 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3400a846:	4b05      	ldr	r3, [pc, #20]	@ (3400a85c <HAL_RCC_GetPCLK1Freq+0x1c>)
3400a848:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400a84a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400a84c:	f3c2 5202 	ubfx	r2, r2, #20, #3
3400a850:	40d0      	lsrs	r0, r2
3400a852:	f003 0307 	and.w	r3, r3, #7
}
3400a856:	40d8      	lsrs	r0, r3
3400a858:	bd08      	pop	{r3, pc}
3400a85a:	bf00      	nop
3400a85c:	56028000 	.word	0x56028000

3400a860 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400a860:	4a02      	ldr	r2, [pc, #8]	@ (3400a86c <LL_RCC_HSE_SelectHSEAsDiv2Clock+0xc>)
3400a862:	6d53      	ldr	r3, [r2, #84]	@ 0x54
3400a864:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3400a868:	6553      	str	r3, [r2, #84]	@ 0x54
}
3400a86a:	4770      	bx	lr
3400a86c:	56028000 	.word	0x56028000

3400a870 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400a870:	4a02      	ldr	r2, [pc, #8]	@ (3400a87c <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0xc>)
3400a872:	6d53      	ldr	r3, [r2, #84]	@ 0x54
3400a874:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3400a878:	6553      	str	r3, [r2, #84]	@ 0x54
}
3400a87a:	4770      	bx	lr
3400a87c:	56028000 	.word	0x56028000

3400a880 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>:
  return ((READ_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL) == RCC_HSECFGR_HSEDIV2SEL) ? 1UL : 0UL);
3400a880:	4b02      	ldr	r3, [pc, #8]	@ (3400a88c <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0xc>)
3400a882:	6d58      	ldr	r0, [r3, #84]	@ 0x54
}
3400a884:	f3c0 1080 	ubfx	r0, r0, #6, #1
3400a888:	4770      	bx	lr
3400a88a:	bf00      	nop
3400a88c:	56028000 	.word	0x56028000

3400a890 <LL_RCC_HSE_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3400a890:	4b02      	ldr	r3, [pc, #8]	@ (3400a89c <LL_RCC_HSE_IsReady+0xc>)
3400a892:	6858      	ldr	r0, [r3, #4]
}
3400a894:	f3c0 1000 	ubfx	r0, r0, #4, #1
3400a898:	4770      	bx	lr
3400a89a:	bf00      	nop
3400a89c:	56028000 	.word	0x56028000

3400a8a0 <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3400a8a0:	4b02      	ldr	r3, [pc, #8]	@ (3400a8ac <LL_RCC_HSI_IsReady+0xc>)
3400a8a2:	6858      	ldr	r0, [r3, #4]
}
3400a8a4:	f3c0 00c0 	ubfx	r0, r0, #3, #1
3400a8a8:	4770      	bx	lr
3400a8aa:	bf00      	nop
3400a8ac:	56028000 	.word	0x56028000

3400a8b0 <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3400a8b0:	4b02      	ldr	r3, [pc, #8]	@ (3400a8bc <LL_RCC_MSI_IsReady+0xc>)
3400a8b2:	6858      	ldr	r0, [r3, #4]
}
3400a8b4:	f3c0 0080 	ubfx	r0, r0, #2, #1
3400a8b8:	4770      	bx	lr
3400a8ba:	bf00      	nop
3400a8bc:	56028000 	.word	0x56028000

3400a8c0 <LL_RCC_LSE_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3400a8c0:	4b02      	ldr	r3, [pc, #8]	@ (3400a8cc <LL_RCC_LSE_IsReady+0xc>)
3400a8c2:	6858      	ldr	r0, [r3, #4]
}
3400a8c4:	f3c0 0040 	ubfx	r0, r0, #1, #1
3400a8c8:	4770      	bx	lr
3400a8ca:	bf00      	nop
3400a8cc:	56028000 	.word	0x56028000

3400a8d0 <LL_RCC_SetClockSource>:
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3400a8d0:	4907      	ldr	r1, [pc, #28]	@ (3400a8f0 <LL_RCC_SetClockSource+0x20>)
{
3400a8d2:	b530      	push	{r4, r5, lr}
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3400a8d4:	b2c4      	uxtb	r4, r0
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
3400a8d6:	f3c0 2504 	ubfx	r5, r0, #8, #5
3400a8da:	5863      	ldr	r3, [r4, r1]
3400a8dc:	0e02      	lsrs	r2, r0, #24
3400a8de:	40aa      	lsls	r2, r5
3400a8e0:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400a8e4:	ea23 0302 	bic.w	r3, r3, r2
3400a8e8:	40a8      	lsls	r0, r5
3400a8ea:	4303      	orrs	r3, r0
3400a8ec:	5063      	str	r3, [r4, r1]
}
3400a8ee:	bd30      	pop	{r4, r5, pc}
3400a8f0:	56028144 	.word	0x56028144

3400a8f4 <LL_RCC_GetClockSource>:
  const volatile uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CCIPR1) + LL_CLKSOURCE_REG(Periph)));
3400a8f4:	4b05      	ldr	r3, [pc, #20]	@ (3400a90c <LL_RCC_GetClockSource+0x18>)
3400a8f6:	b2c2      	uxtb	r2, r0
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
3400a8f8:	58d1      	ldr	r1, [r2, r3]
3400a8fa:	f3c0 2204 	ubfx	r2, r0, #8, #5
3400a8fe:	0e03      	lsrs	r3, r0, #24
3400a900:	4093      	lsls	r3, r2
3400a902:	400b      	ands	r3, r1
3400a904:	40d3      	lsrs	r3, r2
}
3400a906:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
3400a90a:	4770      	bx	lr
3400a90c:	56028144 	.word	0x56028144

3400a910 <LL_RCC_IC7_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC7EN) == RCC_DIVENR_IC7EN) ? 1UL : 0UL);
3400a910:	4b02      	ldr	r3, [pc, #8]	@ (3400a91c <LL_RCC_IC7_IsEnabled+0xc>)
3400a912:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a916:	f3c0 1080 	ubfx	r0, r0, #6, #1
3400a91a:	4770      	bx	lr
3400a91c:	56028000 	.word	0x56028000

3400a920 <LL_RCC_IC7_GetDivider>:
  return ((READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7INT) >> RCC_IC7CFGR_IC7INT_Pos) + 1UL);
3400a920:	4b03      	ldr	r3, [pc, #12]	@ (3400a930 <LL_RCC_IC7_GetDivider+0x10>)
3400a922:	f8d3 00dc 	ldr.w	r0, [r3, #220]	@ 0xdc
3400a926:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a92a:	3001      	adds	r0, #1
3400a92c:	4770      	bx	lr
3400a92e:	bf00      	nop
3400a930:	56028000 	.word	0x56028000

3400a934 <LL_RCC_IC8_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC8EN) == RCC_DIVENR_IC8EN) ? 1UL : 0UL);
3400a934:	4b02      	ldr	r3, [pc, #8]	@ (3400a940 <LL_RCC_IC8_IsEnabled+0xc>)
3400a936:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a93a:	f3c0 10c0 	ubfx	r0, r0, #7, #1
3400a93e:	4770      	bx	lr
3400a940:	56028000 	.word	0x56028000

3400a944 <LL_RCC_IC8_GetDivider>:
  return ((READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8INT) >> RCC_IC8CFGR_IC8INT_Pos) + 1UL);
3400a944:	4b03      	ldr	r3, [pc, #12]	@ (3400a954 <LL_RCC_IC8_GetDivider+0x10>)
3400a946:	f8d3 00e0 	ldr.w	r0, [r3, #224]	@ 0xe0
3400a94a:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a94e:	3001      	adds	r0, #1
3400a950:	4770      	bx	lr
3400a952:	bf00      	nop
3400a954:	56028000 	.word	0x56028000

3400a958 <LL_RCC_IC9_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC9EN) == RCC_DIVENR_IC9EN) ? 1UL : 0UL);
3400a958:	4b02      	ldr	r3, [pc, #8]	@ (3400a964 <LL_RCC_IC9_IsEnabled+0xc>)
3400a95a:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a95e:	f3c0 2000 	ubfx	r0, r0, #8, #1
3400a962:	4770      	bx	lr
3400a964:	56028000 	.word	0x56028000

3400a968 <LL_RCC_IC9_GetDivider>:
  return ((READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9INT) >> RCC_IC9CFGR_IC9INT_Pos) + 1UL);
3400a968:	4b03      	ldr	r3, [pc, #12]	@ (3400a978 <LL_RCC_IC9_GetDivider+0x10>)
3400a96a:	f8d3 00e4 	ldr.w	r0, [r3, #228]	@ 0xe4
3400a96e:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a972:	3001      	adds	r0, #1
3400a974:	4770      	bx	lr
3400a976:	bf00      	nop
3400a978:	56028000 	.word	0x56028000

3400a97c <LL_RCC_IC14_IsEnabled>:
  * @rmtoll DIVENR       IC14EN         LL_RCC_IC14_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC14EN) == RCC_DIVENR_IC14EN) ? 1UL : 0UL);
3400a97c:	4b02      	ldr	r3, [pc, #8]	@ (3400a988 <LL_RCC_IC14_IsEnabled+0xc>)
3400a97e:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a982:	f3c0 3040 	ubfx	r0, r0, #13, #1
3400a986:	4770      	bx	lr
3400a988:	56028000 	.word	0x56028000

3400a98c <LL_RCC_IC14_GetDivider>:
  * @rmtoll IC14CFGR      IC14INT        LL_RCC_IC14_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetDivider(void)
{
  return ((READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14INT) >> RCC_IC14CFGR_IC14INT_Pos) + 1UL);
3400a98c:	4b03      	ldr	r3, [pc, #12]	@ (3400a99c <LL_RCC_IC14_GetDivider+0x10>)
3400a98e:	f8d3 00f8 	ldr.w	r0, [r3, #248]	@ 0xf8
3400a992:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a996:	3001      	adds	r0, #1
3400a998:	4770      	bx	lr
3400a99a:	bf00      	nop
3400a99c:	56028000 	.word	0x56028000

3400a9a0 <LL_RCC_IC15_IsEnabled>:
  * @rmtoll DIVENR       IC15EN         LL_RCC_IC15_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC15EN) == RCC_DIVENR_IC15EN) ? 1UL : 0UL);
3400a9a0:	4b02      	ldr	r3, [pc, #8]	@ (3400a9ac <LL_RCC_IC15_IsEnabled+0xc>)
3400a9a2:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a9a6:	f3c0 3080 	ubfx	r0, r0, #14, #1
3400a9aa:	4770      	bx	lr
3400a9ac:	56028000 	.word	0x56028000

3400a9b0 <LL_RCC_IC15_GetDivider>:
  * @rmtoll IC15CFGR      IC15INT        LL_RCC_IC15_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetDivider(void)
{
  return ((READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15INT) >> RCC_IC15CFGR_IC15INT_Pos) + 1UL);
3400a9b0:	4b03      	ldr	r3, [pc, #12]	@ (3400a9c0 <LL_RCC_IC15_GetDivider+0x10>)
3400a9b2:	f8d3 00fc 	ldr.w	r0, [r3, #252]	@ 0xfc
3400a9b6:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a9ba:	3001      	adds	r0, #1
3400a9bc:	4770      	bx	lr
3400a9be:	bf00      	nop
3400a9c0:	56028000 	.word	0x56028000

3400a9c4 <RCCEx_GetHCLKFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3400a9c4:	4b02      	ldr	r3, [pc, #8]	@ (3400a9d0 <RCCEx_GetHCLKFreq+0xc>)
3400a9c6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCCEx_GetHCLKFreq(uint32_t SYSCLK_Frequency)
{
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
3400a9c8:	f3c3 5302 	ubfx	r3, r3, #20, #3
}
3400a9cc:	40d8      	lsrs	r0, r3
3400a9ce:	4770      	bx	lr
3400a9d0:	56028000 	.word	0x56028000

3400a9d4 <RCCEx_GetPLLSourceFreq>:
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;

  switch (PLLsource)
3400a9d4:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
{
3400a9d8:	b508      	push	{r3, lr}
  switch (PLLsource)
3400a9da:	d01d      	beq.n	3400aa18 <RCCEx_GetPLLSourceFreq+0x44>
3400a9dc:	d80a      	bhi.n	3400a9f4 <RCCEx_GetPLLSourceFreq+0x20>
3400a9de:	b970      	cbnz	r0, 3400a9fe <RCCEx_GetPLLSourceFreq+0x2a>
  {
    case LL_RCC_PLLSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3400a9e0:	f7ff ff5e 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400a9e4:	b148      	cbz	r0, 3400a9fa <RCCEx_GetPLLSourceFreq+0x26>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400a9e6:	4b10      	ldr	r3, [pc, #64]	@ (3400aa28 <RCCEx_GetPLLSourceFreq+0x54>)
      {
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400a9e8:	4810      	ldr	r0, [pc, #64]	@ (3400aa2c <RCCEx_GetPLLSourceFreq+0x58>)
3400a9ea:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400a9ec:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400a9f0:	40d8      	lsrs	r0, r3
3400a9f2:	e003      	b.n	3400a9fc <RCCEx_GetPLLSourceFreq+0x28>
  switch (PLLsource)
3400a9f4:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
3400a9f8:	d014      	beq.n	3400aa24 <RCCEx_GetPLLSourceFreq+0x50>
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
3400a9fa:	2000      	movs	r0, #0
      /* unexpected case */
      break;
  }

  return pllinputfreq;
}
3400a9fc:	bd08      	pop	{r3, pc}
      if (LL_RCC_MSI_IsReady() != 0U)
3400a9fe:	f7ff ff57 	bl	3400a8b0 <LL_RCC_MSI_IsReady>
3400aa02:	2800      	cmp	r0, #0
3400aa04:	d0f9      	beq.n	3400a9fa <RCCEx_GetPLLSourceFreq+0x26>
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3400aa06:	4b08      	ldr	r3, [pc, #32]	@ (3400aa28 <RCCEx_GetPLLSourceFreq+0x54>)
          pllinputfreq = MSI_VALUE;
3400aa08:	4809      	ldr	r0, [pc, #36]	@ (3400aa30 <RCCEx_GetPLLSourceFreq+0x5c>)
3400aa0a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400aa0c:	f413 7f00 	tst.w	r3, #512	@ 0x200
3400aa10:	4b08      	ldr	r3, [pc, #32]	@ (3400aa34 <RCCEx_GetPLLSourceFreq+0x60>)
3400aa12:	bf08      	it	eq
3400aa14:	4618      	moveq	r0, r3
3400aa16:	e7f1      	b.n	3400a9fc <RCCEx_GetPLLSourceFreq+0x28>
      if (LL_RCC_HSE_IsReady() != 0U)
3400aa18:	f7ff ff3a 	bl	3400a890 <LL_RCC_HSE_IsReady>
3400aa1c:	2800      	cmp	r0, #0
3400aa1e:	d0ec      	beq.n	3400a9fa <RCCEx_GetPLLSourceFreq+0x26>
        pllinputfreq = HSE_VALUE;
3400aa20:	4805      	ldr	r0, [pc, #20]	@ (3400aa38 <RCCEx_GetPLLSourceFreq+0x64>)
3400aa22:	e7eb      	b.n	3400a9fc <RCCEx_GetPLLSourceFreq+0x28>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
3400aa24:	4805      	ldr	r0, [pc, #20]	@ (3400aa3c <RCCEx_GetPLLSourceFreq+0x68>)
3400aa26:	e7e9      	b.n	3400a9fc <RCCEx_GetPLLSourceFreq+0x28>
3400aa28:	56028000 	.word	0x56028000
3400aa2c:	03d09000 	.word	0x03d09000
3400aa30:	00f42400 	.word	0x00f42400
3400aa34:	003d0900 	.word	0x003d0900
3400aa38:	02dc6c00 	.word	0x02dc6c00
3400aa3c:	00bb8000 	.word	0x00bb8000

3400aa40 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
3400aa40:	ee07 2a10 	vmov	s14, r2
3400aa44:	ee06 3a10 	vmov	s12, r3
3400aa48:	ee07 0a90 	vmov	s15, r0
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
3400aa4c:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
3400aa50:	eddf 5a10 	vldr	s11, [pc, #64]	@ 3400aa94 <RCCEx_CalcPLLFreq+0x54>
3400aa54:	eeb8 7a47 	vcvt.f32.u32	s14, s14
{
3400aa58:	ee06 1a90 	vmov	s13, r1
  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
3400aa5c:	eea6 7a25 	vfma.f32	s14, s12, s11
3400aa60:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400aa64:	ee67 7a87 	vmul.f32	s15, s15, s14
3400aa68:	eeb8 7a66 	vcvt.f32.u32	s14, s13
3400aa6c:	ee87 6a87 	vdiv.f32	s12, s15, s14

  freq = freq / (float_t)P1;
3400aa70:	eddd 7a00 	vldr	s15, [sp]
3400aa74:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400aa78:	eec6 6a27 	vdiv.f32	s13, s12, s15
  freq = freq / (float_t)P2;
3400aa7c:	eddd 7a01 	vldr	s15, [sp, #4]
3400aa80:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400aa84:	ee86 7aa7 	vdiv.f32	s14, s13, s15

  return (uint32_t)freq;
}
3400aa88:	eefc 7ac7 	vcvt.u32.f32	s15, s14
3400aa8c:	ee17 0a90 	vmov	r0, s15
3400aa90:	4770      	bx	lr
3400aa92:	bf00      	nop
3400aa94:	33800000 	.word	0x33800000

3400aa98 <HAL_RCCEx_PeriphCLKConfig>:
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
3400aa98:	e9d0 2300 	ldrd	r2, r3, [r0]
3400aa9c:	f023 437e 	bic.w	r3, r3, #4261412864	@ 0xfe000000
3400aaa0:	431a      	orrs	r2, r3
{
3400aaa2:	b570      	push	{r4, r5, r6, lr}
3400aaa4:	4604      	mov	r4, r0
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
3400aaa6:	d103      	bne.n	3400aab0 <HAL_RCCEx_PeriphCLKConfig+0x18>
3400aaa8:	2188      	movs	r1, #136	@ 0x88
3400aaaa:	4861      	ldr	r0, [pc, #388]	@ (3400ac30 <HAL_RCCEx_PeriphCLKConfig+0x198>)
3400aaac:	f7f8 f8b0 	bl	34002c10 <assert_failed>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3400aab0:	6823      	ldr	r3, [r4, #0]
3400aab2:	011a      	lsls	r2, r3, #4
3400aab4:	f140 808e 	bpl.w	3400abd4 <HAL_RCCEx_PeriphCLKConfig+0x13c>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
3400aab8:	f8d4 3188 	ldr.w	r3, [r4, #392]	@ 0x188
3400aabc:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3400aac0:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
3400aac4:	d05a      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400aac6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400aaca:	d057      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400aacc:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
3400aad0:	f5b2 5f98 	cmp.w	r2, #4864	@ 0x1300
3400aad4:	d052      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400aad6:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
3400aada:	f5b2 5f0c 	cmp.w	r2, #8960	@ 0x2300
3400aade:	d04d      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400aae0:	f423 4210 	bic.w	r2, r3, #36864	@ 0x9000
3400aae4:	f5b2 4f86 	cmp.w	r2, #17152	@ 0x4300
3400aae8:	d048      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400aaea:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
3400aaee:	f5b2 4fe6 	cmp.w	r2, #29440	@ 0x7300
3400aaf2:	d043      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400aaf4:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
3400aaf8:	f5b2 4f03 	cmp.w	r2, #33536	@ 0x8300
3400aafc:	d03e      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400aafe:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400ab02:	f5b1 4f63 	cmp.w	r1, #58112	@ 0xe300
3400ab06:	d039      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab08:	494a      	ldr	r1, [pc, #296]	@ (3400ac34 <HAL_RCCEx_PeriphCLKConfig+0x19c>)
3400ab0a:	428a      	cmp	r2, r1
3400ab0c:	d036      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab0e:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400ab12:	428a      	cmp	r2, r1
3400ab14:	d032      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab16:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400ab1a:	428a      	cmp	r2, r1
3400ab1c:	d02e      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab1e:	f423 3004 	bic.w	r0, r3, #135168	@ 0x21000
3400ab22:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400ab26:	4288      	cmp	r0, r1
3400ab28:	d028      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab2a:	f423 3000 	bic.w	r0, r3, #131072	@ 0x20000
3400ab2e:	f501 5140 	add.w	r1, r1, #12288	@ 0x3000
3400ab32:	4288      	cmp	r0, r1
3400ab34:	d022      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab36:	f501 5180 	add.w	r1, r1, #4096	@ 0x1000
3400ab3a:	428a      	cmp	r2, r1
3400ab3c:	d01e      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab3e:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400ab42:	428a      	cmp	r2, r1
3400ab44:	d01a      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab46:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400ab4a:	428a      	cmp	r2, r1
3400ab4c:	d016      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab4e:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400ab52:	428a      	cmp	r2, r1
3400ab54:	d012      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab56:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400ab5a:	428a      	cmp	r2, r1
3400ab5c:	d00e      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab5e:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400ab62:	428a      	cmp	r2, r1
3400ab64:	d00a      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab66:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400ab6a:	428a      	cmp	r2, r1
3400ab6c:	d006      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab6e:	4a32      	ldr	r2, [pc, #200]	@ (3400ac38 <HAL_RCCEx_PeriphCLKConfig+0x1a0>)
3400ab70:	4293      	cmp	r3, r2
3400ab72:	d003      	beq.n	3400ab7c <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400ab74:	218e      	movs	r1, #142	@ 0x8e
3400ab76:	482e      	ldr	r0, [pc, #184]	@ (3400ac30 <HAL_RCCEx_PeriphCLKConfig+0x198>)
3400ab78:	f7f8 f84a 	bl	34002c10 <assert_failed>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3400ab7c:	4b2f      	ldr	r3, [pc, #188]	@ (3400ac3c <HAL_RCCEx_PeriphCLKConfig+0x1a4>)
    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3400ab7e:	f8d4 1188 	ldr.w	r1, [r4, #392]	@ 0x188
3400ab82:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400ab86:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
3400ab8a:	d13b      	bne.n	3400ac04 <HAL_RCCEx_PeriphCLKConfig+0x16c>
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
3400ab8c:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
3400ab90:	d108      	bne.n	3400aba4 <HAL_RCCEx_PeriphCLKConfig+0x10c>
        tickstart = HAL_GetTick();
3400ab92:	f7fa f973 	bl	34004e7c <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400ab96:	f241 3688 	movw	r6, #5000	@ 0x1388
        tickstart = HAL_GetTick();
3400ab9a:	4605      	mov	r5, r0
        while (LL_RCC_LSE_IsReady() == 0U)
3400ab9c:	f7ff fe90 	bl	3400a8c0 <LL_RCC_LSE_IsReady>
3400aba0:	2800      	cmp	r0, #0
3400aba2:	d03d      	beq.n	3400ac20 <HAL_RCCEx_PeriphCLKConfig+0x188>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
3400aba4:	f8d4 3188 	ldr.w	r3, [r4, #392]	@ 0x188
3400aba8:	4a24      	ldr	r2, [pc, #144]	@ (3400ac3c <HAL_RCCEx_PeriphCLKConfig+0x1a4>)
3400abaa:	f403 7040 	and.w	r0, r3, #768	@ 0x300
3400abae:	f5b0 7f40 	cmp.w	r0, #768	@ 0x300
3400abb2:	d108      	bne.n	3400abc6 <HAL_RCCEx_PeriphCLKConfig+0x12e>
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
3400abb4:	f8d2 115c 	ldr.w	r1, [r2, #348]	@ 0x15c
3400abb8:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3400abbc:	f421 317c 	bic.w	r1, r1, #258048	@ 0x3f000
3400abc0:	430b      	orrs	r3, r1
3400abc2:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
3400abc6:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400abca:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3400abce:	4303      	orrs	r3, r0
3400abd0:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
3400abd4:	2500      	movs	r5, #0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
3400abd6:	6823      	ldr	r3, [r4, #0]
3400abd8:	075e      	lsls	r6, r3, #29
3400abda:	d55f      	bpl.n	3400ac9c <HAL_RCCEx_PeriphCLKConfig+0x204>
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));
3400abdc:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
3400abe0:	2b07      	cmp	r3, #7
3400abe2:	d903      	bls.n	3400abec <HAL_RCCEx_PeriphCLKConfig+0x154>
3400abe4:	21d4      	movs	r1, #212	@ 0xd4
3400abe6:	4812      	ldr	r0, [pc, #72]	@ (3400ac30 <HAL_RCCEx_PeriphCLKConfig+0x198>)
3400abe8:	f7f8 f812 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
3400abec:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
3400abf0:	3b03      	subs	r3, #3
3400abf2:	2b04      	cmp	r3, #4
3400abf4:	d848      	bhi.n	3400ac88 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
3400abf6:	e8df f013 	tbh	[pc, r3, lsl #1]
3400abfa:	0f27      	.short	0x0f27
3400abfc:	0ee10025 	.word	0x0ee10025
3400ac00:	0f500f04 	.word	0x0f500f04
    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3400ac04:	f401 7240 	and.w	r2, r1, #768	@ 0x300
3400ac08:	429a      	cmp	r2, r3
3400ac0a:	d0bf      	beq.n	3400ab8c <HAL_RCCEx_PeriphCLKConfig+0xf4>
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
3400ac0c:	4b0c      	ldr	r3, [pc, #48]	@ (3400ac40 <HAL_RCCEx_PeriphCLKConfig+0x1a8>)
3400ac0e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400ac10:	f042 0201 	orr.w	r2, r2, #1
3400ac14:	62da      	str	r2, [r3, #44]	@ 0x2c
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
3400ac16:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400ac18:	07db      	lsls	r3, r3, #31
3400ac1a:	d4b7      	bmi.n	3400ab8c <HAL_RCCEx_PeriphCLKConfig+0xf4>
      status = ret;
3400ac1c:	2501      	movs	r5, #1
3400ac1e:	e7da      	b.n	3400abd6 <HAL_RCCEx_PeriphCLKConfig+0x13e>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400ac20:	f7fa f92c 	bl	34004e7c <HAL_GetTick>
3400ac24:	1b40      	subs	r0, r0, r5
3400ac26:	42b0      	cmp	r0, r6
3400ac28:	d9b8      	bls.n	3400ab9c <HAL_RCCEx_PeriphCLKConfig+0x104>
        status = ret;
3400ac2a:	2503      	movs	r5, #3
3400ac2c:	e7d3      	b.n	3400abd6 <HAL_RCCEx_PeriphCLKConfig+0x13e>
3400ac2e:	bf00      	nop
3400ac30:	3402044f 	.word	0x3402044f
3400ac34:	00010300 	.word	0x00010300
3400ac38:	0003e300 	.word	0x0003e300
3400ac3c:	56028000 	.word	0x56028000
3400ac40:	56024800 	.word	0x56024800
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400ac44:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400ac46:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ac4a:	d003      	beq.n	3400ac54 <HAL_RCCEx_PeriphCLKConfig+0x1bc>
3400ac4c:	21d9      	movs	r1, #217	@ 0xd9
3400ac4e:	48bd      	ldr	r0, [pc, #756]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400ac50:	f7f7 ffde 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400ac54:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400ac56:	3b01      	subs	r3, #1
3400ac58:	2bff      	cmp	r3, #255	@ 0xff
3400ac5a:	d903      	bls.n	3400ac64 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
3400ac5c:	21da      	movs	r1, #218	@ 0xda
3400ac5e:	48b9      	ldr	r0, [pc, #740]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400ac60:	f7f7 ffd6 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400ac64:	4ab8      	ldr	r2, [pc, #736]	@ (3400af48 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400ac66:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3400ac68:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3400ac6c:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
3400ac6e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ac72:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ac76:	3901      	subs	r1, #1
3400ac78:	4303      	orrs	r3, r0
3400ac7a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ac7e:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400ac82:	2310      	movs	r3, #16
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3400ac84:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
3400ac88:	4aaf      	ldr	r2, [pc, #700]	@ (3400af48 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400ac8a:	f8d4 10b8 	ldr.w	r1, [r4, #184]	@ 0xb8
3400ac8e:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400ac92:	f023 0307 	bic.w	r3, r3, #7
3400ac96:	430b      	orrs	r3, r1
3400ac98:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
3400ac9c:	6863      	ldr	r3, [r4, #4]
3400ac9e:	0258      	lsls	r0, r3, #9
3400aca0:	d539      	bpl.n	3400ad16 <HAL_RCCEx_PeriphCLKConfig+0x27e>
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));
3400aca2:	f8d4 30ac 	ldr.w	r3, [r4, #172]	@ 0xac
3400aca6:	4aa9      	ldr	r2, [pc, #676]	@ (3400af4c <HAL_RCCEx_PeriphCLKConfig+0x4b4>)
3400aca8:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400acac:	4293      	cmp	r3, r2
3400acae:	d004      	beq.n	3400acba <HAL_RCCEx_PeriphCLKConfig+0x222>
3400acb0:	f44f 7192 	mov.w	r1, #292	@ 0x124
3400acb4:	48a3      	ldr	r0, [pc, #652]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400acb6:	f7f7 ffab 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
3400acba:	f8d4 30ac 	ldr.w	r3, [r4, #172]	@ 0xac
3400acbe:	4aa4      	ldr	r2, [pc, #656]	@ (3400af50 <HAL_RCCEx_PeriphCLKConfig+0x4b8>)
3400acc0:	4293      	cmp	r3, r2
3400acc2:	f041 8713 	bne.w	3400caec <HAL_RCCEx_PeriphCLKConfig+0x2054>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400acc6:	69a3      	ldr	r3, [r4, #24]
3400acc8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400accc:	d004      	beq.n	3400acd8 <HAL_RCCEx_PeriphCLKConfig+0x240>
3400acce:	f240 1129 	movw	r1, #297	@ 0x129
3400acd2:	489c      	ldr	r0, [pc, #624]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400acd4:	f7f7 ff9c 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400acd8:	69e3      	ldr	r3, [r4, #28]
3400acda:	3b01      	subs	r3, #1
3400acdc:	2bff      	cmp	r3, #255	@ 0xff
3400acde:	d904      	bls.n	3400acea <HAL_RCCEx_PeriphCLKConfig+0x252>
3400ace0:	f44f 7195 	mov.w	r1, #298	@ 0x12a
3400ace4:	4897      	ldr	r0, [pc, #604]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400ace6:	f7f7 ff93 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400acea:	4a97      	ldr	r2, [pc, #604]	@ (3400af48 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400acec:	69e1      	ldr	r1, [r4, #28]
3400acee:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400acf2:	69a0      	ldr	r0, [r4, #24]
3400acf4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400acf8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400acfc:	3901      	subs	r1, #1
3400acfe:	4303      	orrs	r3, r0
3400ad00:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ad04:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400ad08:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400ad0a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ad0e:	f8d4 00ac 	ldr.w	r0, [r4, #172]	@ 0xac
3400ad12:	f7ff fddd 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
3400ad16:	6863      	ldr	r3, [r4, #4]
3400ad18:	0219      	lsls	r1, r3, #8
3400ad1a:	d539      	bpl.n	3400ad90 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));
3400ad1c:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
3400ad20:	4a8c      	ldr	r2, [pc, #560]	@ (3400af54 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
3400ad22:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400ad26:	4293      	cmp	r3, r2
3400ad28:	d004      	beq.n	3400ad34 <HAL_RCCEx_PeriphCLKConfig+0x29c>
3400ad2a:	f240 1151 	movw	r1, #337	@ 0x151
3400ad2e:	4885      	ldr	r0, [pc, #532]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400ad30:	f7f7 ff6e 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
3400ad34:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
3400ad38:	4a87      	ldr	r2, [pc, #540]	@ (3400af58 <HAL_RCCEx_PeriphCLKConfig+0x4c0>)
3400ad3a:	4293      	cmp	r3, r2
3400ad3c:	f041 8706 	bne.w	3400cb4c <HAL_RCCEx_PeriphCLKConfig+0x20b4>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400ad40:	69a3      	ldr	r3, [r4, #24]
3400ad42:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ad46:	d004      	beq.n	3400ad52 <HAL_RCCEx_PeriphCLKConfig+0x2ba>
3400ad48:	f44f 71ab 	mov.w	r1, #342	@ 0x156
3400ad4c:	487d      	ldr	r0, [pc, #500]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400ad4e:	f7f7 ff5f 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400ad52:	69e3      	ldr	r3, [r4, #28]
3400ad54:	3b01      	subs	r3, #1
3400ad56:	2bff      	cmp	r3, #255	@ 0xff
3400ad58:	d904      	bls.n	3400ad64 <HAL_RCCEx_PeriphCLKConfig+0x2cc>
3400ad5a:	f240 1157 	movw	r1, #343	@ 0x157
3400ad5e:	4879      	ldr	r0, [pc, #484]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400ad60:	f7f7 ff56 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400ad64:	4a78      	ldr	r2, [pc, #480]	@ (3400af48 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400ad66:	69e1      	ldr	r1, [r4, #28]
3400ad68:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400ad6c:	69a0      	ldr	r0, [r4, #24]
3400ad6e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ad72:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ad76:	3901      	subs	r1, #1
3400ad78:	4303      	orrs	r3, r0
3400ad7a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ad7e:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400ad82:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400ad84:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ad88:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
3400ad8c:	f7ff fda0 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
3400ad90:	6863      	ldr	r3, [r4, #4]
3400ad92:	01da      	lsls	r2, r3, #7
3400ad94:	d539      	bpl.n	3400ae0a <HAL_RCCEx_PeriphCLKConfig+0x372>
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));
3400ad96:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
3400ad9a:	4a70      	ldr	r2, [pc, #448]	@ (3400af5c <HAL_RCCEx_PeriphCLKConfig+0x4c4>)
3400ad9c:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400ada0:	4293      	cmp	r3, r2
3400ada2:	d004      	beq.n	3400adae <HAL_RCCEx_PeriphCLKConfig+0x316>
3400ada4:	f44f 71bf 	mov.w	r1, #382	@ 0x17e
3400ada8:	4866      	ldr	r0, [pc, #408]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400adaa:	f7f7 ff31 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
3400adae:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
3400adb2:	4a6b      	ldr	r2, [pc, #428]	@ (3400af60 <HAL_RCCEx_PeriphCLKConfig+0x4c8>)
3400adb4:	4293      	cmp	r3, r2
3400adb6:	f041 86f9 	bne.w	3400cbac <HAL_RCCEx_PeriphCLKConfig+0x2114>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400adba:	69a3      	ldr	r3, [r4, #24]
3400adbc:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400adc0:	d004      	beq.n	3400adcc <HAL_RCCEx_PeriphCLKConfig+0x334>
3400adc2:	f240 1183 	movw	r1, #387	@ 0x183
3400adc6:	485f      	ldr	r0, [pc, #380]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400adc8:	f7f7 ff22 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400adcc:	69e3      	ldr	r3, [r4, #28]
3400adce:	3b01      	subs	r3, #1
3400add0:	2bff      	cmp	r3, #255	@ 0xff
3400add2:	d904      	bls.n	3400adde <HAL_RCCEx_PeriphCLKConfig+0x346>
3400add4:	f44f 71c2 	mov.w	r1, #388	@ 0x184
3400add8:	485a      	ldr	r0, [pc, #360]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400adda:	f7f7 ff19 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400adde:	4a5a      	ldr	r2, [pc, #360]	@ (3400af48 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400ade0:	69e1      	ldr	r1, [r4, #28]
3400ade2:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400ade6:	69a0      	ldr	r0, [r4, #24]
3400ade8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400adec:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400adf0:	3901      	subs	r1, #1
3400adf2:	4303      	orrs	r3, r0
3400adf4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400adf8:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400adfc:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400adfe:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ae02:	f8d4 00b4 	ldr.w	r0, [r4, #180]	@ 0xb4
3400ae06:	f7ff fd63 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
3400ae0a:	6823      	ldr	r3, [r4, #0]
3400ae0c:	051b      	lsls	r3, r3, #20
3400ae0e:	d53c      	bpl.n	3400ae8a <HAL_RCCEx_PeriphCLKConfig+0x3f2>
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));
3400ae10:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
3400ae14:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400ae18:	d004      	beq.n	3400ae24 <HAL_RCCEx_PeriphCLKConfig+0x38c>
3400ae1a:	f240 11ab 	movw	r1, #427	@ 0x1ab
3400ae1e:	4849      	ldr	r0, [pc, #292]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400ae20:	f7f7 fef6 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
3400ae24:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
3400ae28:	2b20      	cmp	r3, #32
3400ae2a:	f041 86ff 	bne.w	3400cc2c <HAL_RCCEx_PeriphCLKConfig+0x2194>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400ae2e:	69a3      	ldr	r3, [r4, #24]
3400ae30:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ae34:	d004      	beq.n	3400ae40 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
3400ae36:	f44f 71d8 	mov.w	r1, #432	@ 0x1b0
3400ae3a:	4842      	ldr	r0, [pc, #264]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400ae3c:	f7f7 fee8 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400ae40:	69e3      	ldr	r3, [r4, #28]
3400ae42:	3b01      	subs	r3, #1
3400ae44:	2bff      	cmp	r3, #255	@ 0xff
3400ae46:	d904      	bls.n	3400ae52 <HAL_RCCEx_PeriphCLKConfig+0x3ba>
3400ae48:	f240 11b1 	movw	r1, #433	@ 0x1b1
3400ae4c:	483d      	ldr	r0, [pc, #244]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400ae4e:	f7f7 fedf 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400ae52:	4a3d      	ldr	r2, [pc, #244]	@ (3400af48 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400ae54:	69e1      	ldr	r1, [r4, #28]
3400ae56:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400ae5a:	69a0      	ldr	r0, [r4, #24]
3400ae5c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ae60:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ae64:	3901      	subs	r1, #1
3400ae66:	4303      	orrs	r3, r0
3400ae68:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ae6c:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400ae70:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400ae72:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
3400ae76:	4a34      	ldr	r2, [pc, #208]	@ (3400af48 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400ae78:	f8d4 10a8 	ldr.w	r1, [r4, #168]	@ 0xa8
3400ae7c:	f8d2 314c 	ldr.w	r3, [r2, #332]	@ 0x14c
3400ae80:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
3400ae84:	430b      	orrs	r3, r1
3400ae86:	f8c2 314c 	str.w	r3, [r2, #332]	@ 0x14c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
3400ae8a:	6823      	ldr	r3, [r4, #0]
3400ae8c:	005e      	lsls	r6, r3, #1
3400ae8e:	d539      	bpl.n	3400af04 <HAL_RCCEx_PeriphCLKConfig+0x46c>
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
3400ae90:	f8d4 312c 	ldr.w	r3, [r4, #300]	@ 0x12c
3400ae94:	4a33      	ldr	r2, [pc, #204]	@ (3400af64 <HAL_RCCEx_PeriphCLKConfig+0x4cc>)
3400ae96:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400ae9a:	4293      	cmp	r3, r2
3400ae9c:	d004      	beq.n	3400aea8 <HAL_RCCEx_PeriphCLKConfig+0x410>
3400ae9e:	f44f 71ec 	mov.w	r1, #472	@ 0x1d8
3400aea2:	4828      	ldr	r0, [pc, #160]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400aea4:	f7f7 feb4 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
3400aea8:	f8d4 312c 	ldr.w	r3, [r4, #300]	@ 0x12c
3400aeac:	4a2e      	ldr	r2, [pc, #184]	@ (3400af68 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
3400aeae:	4293      	cmp	r3, r2
3400aeb0:	f041 86ea 	bne.w	3400cc88 <HAL_RCCEx_PeriphCLKConfig+0x21f0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400aeb4:	6a23      	ldr	r3, [r4, #32]
3400aeb6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400aeba:	d004      	beq.n	3400aec6 <HAL_RCCEx_PeriphCLKConfig+0x42e>
3400aebc:	f240 11dd 	movw	r1, #477	@ 0x1dd
3400aec0:	4820      	ldr	r0, [pc, #128]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400aec2:	f7f7 fea5 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400aec6:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400aec8:	3b01      	subs	r3, #1
3400aeca:	2bff      	cmp	r3, #255	@ 0xff
3400aecc:	d904      	bls.n	3400aed8 <HAL_RCCEx_PeriphCLKConfig+0x440>
3400aece:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
3400aed2:	481c      	ldr	r0, [pc, #112]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400aed4:	f7f7 fe9c 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400aed8:	4a1b      	ldr	r2, [pc, #108]	@ (3400af48 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400aeda:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400aedc:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400aee0:	6a20      	ldr	r0, [r4, #32]
3400aee2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400aee6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400aeea:	3901      	subs	r1, #1
3400aeec:	4303      	orrs	r3, r0
3400aeee:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400aef2:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400aef6:	2308      	movs	r3, #8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400aef8:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400aefc:	f8d4 012c 	ldr.w	r0, [r4, #300]	@ 0x12c
3400af00:	f7ff fce6 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
3400af04:	6823      	ldr	r3, [r4, #0]
3400af06:	2b00      	cmp	r3, #0
3400af08:	da53      	bge.n	3400afb2 <HAL_RCCEx_PeriphCLKConfig+0x51a>
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));
3400af0a:	f8d4 3130 	ldr.w	r3, [r4, #304]	@ 0x130
3400af0e:	4a17      	ldr	r2, [pc, #92]	@ (3400af6c <HAL_RCCEx_PeriphCLKConfig+0x4d4>)
3400af10:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400af14:	4293      	cmp	r3, r2
3400af16:	d004      	beq.n	3400af22 <HAL_RCCEx_PeriphCLKConfig+0x48a>
3400af18:	f240 2105 	movw	r1, #517	@ 0x205
3400af1c:	4809      	ldr	r0, [pc, #36]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400af1e:	f7f7 fe77 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
3400af22:	f8d4 3130 	ldr.w	r3, [r4, #304]	@ 0x130
3400af26:	4a12      	ldr	r2, [pc, #72]	@ (3400af70 <HAL_RCCEx_PeriphCLKConfig+0x4d8>)
3400af28:	4293      	cmp	r3, r2
3400af2a:	f041 86dd 	bne.w	3400cce8 <HAL_RCCEx_PeriphCLKConfig+0x2250>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400af2e:	6a23      	ldr	r3, [r4, #32]
3400af30:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400af34:	d01e      	beq.n	3400af74 <HAL_RCCEx_PeriphCLKConfig+0x4dc>
3400af36:	f240 210a 	movw	r1, #522	@ 0x20a
3400af3a:	4802      	ldr	r0, [pc, #8]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400af3c:	f7f7 fe68 	bl	34002c10 <assert_failed>
3400af40:	e018      	b.n	3400af74 <HAL_RCCEx_PeriphCLKConfig+0x4dc>
3400af42:	bf00      	nop
3400af44:	3402044f 	.word	0x3402044f
3400af48:	56028000 	.word	0x56028000
3400af4c:	03000014 	.word	0x03000014
3400af50:	03020014 	.word	0x03020014
3400af54:	03000414 	.word	0x03000414
3400af58:	03020414 	.word	0x03020414
3400af5c:	03000814 	.word	0x03000814
3400af60:	03020814 	.word	0x03020814
3400af64:	0300001c 	.word	0x0300001c
3400af68:	0302001c 	.word	0x0302001c
3400af6c:	0300041c 	.word	0x0300041c
3400af70:	0302041c 	.word	0x0302041c
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400af74:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400af76:	3b01      	subs	r3, #1
3400af78:	2bff      	cmp	r3, #255	@ 0xff
3400af7a:	d904      	bls.n	3400af86 <HAL_RCCEx_PeriphCLKConfig+0x4ee>
3400af7c:	f240 210b 	movw	r1, #523	@ 0x20b
3400af80:	48c4      	ldr	r0, [pc, #784]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400af82:	f7f7 fe45 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400af86:	4ac4      	ldr	r2, [pc, #784]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400af88:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400af8a:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400af8e:	6a20      	ldr	r0, [r4, #32]
3400af90:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400af94:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400af98:	3901      	subs	r1, #1
3400af9a:	4303      	orrs	r3, r0
3400af9c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400afa0:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400afa4:	2308      	movs	r3, #8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400afa6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400afaa:	f8d4 0130 	ldr.w	r0, [r4, #304]	@ 0x130
3400afae:	f7ff fc8f 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
3400afb2:	6823      	ldr	r3, [r4, #0]
3400afb4:	07d8      	lsls	r0, r3, #31
3400afb6:	d54f      	bpl.n	3400b058 <HAL_RCCEx_PeriphCLKConfig+0x5c0>
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
3400afb8:	f8d4 30bc 	ldr.w	r3, [r4, #188]	@ 0xbc
3400afbc:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400afc0:	d006      	beq.n	3400afd0 <HAL_RCCEx_PeriphCLKConfig+0x538>
3400afc2:	2b40      	cmp	r3, #64	@ 0x40
3400afc4:	d004      	beq.n	3400afd0 <HAL_RCCEx_PeriphCLKConfig+0x538>
3400afc6:	f240 2132 	movw	r1, #562	@ 0x232
3400afca:	48b2      	ldr	r0, [pc, #712]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400afcc:	f7f7 fe20 	bl	34002c10 <assert_failed>
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));
3400afd0:	f8d4 30c0 	ldr.w	r3, [r4, #192]	@ 0xc0
3400afd4:	3b01      	subs	r3, #1
3400afd6:	2bff      	cmp	r3, #255	@ 0xff
3400afd8:	d904      	bls.n	3400afe4 <HAL_RCCEx_PeriphCLKConfig+0x54c>
3400afda:	f240 2133 	movw	r1, #563	@ 0x233
3400afde:	48ad      	ldr	r0, [pc, #692]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400afe0:	f7f7 fe16 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
3400afe4:	f8d4 30bc 	ldr.w	r3, [r4, #188]	@ 0xbc
3400afe8:	2b20      	cmp	r3, #32
3400afea:	f041 86ad 	bne.w	3400cd48 <HAL_RCCEx_PeriphCLKConfig+0x22b0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400afee:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400aff0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400aff4:	d004      	beq.n	3400b000 <HAL_RCCEx_PeriphCLKConfig+0x568>
3400aff6:	f44f 710e 	mov.w	r1, #568	@ 0x238
3400affa:	48a6      	ldr	r0, [pc, #664]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400affc:	f7f7 fe08 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400b000:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400b002:	3b01      	subs	r3, #1
3400b004:	2bff      	cmp	r3, #255	@ 0xff
3400b006:	d904      	bls.n	3400b012 <HAL_RCCEx_PeriphCLKConfig+0x57a>
3400b008:	f240 2139 	movw	r1, #569	@ 0x239
3400b00c:	48a1      	ldr	r0, [pc, #644]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b00e:	f7f7 fdff 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400b012:	4aa1      	ldr	r2, [pc, #644]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400b014:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400b016:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400b01a:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400b01c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b020:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b024:	3901      	subs	r1, #1
3400b026:	4303      	orrs	r3, r0
3400b028:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b02c:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400b030:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b032:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
3400b036:	4998      	ldr	r1, [pc, #608]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400b038:	f8d4 20c0 	ldr.w	r2, [r4, #192]	@ 0xc0
3400b03c:	f8d1 3144 	ldr.w	r3, [r1, #324]	@ 0x144
3400b040:	f8d4 00bc 	ldr.w	r0, [r4, #188]	@ 0xbc
3400b044:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
3400b048:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
3400b04c:	3a01      	subs	r2, #1
3400b04e:	4303      	orrs	r3, r0
3400b050:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
3400b054:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
3400b058:	6823      	ldr	r3, [r4, #0]
3400b05a:	0799      	lsls	r1, r3, #30
3400b05c:	d53b      	bpl.n	3400b0d6 <HAL_RCCEx_PeriphCLKConfig+0x63e>
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));
3400b05e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	@ 0xc4
3400b062:	2b07      	cmp	r3, #7
3400b064:	d904      	bls.n	3400b070 <HAL_RCCEx_PeriphCLKConfig+0x5d8>
3400b066:	f240 2161 	movw	r1, #609	@ 0x261
3400b06a:	488a      	ldr	r0, [pc, #552]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b06c:	f7f7 fdd0 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
3400b070:	f8d4 30c4 	ldr.w	r3, [r4, #196]	@ 0xc4
3400b074:	2b02      	cmp	r3, #2
3400b076:	f041 8695 	bne.w	3400cda4 <HAL_RCCEx_PeriphCLKConfig+0x230c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400b07a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400b07c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b080:	d004      	beq.n	3400b08c <HAL_RCCEx_PeriphCLKConfig+0x5f4>
3400b082:	f240 2166 	movw	r1, #614	@ 0x266
3400b086:	4883      	ldr	r0, [pc, #524]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b088:	f7f7 fdc2 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400b08c:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400b08e:	3b01      	subs	r3, #1
3400b090:	2bff      	cmp	r3, #255	@ 0xff
3400b092:	d904      	bls.n	3400b09e <HAL_RCCEx_PeriphCLKConfig+0x606>
3400b094:	f240 2167 	movw	r1, #615	@ 0x267
3400b098:	487e      	ldr	r0, [pc, #504]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b09a:	f7f7 fdb9 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400b09e:	4a7e      	ldr	r2, [pc, #504]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400b0a0:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400b0a2:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400b0a6:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400b0a8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b0ac:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b0b0:	3901      	subs	r1, #1
3400b0b2:	4303      	orrs	r3, r0
3400b0b4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b0b8:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400b0bc:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b0be:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
3400b0c2:	4a75      	ldr	r2, [pc, #468]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400b0c4:	f8d4 10c4 	ldr.w	r1, [r4, #196]	@ 0xc4
3400b0c8:	f8d2 3144 	ldr.w	r3, [r2, #324]	@ 0x144
3400b0cc:	f023 0307 	bic.w	r3, r3, #7
3400b0d0:	430b      	orrs	r3, r1
3400b0d2:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
3400b0d6:	6823      	ldr	r3, [r4, #0]
3400b0d8:	071a      	lsls	r2, r3, #28
3400b0da:	d528      	bpl.n	3400b12e <HAL_RCCEx_PeriphCLKConfig+0x696>
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
3400b0dc:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
3400b0e0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b0e4:	d004      	beq.n	3400b0f0 <HAL_RCCEx_PeriphCLKConfig+0x658>
3400b0e6:	f240 218e 	movw	r1, #654	@ 0x28e
3400b0ea:	486a      	ldr	r0, [pc, #424]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b0ec:	f7f7 fd90 	bl	34002c10 <assert_failed>
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));
3400b0f0:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
3400b0f4:	3b01      	subs	r3, #1
3400b0f6:	2bff      	cmp	r3, #255	@ 0xff
3400b0f8:	d904      	bls.n	3400b104 <HAL_RCCEx_PeriphCLKConfig+0x66c>
3400b0fa:	f240 218f 	movw	r1, #655	@ 0x28f
3400b0fe:	4865      	ldr	r0, [pc, #404]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b100:	f7f7 fd86 	bl	34002c10 <assert_failed>
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
3400b104:	4a64      	ldr	r2, [pc, #400]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400b106:	f8d4 1094 	ldr.w	r1, [r4, #148]	@ 0x94
3400b10a:	f8d2 3108 	ldr.w	r3, [r2, #264]	@ 0x108
3400b10e:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
3400b112:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b116:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b11a:	3901      	subs	r1, #1
3400b11c:	4303      	orrs	r3, r0
3400b11e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b122:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
3400b126:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
3400b12a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
3400b12e:	6823      	ldr	r3, [r4, #0]
3400b130:	06db      	lsls	r3, r3, #27
3400b132:	d542      	bpl.n	3400b1ba <HAL_RCCEx_PeriphCLKConfig+0x722>
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));
3400b134:	f8d4 30c8 	ldr.w	r3, [r4, #200]	@ 0xc8
3400b138:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
3400b13c:	d004      	beq.n	3400b148 <HAL_RCCEx_PeriphCLKConfig+0x6b0>
3400b13e:	f240 219d 	movw	r1, #669	@ 0x29d
3400b142:	4854      	ldr	r0, [pc, #336]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b144:	f7f7 fd64 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
3400b148:	f8d4 30c8 	ldr.w	r3, [r4, #200]	@ 0xc8
3400b14c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400b150:	f041 8656 	bne.w	3400ce00 <HAL_RCCEx_PeriphCLKConfig+0x2368>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
3400b154:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
3400b158:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b15c:	d004      	beq.n	3400b168 <HAL_RCCEx_PeriphCLKConfig+0x6d0>
3400b15e:	f240 21a2 	movw	r1, #674	@ 0x2a2
3400b162:	484c      	ldr	r0, [pc, #304]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b164:	f7f7 fd54 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));
3400b168:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
3400b16c:	3b01      	subs	r3, #1
3400b16e:	2bff      	cmp	r3, #255	@ 0xff
3400b170:	d904      	bls.n	3400b17c <HAL_RCCEx_PeriphCLKConfig+0x6e4>
3400b172:	f240 21a3 	movw	r1, #675	@ 0x2a3
3400b176:	4847      	ldr	r0, [pc, #284]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b178:	f7f7 fd4a 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
3400b17c:	4a46      	ldr	r2, [pc, #280]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400b17e:	f8d4 108c 	ldr.w	r1, [r4, #140]	@ 0x8c
3400b182:	f8d2 3104 	ldr.w	r3, [r2, #260]	@ 0x104
3400b186:	f8d4 0088 	ldr.w	r0, [r4, #136]	@ 0x88
3400b18a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b18e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b192:	3901      	subs	r1, #1
3400b194:	4303      	orrs	r3, r0
3400b196:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b19a:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
3400b19e:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
3400b1a2:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
3400b1a6:	4a3c      	ldr	r2, [pc, #240]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400b1a8:	f8d4 10c8 	ldr.w	r1, [r4, #200]	@ 0xc8
3400b1ac:	f8d2 3144 	ldr.w	r3, [r2, #324]	@ 0x144
3400b1b0:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
3400b1b4:	430b      	orrs	r3, r1
3400b1b6:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
3400b1ba:	6823      	ldr	r3, [r4, #0]
3400b1bc:	069e      	lsls	r6, r3, #26
3400b1be:	d53e      	bpl.n	3400b23e <HAL_RCCEx_PeriphCLKConfig+0x7a6>
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));
3400b1c0:	f8d4 30cc 	ldr.w	r3, [r4, #204]	@ 0xcc
3400b1c4:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
3400b1c8:	d004      	beq.n	3400b1d4 <HAL_RCCEx_PeriphCLKConfig+0x73c>
3400b1ca:	f240 21bd 	movw	r1, #701	@ 0x2bd
3400b1ce:	4831      	ldr	r0, [pc, #196]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b1d0:	f7f7 fd1e 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
3400b1d4:	f8d4 30cc 	ldr.w	r3, [r4, #204]	@ 0xcc
3400b1d8:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3400b1dc:	f041 8619 	bne.w	3400ce12 <HAL_RCCEx_PeriphCLKConfig+0x237a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
3400b1e0:	6e23      	ldr	r3, [r4, #96]	@ 0x60
3400b1e2:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b1e6:	d004      	beq.n	3400b1f2 <HAL_RCCEx_PeriphCLKConfig+0x75a>
3400b1e8:	f240 21c2 	movw	r1, #706	@ 0x2c2
3400b1ec:	4829      	ldr	r0, [pc, #164]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b1ee:	f7f7 fd0f 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));
3400b1f2:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3400b1f4:	3b01      	subs	r3, #1
3400b1f6:	2bff      	cmp	r3, #255	@ 0xff
3400b1f8:	d904      	bls.n	3400b204 <HAL_RCCEx_PeriphCLKConfig+0x76c>
3400b1fa:	f240 21c3 	movw	r1, #707	@ 0x2c3
3400b1fe:	4825      	ldr	r0, [pc, #148]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b200:	f7f7 fd06 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
3400b204:	4a24      	ldr	r2, [pc, #144]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400b206:	6e61      	ldr	r1, [r4, #100]	@ 0x64
3400b208:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
3400b20c:	6e20      	ldr	r0, [r4, #96]	@ 0x60
3400b20e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b212:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b216:	3901      	subs	r1, #1
3400b218:	4303      	orrs	r3, r0
3400b21a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b21e:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
3400b222:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400b226:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
3400b22a:	4a1b      	ldr	r2, [pc, #108]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400b22c:	f8d4 10cc 	ldr.w	r1, [r4, #204]	@ 0xcc
3400b230:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400b234:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
3400b238:	430b      	orrs	r3, r1
3400b23a:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
3400b23e:	6823      	ldr	r3, [r4, #0]
3400b240:	0658      	lsls	r0, r3, #25
3400b242:	d516      	bpl.n	3400b272 <HAL_RCCEx_PeriphCLKConfig+0x7da>
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));
3400b244:	f8d4 30d0 	ldr.w	r3, [r4, #208]	@ 0xd0
3400b248:	f433 3280 	bics.w	r2, r3, #65536	@ 0x10000
3400b24c:	d007      	beq.n	3400b25e <HAL_RCCEx_PeriphCLKConfig+0x7c6>
3400b24e:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400b252:	d004      	beq.n	3400b25e <HAL_RCCEx_PeriphCLKConfig+0x7c6>
3400b254:	f240 21dd 	movw	r1, #733	@ 0x2dd
3400b258:	480e      	ldr	r0, [pc, #56]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b25a:	f7f7 fcd9 	bl	34002c10 <assert_failed>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
3400b25e:	4a0e      	ldr	r2, [pc, #56]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400b260:	f8d4 10d0 	ldr.w	r1, [r4, #208]	@ 0xd0
3400b264:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400b268:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400b26c:	430b      	orrs	r3, r1
3400b26e:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
3400b272:	6823      	ldr	r3, [r4, #0]
3400b274:	0619      	lsls	r1, r3, #24
3400b276:	d518      	bpl.n	3400b2aa <HAL_RCCEx_PeriphCLKConfig+0x812>
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));
3400b278:	f8d4 30d4 	ldr.w	r3, [r4, #212]	@ 0xd4
3400b27c:	f433 1380 	bics.w	r3, r3, #1048576	@ 0x100000
3400b280:	d004      	beq.n	3400b28c <HAL_RCCEx_PeriphCLKConfig+0x7f4>
3400b282:	f240 21e7 	movw	r1, #743	@ 0x2e7
3400b286:	4803      	ldr	r0, [pc, #12]	@ (3400b294 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400b288:	f7f7 fcc2 	bl	34002c10 <assert_failed>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
3400b28c:	4a02      	ldr	r2, [pc, #8]	@ (3400b298 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400b28e:	f8d4 10d4 	ldr.w	r1, [r4, #212]	@ 0xd4
3400b292:	e003      	b.n	3400b29c <HAL_RCCEx_PeriphCLKConfig+0x804>
3400b294:	3402044f 	.word	0x3402044f
3400b298:	56028000 	.word	0x56028000
3400b29c:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400b2a0:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
3400b2a4:	430b      	orrs	r3, r1
3400b2a6:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
3400b2aa:	6823      	ldr	r3, [r4, #0]
3400b2ac:	05da      	lsls	r2, r3, #23
3400b2ae:	d513      	bpl.n	3400b2d8 <HAL_RCCEx_PeriphCLKConfig+0x840>
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));
3400b2b0:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
3400b2b4:	f033 7380 	bics.w	r3, r3, #16777216	@ 0x1000000
3400b2b8:	d004      	beq.n	3400b2c4 <HAL_RCCEx_PeriphCLKConfig+0x82c>
3400b2ba:	f240 21f1 	movw	r1, #753	@ 0x2f1
3400b2be:	48c1      	ldr	r0, [pc, #772]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b2c0:	f7f7 fca6 	bl	34002c10 <assert_failed>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
3400b2c4:	4ac0      	ldr	r2, [pc, #768]	@ (3400b5c8 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400b2c6:	f8d4 10d8 	ldr.w	r1, [r4, #216]	@ 0xd8
3400b2ca:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400b2ce:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
3400b2d2:	430b      	orrs	r3, r1
3400b2d4:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
3400b2d8:	6823      	ldr	r3, [r4, #0]
3400b2da:	059b      	lsls	r3, r3, #22
3400b2dc:	d54b      	bpl.n	3400b376 <HAL_RCCEx_PeriphCLKConfig+0x8de>
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
3400b2de:	f8d4 30dc 	ldr.w	r3, [r4, #220]	@ 0xdc
3400b2e2:	2b03      	cmp	r3, #3
3400b2e4:	d904      	bls.n	3400b2f0 <HAL_RCCEx_PeriphCLKConfig+0x858>
3400b2e6:	f240 21fb 	movw	r1, #763	@ 0x2fb
3400b2ea:	48b6      	ldr	r0, [pc, #728]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b2ec:	f7f7 fc90 	bl	34002c10 <assert_failed>
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));
3400b2f0:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
3400b2f4:	3b01      	subs	r3, #1
3400b2f6:	2b0f      	cmp	r3, #15
3400b2f8:	d904      	bls.n	3400b304 <HAL_RCCEx_PeriphCLKConfig+0x86c>
3400b2fa:	f44f 713f 	mov.w	r1, #764	@ 0x2fc
3400b2fe:	48b1      	ldr	r0, [pc, #708]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b300:	f7f7 fc86 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
3400b304:	f8d4 30dc 	ldr.w	r3, [r4, #220]	@ 0xdc
3400b308:	2b02      	cmp	r3, #2
3400b30a:	f041 858b 	bne.w	3400ce24 <HAL_RCCEx_PeriphCLKConfig+0x238c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
3400b30e:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
3400b310:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b314:	d004      	beq.n	3400b320 <HAL_RCCEx_PeriphCLKConfig+0x888>
3400b316:	f240 3101 	movw	r1, #769	@ 0x301
3400b31a:	48aa      	ldr	r0, [pc, #680]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b31c:	f7f7 fc78 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));
3400b320:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
3400b322:	3b01      	subs	r3, #1
3400b324:	2bff      	cmp	r3, #255	@ 0xff
3400b326:	d904      	bls.n	3400b332 <HAL_RCCEx_PeriphCLKConfig+0x89a>
3400b328:	f240 3102 	movw	r1, #770	@ 0x302
3400b32c:	48a5      	ldr	r0, [pc, #660]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b32e:	f7f7 fc6f 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
3400b332:	4aa5      	ldr	r2, [pc, #660]	@ (3400b5c8 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400b334:	6ee1      	ldr	r1, [r4, #108]	@ 0x6c
3400b336:	f8d2 30f4 	ldr.w	r3, [r2, #244]	@ 0xf4
3400b33a:	6ea0      	ldr	r0, [r4, #104]	@ 0x68
3400b33c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b340:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b344:	3901      	subs	r1, #1
3400b346:	4303      	orrs	r3, r0
3400b348:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b34c:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
3400b350:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
3400b354:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
3400b358:	499b      	ldr	r1, [pc, #620]	@ (3400b5c8 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400b35a:	f8d4 20e0 	ldr.w	r2, [r4, #224]	@ 0xe0
3400b35e:	f8d1 3148 	ldr.w	r3, [r1, #328]	@ 0x148
3400b362:	f8d4 00dc 	ldr.w	r0, [r4, #220]	@ 0xdc
3400b366:	f023 03f3 	bic.w	r3, r3, #243	@ 0xf3
3400b36a:	3a01      	subs	r2, #1
3400b36c:	4303      	orrs	r3, r0
3400b36e:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
3400b372:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
3400b376:	6823      	ldr	r3, [r4, #0]
3400b378:	055e      	lsls	r6, r3, #21
3400b37a:	d540      	bpl.n	3400b3fe <HAL_RCCEx_PeriphCLKConfig+0x966>
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));
3400b37c:	f8d4 30e4 	ldr.w	r3, [r4, #228]	@ 0xe4
3400b380:	2b03      	cmp	r3, #3
3400b382:	d904      	bls.n	3400b38e <HAL_RCCEx_PeriphCLKConfig+0x8f6>
3400b384:	f240 311d 	movw	r1, #797	@ 0x31d
3400b388:	488e      	ldr	r0, [pc, #568]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b38a:	f7f7 fc41 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
3400b38e:	f8d4 30e4 	ldr.w	r3, [r4, #228]	@ 0xe4
3400b392:	2b02      	cmp	r3, #2
3400b394:	f041 854e 	bne.w	3400ce34 <HAL_RCCEx_PeriphCLKConfig+0x239c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
3400b398:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
3400b39c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b3a0:	d004      	beq.n	3400b3ac <HAL_RCCEx_PeriphCLKConfig+0x914>
3400b3a2:	f240 3122 	movw	r1, #802	@ 0x322
3400b3a6:	4887      	ldr	r0, [pc, #540]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b3a8:	f7f7 fc32 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));
3400b3ac:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
3400b3b0:	3b01      	subs	r3, #1
3400b3b2:	2bff      	cmp	r3, #255	@ 0xff
3400b3b4:	d904      	bls.n	3400b3c0 <HAL_RCCEx_PeriphCLKConfig+0x928>
3400b3b6:	f240 3123 	movw	r1, #803	@ 0x323
3400b3ba:	4882      	ldr	r0, [pc, #520]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b3bc:	f7f7 fc28 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3400b3c0:	4a81      	ldr	r2, [pc, #516]	@ (3400b5c8 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400b3c2:	f8d4 109c 	ldr.w	r1, [r4, #156]	@ 0x9c
3400b3c6:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
3400b3ca:	f8d4 0098 	ldr.w	r0, [r4, #152]	@ 0x98
3400b3ce:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b3d2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b3d6:	3901      	subs	r1, #1
3400b3d8:	4303      	orrs	r3, r0
3400b3da:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b3de:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3400b3e2:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
3400b3e6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
3400b3ea:	4a77      	ldr	r2, [pc, #476]	@ (3400b5c8 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400b3ec:	f8d4 10e4 	ldr.w	r1, [r4, #228]	@ 0xe4
3400b3f0:	f8d2 314c 	ldr.w	r3, [r2, #332]	@ 0x14c
3400b3f4:	f023 0303 	bic.w	r3, r3, #3
3400b3f8:	430b      	orrs	r3, r1
3400b3fa:	f8c2 314c 	str.w	r3, [r2, #332]	@ 0x14c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
3400b3fe:	6823      	ldr	r3, [r4, #0]
3400b400:	04d8      	lsls	r0, r3, #19
3400b402:	d540      	bpl.n	3400b486 <HAL_RCCEx_PeriphCLKConfig+0x9ee>
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
3400b404:	f8d4 30e8 	ldr.w	r3, [r4, #232]	@ 0xe8
3400b408:	4a70      	ldr	r2, [pc, #448]	@ (3400b5cc <HAL_RCCEx_PeriphCLKConfig+0xb34>)
3400b40a:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b40e:	4291      	cmp	r1, r2
3400b410:	d00a      	beq.n	3400b428 <HAL_RCCEx_PeriphCLKConfig+0x990>
3400b412:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b416:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b41a:	4293      	cmp	r3, r2
3400b41c:	d004      	beq.n	3400b428 <HAL_RCCEx_PeriphCLKConfig+0x990>
3400b41e:	f240 313d 	movw	r1, #829	@ 0x33d
3400b422:	4868      	ldr	r0, [pc, #416]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b424:	f7f7 fbf4 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
3400b428:	f8d4 30e8 	ldr.w	r3, [r4, #232]	@ 0xe8
3400b42c:	4a68      	ldr	r2, [pc, #416]	@ (3400b5d0 <HAL_RCCEx_PeriphCLKConfig+0xb38>)
3400b42e:	4293      	cmp	r3, r2
3400b430:	f041 8508 	bne.w	3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x23ac>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400b434:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400b436:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b43a:	d004      	beq.n	3400b446 <HAL_RCCEx_PeriphCLKConfig+0x9ae>
3400b43c:	f240 3142 	movw	r1, #834	@ 0x342
3400b440:	4860      	ldr	r0, [pc, #384]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b442:	f7f7 fbe5 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400b446:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400b448:	3b01      	subs	r3, #1
3400b44a:	2bff      	cmp	r3, #255	@ 0xff
3400b44c:	d904      	bls.n	3400b458 <HAL_RCCEx_PeriphCLKConfig+0x9c0>
3400b44e:	f240 3143 	movw	r1, #835	@ 0x343
3400b452:	485c      	ldr	r0, [pc, #368]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b454:	f7f7 fbdc 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400b458:	4a5b      	ldr	r2, [pc, #364]	@ (3400b5c8 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400b45a:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400b45c:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400b460:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400b462:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b466:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b46a:	3901      	subs	r1, #1
3400b46c:	4303      	orrs	r3, r0
3400b46e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b472:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400b476:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b47a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b47e:	f8d4 00e8 	ldr.w	r0, [r4, #232]	@ 0xe8
3400b482:	f7ff fa25 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
3400b486:	6823      	ldr	r3, [r4, #0]
3400b488:	0499      	lsls	r1, r3, #18
3400b48a:	d540      	bpl.n	3400b50e <HAL_RCCEx_PeriphCLKConfig+0xa76>
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
3400b48c:	f8d4 30ec 	ldr.w	r3, [r4, #236]	@ 0xec
3400b490:	4a50      	ldr	r2, [pc, #320]	@ (3400b5d4 <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
3400b492:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b496:	4291      	cmp	r1, r2
3400b498:	d00a      	beq.n	3400b4b0 <HAL_RCCEx_PeriphCLKConfig+0xa18>
3400b49a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b49e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b4a2:	4293      	cmp	r3, r2
3400b4a4:	d004      	beq.n	3400b4b0 <HAL_RCCEx_PeriphCLKConfig+0xa18>
3400b4a6:	f240 316a 	movw	r1, #874	@ 0x36a
3400b4aa:	4846      	ldr	r0, [pc, #280]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b4ac:	f7f7 fbb0 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
3400b4b0:	f8d4 30ec 	ldr.w	r3, [r4, #236]	@ 0xec
3400b4b4:	4a48      	ldr	r2, [pc, #288]	@ (3400b5d8 <HAL_RCCEx_PeriphCLKConfig+0xb40>)
3400b4b6:	4293      	cmp	r3, r2
3400b4b8:	f041 84f5 	bne.w	3400cea6 <HAL_RCCEx_PeriphCLKConfig+0x240e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400b4bc:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400b4be:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b4c2:	d004      	beq.n	3400b4ce <HAL_RCCEx_PeriphCLKConfig+0xa36>
3400b4c4:	f240 316f 	movw	r1, #879	@ 0x36f
3400b4c8:	483e      	ldr	r0, [pc, #248]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b4ca:	f7f7 fba1 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400b4ce:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400b4d0:	3b01      	subs	r3, #1
3400b4d2:	2bff      	cmp	r3, #255	@ 0xff
3400b4d4:	d904      	bls.n	3400b4e0 <HAL_RCCEx_PeriphCLKConfig+0xa48>
3400b4d6:	f44f 715c 	mov.w	r1, #880	@ 0x370
3400b4da:	483a      	ldr	r0, [pc, #232]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b4dc:	f7f7 fb98 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400b4e0:	4a39      	ldr	r2, [pc, #228]	@ (3400b5c8 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400b4e2:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400b4e4:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400b4e8:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400b4ea:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b4ee:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b4f2:	3901      	subs	r1, #1
3400b4f4:	4303      	orrs	r3, r0
3400b4f6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b4fa:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400b4fe:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b502:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b506:	f8d4 00ec 	ldr.w	r0, [r4, #236]	@ 0xec
3400b50a:	f7ff f9e1 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
3400b50e:	6823      	ldr	r3, [r4, #0]
3400b510:	045a      	lsls	r2, r3, #17
3400b512:	d540      	bpl.n	3400b596 <HAL_RCCEx_PeriphCLKConfig+0xafe>
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
3400b514:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3400b518:	4a30      	ldr	r2, [pc, #192]	@ (3400b5dc <HAL_RCCEx_PeriphCLKConfig+0xb44>)
3400b51a:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b51e:	4291      	cmp	r1, r2
3400b520:	d00a      	beq.n	3400b538 <HAL_RCCEx_PeriphCLKConfig+0xaa0>
3400b522:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b526:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b52a:	4293      	cmp	r3, r2
3400b52c:	d004      	beq.n	3400b538 <HAL_RCCEx_PeriphCLKConfig+0xaa0>
3400b52e:	f240 3197 	movw	r1, #919	@ 0x397
3400b532:	4824      	ldr	r0, [pc, #144]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b534:	f7f7 fb6c 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
3400b538:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3400b53c:	4a28      	ldr	r2, [pc, #160]	@ (3400b5e0 <HAL_RCCEx_PeriphCLKConfig+0xb48>)
3400b53e:	4293      	cmp	r3, r2
3400b540:	f041 84f6 	bne.w	3400cf30 <HAL_RCCEx_PeriphCLKConfig+0x2498>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400b544:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400b546:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b54a:	d004      	beq.n	3400b556 <HAL_RCCEx_PeriphCLKConfig+0xabe>
3400b54c:	f44f 7167 	mov.w	r1, #924	@ 0x39c
3400b550:	481c      	ldr	r0, [pc, #112]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b552:	f7f7 fb5d 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400b556:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400b558:	3b01      	subs	r3, #1
3400b55a:	2bff      	cmp	r3, #255	@ 0xff
3400b55c:	d904      	bls.n	3400b568 <HAL_RCCEx_PeriphCLKConfig+0xad0>
3400b55e:	f240 319d 	movw	r1, #925	@ 0x39d
3400b562:	4818      	ldr	r0, [pc, #96]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b564:	f7f7 fb54 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400b568:	4a17      	ldr	r2, [pc, #92]	@ (3400b5c8 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400b56a:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400b56c:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400b570:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400b572:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b576:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b57a:	3901      	subs	r1, #1
3400b57c:	4303      	orrs	r3, r0
3400b57e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b582:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400b586:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b58a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b58e:	f8d4 00f0 	ldr.w	r0, [r4, #240]	@ 0xf0
3400b592:	f7ff f99d 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
3400b596:	6823      	ldr	r3, [r4, #0]
3400b598:	041b      	lsls	r3, r3, #16
3400b59a:	d554      	bpl.n	3400b646 <HAL_RCCEx_PeriphCLKConfig+0xbae>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
3400b59c:	f8d4 30f4 	ldr.w	r3, [r4, #244]	@ 0xf4
3400b5a0:	4a10      	ldr	r2, [pc, #64]	@ (3400b5e4 <HAL_RCCEx_PeriphCLKConfig+0xb4c>)
3400b5a2:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b5a6:	4291      	cmp	r1, r2
3400b5a8:	d01e      	beq.n	3400b5e8 <HAL_RCCEx_PeriphCLKConfig+0xb50>
3400b5aa:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b5ae:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b5b2:	4293      	cmp	r3, r2
3400b5b4:	d018      	beq.n	3400b5e8 <HAL_RCCEx_PeriphCLKConfig+0xb50>
3400b5b6:	f44f 7171 	mov.w	r1, #964	@ 0x3c4
3400b5ba:	4802      	ldr	r0, [pc, #8]	@ (3400b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400b5bc:	f7f7 fb28 	bl	34002c10 <assert_failed>
3400b5c0:	e012      	b.n	3400b5e8 <HAL_RCCEx_PeriphCLKConfig+0xb50>
3400b5c2:	bf00      	nop
3400b5c4:	3402044f 	.word	0x3402044f
3400b5c8:	56028000 	.word	0x56028000
3400b5cc:	0700000c 	.word	0x0700000c
3400b5d0:	0702000c 	.word	0x0702000c
3400b5d4:	0700040c 	.word	0x0700040c
3400b5d8:	0702040c 	.word	0x0702040c
3400b5dc:	0700080c 	.word	0x0700080c
3400b5e0:	0702080c 	.word	0x0702080c
3400b5e4:	07000c0c 	.word	0x07000c0c
    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
3400b5e8:	f8d4 30f4 	ldr.w	r3, [r4, #244]	@ 0xf4
3400b5ec:	4abd      	ldr	r2, [pc, #756]	@ (3400b8e4 <HAL_RCCEx_PeriphCLKConfig+0xe4c>)
3400b5ee:	4293      	cmp	r3, r2
3400b5f0:	f041 84cf 	bne.w	3400cf92 <HAL_RCCEx_PeriphCLKConfig+0x24fa>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400b5f4:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400b5f6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b5fa:	d004      	beq.n	3400b606 <HAL_RCCEx_PeriphCLKConfig+0xb6e>
3400b5fc:	f240 31c9 	movw	r1, #969	@ 0x3c9
3400b600:	48b9      	ldr	r0, [pc, #740]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b602:	f7f7 fb05 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400b606:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400b608:	3b01      	subs	r3, #1
3400b60a:	2bff      	cmp	r3, #255	@ 0xff
3400b60c:	d904      	bls.n	3400b618 <HAL_RCCEx_PeriphCLKConfig+0xb80>
3400b60e:	f240 31ca 	movw	r1, #970	@ 0x3ca
3400b612:	48b5      	ldr	r0, [pc, #724]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b614:	f7f7 fafc 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400b618:	4ab4      	ldr	r2, [pc, #720]	@ (3400b8ec <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b61a:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400b61c:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400b620:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400b622:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b626:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b62a:	3901      	subs	r1, #1
3400b62c:	4303      	orrs	r3, r0
3400b62e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b632:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400b636:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b63a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b63e:	f8d4 00f4 	ldr.w	r0, [r4, #244]	@ 0xf4
3400b642:	f7ff f945 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
3400b646:	6823      	ldr	r3, [r4, #0]
3400b648:	03de      	lsls	r6, r3, #15
3400b64a:	d540      	bpl.n	3400b6ce <HAL_RCCEx_PeriphCLKConfig+0xc36>
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));
3400b64c:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
3400b650:	4aa7      	ldr	r2, [pc, #668]	@ (3400b8f0 <HAL_RCCEx_PeriphCLKConfig+0xe58>)
3400b652:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b656:	4291      	cmp	r1, r2
3400b658:	d00a      	beq.n	3400b670 <HAL_RCCEx_PeriphCLKConfig+0xbd8>
3400b65a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b65e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b662:	4293      	cmp	r3, r2
3400b664:	d004      	beq.n	3400b670 <HAL_RCCEx_PeriphCLKConfig+0xbd8>
3400b666:	f240 31f1 	movw	r1, #1009	@ 0x3f1
3400b66a:	489f      	ldr	r0, [pc, #636]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b66c:	f7f7 fad0 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
3400b670:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
3400b674:	4a9f      	ldr	r2, [pc, #636]	@ (3400b8f4 <HAL_RCCEx_PeriphCLKConfig+0xe5c>)
3400b676:	4293      	cmp	r3, r2
3400b678:	f041 84bc 	bne.w	3400cff4 <HAL_RCCEx_PeriphCLKConfig+0x255c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400b67c:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400b67e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b682:	d004      	beq.n	3400b68e <HAL_RCCEx_PeriphCLKConfig+0xbf6>
3400b684:	f240 31f6 	movw	r1, #1014	@ 0x3f6
3400b688:	4897      	ldr	r0, [pc, #604]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b68a:	f7f7 fac1 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400b68e:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400b690:	3b01      	subs	r3, #1
3400b692:	2bff      	cmp	r3, #255	@ 0xff
3400b694:	d904      	bls.n	3400b6a0 <HAL_RCCEx_PeriphCLKConfig+0xc08>
3400b696:	f240 31f7 	movw	r1, #1015	@ 0x3f7
3400b69a:	4893      	ldr	r0, [pc, #588]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b69c:	f7f7 fab8 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400b6a0:	4a92      	ldr	r2, [pc, #584]	@ (3400b8ec <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b6a2:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400b6a4:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400b6a8:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400b6aa:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b6ae:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b6b2:	3901      	subs	r1, #1
3400b6b4:	4303      	orrs	r3, r0
3400b6b6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b6ba:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400b6be:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b6c2:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b6c6:	f8d4 00f8 	ldr.w	r0, [r4, #248]	@ 0xf8
3400b6ca:	f7ff f901 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
3400b6ce:	6823      	ldr	r3, [r4, #0]
3400b6d0:	0398      	lsls	r0, r3, #14
3400b6d2:	d540      	bpl.n	3400b756 <HAL_RCCEx_PeriphCLKConfig+0xcbe>
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));
3400b6d4:	f8d4 30fc 	ldr.w	r3, [r4, #252]	@ 0xfc
3400b6d8:	4a87      	ldr	r2, [pc, #540]	@ (3400b8f8 <HAL_RCCEx_PeriphCLKConfig+0xe60>)
3400b6da:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b6de:	4291      	cmp	r1, r2
3400b6e0:	d00a      	beq.n	3400b6f8 <HAL_RCCEx_PeriphCLKConfig+0xc60>
3400b6e2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b6e6:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b6ea:	4293      	cmp	r3, r2
3400b6ec:	d004      	beq.n	3400b6f8 <HAL_RCCEx_PeriphCLKConfig+0xc60>
3400b6ee:	f240 411e 	movw	r1, #1054	@ 0x41e
3400b6f2:	487d      	ldr	r0, [pc, #500]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b6f4:	f7f7 fa8c 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
3400b6f8:	f8d4 30fc 	ldr.w	r3, [r4, #252]	@ 0xfc
3400b6fc:	4a7f      	ldr	r2, [pc, #508]	@ (3400b8fc <HAL_RCCEx_PeriphCLKConfig+0xe64>)
3400b6fe:	4293      	cmp	r3, r2
3400b700:	f041 84a9 	bne.w	3400d056 <HAL_RCCEx_PeriphCLKConfig+0x25be>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400b704:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400b706:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b70a:	d004      	beq.n	3400b716 <HAL_RCCEx_PeriphCLKConfig+0xc7e>
3400b70c:	f240 4123 	movw	r1, #1059	@ 0x423
3400b710:	4875      	ldr	r0, [pc, #468]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b712:	f7f7 fa7d 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400b716:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400b718:	3b01      	subs	r3, #1
3400b71a:	2bff      	cmp	r3, #255	@ 0xff
3400b71c:	d904      	bls.n	3400b728 <HAL_RCCEx_PeriphCLKConfig+0xc90>
3400b71e:	f240 4124 	movw	r1, #1060	@ 0x424
3400b722:	4871      	ldr	r0, [pc, #452]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b724:	f7f7 fa74 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400b728:	4a70      	ldr	r2, [pc, #448]	@ (3400b8ec <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b72a:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400b72c:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400b730:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400b732:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b736:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b73a:	3901      	subs	r1, #1
3400b73c:	4303      	orrs	r3, r0
3400b73e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b742:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400b746:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b74a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b74e:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
3400b752:	f7ff f8bd 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
3400b756:	6823      	ldr	r3, [r4, #0]
3400b758:	0359      	lsls	r1, r3, #13
3400b75a:	d540      	bpl.n	3400b7de <HAL_RCCEx_PeriphCLKConfig+0xd46>
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));
3400b75c:	f8d4 3100 	ldr.w	r3, [r4, #256]	@ 0x100
3400b760:	4a67      	ldr	r2, [pc, #412]	@ (3400b900 <HAL_RCCEx_PeriphCLKConfig+0xe68>)
3400b762:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b766:	4291      	cmp	r1, r2
3400b768:	d00a      	beq.n	3400b780 <HAL_RCCEx_PeriphCLKConfig+0xce8>
3400b76a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b76e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b772:	4293      	cmp	r3, r2
3400b774:	d004      	beq.n	3400b780 <HAL_RCCEx_PeriphCLKConfig+0xce8>
3400b776:	f240 414b 	movw	r1, #1099	@ 0x44b
3400b77a:	485b      	ldr	r0, [pc, #364]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b77c:	f7f7 fa48 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
3400b780:	f8d4 3100 	ldr.w	r3, [r4, #256]	@ 0x100
3400b784:	4a5f      	ldr	r2, [pc, #380]	@ (3400b904 <HAL_RCCEx_PeriphCLKConfig+0xe6c>)
3400b786:	4293      	cmp	r3, r2
3400b788:	f041 8496 	bne.w	3400d0b8 <HAL_RCCEx_PeriphCLKConfig+0x2620>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b78c:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b78e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b792:	d004      	beq.n	3400b79e <HAL_RCCEx_PeriphCLKConfig+0xd06>
3400b794:	f44f 618a 	mov.w	r1, #1104	@ 0x450
3400b798:	4853      	ldr	r0, [pc, #332]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b79a:	f7f7 fa39 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b79e:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b7a0:	3b01      	subs	r3, #1
3400b7a2:	2bff      	cmp	r3, #255	@ 0xff
3400b7a4:	d904      	bls.n	3400b7b0 <HAL_RCCEx_PeriphCLKConfig+0xd18>
3400b7a6:	f240 4151 	movw	r1, #1105	@ 0x451
3400b7aa:	484f      	ldr	r0, [pc, #316]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b7ac:	f7f7 fa30 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b7b0:	4a4e      	ldr	r2, [pc, #312]	@ (3400b8ec <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b7b2:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b7b4:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b7b8:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b7ba:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b7be:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b7c2:	3901      	subs	r1, #1
3400b7c4:	4303      	orrs	r3, r0
3400b7c6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b7ca:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b7ce:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b7d2:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b7d6:	f8d4 0100 	ldr.w	r0, [r4, #256]	@ 0x100
3400b7da:	f7ff f879 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
3400b7de:	6823      	ldr	r3, [r4, #0]
3400b7e0:	031a      	lsls	r2, r3, #12
3400b7e2:	d540      	bpl.n	3400b866 <HAL_RCCEx_PeriphCLKConfig+0xdce>
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));
3400b7e4:	f8d4 3104 	ldr.w	r3, [r4, #260]	@ 0x104
3400b7e8:	4a47      	ldr	r2, [pc, #284]	@ (3400b908 <HAL_RCCEx_PeriphCLKConfig+0xe70>)
3400b7ea:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b7ee:	4291      	cmp	r1, r2
3400b7f0:	d00a      	beq.n	3400b808 <HAL_RCCEx_PeriphCLKConfig+0xd70>
3400b7f2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b7f6:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b7fa:	4293      	cmp	r3, r2
3400b7fc:	d004      	beq.n	3400b808 <HAL_RCCEx_PeriphCLKConfig+0xd70>
3400b7fe:	f240 416b 	movw	r1, #1131	@ 0x46b
3400b802:	4839      	ldr	r0, [pc, #228]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b804:	f7f7 fa04 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
3400b808:	f8d4 3104 	ldr.w	r3, [r4, #260]	@ 0x104
3400b80c:	4a3f      	ldr	r2, [pc, #252]	@ (3400b90c <HAL_RCCEx_PeriphCLKConfig+0xe74>)
3400b80e:	4293      	cmp	r3, r2
3400b810:	f041 845b 	bne.w	3400d0ca <HAL_RCCEx_PeriphCLKConfig+0x2632>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b814:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b816:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b81a:	d004      	beq.n	3400b826 <HAL_RCCEx_PeriphCLKConfig+0xd8e>
3400b81c:	f44f 618e 	mov.w	r1, #1136	@ 0x470
3400b820:	4831      	ldr	r0, [pc, #196]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b822:	f7f7 f9f5 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b826:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b828:	3b01      	subs	r3, #1
3400b82a:	2bff      	cmp	r3, #255	@ 0xff
3400b82c:	d904      	bls.n	3400b838 <HAL_RCCEx_PeriphCLKConfig+0xda0>
3400b82e:	f240 4171 	movw	r1, #1137	@ 0x471
3400b832:	482d      	ldr	r0, [pc, #180]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b834:	f7f7 f9ec 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b838:	4a2c      	ldr	r2, [pc, #176]	@ (3400b8ec <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b83a:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b83c:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b840:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b842:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b846:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b84a:	3901      	subs	r1, #1
3400b84c:	4303      	orrs	r3, r0
3400b84e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b852:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b856:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b85a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b85e:	f8d4 0104 	ldr.w	r0, [r4, #260]	@ 0x104
3400b862:	f7ff f835 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
3400b866:	6823      	ldr	r3, [r4, #0]
3400b868:	02db      	lsls	r3, r3, #11
3400b86a:	d55b      	bpl.n	3400b924 <HAL_RCCEx_PeriphCLKConfig+0xe8c>
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));
3400b86c:	f8d4 3108 	ldr.w	r3, [r4, #264]	@ 0x108
3400b870:	4a27      	ldr	r2, [pc, #156]	@ (3400b910 <HAL_RCCEx_PeriphCLKConfig+0xe78>)
3400b872:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b876:	4291      	cmp	r1, r2
3400b878:	d00a      	beq.n	3400b890 <HAL_RCCEx_PeriphCLKConfig+0xdf8>
3400b87a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b87e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b882:	4293      	cmp	r3, r2
3400b884:	d004      	beq.n	3400b890 <HAL_RCCEx_PeriphCLKConfig+0xdf8>
3400b886:	f240 418b 	movw	r1, #1163	@ 0x48b
3400b88a:	4817      	ldr	r0, [pc, #92]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b88c:	f7f7 f9c0 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
3400b890:	f8d4 3108 	ldr.w	r3, [r4, #264]	@ 0x108
3400b894:	4a1f      	ldr	r2, [pc, #124]	@ (3400b914 <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
3400b896:	4293      	cmp	r3, r2
3400b898:	f041 8420 	bne.w	3400d0dc <HAL_RCCEx_PeriphCLKConfig+0x2644>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b89c:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b89e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b8a2:	d004      	beq.n	3400b8ae <HAL_RCCEx_PeriphCLKConfig+0xe16>
3400b8a4:	f44f 6192 	mov.w	r1, #1168	@ 0x490
3400b8a8:	480f      	ldr	r0, [pc, #60]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b8aa:	f7f7 f9b1 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b8ae:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b8b0:	3b01      	subs	r3, #1
3400b8b2:	2bff      	cmp	r3, #255	@ 0xff
3400b8b4:	d904      	bls.n	3400b8c0 <HAL_RCCEx_PeriphCLKConfig+0xe28>
3400b8b6:	f240 4191 	movw	r1, #1169	@ 0x491
3400b8ba:	480b      	ldr	r0, [pc, #44]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b8bc:	f7f7 f9a8 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b8c0:	4a0a      	ldr	r2, [pc, #40]	@ (3400b8ec <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b8c2:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b8c4:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b8c8:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b8ca:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b8ce:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b8d2:	3901      	subs	r1, #1
3400b8d4:	4303      	orrs	r3, r0
3400b8d6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b8da:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b8de:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b8e2:	e019      	b.n	3400b918 <HAL_RCCEx_PeriphCLKConfig+0xe80>
3400b8e4:	07020c0c 	.word	0x07020c0c
3400b8e8:	3402044f 	.word	0x3402044f
3400b8ec:	56028000 	.word	0x56028000
3400b8f0:	0700100c 	.word	0x0700100c
3400b8f4:	0702100c 	.word	0x0702100c
3400b8f8:	0700140c 	.word	0x0700140c
3400b8fc:	0702140c 	.word	0x0702140c
3400b900:	0700082c 	.word	0x0700082c
3400b904:	0702082c 	.word	0x0702082c
3400b908:	07000c2c 	.word	0x07000c2c
3400b90c:	07020c2c 	.word	0x07020c2c
3400b910:	0700102c 	.word	0x0700102c
3400b914:	0702102c 	.word	0x0702102c
3400b918:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b91c:	f8d4 0108 	ldr.w	r0, [r4, #264]	@ 0x108
3400b920:	f7fe ffd6 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
3400b924:	6823      	ldr	r3, [r4, #0]
3400b926:	029e      	lsls	r6, r3, #10
3400b928:	d540      	bpl.n	3400b9ac <HAL_RCCEx_PeriphCLKConfig+0xf14>
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));
3400b92a:	f8d4 310c 	ldr.w	r3, [r4, #268]	@ 0x10c
3400b92e:	4ac2      	ldr	r2, [pc, #776]	@ (3400bc38 <HAL_RCCEx_PeriphCLKConfig+0x11a0>)
3400b930:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b934:	4291      	cmp	r1, r2
3400b936:	d00a      	beq.n	3400b94e <HAL_RCCEx_PeriphCLKConfig+0xeb6>
3400b938:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b93c:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b940:	4293      	cmp	r3, r2
3400b942:	d004      	beq.n	3400b94e <HAL_RCCEx_PeriphCLKConfig+0xeb6>
3400b944:	f240 41ab 	movw	r1, #1195	@ 0x4ab
3400b948:	48bc      	ldr	r0, [pc, #752]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b94a:	f7f7 f961 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
3400b94e:	f8d4 310c 	ldr.w	r3, [r4, #268]	@ 0x10c
3400b952:	4abb      	ldr	r2, [pc, #748]	@ (3400bc40 <HAL_RCCEx_PeriphCLKConfig+0x11a8>)
3400b954:	4293      	cmp	r3, r2
3400b956:	f041 83ca 	bne.w	3400d0ee <HAL_RCCEx_PeriphCLKConfig+0x2656>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b95a:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b95c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b960:	d004      	beq.n	3400b96c <HAL_RCCEx_PeriphCLKConfig+0xed4>
3400b962:	f44f 6196 	mov.w	r1, #1200	@ 0x4b0
3400b966:	48b5      	ldr	r0, [pc, #724]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b968:	f7f7 f952 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b96c:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b96e:	3b01      	subs	r3, #1
3400b970:	2bff      	cmp	r3, #255	@ 0xff
3400b972:	d904      	bls.n	3400b97e <HAL_RCCEx_PeriphCLKConfig+0xee6>
3400b974:	f240 41b1 	movw	r1, #1201	@ 0x4b1
3400b978:	48b0      	ldr	r0, [pc, #704]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b97a:	f7f7 f949 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b97e:	4ab1      	ldr	r2, [pc, #708]	@ (3400bc44 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b980:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b982:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b986:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b988:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b98c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b990:	3901      	subs	r1, #1
3400b992:	4303      	orrs	r3, r0
3400b994:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b998:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b99c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b9a0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b9a4:	f8d4 010c 	ldr.w	r0, [r4, #268]	@ 0x10c
3400b9a8:	f7fe ff92 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
3400b9ac:	6823      	ldr	r3, [r4, #0]
3400b9ae:	0258      	lsls	r0, r3, #9
3400b9b0:	d540      	bpl.n	3400ba34 <HAL_RCCEx_PeriphCLKConfig+0xf9c>
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));
3400b9b2:	f8d4 3110 	ldr.w	r3, [r4, #272]	@ 0x110
3400b9b6:	4aa4      	ldr	r2, [pc, #656]	@ (3400bc48 <HAL_RCCEx_PeriphCLKConfig+0x11b0>)
3400b9b8:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b9bc:	4291      	cmp	r1, r2
3400b9be:	d00a      	beq.n	3400b9d6 <HAL_RCCEx_PeriphCLKConfig+0xf3e>
3400b9c0:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b9c4:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b9c8:	4293      	cmp	r3, r2
3400b9ca:	d004      	beq.n	3400b9d6 <HAL_RCCEx_PeriphCLKConfig+0xf3e>
3400b9cc:	f240 41cb 	movw	r1, #1227	@ 0x4cb
3400b9d0:	489a      	ldr	r0, [pc, #616]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b9d2:	f7f7 f91d 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
3400b9d6:	f8d4 3110 	ldr.w	r3, [r4, #272]	@ 0x110
3400b9da:	4a9c      	ldr	r2, [pc, #624]	@ (3400bc4c <HAL_RCCEx_PeriphCLKConfig+0x11b4>)
3400b9dc:	4293      	cmp	r3, r2
3400b9de:	f041 838f 	bne.w	3400d100 <HAL_RCCEx_PeriphCLKConfig+0x2668>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b9e2:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b9e4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b9e8:	d004      	beq.n	3400b9f4 <HAL_RCCEx_PeriphCLKConfig+0xf5c>
3400b9ea:	f44f 619a 	mov.w	r1, #1232	@ 0x4d0
3400b9ee:	4893      	ldr	r0, [pc, #588]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b9f0:	f7f7 f90e 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b9f4:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b9f6:	3b01      	subs	r3, #1
3400b9f8:	2bff      	cmp	r3, #255	@ 0xff
3400b9fa:	d904      	bls.n	3400ba06 <HAL_RCCEx_PeriphCLKConfig+0xf6e>
3400b9fc:	f240 41d1 	movw	r1, #1233	@ 0x4d1
3400ba00:	488e      	ldr	r0, [pc, #568]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400ba02:	f7f7 f905 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400ba06:	4a8f      	ldr	r2, [pc, #572]	@ (3400bc44 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400ba08:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400ba0a:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400ba0e:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400ba10:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ba14:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ba18:	3901      	subs	r1, #1
3400ba1a:	4303      	orrs	r3, r0
3400ba1c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ba20:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400ba24:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400ba28:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ba2c:	f8d4 0110 	ldr.w	r0, [r4, #272]	@ 0x110
3400ba30:	f7fe ff4e 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
3400ba34:	6823      	ldr	r3, [r4, #0]
3400ba36:	0219      	lsls	r1, r3, #8
3400ba38:	d546      	bpl.n	3400bac8 <HAL_RCCEx_PeriphCLKConfig+0x1030>
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));
3400ba3a:	f8d4 3114 	ldr.w	r3, [r4, #276]	@ 0x114
3400ba3e:	f433 7240 	bics.w	r2, r3, #768	@ 0x300
3400ba42:	d00c      	beq.n	3400ba5e <HAL_RCCEx_PeriphCLKConfig+0xfc6>
3400ba44:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
3400ba48:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
3400ba4c:	d007      	beq.n	3400ba5e <HAL_RCCEx_PeriphCLKConfig+0xfc6>
3400ba4e:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3400ba52:	d004      	beq.n	3400ba5e <HAL_RCCEx_PeriphCLKConfig+0xfc6>
3400ba54:	f240 41eb 	movw	r1, #1259	@ 0x4eb
3400ba58:	4878      	ldr	r0, [pc, #480]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400ba5a:	f7f7 f8d9 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
3400ba5e:	f8d4 3114 	ldr.w	r3, [r4, #276]	@ 0x114
3400ba62:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400ba66:	f041 8354 	bne.w	3400d112 <HAL_RCCEx_PeriphCLKConfig+0x267a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400ba6a:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400ba6c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ba70:	d004      	beq.n	3400ba7c <HAL_RCCEx_PeriphCLKConfig+0xfe4>
3400ba72:	f44f 619e 	mov.w	r1, #1264	@ 0x4f0
3400ba76:	4871      	ldr	r0, [pc, #452]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400ba78:	f7f7 f8ca 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400ba7c:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400ba7e:	3b01      	subs	r3, #1
3400ba80:	2bff      	cmp	r3, #255	@ 0xff
3400ba82:	d904      	bls.n	3400ba8e <HAL_RCCEx_PeriphCLKConfig+0xff6>
3400ba84:	f240 41f1 	movw	r1, #1265	@ 0x4f1
3400ba88:	486c      	ldr	r0, [pc, #432]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400ba8a:	f7f7 f8c1 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400ba8e:	4a6d      	ldr	r2, [pc, #436]	@ (3400bc44 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400ba90:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400ba92:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400ba96:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400ba98:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ba9c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400baa0:	3901      	subs	r1, #1
3400baa2:	4303      	orrs	r3, r0
3400baa4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400baa8:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400baac:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bab0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
3400bab4:	4a63      	ldr	r2, [pc, #396]	@ (3400bc44 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400bab6:	f8d4 1114 	ldr.w	r1, [r4, #276]	@ 0x114
3400baba:	f8d2 3178 	ldr.w	r3, [r2, #376]	@ 0x178
3400babe:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
3400bac2:	430b      	orrs	r3, r1
3400bac4:	f8c2 3178 	str.w	r3, [r2, #376]	@ 0x178
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
3400bac8:	6823      	ldr	r3, [r4, #0]
3400baca:	01da      	lsls	r2, r3, #7
3400bacc:	d542      	bpl.n	3400bb54 <HAL_RCCEx_PeriphCLKConfig+0x10bc>
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));
3400bace:	f8d4 3118 	ldr.w	r3, [r4, #280]	@ 0x118
3400bad2:	f033 7340 	bics.w	r3, r3, #50331648	@ 0x3000000
3400bad6:	d004      	beq.n	3400bae2 <HAL_RCCEx_PeriphCLKConfig+0x104a>
3400bad8:	f44f 61a3 	mov.w	r1, #1304	@ 0x518
3400badc:	4857      	ldr	r0, [pc, #348]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400bade:	f7f7 f897 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
3400bae2:	f8d4 3118 	ldr.w	r3, [r4, #280]	@ 0x118
3400bae6:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400baea:	f041 8343 	bne.w	3400d174 <HAL_RCCEx_PeriphCLKConfig+0x26dc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
3400baee:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
3400baf2:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400baf6:	d004      	beq.n	3400bb02 <HAL_RCCEx_PeriphCLKConfig+0x106a>
3400baf8:	f240 511d 	movw	r1, #1309	@ 0x51d
3400bafc:	484f      	ldr	r0, [pc, #316]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400bafe:	f7f7 f887 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));
3400bb02:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
3400bb06:	3b01      	subs	r3, #1
3400bb08:	2bff      	cmp	r3, #255	@ 0xff
3400bb0a:	d904      	bls.n	3400bb16 <HAL_RCCEx_PeriphCLKConfig+0x107e>
3400bb0c:	f240 511e 	movw	r1, #1310	@ 0x51e
3400bb10:	484a      	ldr	r0, [pc, #296]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400bb12:	f7f7 f87d 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
3400bb16:	4a4b      	ldr	r2, [pc, #300]	@ (3400bc44 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400bb18:	f8d4 1084 	ldr.w	r1, [r4, #132]	@ 0x84
3400bb1c:	f8d2 3100 	ldr.w	r3, [r2, #256]	@ 0x100
3400bb20:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
3400bb24:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bb28:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bb2c:	3901      	subs	r1, #1
3400bb2e:	4303      	orrs	r3, r0
3400bb30:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bb34:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
3400bb38:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3400bb3c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
3400bb40:	4a40      	ldr	r2, [pc, #256]	@ (3400bc44 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400bb42:	f8d4 1118 	ldr.w	r1, [r4, #280]	@ 0x118
3400bb46:	f8d2 3150 	ldr.w	r3, [r2, #336]	@ 0x150
3400bb4a:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
3400bb4e:	430b      	orrs	r3, r1
3400bb50:	f8c2 3150 	str.w	r3, [r2, #336]	@ 0x150
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
3400bb54:	6823      	ldr	r3, [r4, #0]
3400bb56:	019b      	lsls	r3, r3, #6
3400bb58:	d540      	bpl.n	3400bbdc <HAL_RCCEx_PeriphCLKConfig+0x1144>
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));
3400bb5a:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
3400bb5e:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
3400bb62:	d007      	beq.n	3400bb74 <HAL_RCCEx_PeriphCLKConfig+0x10dc>
3400bb64:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400bb68:	d004      	beq.n	3400bb74 <HAL_RCCEx_PeriphCLKConfig+0x10dc>
3400bb6a:	f44f 61a7 	mov.w	r1, #1336	@ 0x538
3400bb6e:	4833      	ldr	r0, [pc, #204]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400bb70:	f7f7 f84e 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
3400bb74:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
3400bb78:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400bb7c:	f041 8303 	bne.w	3400d186 <HAL_RCCEx_PeriphCLKConfig+0x26ee>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400bb80:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400bb82:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bb86:	d004      	beq.n	3400bb92 <HAL_RCCEx_PeriphCLKConfig+0x10fa>
3400bb88:	f240 513d 	movw	r1, #1341	@ 0x53d
3400bb8c:	482b      	ldr	r0, [pc, #172]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400bb8e:	f7f7 f83f 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400bb92:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400bb94:	3b01      	subs	r3, #1
3400bb96:	2bff      	cmp	r3, #255	@ 0xff
3400bb98:	d904      	bls.n	3400bba4 <HAL_RCCEx_PeriphCLKConfig+0x110c>
3400bb9a:	f240 513e 	movw	r1, #1342	@ 0x53e
3400bb9e:	4827      	ldr	r0, [pc, #156]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400bba0:	f7f7 f836 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400bba4:	4a27      	ldr	r2, [pc, #156]	@ (3400bc44 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400bba6:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400bba8:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400bbac:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400bbae:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bbb2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bbb6:	3901      	subs	r1, #1
3400bbb8:	4303      	orrs	r3, r0
3400bbba:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bbbe:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400bbc2:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400bbc4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
3400bbc8:	4a1e      	ldr	r2, [pc, #120]	@ (3400bc44 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400bbca:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
3400bbce:	f8d2 3154 	ldr.w	r3, [r2, #340]	@ 0x154
3400bbd2:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400bbd6:	430b      	orrs	r3, r1
3400bbd8:	f8c2 3154 	str.w	r3, [r2, #340]	@ 0x154
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
3400bbdc:	6823      	ldr	r3, [r4, #0]
3400bbde:	015e      	lsls	r6, r3, #5
3400bbe0:	d54e      	bpl.n	3400bc80 <HAL_RCCEx_PeriphCLKConfig+0x11e8>
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));
3400bbe2:	f8d4 3120 	ldr.w	r3, [r4, #288]	@ 0x120
3400bbe6:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400bbea:	d004      	beq.n	3400bbf6 <HAL_RCCEx_PeriphCLKConfig+0x115e>
3400bbec:	f240 5165 	movw	r1, #1381	@ 0x565
3400bbf0:	4812      	ldr	r0, [pc, #72]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400bbf2:	f7f7 f80d 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
3400bbf6:	f8d4 3120 	ldr.w	r3, [r4, #288]	@ 0x120
3400bbfa:	2b20      	cmp	r3, #32
3400bbfc:	f041 82f3 	bne.w	3400d1e6 <HAL_RCCEx_PeriphCLKConfig+0x274e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
3400bc00:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
3400bc04:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bc08:	d004      	beq.n	3400bc14 <HAL_RCCEx_PeriphCLKConfig+0x117c>
3400bc0a:	f240 516a 	movw	r1, #1386	@ 0x56a
3400bc0e:	480b      	ldr	r0, [pc, #44]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400bc10:	f7f6 fffe 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));
3400bc14:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
3400bc18:	3b01      	subs	r3, #1
3400bc1a:	2bff      	cmp	r3, #255	@ 0xff
3400bc1c:	d904      	bls.n	3400bc28 <HAL_RCCEx_PeriphCLKConfig+0x1190>
3400bc1e:	f240 516b 	movw	r1, #1387	@ 0x56b
3400bc22:	4806      	ldr	r0, [pc, #24]	@ (3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400bc24:	f7f6 fff4 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3400bc28:	4a06      	ldr	r2, [pc, #24]	@ (3400bc44 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400bc2a:	f8d4 10a4 	ldr.w	r1, [r4, #164]	@ 0xa4
3400bc2e:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
3400bc32:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
3400bc36:	e00b      	b.n	3400bc50 <HAL_RCCEx_PeriphCLKConfig+0x11b8>
3400bc38:	0700142c 	.word	0x0700142c
3400bc3c:	3402044f 	.word	0x3402044f
3400bc40:	0702142c 	.word	0x0702142c
3400bc44:	56028000 	.word	0x56028000
3400bc48:	0700182c 	.word	0x0700182c
3400bc4c:	0702182c 	.word	0x0702182c
3400bc50:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bc54:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bc58:	3901      	subs	r1, #1
3400bc5a:	4303      	orrs	r3, r0
3400bc5c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bc60:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3400bc64:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
3400bc68:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
3400bc6c:	4abc      	ldr	r2, [pc, #752]	@ (3400bf60 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400bc6e:	f8d4 1120 	ldr.w	r1, [r4, #288]	@ 0x120
3400bc72:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400bc76:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
3400bc7a:	430b      	orrs	r3, r1
3400bc7c:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
3400bc80:	6823      	ldr	r3, [r4, #0]
3400bc82:	00d8      	lsls	r0, r3, #3
3400bc84:	d53d      	bpl.n	3400bd02 <HAL_RCCEx_PeriphCLKConfig+0x126a>
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
3400bc86:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
3400bc8a:	4ab6      	ldr	r2, [pc, #728]	@ (3400bf64 <HAL_RCCEx_PeriphCLKConfig+0x14cc>)
3400bc8c:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400bc90:	4293      	cmp	r3, r2
3400bc92:	d008      	beq.n	3400bca6 <HAL_RCCEx_PeriphCLKConfig+0x120e>
3400bc94:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bc98:	4293      	cmp	r3, r2
3400bc9a:	d004      	beq.n	3400bca6 <HAL_RCCEx_PeriphCLKConfig+0x120e>
3400bc9c:	f240 5185 	movw	r1, #1413	@ 0x585
3400bca0:	48b1      	ldr	r0, [pc, #708]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bca2:	f7f6 ffb5 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
3400bca6:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
3400bcaa:	4ab0      	ldr	r2, [pc, #704]	@ (3400bf6c <HAL_RCCEx_PeriphCLKConfig+0x14d4>)
3400bcac:	4293      	cmp	r3, r2
3400bcae:	f041 82c1 	bne.w	3400d234 <HAL_RCCEx_PeriphCLKConfig+0x279c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400bcb2:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400bcb4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bcb8:	d004      	beq.n	3400bcc4 <HAL_RCCEx_PeriphCLKConfig+0x122c>
3400bcba:	f240 518a 	movw	r1, #1418	@ 0x58a
3400bcbe:	48aa      	ldr	r0, [pc, #680]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bcc0:	f7f6 ffa6 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400bcc4:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400bcc6:	3b01      	subs	r3, #1
3400bcc8:	2bff      	cmp	r3, #255	@ 0xff
3400bcca:	d904      	bls.n	3400bcd6 <HAL_RCCEx_PeriphCLKConfig+0x123e>
3400bccc:	f240 518b 	movw	r1, #1419	@ 0x58b
3400bcd0:	48a5      	ldr	r0, [pc, #660]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bcd2:	f7f6 ff9d 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400bcd6:	4aa2      	ldr	r2, [pc, #648]	@ (3400bf60 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400bcd8:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400bcda:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400bcde:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400bce0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bce4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bce8:	3901      	subs	r1, #1
3400bcea:	4303      	orrs	r3, r0
3400bcec:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bcf0:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400bcf4:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400bcf6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bcfa:	f8d4 0124 	ldr.w	r0, [r4, #292]	@ 0x124
3400bcfe:	f7fe fde7 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
3400bd02:	6823      	ldr	r3, [r4, #0]
3400bd04:	0099      	lsls	r1, r3, #2
3400bd06:	d53d      	bpl.n	3400bd84 <HAL_RCCEx_PeriphCLKConfig+0x12ec>
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
3400bd08:	f8d4 3128 	ldr.w	r3, [r4, #296]	@ 0x128
3400bd0c:	4a98      	ldr	r2, [pc, #608]	@ (3400bf70 <HAL_RCCEx_PeriphCLKConfig+0x14d8>)
3400bd0e:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400bd12:	4293      	cmp	r3, r2
3400bd14:	d008      	beq.n	3400bd28 <HAL_RCCEx_PeriphCLKConfig+0x1290>
3400bd16:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bd1a:	4293      	cmp	r3, r2
3400bd1c:	d004      	beq.n	3400bd28 <HAL_RCCEx_PeriphCLKConfig+0x1290>
3400bd1e:	f240 51b2 	movw	r1, #1458	@ 0x5b2
3400bd22:	4891      	ldr	r0, [pc, #580]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bd24:	f7f6 ff74 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
3400bd28:	f8d4 3128 	ldr.w	r3, [r4, #296]	@ 0x128
3400bd2c:	4a91      	ldr	r2, [pc, #580]	@ (3400bf74 <HAL_RCCEx_PeriphCLKConfig+0x14dc>)
3400bd2e:	4293      	cmp	r3, r2
3400bd30:	f041 82b0 	bne.w	3400d294 <HAL_RCCEx_PeriphCLKConfig+0x27fc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400bd34:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400bd36:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bd3a:	d004      	beq.n	3400bd46 <HAL_RCCEx_PeriphCLKConfig+0x12ae>
3400bd3c:	f240 51b7 	movw	r1, #1463	@ 0x5b7
3400bd40:	4889      	ldr	r0, [pc, #548]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bd42:	f7f6 ff65 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400bd46:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400bd48:	3b01      	subs	r3, #1
3400bd4a:	2bff      	cmp	r3, #255	@ 0xff
3400bd4c:	d904      	bls.n	3400bd58 <HAL_RCCEx_PeriphCLKConfig+0x12c0>
3400bd4e:	f44f 61b7 	mov.w	r1, #1464	@ 0x5b8
3400bd52:	4885      	ldr	r0, [pc, #532]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bd54:	f7f6 ff5c 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400bd58:	4a81      	ldr	r2, [pc, #516]	@ (3400bf60 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400bd5a:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400bd5c:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400bd60:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400bd62:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bd66:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bd6a:	3901      	subs	r1, #1
3400bd6c:	4303      	orrs	r3, r0
3400bd6e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bd72:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400bd76:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400bd78:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bd7c:	f8d4 0128 	ldr.w	r0, [r4, #296]	@ 0x128
3400bd80:	f7fe fda6 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
3400bd84:	6863      	ldr	r3, [r4, #4]
3400bd86:	07da      	lsls	r2, r3, #31
3400bd88:	d53b      	bpl.n	3400be02 <HAL_RCCEx_PeriphCLKConfig+0x136a>
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));
3400bd8a:	f8d4 314c 	ldr.w	r3, [r4, #332]	@ 0x14c
3400bd8e:	2b06      	cmp	r3, #6
3400bd90:	d904      	bls.n	3400bd9c <HAL_RCCEx_PeriphCLKConfig+0x1304>
3400bd92:	f240 51df 	movw	r1, #1503	@ 0x5df
3400bd96:	4874      	ldr	r0, [pc, #464]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bd98:	f7f6 ff3a 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
3400bd9c:	f8d4 314c 	ldr.w	r3, [r4, #332]	@ 0x14c
3400bda0:	2b02      	cmp	r3, #2
3400bda2:	f041 82a7 	bne.w	3400d2f4 <HAL_RCCEx_PeriphCLKConfig+0x285c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400bda6:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400bda8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bdac:	d004      	beq.n	3400bdb8 <HAL_RCCEx_PeriphCLKConfig+0x1320>
3400bdae:	f240 51e4 	movw	r1, #1508	@ 0x5e4
3400bdb2:	486d      	ldr	r0, [pc, #436]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bdb4:	f7f6 ff2c 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400bdb8:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400bdba:	3b01      	subs	r3, #1
3400bdbc:	2bff      	cmp	r3, #255	@ 0xff
3400bdbe:	d904      	bls.n	3400bdca <HAL_RCCEx_PeriphCLKConfig+0x1332>
3400bdc0:	f240 51e5 	movw	r1, #1509	@ 0x5e5
3400bdc4:	4868      	ldr	r0, [pc, #416]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bdc6:	f7f6 ff23 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400bdca:	4a65      	ldr	r2, [pc, #404]	@ (3400bf60 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400bdcc:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400bdce:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400bdd2:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400bdd4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bdd8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bddc:	3901      	subs	r1, #1
3400bdde:	4303      	orrs	r3, r0
3400bde0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bde4:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400bde8:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400bdea:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
3400bdee:	4a5c      	ldr	r2, [pc, #368]	@ (3400bf60 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400bdf0:	f8d4 114c 	ldr.w	r1, [r4, #332]	@ 0x14c
3400bdf4:	f8d2 3164 	ldr.w	r3, [r2, #356]	@ 0x164
3400bdf8:	f023 0307 	bic.w	r3, r3, #7
3400bdfc:	430b      	orrs	r3, r1
3400bdfe:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
3400be02:	6863      	ldr	r3, [r4, #4]
3400be04:	079b      	lsls	r3, r3, #30
3400be06:	d543      	bpl.n	3400be90 <HAL_RCCEx_PeriphCLKConfig+0x13f8>
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));
3400be08:	f8d4 3134 	ldr.w	r3, [r4, #308]	@ 0x134
3400be0c:	4a5a      	ldr	r2, [pc, #360]	@ (3400bf78 <HAL_RCCEx_PeriphCLKConfig+0x14e0>)
3400be0e:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400be12:	4291      	cmp	r1, r2
3400be14:	d00e      	beq.n	3400be34 <HAL_RCCEx_PeriphCLKConfig+0x139c>
3400be16:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400be1a:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400be1e:	4291      	cmp	r1, r2
3400be20:	d008      	beq.n	3400be34 <HAL_RCCEx_PeriphCLKConfig+0x139c>
3400be22:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400be26:	4293      	cmp	r3, r2
3400be28:	d004      	beq.n	3400be34 <HAL_RCCEx_PeriphCLKConfig+0x139c>
3400be2a:	f240 610c 	movw	r1, #1548	@ 0x60c
3400be2e:	484e      	ldr	r0, [pc, #312]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400be30:	f7f6 feee 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
3400be34:	f8d4 3134 	ldr.w	r3, [r4, #308]	@ 0x134
3400be38:	4a50      	ldr	r2, [pc, #320]	@ (3400bf7c <HAL_RCCEx_PeriphCLKConfig+0x14e4>)
3400be3a:	4293      	cmp	r3, r2
3400be3c:	f041 8288 	bne.w	3400d350 <HAL_RCCEx_PeriphCLKConfig+0x28b8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400be40:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400be42:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400be46:	d004      	beq.n	3400be52 <HAL_RCCEx_PeriphCLKConfig+0x13ba>
3400be48:	f240 6111 	movw	r1, #1553	@ 0x611
3400be4c:	4846      	ldr	r0, [pc, #280]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400be4e:	f7f6 fedf 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400be52:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400be54:	3b01      	subs	r3, #1
3400be56:	2bff      	cmp	r3, #255	@ 0xff
3400be58:	d904      	bls.n	3400be64 <HAL_RCCEx_PeriphCLKConfig+0x13cc>
3400be5a:	f240 6112 	movw	r1, #1554	@ 0x612
3400be5e:	4842      	ldr	r0, [pc, #264]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400be60:	f7f6 fed6 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400be64:	4a3e      	ldr	r2, [pc, #248]	@ (3400bf60 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400be66:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400be68:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400be6c:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400be6e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400be72:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400be76:	3901      	subs	r1, #1
3400be78:	4303      	orrs	r3, r0
3400be7a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400be7e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400be82:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400be84:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400be88:	f8d4 0134 	ldr.w	r0, [r4, #308]	@ 0x134
3400be8c:	f7fe fd20 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
3400be90:	6863      	ldr	r3, [r4, #4]
3400be92:	075e      	lsls	r6, r3, #29
3400be94:	d543      	bpl.n	3400bf1e <HAL_RCCEx_PeriphCLKConfig+0x1486>
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));
3400be96:	f8d4 3138 	ldr.w	r3, [r4, #312]	@ 0x138
3400be9a:	4a39      	ldr	r2, [pc, #228]	@ (3400bf80 <HAL_RCCEx_PeriphCLKConfig+0x14e8>)
3400be9c:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bea0:	4291      	cmp	r1, r2
3400bea2:	d00e      	beq.n	3400bec2 <HAL_RCCEx_PeriphCLKConfig+0x142a>
3400bea4:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bea8:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400beac:	4291      	cmp	r1, r2
3400beae:	d008      	beq.n	3400bec2 <HAL_RCCEx_PeriphCLKConfig+0x142a>
3400beb0:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400beb4:	4293      	cmp	r3, r2
3400beb6:	d004      	beq.n	3400bec2 <HAL_RCCEx_PeriphCLKConfig+0x142a>
3400beb8:	f240 6139 	movw	r1, #1593	@ 0x639
3400bebc:	482a      	ldr	r0, [pc, #168]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bebe:	f7f6 fea7 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
3400bec2:	f8d4 3138 	ldr.w	r3, [r4, #312]	@ 0x138
3400bec6:	4a2f      	ldr	r2, [pc, #188]	@ (3400bf84 <HAL_RCCEx_PeriphCLKConfig+0x14ec>)
3400bec8:	4293      	cmp	r3, r2
3400beca:	f041 8272 	bne.w	3400d3b2 <HAL_RCCEx_PeriphCLKConfig+0x291a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400bece:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400bed0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bed4:	d004      	beq.n	3400bee0 <HAL_RCCEx_PeriphCLKConfig+0x1448>
3400bed6:	f240 613e 	movw	r1, #1598	@ 0x63e
3400beda:	4823      	ldr	r0, [pc, #140]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bedc:	f7f6 fe98 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400bee0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400bee2:	3b01      	subs	r3, #1
3400bee4:	2bff      	cmp	r3, #255	@ 0xff
3400bee6:	d904      	bls.n	3400bef2 <HAL_RCCEx_PeriphCLKConfig+0x145a>
3400bee8:	f240 613f 	movw	r1, #1599	@ 0x63f
3400beec:	481e      	ldr	r0, [pc, #120]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400beee:	f7f6 fe8f 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400bef2:	4a1b      	ldr	r2, [pc, #108]	@ (3400bf60 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400bef4:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400bef6:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400befa:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400befc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bf00:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bf04:	3901      	subs	r1, #1
3400bf06:	4303      	orrs	r3, r0
3400bf08:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bf0c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400bf10:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bf12:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bf16:	f8d4 0138 	ldr.w	r0, [r4, #312]	@ 0x138
3400bf1a:	f7fe fcd9 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
3400bf1e:	6863      	ldr	r3, [r4, #4]
3400bf20:	0718      	lsls	r0, r3, #28
3400bf22:	d55d      	bpl.n	3400bfe0 <HAL_RCCEx_PeriphCLKConfig+0x1548>
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));
3400bf24:	f8d4 313c 	ldr.w	r3, [r4, #316]	@ 0x13c
3400bf28:	4a17      	ldr	r2, [pc, #92]	@ (3400bf88 <HAL_RCCEx_PeriphCLKConfig+0x14f0>)
3400bf2a:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bf2e:	4291      	cmp	r1, r2
3400bf30:	d00e      	beq.n	3400bf50 <HAL_RCCEx_PeriphCLKConfig+0x14b8>
3400bf32:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bf36:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bf3a:	4291      	cmp	r1, r2
3400bf3c:	d008      	beq.n	3400bf50 <HAL_RCCEx_PeriphCLKConfig+0x14b8>
3400bf3e:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bf42:	4293      	cmp	r3, r2
3400bf44:	d004      	beq.n	3400bf50 <HAL_RCCEx_PeriphCLKConfig+0x14b8>
3400bf46:	f240 6166 	movw	r1, #1638	@ 0x666
3400bf4a:	4807      	ldr	r0, [pc, #28]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400bf4c:	f7f6 fe60 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
3400bf50:	f8d4 313c 	ldr.w	r3, [r4, #316]	@ 0x13c
3400bf54:	4a0d      	ldr	r2, [pc, #52]	@ (3400bf8c <HAL_RCCEx_PeriphCLKConfig+0x14f4>)
3400bf56:	4293      	cmp	r3, r2
3400bf58:	f041 825c 	bne.w	3400d414 <HAL_RCCEx_PeriphCLKConfig+0x297c>
3400bf5c:	e018      	b.n	3400bf90 <HAL_RCCEx_PeriphCLKConfig+0x14f8>
3400bf5e:	bf00      	nop
3400bf60:	56028000 	.word	0x56028000
3400bf64:	07001418 	.word	0x07001418
3400bf68:	3402044f 	.word	0x3402044f
3400bf6c:	07021418 	.word	0x07021418
3400bf70:	07001818 	.word	0x07001818
3400bf74:	07021818 	.word	0x07021818
3400bf78:	07000420 	.word	0x07000420
3400bf7c:	07020420 	.word	0x07020420
3400bf80:	07000820 	.word	0x07000820
3400bf84:	07020820 	.word	0x07020820
3400bf88:	07000c20 	.word	0x07000c20
3400bf8c:	07020c20 	.word	0x07020c20
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400bf90:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400bf92:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bf96:	d004      	beq.n	3400bfa2 <HAL_RCCEx_PeriphCLKConfig+0x150a>
3400bf98:	f240 616b 	movw	r1, #1643	@ 0x66b
3400bf9c:	48bb      	ldr	r0, [pc, #748]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bf9e:	f7f6 fe37 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400bfa2:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400bfa4:	3b01      	subs	r3, #1
3400bfa6:	2bff      	cmp	r3, #255	@ 0xff
3400bfa8:	d904      	bls.n	3400bfb4 <HAL_RCCEx_PeriphCLKConfig+0x151c>
3400bfaa:	f240 616c 	movw	r1, #1644	@ 0x66c
3400bfae:	48b7      	ldr	r0, [pc, #732]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bfb0:	f7f6 fe2e 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400bfb4:	4ab6      	ldr	r2, [pc, #728]	@ (3400c290 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400bfb6:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400bfb8:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400bfbc:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400bfbe:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bfc2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bfc6:	3901      	subs	r1, #1
3400bfc8:	4303      	orrs	r3, r0
3400bfca:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bfce:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400bfd2:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bfd4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bfd8:	f8d4 013c 	ldr.w	r0, [r4, #316]	@ 0x13c
3400bfdc:	f7fe fc78 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
3400bfe0:	6863      	ldr	r3, [r4, #4]
3400bfe2:	06d9      	lsls	r1, r3, #27
3400bfe4:	d544      	bpl.n	3400c070 <HAL_RCCEx_PeriphCLKConfig+0x15d8>
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));
3400bfe6:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
3400bfea:	4aaa      	ldr	r2, [pc, #680]	@ (3400c294 <HAL_RCCEx_PeriphCLKConfig+0x17fc>)
3400bfec:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bff0:	4291      	cmp	r1, r2
3400bff2:	d00e      	beq.n	3400c012 <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400bff4:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bff8:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bffc:	4291      	cmp	r1, r2
3400bffe:	d008      	beq.n	3400c012 <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400c000:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c004:	4293      	cmp	r3, r2
3400c006:	d004      	beq.n	3400c012 <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400c008:	f240 6193 	movw	r1, #1683	@ 0x693
3400c00c:	489f      	ldr	r0, [pc, #636]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c00e:	f7f6 fdff 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
3400c012:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
3400c016:	4aa0      	ldr	r2, [pc, #640]	@ (3400c298 <HAL_RCCEx_PeriphCLKConfig+0x1800>)
3400c018:	4293      	cmp	r3, r2
3400c01a:	f041 822c 	bne.w	3400d476 <HAL_RCCEx_PeriphCLKConfig+0x29de>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c01e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c020:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c024:	d004      	beq.n	3400c030 <HAL_RCCEx_PeriphCLKConfig+0x1598>
3400c026:	f44f 61d3 	mov.w	r1, #1688	@ 0x698
3400c02a:	4898      	ldr	r0, [pc, #608]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c02c:	f7f6 fdf0 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c030:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c032:	3b01      	subs	r3, #1
3400c034:	2bff      	cmp	r3, #255	@ 0xff
3400c036:	d904      	bls.n	3400c042 <HAL_RCCEx_PeriphCLKConfig+0x15aa>
3400c038:	f240 6199 	movw	r1, #1689	@ 0x699
3400c03c:	4893      	ldr	r0, [pc, #588]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c03e:	f7f6 fde7 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c042:	4a93      	ldr	r2, [pc, #588]	@ (3400c290 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400c044:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c046:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c04a:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c04c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c050:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c054:	3901      	subs	r1, #1
3400c056:	4303      	orrs	r3, r0
3400c058:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c05c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c060:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c064:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c068:	f8d4 0140 	ldr.w	r0, [r4, #320]	@ 0x140
3400c06c:	f7fe fc30 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
3400c070:	6863      	ldr	r3, [r4, #4]
3400c072:	069a      	lsls	r2, r3, #26
3400c074:	d544      	bpl.n	3400c100 <HAL_RCCEx_PeriphCLKConfig+0x1668>
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));
3400c076:	f8d4 3144 	ldr.w	r3, [r4, #324]	@ 0x144
3400c07a:	4a88      	ldr	r2, [pc, #544]	@ (3400c29c <HAL_RCCEx_PeriphCLKConfig+0x1804>)
3400c07c:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c080:	4291      	cmp	r1, r2
3400c082:	d00e      	beq.n	3400c0a2 <HAL_RCCEx_PeriphCLKConfig+0x160a>
3400c084:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c088:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c08c:	4291      	cmp	r1, r2
3400c08e:	d008      	beq.n	3400c0a2 <HAL_RCCEx_PeriphCLKConfig+0x160a>
3400c090:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c094:	4293      	cmp	r3, r2
3400c096:	d004      	beq.n	3400c0a2 <HAL_RCCEx_PeriphCLKConfig+0x160a>
3400c098:	f44f 61d8 	mov.w	r1, #1728	@ 0x6c0
3400c09c:	487b      	ldr	r0, [pc, #492]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c09e:	f7f6 fdb7 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
3400c0a2:	f8d4 3144 	ldr.w	r3, [r4, #324]	@ 0x144
3400c0a6:	4a7e      	ldr	r2, [pc, #504]	@ (3400c2a0 <HAL_RCCEx_PeriphCLKConfig+0x1808>)
3400c0a8:	4293      	cmp	r3, r2
3400c0aa:	f041 8231 	bne.w	3400d510 <HAL_RCCEx_PeriphCLKConfig+0x2a78>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c0ae:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c0b0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c0b4:	d004      	beq.n	3400c0c0 <HAL_RCCEx_PeriphCLKConfig+0x1628>
3400c0b6:	f240 61c5 	movw	r1, #1733	@ 0x6c5
3400c0ba:	4874      	ldr	r0, [pc, #464]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c0bc:	f7f6 fda8 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c0c0:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c0c2:	3b01      	subs	r3, #1
3400c0c4:	2bff      	cmp	r3, #255	@ 0xff
3400c0c6:	d904      	bls.n	3400c0d2 <HAL_RCCEx_PeriphCLKConfig+0x163a>
3400c0c8:	f240 61c6 	movw	r1, #1734	@ 0x6c6
3400c0cc:	486f      	ldr	r0, [pc, #444]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c0ce:	f7f6 fd9f 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c0d2:	4a6f      	ldr	r2, [pc, #444]	@ (3400c290 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400c0d4:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c0d6:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c0da:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c0dc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c0e0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c0e4:	3901      	subs	r1, #1
3400c0e6:	4303      	orrs	r3, r0
3400c0e8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c0ec:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c0f0:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c0f4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c0f8:	f8d4 0144 	ldr.w	r0, [r4, #324]	@ 0x144
3400c0fc:	f7fe fbe8 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
3400c100:	6863      	ldr	r3, [r4, #4]
3400c102:	065b      	lsls	r3, r3, #25
3400c104:	d543      	bpl.n	3400c18e <HAL_RCCEx_PeriphCLKConfig+0x16f6>
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));
3400c106:	f8d4 3148 	ldr.w	r3, [r4, #328]	@ 0x148
3400c10a:	4a66      	ldr	r2, [pc, #408]	@ (3400c2a4 <HAL_RCCEx_PeriphCLKConfig+0x180c>)
3400c10c:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c110:	4291      	cmp	r1, r2
3400c112:	d00e      	beq.n	3400c132 <HAL_RCCEx_PeriphCLKConfig+0x169a>
3400c114:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c118:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c11c:	4291      	cmp	r1, r2
3400c11e:	d008      	beq.n	3400c132 <HAL_RCCEx_PeriphCLKConfig+0x169a>
3400c120:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c124:	4293      	cmp	r3, r2
3400c126:	d004      	beq.n	3400c132 <HAL_RCCEx_PeriphCLKConfig+0x169a>
3400c128:	f240 61ed 	movw	r1, #1773	@ 0x6ed
3400c12c:	4857      	ldr	r0, [pc, #348]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c12e:	f7f6 fd6f 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
3400c132:	f8d4 3148 	ldr.w	r3, [r4, #328]	@ 0x148
3400c136:	4a5c      	ldr	r2, [pc, #368]	@ (3400c2a8 <HAL_RCCEx_PeriphCLKConfig+0x1810>)
3400c138:	4293      	cmp	r3, r2
3400c13a:	f041 821a 	bne.w	3400d572 <HAL_RCCEx_PeriphCLKConfig+0x2ada>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400c13e:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400c140:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c144:	d004      	beq.n	3400c150 <HAL_RCCEx_PeriphCLKConfig+0x16b8>
3400c146:	f240 61f2 	movw	r1, #1778	@ 0x6f2
3400c14a:	4850      	ldr	r0, [pc, #320]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c14c:	f7f6 fd60 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400c150:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400c152:	3b01      	subs	r3, #1
3400c154:	2bff      	cmp	r3, #255	@ 0xff
3400c156:	d904      	bls.n	3400c162 <HAL_RCCEx_PeriphCLKConfig+0x16ca>
3400c158:	f240 61f3 	movw	r1, #1779	@ 0x6f3
3400c15c:	484b      	ldr	r0, [pc, #300]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c15e:	f7f6 fd57 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400c162:	4a4b      	ldr	r2, [pc, #300]	@ (3400c290 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400c164:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400c166:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400c16a:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400c16c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c170:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c174:	3901      	subs	r1, #1
3400c176:	4303      	orrs	r3, r0
3400c178:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c17c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400c180:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c182:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c186:	f8d4 0148 	ldr.w	r0, [r4, #328]	@ 0x148
3400c18a:	f7fe fba1 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
3400c18e:	6863      	ldr	r3, [r4, #4]
3400c190:	05de      	lsls	r6, r3, #23
3400c192:	d544      	bpl.n	3400c21e <HAL_RCCEx_PeriphCLKConfig+0x1786>
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
3400c194:	f8d4 3150 	ldr.w	r3, [r4, #336]	@ 0x150
3400c198:	4a44      	ldr	r2, [pc, #272]	@ (3400c2ac <HAL_RCCEx_PeriphCLKConfig+0x1814>)
3400c19a:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c19e:	4291      	cmp	r1, r2
3400c1a0:	d00e      	beq.n	3400c1c0 <HAL_RCCEx_PeriphCLKConfig+0x1728>
3400c1a2:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c1a6:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c1aa:	4291      	cmp	r1, r2
3400c1ac:	d008      	beq.n	3400c1c0 <HAL_RCCEx_PeriphCLKConfig+0x1728>
3400c1ae:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c1b2:	4293      	cmp	r3, r2
3400c1b4:	d004      	beq.n	3400c1c0 <HAL_RCCEx_PeriphCLKConfig+0x1728>
3400c1b6:	f240 711a 	movw	r1, #1818	@ 0x71a
3400c1ba:	4834      	ldr	r0, [pc, #208]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c1bc:	f7f6 fd28 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
3400c1c0:	f8d4 3150 	ldr.w	r3, [r4, #336]	@ 0x150
3400c1c4:	4a3a      	ldr	r2, [pc, #232]	@ (3400c2b0 <HAL_RCCEx_PeriphCLKConfig+0x1818>)
3400c1c6:	4293      	cmp	r3, r2
3400c1c8:	f041 8204 	bne.w	3400d5d4 <HAL_RCCEx_PeriphCLKConfig+0x2b3c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c1cc:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c1ce:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c1d2:	d004      	beq.n	3400c1de <HAL_RCCEx_PeriphCLKConfig+0x1746>
3400c1d4:	f240 711f 	movw	r1, #1823	@ 0x71f
3400c1d8:	482c      	ldr	r0, [pc, #176]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c1da:	f7f6 fd19 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c1de:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c1e0:	3b01      	subs	r3, #1
3400c1e2:	2bff      	cmp	r3, #255	@ 0xff
3400c1e4:	d904      	bls.n	3400c1f0 <HAL_RCCEx_PeriphCLKConfig+0x1758>
3400c1e6:	f44f 61e4 	mov.w	r1, #1824	@ 0x720
3400c1ea:	4828      	ldr	r0, [pc, #160]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c1ec:	f7f6 fd10 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c1f0:	4a27      	ldr	r2, [pc, #156]	@ (3400c290 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400c1f2:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c1f4:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c1f8:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c1fa:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c1fe:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c202:	3901      	subs	r1, #1
3400c204:	4303      	orrs	r3, r0
3400c206:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c20a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c20e:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c212:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c216:	f8d4 0150 	ldr.w	r0, [r4, #336]	@ 0x150
3400c21a:	f7fe fb59 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
3400c21e:	6863      	ldr	r3, [r4, #4]
3400c220:	0598      	lsls	r0, r3, #22
3400c222:	d55d      	bpl.n	3400c2e0 <HAL_RCCEx_PeriphCLKConfig+0x1848>
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
3400c224:	f8d4 3154 	ldr.w	r3, [r4, #340]	@ 0x154
3400c228:	4a22      	ldr	r2, [pc, #136]	@ (3400c2b4 <HAL_RCCEx_PeriphCLKConfig+0x181c>)
3400c22a:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c22e:	4291      	cmp	r1, r2
3400c230:	d00e      	beq.n	3400c250 <HAL_RCCEx_PeriphCLKConfig+0x17b8>
3400c232:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c236:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c23a:	4291      	cmp	r1, r2
3400c23c:	d008      	beq.n	3400c250 <HAL_RCCEx_PeriphCLKConfig+0x17b8>
3400c23e:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c242:	4293      	cmp	r3, r2
3400c244:	d004      	beq.n	3400c250 <HAL_RCCEx_PeriphCLKConfig+0x17b8>
3400c246:	f240 7147 	movw	r1, #1863	@ 0x747
3400c24a:	4810      	ldr	r0, [pc, #64]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c24c:	f7f6 fce0 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
3400c250:	f8d4 3154 	ldr.w	r3, [r4, #340]	@ 0x154
3400c254:	4a18      	ldr	r2, [pc, #96]	@ (3400c2b8 <HAL_RCCEx_PeriphCLKConfig+0x1820>)
3400c256:	4293      	cmp	r3, r2
3400c258:	f041 81ed 	bne.w	3400d636 <HAL_RCCEx_PeriphCLKConfig+0x2b9e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c25c:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c25e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c262:	d004      	beq.n	3400c26e <HAL_RCCEx_PeriphCLKConfig+0x17d6>
3400c264:	f240 714c 	movw	r1, #1868	@ 0x74c
3400c268:	4808      	ldr	r0, [pc, #32]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c26a:	f7f6 fcd1 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c26e:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c270:	3b01      	subs	r3, #1
3400c272:	2bff      	cmp	r3, #255	@ 0xff
3400c274:	d904      	bls.n	3400c280 <HAL_RCCEx_PeriphCLKConfig+0x17e8>
3400c276:	f240 714d 	movw	r1, #1869	@ 0x74d
3400c27a:	4804      	ldr	r0, [pc, #16]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400c27c:	f7f6 fcc8 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c280:	4a03      	ldr	r2, [pc, #12]	@ (3400c290 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400c282:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c284:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c288:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c28a:	e017      	b.n	3400c2bc <HAL_RCCEx_PeriphCLKConfig+0x1824>
3400c28c:	3402044f 	.word	0x3402044f
3400c290:	56028000 	.word	0x56028000
3400c294:	07001020 	.word	0x07001020
3400c298:	07021020 	.word	0x07021020
3400c29c:	07001420 	.word	0x07001420
3400c2a0:	07021420 	.word	0x07021420
3400c2a4:	07001820 	.word	0x07001820
3400c2a8:	07021820 	.word	0x07021820
3400c2ac:	07000030 	.word	0x07000030
3400c2b0:	07020030 	.word	0x07020030
3400c2b4:	07000430 	.word	0x07000430
3400c2b8:	07020430 	.word	0x07020430
3400c2bc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c2c0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c2c4:	3901      	subs	r1, #1
3400c2c6:	4303      	orrs	r3, r0
3400c2c8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c2cc:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c2d0:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c2d4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c2d8:	f8d4 0154 	ldr.w	r0, [r4, #340]	@ 0x154
3400c2dc:	f7fe faf8 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
3400c2e0:	6863      	ldr	r3, [r4, #4]
3400c2e2:	0559      	lsls	r1, r3, #21
3400c2e4:	d544      	bpl.n	3400c370 <HAL_RCCEx_PeriphCLKConfig+0x18d8>
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
3400c2e6:	f8d4 3158 	ldr.w	r3, [r4, #344]	@ 0x158
3400c2ea:	4abc      	ldr	r2, [pc, #752]	@ (3400c5dc <HAL_RCCEx_PeriphCLKConfig+0x1b44>)
3400c2ec:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c2f0:	4291      	cmp	r1, r2
3400c2f2:	d00e      	beq.n	3400c312 <HAL_RCCEx_PeriphCLKConfig+0x187a>
3400c2f4:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c2f8:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c2fc:	4291      	cmp	r1, r2
3400c2fe:	d008      	beq.n	3400c312 <HAL_RCCEx_PeriphCLKConfig+0x187a>
3400c300:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c304:	4293      	cmp	r3, r2
3400c306:	d004      	beq.n	3400c312 <HAL_RCCEx_PeriphCLKConfig+0x187a>
3400c308:	f240 7174 	movw	r1, #1908	@ 0x774
3400c30c:	48b4      	ldr	r0, [pc, #720]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c30e:	f7f6 fc7f 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
3400c312:	f8d4 3158 	ldr.w	r3, [r4, #344]	@ 0x158
3400c316:	4ab3      	ldr	r2, [pc, #716]	@ (3400c5e4 <HAL_RCCEx_PeriphCLKConfig+0x1b4c>)
3400c318:	4293      	cmp	r3, r2
3400c31a:	f041 81bd 	bne.w	3400d698 <HAL_RCCEx_PeriphCLKConfig+0x2c00>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c31e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c320:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c324:	d004      	beq.n	3400c330 <HAL_RCCEx_PeriphCLKConfig+0x1898>
3400c326:	f240 7179 	movw	r1, #1913	@ 0x779
3400c32a:	48ad      	ldr	r0, [pc, #692]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c32c:	f7f6 fc70 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c330:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c332:	3b01      	subs	r3, #1
3400c334:	2bff      	cmp	r3, #255	@ 0xff
3400c336:	d904      	bls.n	3400c342 <HAL_RCCEx_PeriphCLKConfig+0x18aa>
3400c338:	f240 717a 	movw	r1, #1914	@ 0x77a
3400c33c:	48a8      	ldr	r0, [pc, #672]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c33e:	f7f6 fc67 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c342:	4aa9      	ldr	r2, [pc, #676]	@ (3400c5e8 <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400c344:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c346:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c34a:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c34c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c350:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c354:	3901      	subs	r1, #1
3400c356:	4303      	orrs	r3, r0
3400c358:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c35c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c360:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c364:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c368:	f8d4 0158 	ldr.w	r0, [r4, #344]	@ 0x158
3400c36c:	f7fe fab0 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
3400c370:	6863      	ldr	r3, [r4, #4]
3400c372:	051a      	lsls	r2, r3, #20
3400c374:	d544      	bpl.n	3400c400 <HAL_RCCEx_PeriphCLKConfig+0x1968>
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
3400c376:	f8d4 315c 	ldr.w	r3, [r4, #348]	@ 0x15c
3400c37a:	4a9c      	ldr	r2, [pc, #624]	@ (3400c5ec <HAL_RCCEx_PeriphCLKConfig+0x1b54>)
3400c37c:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c380:	4291      	cmp	r1, r2
3400c382:	d00e      	beq.n	3400c3a2 <HAL_RCCEx_PeriphCLKConfig+0x190a>
3400c384:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c388:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c38c:	4291      	cmp	r1, r2
3400c38e:	d008      	beq.n	3400c3a2 <HAL_RCCEx_PeriphCLKConfig+0x190a>
3400c390:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c394:	4293      	cmp	r3, r2
3400c396:	d004      	beq.n	3400c3a2 <HAL_RCCEx_PeriphCLKConfig+0x190a>
3400c398:	f240 71a1 	movw	r1, #1953	@ 0x7a1
3400c39c:	4890      	ldr	r0, [pc, #576]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c39e:	f7f6 fc37 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
3400c3a2:	f8d4 315c 	ldr.w	r3, [r4, #348]	@ 0x15c
3400c3a6:	4a92      	ldr	r2, [pc, #584]	@ (3400c5f0 <HAL_RCCEx_PeriphCLKConfig+0x1b58>)
3400c3a8:	4293      	cmp	r3, r2
3400c3aa:	f041 81a6 	bne.w	3400d6fa <HAL_RCCEx_PeriphCLKConfig+0x2c62>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c3ae:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c3b0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c3b4:	d004      	beq.n	3400c3c0 <HAL_RCCEx_PeriphCLKConfig+0x1928>
3400c3b6:	f240 71a6 	movw	r1, #1958	@ 0x7a6
3400c3ba:	4889      	ldr	r0, [pc, #548]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c3bc:	f7f6 fc28 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c3c0:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c3c2:	3b01      	subs	r3, #1
3400c3c4:	2bff      	cmp	r3, #255	@ 0xff
3400c3c6:	d904      	bls.n	3400c3d2 <HAL_RCCEx_PeriphCLKConfig+0x193a>
3400c3c8:	f240 71a7 	movw	r1, #1959	@ 0x7a7
3400c3cc:	4884      	ldr	r0, [pc, #528]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c3ce:	f7f6 fc1f 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c3d2:	4a85      	ldr	r2, [pc, #532]	@ (3400c5e8 <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400c3d4:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c3d6:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c3da:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c3dc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c3e0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c3e4:	3901      	subs	r1, #1
3400c3e6:	4303      	orrs	r3, r0
3400c3e8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c3ec:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c3f0:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c3f4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c3f8:	f8d4 015c 	ldr.w	r0, [r4, #348]	@ 0x15c
3400c3fc:	f7fe fa68 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
3400c400:	6863      	ldr	r3, [r4, #4]
3400c402:	04db      	lsls	r3, r3, #19
3400c404:	d544      	bpl.n	3400c490 <HAL_RCCEx_PeriphCLKConfig+0x19f8>
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
3400c406:	f8d4 3160 	ldr.w	r3, [r4, #352]	@ 0x160
3400c40a:	4a7a      	ldr	r2, [pc, #488]	@ (3400c5f4 <HAL_RCCEx_PeriphCLKConfig+0x1b5c>)
3400c40c:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c410:	4291      	cmp	r1, r2
3400c412:	d00e      	beq.n	3400c432 <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400c414:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c418:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c41c:	4291      	cmp	r1, r2
3400c41e:	d008      	beq.n	3400c432 <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400c420:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c424:	4293      	cmp	r3, r2
3400c426:	d004      	beq.n	3400c432 <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400c428:	f240 71ce 	movw	r1, #1998	@ 0x7ce
3400c42c:	486c      	ldr	r0, [pc, #432]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c42e:	f7f6 fbef 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
3400c432:	f8d4 3160 	ldr.w	r3, [r4, #352]	@ 0x160
3400c436:	4a70      	ldr	r2, [pc, #448]	@ (3400c5f8 <HAL_RCCEx_PeriphCLKConfig+0x1b60>)
3400c438:	4293      	cmp	r3, r2
3400c43a:	f041 818f 	bne.w	3400d75c <HAL_RCCEx_PeriphCLKConfig+0x2cc4>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c43e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c440:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c444:	d004      	beq.n	3400c450 <HAL_RCCEx_PeriphCLKConfig+0x19b8>
3400c446:	f240 71d3 	movw	r1, #2003	@ 0x7d3
3400c44a:	4865      	ldr	r0, [pc, #404]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c44c:	f7f6 fbe0 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c450:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c452:	3b01      	subs	r3, #1
3400c454:	2bff      	cmp	r3, #255	@ 0xff
3400c456:	d904      	bls.n	3400c462 <HAL_RCCEx_PeriphCLKConfig+0x19ca>
3400c458:	f240 71d4 	movw	r1, #2004	@ 0x7d4
3400c45c:	4860      	ldr	r0, [pc, #384]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c45e:	f7f6 fbd7 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c462:	4a61      	ldr	r2, [pc, #388]	@ (3400c5e8 <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400c464:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c466:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c46a:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c46c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c470:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c474:	3901      	subs	r1, #1
3400c476:	4303      	orrs	r3, r0
3400c478:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c47c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c480:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c484:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c488:	f8d4 0160 	ldr.w	r0, [r4, #352]	@ 0x160
3400c48c:	f7fe fa20 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
3400c490:	6863      	ldr	r3, [r4, #4]
3400c492:	049e      	lsls	r6, r3, #18
3400c494:	d544      	bpl.n	3400c520 <HAL_RCCEx_PeriphCLKConfig+0x1a88>
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
3400c496:	f8d4 3164 	ldr.w	r3, [r4, #356]	@ 0x164
3400c49a:	4a58      	ldr	r2, [pc, #352]	@ (3400c5fc <HAL_RCCEx_PeriphCLKConfig+0x1b64>)
3400c49c:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c4a0:	4291      	cmp	r1, r2
3400c4a2:	d00e      	beq.n	3400c4c2 <HAL_RCCEx_PeriphCLKConfig+0x1a2a>
3400c4a4:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c4a8:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c4ac:	4291      	cmp	r1, r2
3400c4ae:	d008      	beq.n	3400c4c2 <HAL_RCCEx_PeriphCLKConfig+0x1a2a>
3400c4b0:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c4b4:	4293      	cmp	r3, r2
3400c4b6:	d004      	beq.n	3400c4c2 <HAL_RCCEx_PeriphCLKConfig+0x1a2a>
3400c4b8:	f240 71fb 	movw	r1, #2043	@ 0x7fb
3400c4bc:	4848      	ldr	r0, [pc, #288]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c4be:	f7f6 fba7 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
3400c4c2:	f8d4 3164 	ldr.w	r3, [r4, #356]	@ 0x164
3400c4c6:	4a4e      	ldr	r2, [pc, #312]	@ (3400c600 <HAL_RCCEx_PeriphCLKConfig+0x1b68>)
3400c4c8:	4293      	cmp	r3, r2
3400c4ca:	f041 8199 	bne.w	3400d800 <HAL_RCCEx_PeriphCLKConfig+0x2d68>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c4ce:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c4d0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c4d4:	d004      	beq.n	3400c4e0 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
3400c4d6:	f44f 6100 	mov.w	r1, #2048	@ 0x800
3400c4da:	4841      	ldr	r0, [pc, #260]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c4dc:	f7f6 fb98 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c4e0:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c4e2:	3b01      	subs	r3, #1
3400c4e4:	2bff      	cmp	r3, #255	@ 0xff
3400c4e6:	d904      	bls.n	3400c4f2 <HAL_RCCEx_PeriphCLKConfig+0x1a5a>
3400c4e8:	f640 0101 	movw	r1, #2049	@ 0x801
3400c4ec:	483c      	ldr	r0, [pc, #240]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c4ee:	f7f6 fb8f 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c4f2:	4a3d      	ldr	r2, [pc, #244]	@ (3400c5e8 <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400c4f4:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c4f6:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c4fa:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c4fc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c500:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c504:	3901      	subs	r1, #1
3400c506:	4303      	orrs	r3, r0
3400c508:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c50c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c510:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c514:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c518:	f8d4 0164 	ldr.w	r0, [r4, #356]	@ 0x164
3400c51c:	f7fe f9d8 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
3400c520:	6863      	ldr	r3, [r4, #4]
3400c522:	0458      	lsls	r0, r3, #17
3400c524:	d544      	bpl.n	3400c5b0 <HAL_RCCEx_PeriphCLKConfig+0x1b18>
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
3400c526:	f8d4 3168 	ldr.w	r3, [r4, #360]	@ 0x168
3400c52a:	4a36      	ldr	r2, [pc, #216]	@ (3400c604 <HAL_RCCEx_PeriphCLKConfig+0x1b6c>)
3400c52c:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c530:	4291      	cmp	r1, r2
3400c532:	d00e      	beq.n	3400c552 <HAL_RCCEx_PeriphCLKConfig+0x1aba>
3400c534:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c538:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c53c:	4291      	cmp	r1, r2
3400c53e:	d008      	beq.n	3400c552 <HAL_RCCEx_PeriphCLKConfig+0x1aba>
3400c540:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c544:	4293      	cmp	r3, r2
3400c546:	d004      	beq.n	3400c552 <HAL_RCCEx_PeriphCLKConfig+0x1aba>
3400c548:	f640 0128 	movw	r1, #2088	@ 0x828
3400c54c:	4824      	ldr	r0, [pc, #144]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c54e:	f7f6 fb5f 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
3400c552:	f8d4 3168 	ldr.w	r3, [r4, #360]	@ 0x168
3400c556:	4a2c      	ldr	r2, [pc, #176]	@ (3400c608 <HAL_RCCEx_PeriphCLKConfig+0x1b70>)
3400c558:	4293      	cmp	r3, r2
3400c55a:	f041 8182 	bne.w	3400d862 <HAL_RCCEx_PeriphCLKConfig+0x2dca>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c55e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c560:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c564:	d004      	beq.n	3400c570 <HAL_RCCEx_PeriphCLKConfig+0x1ad8>
3400c566:	f640 012d 	movw	r1, #2093	@ 0x82d
3400c56a:	481d      	ldr	r0, [pc, #116]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c56c:	f7f6 fb50 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c570:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c572:	3b01      	subs	r3, #1
3400c574:	2bff      	cmp	r3, #255	@ 0xff
3400c576:	d904      	bls.n	3400c582 <HAL_RCCEx_PeriphCLKConfig+0x1aea>
3400c578:	f640 012e 	movw	r1, #2094	@ 0x82e
3400c57c:	4818      	ldr	r0, [pc, #96]	@ (3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400c57e:	f7f6 fb47 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c582:	4a19      	ldr	r2, [pc, #100]	@ (3400c5e8 <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400c584:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c586:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c58a:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c58c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c590:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c594:	3901      	subs	r1, #1
3400c596:	4303      	orrs	r3, r0
3400c598:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c59c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c5a0:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c5a4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c5a8:	f8d4 0168 	ldr.w	r0, [r4, #360]	@ 0x168
3400c5ac:	f7fe f990 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
3400c5b0:	6863      	ldr	r3, [r4, #4]
3400c5b2:	0419      	lsls	r1, r3, #16
3400c5b4:	d560      	bpl.n	3400c678 <HAL_RCCEx_PeriphCLKConfig+0x1be0>
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
3400c5b6:	f8d4 316c 	ldr.w	r3, [r4, #364]	@ 0x16c
3400c5ba:	4a14      	ldr	r2, [pc, #80]	@ (3400c60c <HAL_RCCEx_PeriphCLKConfig+0x1b74>)
3400c5bc:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c5c0:	4291      	cmp	r1, r2
3400c5c2:	d02a      	beq.n	3400c61a <HAL_RCCEx_PeriphCLKConfig+0x1b82>
3400c5c4:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c5c8:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c5cc:	4291      	cmp	r1, r2
3400c5ce:	d024      	beq.n	3400c61a <HAL_RCCEx_PeriphCLKConfig+0x1b82>
3400c5d0:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c5d4:	4293      	cmp	r3, r2
3400c5d6:	d020      	beq.n	3400c61a <HAL_RCCEx_PeriphCLKConfig+0x1b82>
3400c5d8:	e01a      	b.n	3400c610 <HAL_RCCEx_PeriphCLKConfig+0x1b78>
3400c5da:	bf00      	nop
3400c5dc:	07000830 	.word	0x07000830
3400c5e0:	3402044f 	.word	0x3402044f
3400c5e4:	07020830 	.word	0x07020830
3400c5e8:	56028000 	.word	0x56028000
3400c5ec:	07000c30 	.word	0x07000c30
3400c5f0:	07020c30 	.word	0x07020c30
3400c5f4:	07001030 	.word	0x07001030
3400c5f8:	07021030 	.word	0x07021030
3400c5fc:	07001430 	.word	0x07001430
3400c600:	07021430 	.word	0x07021430
3400c604:	07001830 	.word	0x07001830
3400c608:	07021830 	.word	0x07021830
3400c60c:	07001c30 	.word	0x07001c30
3400c610:	f640 0155 	movw	r1, #2133	@ 0x855
3400c614:	48bb      	ldr	r0, [pc, #748]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c616:	f7f6 fafb 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
3400c61a:	f8d4 316c 	ldr.w	r3, [r4, #364]	@ 0x16c
3400c61e:	4aba      	ldr	r2, [pc, #744]	@ (3400c908 <HAL_RCCEx_PeriphCLKConfig+0x1e70>)
3400c620:	4293      	cmp	r3, r2
3400c622:	f041 814f 	bne.w	3400d8c4 <HAL_RCCEx_PeriphCLKConfig+0x2e2c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c626:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c628:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c62c:	d004      	beq.n	3400c638 <HAL_RCCEx_PeriphCLKConfig+0x1ba0>
3400c62e:	f640 015a 	movw	r1, #2138	@ 0x85a
3400c632:	48b4      	ldr	r0, [pc, #720]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c634:	f7f6 faec 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c638:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c63a:	3b01      	subs	r3, #1
3400c63c:	2bff      	cmp	r3, #255	@ 0xff
3400c63e:	d904      	bls.n	3400c64a <HAL_RCCEx_PeriphCLKConfig+0x1bb2>
3400c640:	f640 015b 	movw	r1, #2139	@ 0x85b
3400c644:	48af      	ldr	r0, [pc, #700]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c646:	f7f6 fae3 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c64a:	4ab0      	ldr	r2, [pc, #704]	@ (3400c90c <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400c64c:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c64e:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c652:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c654:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c658:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c65c:	3901      	subs	r1, #1
3400c65e:	4303      	orrs	r3, r0
3400c660:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c664:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c668:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c66c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c670:	f8d4 016c 	ldr.w	r0, [r4, #364]	@ 0x16c
3400c674:	f7fe f92c 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
3400c678:	6863      	ldr	r3, [r4, #4]
3400c67a:	03da      	lsls	r2, r3, #15
3400c67c:	d544      	bpl.n	3400c708 <HAL_RCCEx_PeriphCLKConfig+0x1c70>
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));
3400c67e:	f8d4 3170 	ldr.w	r3, [r4, #368]	@ 0x170
3400c682:	4aa3      	ldr	r2, [pc, #652]	@ (3400c910 <HAL_RCCEx_PeriphCLKConfig+0x1e78>)
3400c684:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c688:	4291      	cmp	r1, r2
3400c68a:	d00e      	beq.n	3400c6aa <HAL_RCCEx_PeriphCLKConfig+0x1c12>
3400c68c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c690:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c694:	4291      	cmp	r1, r2
3400c696:	d008      	beq.n	3400c6aa <HAL_RCCEx_PeriphCLKConfig+0x1c12>
3400c698:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c69c:	4293      	cmp	r3, r2
3400c69e:	d004      	beq.n	3400c6aa <HAL_RCCEx_PeriphCLKConfig+0x1c12>
3400c6a0:	f640 0182 	movw	r1, #2178	@ 0x882
3400c6a4:	4897      	ldr	r0, [pc, #604]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c6a6:	f7f6 fab3 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
3400c6aa:	f8d4 3170 	ldr.w	r3, [r4, #368]	@ 0x170
3400c6ae:	4a99      	ldr	r2, [pc, #612]	@ (3400c914 <HAL_RCCEx_PeriphCLKConfig+0x1e7c>)
3400c6b0:	4293      	cmp	r3, r2
3400c6b2:	f041 8138 	bne.w	3400d926 <HAL_RCCEx_PeriphCLKConfig+0x2e8e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c6b6:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c6b8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c6bc:	d004      	beq.n	3400c6c8 <HAL_RCCEx_PeriphCLKConfig+0x1c30>
3400c6be:	f640 0187 	movw	r1, #2183	@ 0x887
3400c6c2:	4890      	ldr	r0, [pc, #576]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c6c4:	f7f6 faa4 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c6c8:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c6ca:	3b01      	subs	r3, #1
3400c6cc:	2bff      	cmp	r3, #255	@ 0xff
3400c6ce:	d904      	bls.n	3400c6da <HAL_RCCEx_PeriphCLKConfig+0x1c42>
3400c6d0:	f640 0188 	movw	r1, #2184	@ 0x888
3400c6d4:	488b      	ldr	r0, [pc, #556]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c6d6:	f7f6 fa9b 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c6da:	4a8c      	ldr	r2, [pc, #560]	@ (3400c90c <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400c6dc:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c6de:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c6e2:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c6e4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c6e8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c6ec:	3901      	subs	r1, #1
3400c6ee:	4303      	orrs	r3, r0
3400c6f0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c6f4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c6f8:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c6fc:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c700:	f8d4 0170 	ldr.w	r0, [r4, #368]	@ 0x170
3400c704:	f7fe f8e4 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
3400c708:	6863      	ldr	r3, [r4, #4]
3400c70a:	039b      	lsls	r3, r3, #14
3400c70c:	d544      	bpl.n	3400c798 <HAL_RCCEx_PeriphCLKConfig+0x1d00>
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));
3400c70e:	f8d4 3174 	ldr.w	r3, [r4, #372]	@ 0x174
3400c712:	4a81      	ldr	r2, [pc, #516]	@ (3400c918 <HAL_RCCEx_PeriphCLKConfig+0x1e80>)
3400c714:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c718:	4291      	cmp	r1, r2
3400c71a:	d00e      	beq.n	3400c73a <HAL_RCCEx_PeriphCLKConfig+0x1ca2>
3400c71c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c720:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c724:	4291      	cmp	r1, r2
3400c726:	d008      	beq.n	3400c73a <HAL_RCCEx_PeriphCLKConfig+0x1ca2>
3400c728:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c72c:	4293      	cmp	r3, r2
3400c72e:	d004      	beq.n	3400c73a <HAL_RCCEx_PeriphCLKConfig+0x1ca2>
3400c730:	f640 01af 	movw	r1, #2223	@ 0x8af
3400c734:	4873      	ldr	r0, [pc, #460]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c736:	f7f6 fa6b 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
3400c73a:	f8d4 3174 	ldr.w	r3, [r4, #372]	@ 0x174
3400c73e:	4a77      	ldr	r2, [pc, #476]	@ (3400c91c <HAL_RCCEx_PeriphCLKConfig+0x1e84>)
3400c740:	4293      	cmp	r3, r2
3400c742:	f041 8121 	bne.w	3400d988 <HAL_RCCEx_PeriphCLKConfig+0x2ef0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c746:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c748:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c74c:	d004      	beq.n	3400c758 <HAL_RCCEx_PeriphCLKConfig+0x1cc0>
3400c74e:	f640 01b4 	movw	r1, #2228	@ 0x8b4
3400c752:	486c      	ldr	r0, [pc, #432]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c754:	f7f6 fa5c 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c758:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c75a:	3b01      	subs	r3, #1
3400c75c:	2bff      	cmp	r3, #255	@ 0xff
3400c75e:	d904      	bls.n	3400c76a <HAL_RCCEx_PeriphCLKConfig+0x1cd2>
3400c760:	f640 01b5 	movw	r1, #2229	@ 0x8b5
3400c764:	4867      	ldr	r0, [pc, #412]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c766:	f7f6 fa53 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c76a:	4a68      	ldr	r2, [pc, #416]	@ (3400c90c <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400c76c:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c76e:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c772:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c774:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c778:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c77c:	3901      	subs	r1, #1
3400c77e:	4303      	orrs	r3, r0
3400c780:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c784:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c788:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c78c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c790:	f8d4 0174 	ldr.w	r0, [r4, #372]	@ 0x174
3400c794:	f7fe f89c 	bl	3400a8d0 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
3400c798:	6863      	ldr	r3, [r4, #4]
3400c79a:	035e      	lsls	r6, r3, #13
3400c79c:	d51e      	bpl.n	3400c7dc <HAL_RCCEx_PeriphCLKConfig+0x1d44>
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));
3400c79e:	f8d4 3178 	ldr.w	r3, [r4, #376]	@ 0x178
3400c7a2:	4a5f      	ldr	r2, [pc, #380]	@ (3400c920 <HAL_RCCEx_PeriphCLKConfig+0x1e88>)
3400c7a4:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c7a8:	4291      	cmp	r1, r2
3400c7aa:	d00a      	beq.n	3400c7c2 <HAL_RCCEx_PeriphCLKConfig+0x1d2a>
3400c7ac:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c7b0:	f502 3280 	add.w	r2, r2, #65536	@ 0x10000
3400c7b4:	4293      	cmp	r3, r2
3400c7b6:	d004      	beq.n	3400c7c2 <HAL_RCCEx_PeriphCLKConfig+0x1d2a>
3400c7b8:	f640 01dc 	movw	r1, #2268	@ 0x8dc
3400c7bc:	4851      	ldr	r0, [pc, #324]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c7be:	f7f6 fa27 	bl	34002c10 <assert_failed>
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
3400c7c2:	f8d4 0178 	ldr.w	r0, [r4, #376]	@ 0x178
  LL_RCC_SetClockSource(ClkSource);
3400c7c6:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c7ca:	f7fe f881 	bl	3400a8d0 <LL_RCC_SetClockSource>
3400c7ce:	f8d4 3178 	ldr.w	r3, [r4, #376]	@ 0x178
3400c7d2:	2b00      	cmp	r3, #0
3400c7d4:	f281 8109 	bge.w	3400d9ea <HAL_RCCEx_PeriphCLKConfig+0x2f52>
3400c7d8:	f7fe f84a 	bl	3400a870 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
3400c7dc:	6863      	ldr	r3, [r4, #4]
3400c7de:	02d8      	lsls	r0, r3, #11
3400c7e0:	d51e      	bpl.n	3400c820 <HAL_RCCEx_PeriphCLKConfig+0x1d88>
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));
3400c7e2:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
3400c7e6:	4a4f      	ldr	r2, [pc, #316]	@ (3400c924 <HAL_RCCEx_PeriphCLKConfig+0x1e8c>)
3400c7e8:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c7ec:	4291      	cmp	r1, r2
3400c7ee:	d00a      	beq.n	3400c806 <HAL_RCCEx_PeriphCLKConfig+0x1d6e>
3400c7f0:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c7f4:	f502 3280 	add.w	r2, r2, #65536	@ 0x10000
3400c7f8:	4293      	cmp	r3, r2
3400c7fa:	d004      	beq.n	3400c806 <HAL_RCCEx_PeriphCLKConfig+0x1d6e>
3400c7fc:	f640 01e6 	movw	r1, #2278	@ 0x8e6
3400c800:	4840      	ldr	r0, [pc, #256]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c802:	f7f6 fa05 	bl	34002c10 <assert_failed>
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
3400c806:	f8d4 0180 	ldr.w	r0, [r4, #384]	@ 0x180
3400c80a:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c80e:	f7fe f85f 	bl	3400a8d0 <LL_RCC_SetClockSource>
3400c812:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
3400c816:	2b00      	cmp	r3, #0
3400c818:	f281 80eb 	bge.w	3400d9f2 <HAL_RCCEx_PeriphCLKConfig+0x2f5a>
3400c81c:	f7fe f828 	bl	3400a870 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
3400c820:	6863      	ldr	r3, [r4, #4]
3400c822:	0319      	lsls	r1, r3, #12
3400c824:	d549      	bpl.n	3400c8ba <HAL_RCCEx_PeriphCLKConfig+0x1e22>
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));
3400c826:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
3400c82a:	4a3f      	ldr	r2, [pc, #252]	@ (3400c928 <HAL_RCCEx_PeriphCLKConfig+0x1e90>)
3400c82c:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c830:	4291      	cmp	r1, r2
3400c832:	d00a      	beq.n	3400c84a <HAL_RCCEx_PeriphCLKConfig+0x1db2>
3400c834:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c838:	f502 3240 	add.w	r2, r2, #196608	@ 0x30000
3400c83c:	4293      	cmp	r3, r2
3400c83e:	d004      	beq.n	3400c84a <HAL_RCCEx_PeriphCLKConfig+0x1db2>
3400c840:	f44f 610f 	mov.w	r1, #2288	@ 0x8f0
3400c844:	482f      	ldr	r0, [pc, #188]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c846:	f7f6 f9e3 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
3400c84a:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
3400c84e:	4a37      	ldr	r2, [pc, #220]	@ (3400c92c <HAL_RCCEx_PeriphCLKConfig+0x1e94>)
3400c850:	4293      	cmp	r3, r2
3400c852:	f041 80d2 	bne.w	3400d9fa <HAL_RCCEx_PeriphCLKConfig+0x2f62>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c856:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c858:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c85c:	d004      	beq.n	3400c868 <HAL_RCCEx_PeriphCLKConfig+0x1dd0>
3400c85e:	f640 01f5 	movw	r1, #2293	@ 0x8f5
3400c862:	4828      	ldr	r0, [pc, #160]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c864:	f7f6 f9d4 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c868:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c86a:	3b01      	subs	r3, #1
3400c86c:	2bff      	cmp	r3, #255	@ 0xff
3400c86e:	d904      	bls.n	3400c87a <HAL_RCCEx_PeriphCLKConfig+0x1de2>
3400c870:	f640 01f6 	movw	r1, #2294	@ 0x8f6
3400c874:	4823      	ldr	r0, [pc, #140]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c876:	f7f6 f9cb 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c87a:	4a24      	ldr	r2, [pc, #144]	@ (3400c90c <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400c87c:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c87e:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c882:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c884:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c888:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c88c:	3901      	subs	r1, #1
3400c88e:	4303      	orrs	r3, r0
3400c890:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c894:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c898:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c89c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
3400c8a0:	f8d4 017c 	ldr.w	r0, [r4, #380]	@ 0x17c
  LL_RCC_SetClockSource(ClkSource);
3400c8a4:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c8a8:	f7fe f812 	bl	3400a8d0 <LL_RCC_SetClockSource>
3400c8ac:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
3400c8b0:	2b00      	cmp	r3, #0
3400c8b2:	f281 80ab 	bge.w	3400da0c <HAL_RCCEx_PeriphCLKConfig+0x2f74>
3400c8b6:	f7fd ffdb 	bl	3400a870 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
3400c8ba:	6863      	ldr	r3, [r4, #4]
3400c8bc:	029a      	lsls	r2, r3, #10
3400c8be:	d564      	bpl.n	3400c98a <HAL_RCCEx_PeriphCLKConfig+0x1ef2>
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));
3400c8c0:	f8d4 3184 	ldr.w	r3, [r4, #388]	@ 0x184
3400c8c4:	4a1a      	ldr	r2, [pc, #104]	@ (3400c930 <HAL_RCCEx_PeriphCLKConfig+0x1e98>)
3400c8c6:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c8ca:	4291      	cmp	r1, r2
3400c8cc:	d00a      	beq.n	3400c8e4 <HAL_RCCEx_PeriphCLKConfig+0x1e4c>
3400c8ce:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c8d2:	f502 3240 	add.w	r2, r2, #196608	@ 0x30000
3400c8d6:	4293      	cmp	r3, r2
3400c8d8:	d004      	beq.n	3400c8e4 <HAL_RCCEx_PeriphCLKConfig+0x1e4c>
3400c8da:	f44f 6111 	mov.w	r1, #2320	@ 0x910
3400c8de:	4809      	ldr	r0, [pc, #36]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c8e0:	f7f6 f996 	bl	34002c10 <assert_failed>
    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
3400c8e4:	f8d4 3184 	ldr.w	r3, [r4, #388]	@ 0x184
3400c8e8:	4a12      	ldr	r2, [pc, #72]	@ (3400c934 <HAL_RCCEx_PeriphCLKConfig+0x1e9c>)
3400c8ea:	4293      	cmp	r3, r2
3400c8ec:	f041 8092 	bne.w	3400da14 <HAL_RCCEx_PeriphCLKConfig+0x2f7c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c8f0:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c8f2:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c8f6:	d01f      	beq.n	3400c938 <HAL_RCCEx_PeriphCLKConfig+0x1ea0>
3400c8f8:	f640 1115 	movw	r1, #2325	@ 0x915
3400c8fc:	4801      	ldr	r0, [pc, #4]	@ (3400c904 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c8fe:	f7f6 f987 	bl	34002c10 <assert_failed>
3400c902:	e019      	b.n	3400c938 <HAL_RCCEx_PeriphCLKConfig+0x1ea0>
3400c904:	3402044f 	.word	0x3402044f
3400c908:	07021c30 	.word	0x07021c30
3400c90c:	56028000 	.word	0x56028000
3400c910:	07000034 	.word	0x07000034
3400c914:	07020034 	.word	0x07020034
3400c918:	07000434 	.word	0x07000434
3400c91c:	07020434 	.word	0x07020434
3400c920:	01001014 	.word	0x01001014
3400c924:	01001814 	.word	0x01001814
3400c928:	03000c14 	.word	0x03000c14
3400c92c:	03020c14 	.word	0x03020c14
3400c930:	03001414 	.word	0x03001414
3400c934:	03021414 	.word	0x03021414
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c938:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c93a:	3b01      	subs	r3, #1
3400c93c:	2bff      	cmp	r3, #255	@ 0xff
3400c93e:	d904      	bls.n	3400c94a <HAL_RCCEx_PeriphCLKConfig+0x1eb2>
3400c940:	f640 1116 	movw	r1, #2326	@ 0x916
3400c944:	48b1      	ldr	r0, [pc, #708]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c946:	f7f6 f963 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c94a:	4ab1      	ldr	r2, [pc, #708]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c94c:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c94e:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c952:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c954:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c958:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c95c:	3901      	subs	r1, #1
3400c95e:	4303      	orrs	r3, r0
3400c960:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c964:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c968:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c96c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
3400c970:	f8d4 0184 	ldr.w	r0, [r4, #388]	@ 0x184
  LL_RCC_SetClockSource(ClkSource);
3400c974:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c978:	f7fd ffaa 	bl	3400a8d0 <LL_RCC_SetClockSource>
3400c97c:	f8d4 3184 	ldr.w	r3, [r4, #388]	@ 0x184
3400c980:	2b00      	cmp	r3, #0
3400c982:	f281 8050 	bge.w	3400da26 <HAL_RCCEx_PeriphCLKConfig+0x2f8e>
3400c986:	f7fd ff73 	bl	3400a870 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
3400c98a:	6863      	ldr	r3, [r4, #4]
3400c98c:	061b      	lsls	r3, r3, #24
3400c98e:	d511      	bpl.n	3400c9b4 <HAL_RCCEx_PeriphCLKConfig+0x1f1c>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
3400c990:	f8d4 318c 	ldr.w	r3, [r4, #396]	@ 0x18c
3400c994:	2b03      	cmp	r3, #3
3400c996:	d904      	bls.n	3400c9a2 <HAL_RCCEx_PeriphCLKConfig+0x1f0a>
3400c998:	f44f 6113 	mov.w	r1, #2352	@ 0x930
3400c99c:	489b      	ldr	r0, [pc, #620]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c99e:	f7f6 f937 	bl	34002c10 <assert_failed>
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
3400c9a2:	4a9b      	ldr	r2, [pc, #620]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c9a4:	f8d4 118c 	ldr.w	r1, [r4, #396]	@ 0x18c
3400c9a8:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400c9aa:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
3400c9ae:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
3400c9b2:	6253      	str	r3, [r2, #36]	@ 0x24
}
3400c9b4:	1e28      	subs	r0, r5, #0
3400c9b6:	bf18      	it	ne
3400c9b8:	2001      	movne	r0, #1
3400c9ba:	bd70      	pop	{r4, r5, r6, pc}
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400c9bc:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400c9be:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c9c2:	d003      	beq.n	3400c9cc <HAL_RCCEx_PeriphCLKConfig+0x1f34>
3400c9c4:	21e6      	movs	r1, #230	@ 0xe6
3400c9c6:	4891      	ldr	r0, [pc, #580]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c9c8:	f7f6 f922 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400c9cc:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400c9ce:	3b01      	subs	r3, #1
3400c9d0:	2bff      	cmp	r3, #255	@ 0xff
3400c9d2:	d903      	bls.n	3400c9dc <HAL_RCCEx_PeriphCLKConfig+0x1f44>
3400c9d4:	21e7      	movs	r1, #231	@ 0xe7
3400c9d6:	488d      	ldr	r0, [pc, #564]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c9d8:	f7f6 f91a 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400c9dc:	4a8c      	ldr	r2, [pc, #560]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c9de:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400c9e0:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400c9e4:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400c9e6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c9ea:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c9ee:	3901      	subs	r1, #1
3400c9f0:	4303      	orrs	r3, r0
3400c9f2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c9f6:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400c9fa:	f44f 7300 	mov.w	r3, #512	@ 0x200
3400c9fe:	f7fe b941 	b.w	3400ac84 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400ca02:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400ca04:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ca08:	d003      	beq.n	3400ca12 <HAL_RCCEx_PeriphCLKConfig+0x1f7a>
3400ca0a:	21f3      	movs	r1, #243	@ 0xf3
3400ca0c:	487f      	ldr	r0, [pc, #508]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400ca0e:	f7f6 f8ff 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400ca12:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400ca14:	3b01      	subs	r3, #1
3400ca16:	2bff      	cmp	r3, #255	@ 0xff
3400ca18:	d903      	bls.n	3400ca22 <HAL_RCCEx_PeriphCLKConfig+0x1f8a>
3400ca1a:	21f4      	movs	r1, #244	@ 0xf4
3400ca1c:	487b      	ldr	r0, [pc, #492]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400ca1e:	f7f6 f8f7 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400ca22:	4a7b      	ldr	r2, [pc, #492]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400ca24:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400ca26:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400ca2a:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400ca2c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ca30:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ca34:	3901      	subs	r1, #1
3400ca36:	4303      	orrs	r3, r0
3400ca38:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ca3c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400ca40:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400ca44:	f7fe b91e 	b.w	3400ac84 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
3400ca48:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
3400ca4c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ca50:	d004      	beq.n	3400ca5c <HAL_RCCEx_PeriphCLKConfig+0x1fc4>
3400ca52:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400ca56:	486d      	ldr	r0, [pc, #436]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400ca58:	f7f6 f8da 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));
3400ca5c:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
3400ca60:	3b01      	subs	r3, #1
3400ca62:	2bff      	cmp	r3, #255	@ 0xff
3400ca64:	d904      	bls.n	3400ca70 <HAL_RCCEx_PeriphCLKConfig+0x1fd8>
3400ca66:	f240 1101 	movw	r1, #257	@ 0x101
3400ca6a:	4868      	ldr	r0, [pc, #416]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400ca6c:	f7f6 f8d0 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3400ca70:	4a67      	ldr	r2, [pc, #412]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400ca72:	f8d4 109c 	ldr.w	r1, [r4, #156]	@ 0x9c
3400ca76:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
3400ca7a:	f8d4 0098 	ldr.w	r0, [r4, #152]	@ 0x98
3400ca7e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ca82:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ca86:	3901      	subs	r1, #1
3400ca88:	4303      	orrs	r3, r0
3400ca8a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ca8e:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3400ca92:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
3400ca96:	f7fe b8f5 	b.w	3400ac84 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
3400ca9a:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
3400ca9e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400caa2:	d004      	beq.n	3400caae <HAL_RCCEx_PeriphCLKConfig+0x2016>
3400caa4:	f240 110d 	movw	r1, #269	@ 0x10d
3400caa8:	4858      	ldr	r0, [pc, #352]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400caaa:	f7f6 f8b1 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));
3400caae:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
3400cab2:	3b01      	subs	r3, #1
3400cab4:	2bff      	cmp	r3, #255	@ 0xff
3400cab6:	d904      	bls.n	3400cac2 <HAL_RCCEx_PeriphCLKConfig+0x202a>
3400cab8:	f44f 7187 	mov.w	r1, #270	@ 0x10e
3400cabc:	4853      	ldr	r0, [pc, #332]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400cabe:	f7f6 f8a7 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3400cac2:	4a53      	ldr	r2, [pc, #332]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400cac4:	f8d4 10a4 	ldr.w	r1, [r4, #164]	@ 0xa4
3400cac8:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
3400cacc:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
3400cad0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cad4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cad8:	3901      	subs	r1, #1
3400cada:	4303      	orrs	r3, r0
3400cadc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cae0:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3400cae4:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
3400cae8:	f7fe b8cc 	b.w	3400ac84 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
3400caec:	4a49      	ldr	r2, [pc, #292]	@ (3400cc14 <HAL_RCCEx_PeriphCLKConfig+0x217c>)
3400caee:	4293      	cmp	r3, r2
3400caf0:	d123      	bne.n	3400cb3a <HAL_RCCEx_PeriphCLKConfig+0x20a2>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400caf2:	6a23      	ldr	r3, [r4, #32]
3400caf4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400caf8:	d004      	beq.n	3400cb04 <HAL_RCCEx_PeriphCLKConfig+0x206c>
3400cafa:	f44f 719b 	mov.w	r1, #310	@ 0x136
3400cafe:	4843      	ldr	r0, [pc, #268]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400cb00:	f7f6 f886 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400cb04:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400cb06:	3b01      	subs	r3, #1
3400cb08:	2bff      	cmp	r3, #255	@ 0xff
3400cb0a:	d904      	bls.n	3400cb16 <HAL_RCCEx_PeriphCLKConfig+0x207e>
3400cb0c:	f240 1137 	movw	r1, #311	@ 0x137
3400cb10:	483e      	ldr	r0, [pc, #248]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400cb12:	f7f6 f87d 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400cb16:	4a3e      	ldr	r2, [pc, #248]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400cb18:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400cb1a:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400cb1e:	6a20      	ldr	r0, [r4, #32]
3400cb20:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cb24:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cb28:	3901      	subs	r1, #1
3400cb2a:	4303      	orrs	r3, r0
3400cb2c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cb30:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400cb34:	2308      	movs	r3, #8
3400cb36:	f7fe b8e8 	b.w	3400ad0a <HAL_RCCEx_PeriphCLKConfig+0x272>
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
3400cb3a:	4a37      	ldr	r2, [pc, #220]	@ (3400cc18 <HAL_RCCEx_PeriphCLKConfig+0x2180>)
3400cb3c:	4293      	cmp	r3, r2
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cb3e:	bf02      	ittt	eq
3400cb40:	2240      	moveq	r2, #64	@ 0x40
3400cb42:	4b33      	ldreq	r3, [pc, #204]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400cb44:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cb48:	f7fe b8e1 	b.w	3400ad0e <HAL_RCCEx_PeriphCLKConfig+0x276>
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
3400cb4c:	4a33      	ldr	r2, [pc, #204]	@ (3400cc1c <HAL_RCCEx_PeriphCLKConfig+0x2184>)
3400cb4e:	4293      	cmp	r3, r2
3400cb50:	d123      	bne.n	3400cb9a <HAL_RCCEx_PeriphCLKConfig+0x2102>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400cb52:	6a23      	ldr	r3, [r4, #32]
3400cb54:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cb58:	d004      	beq.n	3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x20cc>
3400cb5a:	f240 1163 	movw	r1, #355	@ 0x163
3400cb5e:	482b      	ldr	r0, [pc, #172]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400cb60:	f7f6 f856 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400cb64:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400cb66:	3b01      	subs	r3, #1
3400cb68:	2bff      	cmp	r3, #255	@ 0xff
3400cb6a:	d904      	bls.n	3400cb76 <HAL_RCCEx_PeriphCLKConfig+0x20de>
3400cb6c:	f44f 71b2 	mov.w	r1, #356	@ 0x164
3400cb70:	4826      	ldr	r0, [pc, #152]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400cb72:	f7f6 f84d 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400cb76:	4a26      	ldr	r2, [pc, #152]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400cb78:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400cb7a:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400cb7e:	6a20      	ldr	r0, [r4, #32]
3400cb80:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cb84:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cb88:	3901      	subs	r1, #1
3400cb8a:	4303      	orrs	r3, r0
3400cb8c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cb90:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400cb94:	2308      	movs	r3, #8
3400cb96:	f7fe b8f5 	b.w	3400ad84 <HAL_RCCEx_PeriphCLKConfig+0x2ec>
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
3400cb9a:	4a21      	ldr	r2, [pc, #132]	@ (3400cc20 <HAL_RCCEx_PeriphCLKConfig+0x2188>)
3400cb9c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cb9e:	bf02      	ittt	eq
3400cba0:	2240      	moveq	r2, #64	@ 0x40
3400cba2:	4b1b      	ldreq	r3, [pc, #108]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400cba4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cba8:	f7fe b8ee 	b.w	3400ad88 <HAL_RCCEx_PeriphCLKConfig+0x2f0>
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
3400cbac:	4a1d      	ldr	r2, [pc, #116]	@ (3400cc24 <HAL_RCCEx_PeriphCLKConfig+0x218c>)
3400cbae:	4293      	cmp	r3, r2
3400cbb0:	d123      	bne.n	3400cbfa <HAL_RCCEx_PeriphCLKConfig+0x2162>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400cbb2:	6a23      	ldr	r3, [r4, #32]
3400cbb4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cbb8:	d004      	beq.n	3400cbc4 <HAL_RCCEx_PeriphCLKConfig+0x212c>
3400cbba:	f44f 71c8 	mov.w	r1, #400	@ 0x190
3400cbbe:	4813      	ldr	r0, [pc, #76]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400cbc0:	f7f6 f826 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400cbc4:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400cbc6:	3b01      	subs	r3, #1
3400cbc8:	2bff      	cmp	r3, #255	@ 0xff
3400cbca:	d904      	bls.n	3400cbd6 <HAL_RCCEx_PeriphCLKConfig+0x213e>
3400cbcc:	f240 1191 	movw	r1, #401	@ 0x191
3400cbd0:	480e      	ldr	r0, [pc, #56]	@ (3400cc0c <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400cbd2:	f7f6 f81d 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400cbd6:	4a0e      	ldr	r2, [pc, #56]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400cbd8:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400cbda:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400cbde:	6a20      	ldr	r0, [r4, #32]
3400cbe0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cbe4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cbe8:	3901      	subs	r1, #1
3400cbea:	4303      	orrs	r3, r0
3400cbec:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cbf0:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400cbf4:	2308      	movs	r3, #8
3400cbf6:	f7fe b902 	b.w	3400adfe <HAL_RCCEx_PeriphCLKConfig+0x366>
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
3400cbfa:	4a0b      	ldr	r2, [pc, #44]	@ (3400cc28 <HAL_RCCEx_PeriphCLKConfig+0x2190>)
3400cbfc:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cbfe:	bf02      	ittt	eq
3400cc00:	2240      	moveq	r2, #64	@ 0x40
3400cc02:	4b03      	ldreq	r3, [pc, #12]	@ (3400cc10 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400cc04:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cc08:	f7fe b8fb 	b.w	3400ae02 <HAL_RCCEx_PeriphCLKConfig+0x36a>
3400cc0c:	3402044f 	.word	0x3402044f
3400cc10:	56028000 	.word	0x56028000
3400cc14:	03030014 	.word	0x03030014
3400cc18:	03010014 	.word	0x03010014
3400cc1c:	03030414 	.word	0x03030414
3400cc20:	03010414 	.word	0x03010414
3400cc24:	03030814 	.word	0x03030814
3400cc28:	03010814 	.word	0x03010814
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
3400cc2c:	2b30      	cmp	r3, #48	@ 0x30
3400cc2e:	d123      	bne.n	3400cc78 <HAL_RCCEx_PeriphCLKConfig+0x21e0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400cc30:	6a23      	ldr	r3, [r4, #32]
3400cc32:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cc36:	d004      	beq.n	3400cc42 <HAL_RCCEx_PeriphCLKConfig+0x21aa>
3400cc38:	f240 11bd 	movw	r1, #445	@ 0x1bd
3400cc3c:	48b2      	ldr	r0, [pc, #712]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400cc3e:	f7f5 ffe7 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400cc42:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400cc44:	3b01      	subs	r3, #1
3400cc46:	2bff      	cmp	r3, #255	@ 0xff
3400cc48:	d904      	bls.n	3400cc54 <HAL_RCCEx_PeriphCLKConfig+0x21bc>
3400cc4a:	f44f 71df 	mov.w	r1, #446	@ 0x1be
3400cc4e:	48ae      	ldr	r0, [pc, #696]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400cc50:	f7f5 ffde 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400cc54:	4aad      	ldr	r2, [pc, #692]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400cc56:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400cc58:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400cc5c:	6a20      	ldr	r0, [r4, #32]
3400cc5e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cc62:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cc66:	3901      	subs	r1, #1
3400cc68:	4303      	orrs	r3, r0
3400cc6a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cc6e:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400cc72:	2308      	movs	r3, #8
3400cc74:	f7fe b8fd 	b.w	3400ae72 <HAL_RCCEx_PeriphCLKConfig+0x3da>
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
3400cc78:	2b10      	cmp	r3, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cc7a:	bf02      	ittt	eq
3400cc7c:	2240      	moveq	r2, #64	@ 0x40
3400cc7e:	4ba3      	ldreq	r3, [pc, #652]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400cc80:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cc84:	f7fe b8f7 	b.w	3400ae76 <HAL_RCCEx_PeriphCLKConfig+0x3de>
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
3400cc88:	4aa1      	ldr	r2, [pc, #644]	@ (3400cf10 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400cc8a:	4293      	cmp	r3, r2
3400cc8c:	d123      	bne.n	3400ccd6 <HAL_RCCEx_PeriphCLKConfig+0x223e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400cc8e:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400cc90:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cc94:	d004      	beq.n	3400cca0 <HAL_RCCEx_PeriphCLKConfig+0x2208>
3400cc96:	f44f 71f5 	mov.w	r1, #490	@ 0x1ea
3400cc9a:	489b      	ldr	r0, [pc, #620]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400cc9c:	f7f5 ffb8 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400cca0:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400cca2:	3b01      	subs	r3, #1
3400cca4:	2bff      	cmp	r3, #255	@ 0xff
3400cca6:	d904      	bls.n	3400ccb2 <HAL_RCCEx_PeriphCLKConfig+0x221a>
3400cca8:	f240 11eb 	movw	r1, #491	@ 0x1eb
3400ccac:	4896      	ldr	r0, [pc, #600]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400ccae:	f7f5 ffaf 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400ccb2:	4a96      	ldr	r2, [pc, #600]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400ccb4:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3400ccb6:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3400ccba:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
3400ccbc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ccc0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ccc4:	3901      	subs	r1, #1
3400ccc6:	4303      	orrs	r3, r0
3400ccc8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cccc:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400ccd0:	2310      	movs	r3, #16
3400ccd2:	f7fe b911 	b.w	3400aef8 <HAL_RCCEx_PeriphCLKConfig+0x460>
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
3400ccd6:	4a8f      	ldr	r2, [pc, #572]	@ (3400cf14 <HAL_RCCEx_PeriphCLKConfig+0x247c>)
3400ccd8:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ccda:	bf02      	ittt	eq
3400ccdc:	2240      	moveq	r2, #64	@ 0x40
3400ccde:	4b8b      	ldreq	r3, [pc, #556]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400cce0:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cce4:	f7fe b90a 	b.w	3400aefc <HAL_RCCEx_PeriphCLKConfig+0x464>
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
3400cce8:	4a8b      	ldr	r2, [pc, #556]	@ (3400cf18 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
3400ccea:	4293      	cmp	r3, r2
3400ccec:	d123      	bne.n	3400cd36 <HAL_RCCEx_PeriphCLKConfig+0x229e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400ccee:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400ccf0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ccf4:	d004      	beq.n	3400cd00 <HAL_RCCEx_PeriphCLKConfig+0x2268>
3400ccf6:	f240 2117 	movw	r1, #535	@ 0x217
3400ccfa:	4883      	ldr	r0, [pc, #524]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400ccfc:	f7f5 ff88 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400cd00:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400cd02:	3b01      	subs	r3, #1
3400cd04:	2bff      	cmp	r3, #255	@ 0xff
3400cd06:	d904      	bls.n	3400cd12 <HAL_RCCEx_PeriphCLKConfig+0x227a>
3400cd08:	f44f 7106 	mov.w	r1, #536	@ 0x218
3400cd0c:	487e      	ldr	r0, [pc, #504]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400cd0e:	f7f5 ff7f 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400cd12:	4a7e      	ldr	r2, [pc, #504]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400cd14:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3400cd16:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3400cd1a:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
3400cd1c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cd20:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cd24:	3901      	subs	r1, #1
3400cd26:	4303      	orrs	r3, r0
3400cd28:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cd2c:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400cd30:	2310      	movs	r3, #16
3400cd32:	f7fe b938 	b.w	3400afa6 <HAL_RCCEx_PeriphCLKConfig+0x50e>
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
3400cd36:	4a79      	ldr	r2, [pc, #484]	@ (3400cf1c <HAL_RCCEx_PeriphCLKConfig+0x2484>)
3400cd38:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cd3a:	bf02      	ittt	eq
3400cd3c:	2240      	moveq	r2, #64	@ 0x40
3400cd3e:	4b73      	ldreq	r3, [pc, #460]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400cd40:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cd44:	f7fe b931 	b.w	3400afaa <HAL_RCCEx_PeriphCLKConfig+0x512>
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
3400cd48:	2b30      	cmp	r3, #48	@ 0x30
3400cd4a:	d123      	bne.n	3400cd94 <HAL_RCCEx_PeriphCLKConfig+0x22fc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400cd4c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400cd4e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cd52:	d004      	beq.n	3400cd5e <HAL_RCCEx_PeriphCLKConfig+0x22c6>
3400cd54:	f240 2145 	movw	r1, #581	@ 0x245
3400cd58:	486b      	ldr	r0, [pc, #428]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400cd5a:	f7f5 ff59 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400cd5e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400cd60:	3b01      	subs	r3, #1
3400cd62:	2bff      	cmp	r3, #255	@ 0xff
3400cd64:	d904      	bls.n	3400cd70 <HAL_RCCEx_PeriphCLKConfig+0x22d8>
3400cd66:	f240 2146 	movw	r1, #582	@ 0x246
3400cd6a:	4867      	ldr	r0, [pc, #412]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400cd6c:	f7f5 ff50 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400cd70:	4a66      	ldr	r2, [pc, #408]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400cd72:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400cd74:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400cd78:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400cd7a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cd7e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cd82:	3901      	subs	r1, #1
3400cd84:	4303      	orrs	r3, r0
3400cd86:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cd8a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400cd8e:	2380      	movs	r3, #128	@ 0x80
3400cd90:	f7fe b94f 	b.w	3400b032 <HAL_RCCEx_PeriphCLKConfig+0x59a>
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
3400cd94:	2b10      	cmp	r3, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cd96:	bf02      	ittt	eq
3400cd98:	2240      	moveq	r2, #64	@ 0x40
3400cd9a:	4b5c      	ldreq	r3, [pc, #368]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400cd9c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cda0:	f7fe b949 	b.w	3400b036 <HAL_RCCEx_PeriphCLKConfig+0x59e>
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
3400cda4:	2b03      	cmp	r3, #3
3400cda6:	d123      	bne.n	3400cdf0 <HAL_RCCEx_PeriphCLKConfig+0x2358>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400cda8:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400cdaa:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cdae:	d004      	beq.n	3400cdba <HAL_RCCEx_PeriphCLKConfig+0x2322>
3400cdb0:	f240 2173 	movw	r1, #627	@ 0x273
3400cdb4:	4854      	ldr	r0, [pc, #336]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400cdb6:	f7f5 ff2b 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400cdba:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400cdbc:	3b01      	subs	r3, #1
3400cdbe:	2bff      	cmp	r3, #255	@ 0xff
3400cdc0:	d904      	bls.n	3400cdcc <HAL_RCCEx_PeriphCLKConfig+0x2334>
3400cdc2:	f44f 711d 	mov.w	r1, #628	@ 0x274
3400cdc6:	4850      	ldr	r0, [pc, #320]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400cdc8:	f7f5 ff22 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400cdcc:	4a4f      	ldr	r2, [pc, #316]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400cdce:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400cdd0:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400cdd4:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400cdd6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cdda:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cdde:	3901      	subs	r1, #1
3400cde0:	4303      	orrs	r3, r0
3400cde2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cde6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400cdea:	2380      	movs	r3, #128	@ 0x80
3400cdec:	f7fe b967 	b.w	3400b0be <HAL_RCCEx_PeriphCLKConfig+0x626>
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
3400cdf0:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cdf2:	bf02      	ittt	eq
3400cdf4:	2240      	moveq	r2, #64	@ 0x40
3400cdf6:	4b45      	ldreq	r3, [pc, #276]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400cdf8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cdfc:	f7fe b961 	b.w	3400b0c2 <HAL_RCCEx_PeriphCLKConfig+0x62a>
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
3400ce00:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ce04:	bf02      	ittt	eq
3400ce06:	2240      	moveq	r2, #64	@ 0x40
3400ce08:	4b40      	ldreq	r3, [pc, #256]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400ce0a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ce0e:	f7fe b9ca 	b.w	3400b1a6 <HAL_RCCEx_PeriphCLKConfig+0x70e>
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
3400ce12:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ce16:	bf02      	ittt	eq
3400ce18:	2240      	moveq	r2, #64	@ 0x40
3400ce1a:	4b3c      	ldreq	r3, [pc, #240]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400ce1c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ce20:	f7fe ba03 	b.w	3400b22a <HAL_RCCEx_PeriphCLKConfig+0x792>
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
3400ce24:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ce26:	bf02      	ittt	eq
3400ce28:	2240      	moveq	r2, #64	@ 0x40
3400ce2a:	4b38      	ldreq	r3, [pc, #224]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400ce2c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ce30:	f7fe ba92 	b.w	3400b358 <HAL_RCCEx_PeriphCLKConfig+0x8c0>
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
3400ce34:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ce36:	bf02      	ittt	eq
3400ce38:	2240      	moveq	r2, #64	@ 0x40
3400ce3a:	4b34      	ldreq	r3, [pc, #208]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400ce3c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ce40:	f7fe bad3 	b.w	3400b3ea <HAL_RCCEx_PeriphCLKConfig+0x952>
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
3400ce44:	4a36      	ldr	r2, [pc, #216]	@ (3400cf20 <HAL_RCCEx_PeriphCLKConfig+0x2488>)
3400ce46:	4293      	cmp	r3, r2
3400ce48:	d124      	bne.n	3400ce94 <HAL_RCCEx_PeriphCLKConfig+0x23fc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400ce4a:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400ce4c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ce50:	d004      	beq.n	3400ce5c <HAL_RCCEx_PeriphCLKConfig+0x23c4>
3400ce52:	f240 314f 	movw	r1, #847	@ 0x34f
3400ce56:	482c      	ldr	r0, [pc, #176]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400ce58:	f7f5 feda 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400ce5c:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400ce5e:	3b01      	subs	r3, #1
3400ce60:	2bff      	cmp	r3, #255	@ 0xff
3400ce62:	d904      	bls.n	3400ce6e <HAL_RCCEx_PeriphCLKConfig+0x23d6>
3400ce64:	f44f 7154 	mov.w	r1, #848	@ 0x350
3400ce68:	4827      	ldr	r0, [pc, #156]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400ce6a:	f7f5 fed1 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400ce6e:	4a27      	ldr	r2, [pc, #156]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400ce70:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400ce72:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400ce76:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400ce78:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ce7c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ce80:	3901      	subs	r1, #1
3400ce82:	4303      	orrs	r3, r0
3400ce84:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ce88:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400ce8c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400ce90:	f7fe baf3 	b.w	3400b47a <HAL_RCCEx_PeriphCLKConfig+0x9e2>
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
3400ce94:	4a23      	ldr	r2, [pc, #140]	@ (3400cf24 <HAL_RCCEx_PeriphCLKConfig+0x248c>)
3400ce96:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ce98:	bf02      	ittt	eq
3400ce9a:	2240      	moveq	r2, #64	@ 0x40
3400ce9c:	4b1b      	ldreq	r3, [pc, #108]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400ce9e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cea2:	f7fe baec 	b.w	3400b47e <HAL_RCCEx_PeriphCLKConfig+0x9e6>
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
3400cea6:	4a20      	ldr	r2, [pc, #128]	@ (3400cf28 <HAL_RCCEx_PeriphCLKConfig+0x2490>)
3400cea8:	4293      	cmp	r3, r2
3400ceaa:	d124      	bne.n	3400cef6 <HAL_RCCEx_PeriphCLKConfig+0x245e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400ceac:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400ceae:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ceb2:	d004      	beq.n	3400cebe <HAL_RCCEx_PeriphCLKConfig+0x2426>
3400ceb4:	f44f 715f 	mov.w	r1, #892	@ 0x37c
3400ceb8:	4813      	ldr	r0, [pc, #76]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400ceba:	f7f5 fea9 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400cebe:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400cec0:	3b01      	subs	r3, #1
3400cec2:	2bff      	cmp	r3, #255	@ 0xff
3400cec4:	d904      	bls.n	3400ced0 <HAL_RCCEx_PeriphCLKConfig+0x2438>
3400cec6:	f240 317d 	movw	r1, #893	@ 0x37d
3400ceca:	480f      	ldr	r0, [pc, #60]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400cecc:	f7f5 fea0 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400ced0:	4a0e      	ldr	r2, [pc, #56]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400ced2:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400ced4:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400ced8:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400ceda:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cede:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cee2:	3901      	subs	r1, #1
3400cee4:	4303      	orrs	r3, r0
3400cee6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ceea:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400ceee:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400cef2:	f7fe bb06 	b.w	3400b502 <HAL_RCCEx_PeriphCLKConfig+0xa6a>
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
3400cef6:	4a0d      	ldr	r2, [pc, #52]	@ (3400cf2c <HAL_RCCEx_PeriphCLKConfig+0x2494>)
3400cef8:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cefa:	bf02      	ittt	eq
3400cefc:	2240      	moveq	r2, #64	@ 0x40
3400cefe:	4b03      	ldreq	r3, [pc, #12]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400cf00:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cf04:	f7fe baff 	b.w	3400b506 <HAL_RCCEx_PeriphCLKConfig+0xa6e>
3400cf08:	3402044f 	.word	0x3402044f
3400cf0c:	56028000 	.word	0x56028000
3400cf10:	0303001c 	.word	0x0303001c
3400cf14:	0301001c 	.word	0x0301001c
3400cf18:	0303041c 	.word	0x0303041c
3400cf1c:	0301041c 	.word	0x0301041c
3400cf20:	0703000c 	.word	0x0703000c
3400cf24:	0701000c 	.word	0x0701000c
3400cf28:	0703040c 	.word	0x0703040c
3400cf2c:	0701040c 	.word	0x0701040c
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
3400cf30:	4ab1      	ldr	r2, [pc, #708]	@ (3400d1f8 <HAL_RCCEx_PeriphCLKConfig+0x2760>)
3400cf32:	4293      	cmp	r3, r2
3400cf34:	d124      	bne.n	3400cf80 <HAL_RCCEx_PeriphCLKConfig+0x24e8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400cf36:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400cf38:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cf3c:	d004      	beq.n	3400cf48 <HAL_RCCEx_PeriphCLKConfig+0x24b0>
3400cf3e:	f240 31a9 	movw	r1, #937	@ 0x3a9
3400cf42:	48ae      	ldr	r0, [pc, #696]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400cf44:	f7f5 fe64 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400cf48:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400cf4a:	3b01      	subs	r3, #1
3400cf4c:	2bff      	cmp	r3, #255	@ 0xff
3400cf4e:	d904      	bls.n	3400cf5a <HAL_RCCEx_PeriphCLKConfig+0x24c2>
3400cf50:	f240 31aa 	movw	r1, #938	@ 0x3aa
3400cf54:	48a9      	ldr	r0, [pc, #676]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400cf56:	f7f5 fe5b 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400cf5a:	4aa9      	ldr	r2, [pc, #676]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400cf5c:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400cf5e:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400cf62:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400cf64:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cf68:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cf6c:	3901      	subs	r1, #1
3400cf6e:	4303      	orrs	r3, r0
3400cf70:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cf74:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400cf78:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400cf7c:	f7fe bb05 	b.w	3400b58a <HAL_RCCEx_PeriphCLKConfig+0xaf2>
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
3400cf80:	4aa0      	ldr	r2, [pc, #640]	@ (3400d204 <HAL_RCCEx_PeriphCLKConfig+0x276c>)
3400cf82:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cf84:	bf02      	ittt	eq
3400cf86:	2240      	moveq	r2, #64	@ 0x40
3400cf88:	4b9d      	ldreq	r3, [pc, #628]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400cf8a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cf8e:	f7fe bafe 	b.w	3400b58e <HAL_RCCEx_PeriphCLKConfig+0xaf6>
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
3400cf92:	4a9d      	ldr	r2, [pc, #628]	@ (3400d208 <HAL_RCCEx_PeriphCLKConfig+0x2770>)
3400cf94:	4293      	cmp	r3, r2
3400cf96:	d124      	bne.n	3400cfe2 <HAL_RCCEx_PeriphCLKConfig+0x254a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400cf98:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400cf9a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cf9e:	d004      	beq.n	3400cfaa <HAL_RCCEx_PeriphCLKConfig+0x2512>
3400cfa0:	f240 31d6 	movw	r1, #982	@ 0x3d6
3400cfa4:	4895      	ldr	r0, [pc, #596]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400cfa6:	f7f5 fe33 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400cfaa:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400cfac:	3b01      	subs	r3, #1
3400cfae:	2bff      	cmp	r3, #255	@ 0xff
3400cfb0:	d904      	bls.n	3400cfbc <HAL_RCCEx_PeriphCLKConfig+0x2524>
3400cfb2:	f240 31d7 	movw	r1, #983	@ 0x3d7
3400cfb6:	4891      	ldr	r0, [pc, #580]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400cfb8:	f7f5 fe2a 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400cfbc:	4a90      	ldr	r2, [pc, #576]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400cfbe:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400cfc0:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400cfc4:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400cfc6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cfca:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cfce:	3901      	subs	r1, #1
3400cfd0:	4303      	orrs	r3, r0
3400cfd2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cfd6:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400cfda:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400cfde:	f7fe bb2c 	b.w	3400b63a <HAL_RCCEx_PeriphCLKConfig+0xba2>
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
3400cfe2:	4a8a      	ldr	r2, [pc, #552]	@ (3400d20c <HAL_RCCEx_PeriphCLKConfig+0x2774>)
3400cfe4:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cfe6:	bf02      	ittt	eq
3400cfe8:	2240      	moveq	r2, #64	@ 0x40
3400cfea:	4b85      	ldreq	r3, [pc, #532]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400cfec:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cff0:	f7fe bb25 	b.w	3400b63e <HAL_RCCEx_PeriphCLKConfig+0xba6>
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
3400cff4:	4a86      	ldr	r2, [pc, #536]	@ (3400d210 <HAL_RCCEx_PeriphCLKConfig+0x2778>)
3400cff6:	4293      	cmp	r3, r2
3400cff8:	d124      	bne.n	3400d044 <HAL_RCCEx_PeriphCLKConfig+0x25ac>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400cffa:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400cffc:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d000:	d004      	beq.n	3400d00c <HAL_RCCEx_PeriphCLKConfig+0x2574>
3400d002:	f240 4103 	movw	r1, #1027	@ 0x403
3400d006:	487d      	ldr	r0, [pc, #500]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400d008:	f7f5 fe02 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400d00c:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400d00e:	3b01      	subs	r3, #1
3400d010:	2bff      	cmp	r3, #255	@ 0xff
3400d012:	d904      	bls.n	3400d01e <HAL_RCCEx_PeriphCLKConfig+0x2586>
3400d014:	f240 4104 	movw	r1, #1028	@ 0x404
3400d018:	4878      	ldr	r0, [pc, #480]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400d01a:	f7f5 fdf9 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400d01e:	4a78      	ldr	r2, [pc, #480]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d020:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400d022:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400d026:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400d028:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d02c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d030:	3901      	subs	r1, #1
3400d032:	4303      	orrs	r3, r0
3400d034:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d038:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400d03c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400d040:	f7fe bb3f 	b.w	3400b6c2 <HAL_RCCEx_PeriphCLKConfig+0xc2a>
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
3400d044:	4a73      	ldr	r2, [pc, #460]	@ (3400d214 <HAL_RCCEx_PeriphCLKConfig+0x277c>)
3400d046:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d048:	bf02      	ittt	eq
3400d04a:	2240      	moveq	r2, #64	@ 0x40
3400d04c:	4b6c      	ldreq	r3, [pc, #432]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d04e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d052:	f7fe bb38 	b.w	3400b6c6 <HAL_RCCEx_PeriphCLKConfig+0xc2e>
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
3400d056:	4a70      	ldr	r2, [pc, #448]	@ (3400d218 <HAL_RCCEx_PeriphCLKConfig+0x2780>)
3400d058:	4293      	cmp	r3, r2
3400d05a:	d124      	bne.n	3400d0a6 <HAL_RCCEx_PeriphCLKConfig+0x260e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400d05c:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400d05e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d062:	d004      	beq.n	3400d06e <HAL_RCCEx_PeriphCLKConfig+0x25d6>
3400d064:	f44f 6186 	mov.w	r1, #1072	@ 0x430
3400d068:	4864      	ldr	r0, [pc, #400]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400d06a:	f7f5 fdd1 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400d06e:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400d070:	3b01      	subs	r3, #1
3400d072:	2bff      	cmp	r3, #255	@ 0xff
3400d074:	d904      	bls.n	3400d080 <HAL_RCCEx_PeriphCLKConfig+0x25e8>
3400d076:	f240 4131 	movw	r1, #1073	@ 0x431
3400d07a:	4860      	ldr	r0, [pc, #384]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400d07c:	f7f5 fdc8 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400d080:	4a5f      	ldr	r2, [pc, #380]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d082:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400d084:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400d088:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400d08a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d08e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d092:	3901      	subs	r1, #1
3400d094:	4303      	orrs	r3, r0
3400d096:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d09a:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400d09e:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400d0a2:	f7fe bb52 	b.w	3400b74a <HAL_RCCEx_PeriphCLKConfig+0xcb2>
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
3400d0a6:	4a5d      	ldr	r2, [pc, #372]	@ (3400d21c <HAL_RCCEx_PeriphCLKConfig+0x2784>)
3400d0a8:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d0aa:	bf02      	ittt	eq
3400d0ac:	2240      	moveq	r2, #64	@ 0x40
3400d0ae:	4b54      	ldreq	r3, [pc, #336]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d0b0:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d0b4:	f7fe bb4b 	b.w	3400b74e <HAL_RCCEx_PeriphCLKConfig+0xcb6>
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
3400d0b8:	4a59      	ldr	r2, [pc, #356]	@ (3400d220 <HAL_RCCEx_PeriphCLKConfig+0x2788>)
3400d0ba:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d0bc:	bf02      	ittt	eq
3400d0be:	2240      	moveq	r2, #64	@ 0x40
3400d0c0:	4b4f      	ldreq	r3, [pc, #316]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d0c2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d0c6:	f7fe bb86 	b.w	3400b7d6 <HAL_RCCEx_PeriphCLKConfig+0xd3e>
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
3400d0ca:	4a56      	ldr	r2, [pc, #344]	@ (3400d224 <HAL_RCCEx_PeriphCLKConfig+0x278c>)
3400d0cc:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d0ce:	bf02      	ittt	eq
3400d0d0:	2240      	moveq	r2, #64	@ 0x40
3400d0d2:	4b4b      	ldreq	r3, [pc, #300]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d0d4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d0d8:	f7fe bbc1 	b.w	3400b85e <HAL_RCCEx_PeriphCLKConfig+0xdc6>
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
3400d0dc:	4a52      	ldr	r2, [pc, #328]	@ (3400d228 <HAL_RCCEx_PeriphCLKConfig+0x2790>)
3400d0de:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d0e0:	bf02      	ittt	eq
3400d0e2:	2240      	moveq	r2, #64	@ 0x40
3400d0e4:	4b46      	ldreq	r3, [pc, #280]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d0e6:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d0ea:	f7fe bc17 	b.w	3400b91c <HAL_RCCEx_PeriphCLKConfig+0xe84>
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
3400d0ee:	4a4f      	ldr	r2, [pc, #316]	@ (3400d22c <HAL_RCCEx_PeriphCLKConfig+0x2794>)
3400d0f0:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d0f2:	bf02      	ittt	eq
3400d0f4:	2240      	moveq	r2, #64	@ 0x40
3400d0f6:	4b42      	ldreq	r3, [pc, #264]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d0f8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d0fc:	f7fe bc52 	b.w	3400b9a4 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
3400d100:	4a4b      	ldr	r2, [pc, #300]	@ (3400d230 <HAL_RCCEx_PeriphCLKConfig+0x2798>)
3400d102:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d104:	bf02      	ittt	eq
3400d106:	2240      	moveq	r2, #64	@ 0x40
3400d108:	4b3d      	ldreq	r3, [pc, #244]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d10a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d10e:	f7fe bc8d 	b.w	3400ba2c <HAL_RCCEx_PeriphCLKConfig+0xf94>
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
3400d112:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400d116:	d124      	bne.n	3400d162 <HAL_RCCEx_PeriphCLKConfig+0x26ca>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d118:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d11a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d11e:	d004      	beq.n	3400d12a <HAL_RCCEx_PeriphCLKConfig+0x2692>
3400d120:	f240 41fd 	movw	r1, #1277	@ 0x4fd
3400d124:	4835      	ldr	r0, [pc, #212]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400d126:	f7f5 fd73 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d12a:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d12c:	3b01      	subs	r3, #1
3400d12e:	2bff      	cmp	r3, #255	@ 0xff
3400d130:	d904      	bls.n	3400d13c <HAL_RCCEx_PeriphCLKConfig+0x26a4>
3400d132:	f240 41fe 	movw	r1, #1278	@ 0x4fe
3400d136:	4831      	ldr	r0, [pc, #196]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400d138:	f7f5 fd6a 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d13c:	4a30      	ldr	r2, [pc, #192]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d13e:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d140:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d144:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d146:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d14a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d14e:	3901      	subs	r1, #1
3400d150:	4303      	orrs	r3, r0
3400d152:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d156:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d15a:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d15e:	f7fe bca7 	b.w	3400bab0 <HAL_RCCEx_PeriphCLKConfig+0x1018>
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
3400d162:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d166:	bf02      	ittt	eq
3400d168:	2240      	moveq	r2, #64	@ 0x40
3400d16a:	4b25      	ldreq	r3, [pc, #148]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d16c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d170:	f7fe bca0 	b.w	3400bab4 <HAL_RCCEx_PeriphCLKConfig+0x101c>
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
3400d174:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d178:	bf02      	ittt	eq
3400d17a:	2240      	moveq	r2, #64	@ 0x40
3400d17c:	4b20      	ldreq	r3, [pc, #128]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d17e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d182:	f7fe bcdd 	b.w	3400bb40 <HAL_RCCEx_PeriphCLKConfig+0x10a8>
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
3400d186:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400d18a:	d123      	bne.n	3400d1d4 <HAL_RCCEx_PeriphCLKConfig+0x273c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400d18c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400d18e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d192:	d004      	beq.n	3400d19e <HAL_RCCEx_PeriphCLKConfig+0x2706>
3400d194:	f240 514a 	movw	r1, #1354	@ 0x54a
3400d198:	4818      	ldr	r0, [pc, #96]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400d19a:	f7f5 fd39 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400d19e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400d1a0:	3b01      	subs	r3, #1
3400d1a2:	2bff      	cmp	r3, #255	@ 0xff
3400d1a4:	d904      	bls.n	3400d1b0 <HAL_RCCEx_PeriphCLKConfig+0x2718>
3400d1a6:	f240 514b 	movw	r1, #1355	@ 0x54b
3400d1aa:	4814      	ldr	r0, [pc, #80]	@ (3400d1fc <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400d1ac:	f7f5 fd30 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400d1b0:	4a13      	ldr	r2, [pc, #76]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d1b2:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400d1b4:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400d1b8:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400d1ba:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d1be:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d1c2:	3901      	subs	r1, #1
3400d1c4:	4303      	orrs	r3, r0
3400d1c6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d1ca:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400d1ce:	2380      	movs	r3, #128	@ 0x80
3400d1d0:	f7fe bcf8 	b.w	3400bbc4 <HAL_RCCEx_PeriphCLKConfig+0x112c>
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
3400d1d4:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d1d8:	bf02      	ittt	eq
3400d1da:	2240      	moveq	r2, #64	@ 0x40
3400d1dc:	4b08      	ldreq	r3, [pc, #32]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d1de:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d1e2:	f7fe bcf1 	b.w	3400bbc8 <HAL_RCCEx_PeriphCLKConfig+0x1130>
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
3400d1e6:	2b10      	cmp	r3, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d1e8:	bf02      	ittt	eq
3400d1ea:	2240      	moveq	r2, #64	@ 0x40
3400d1ec:	4b04      	ldreq	r3, [pc, #16]	@ (3400d200 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400d1ee:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d1f2:	f7fe bd3b 	b.w	3400bc6c <HAL_RCCEx_PeriphCLKConfig+0x11d4>
3400d1f6:	bf00      	nop
3400d1f8:	0703080c 	.word	0x0703080c
3400d1fc:	3402044f 	.word	0x3402044f
3400d200:	56028000 	.word	0x56028000
3400d204:	0701080c 	.word	0x0701080c
3400d208:	07030c0c 	.word	0x07030c0c
3400d20c:	07010c0c 	.word	0x07010c0c
3400d210:	0703100c 	.word	0x0703100c
3400d214:	0701100c 	.word	0x0701100c
3400d218:	0703140c 	.word	0x0703140c
3400d21c:	0701140c 	.word	0x0701140c
3400d220:	0701082c 	.word	0x0701082c
3400d224:	07010c2c 	.word	0x07010c2c
3400d228:	0701102c 	.word	0x0701102c
3400d22c:	0701142c 	.word	0x0701142c
3400d230:	0701182c 	.word	0x0701182c
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
3400d234:	4aa8      	ldr	r2, [pc, #672]	@ (3400d4d8 <HAL_RCCEx_PeriphCLKConfig+0x2a40>)
3400d236:	4293      	cmp	r3, r2
3400d238:	d123      	bne.n	3400d282 <HAL_RCCEx_PeriphCLKConfig+0x27ea>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400d23a:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400d23c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d240:	d004      	beq.n	3400d24c <HAL_RCCEx_PeriphCLKConfig+0x27b4>
3400d242:	f240 5197 	movw	r1, #1431	@ 0x597
3400d246:	48a5      	ldr	r0, [pc, #660]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d248:	f7f5 fce2 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400d24c:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400d24e:	3b01      	subs	r3, #1
3400d250:	2bff      	cmp	r3, #255	@ 0xff
3400d252:	d904      	bls.n	3400d25e <HAL_RCCEx_PeriphCLKConfig+0x27c6>
3400d254:	f44f 61b3 	mov.w	r1, #1432	@ 0x598
3400d258:	48a0      	ldr	r0, [pc, #640]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d25a:	f7f5 fcd9 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400d25e:	4aa0      	ldr	r2, [pc, #640]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d260:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400d262:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400d266:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400d268:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d26c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d270:	3901      	subs	r1, #1
3400d272:	4303      	orrs	r3, r0
3400d274:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d278:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400d27c:	2380      	movs	r3, #128	@ 0x80
3400d27e:	f7fe bd3a 	b.w	3400bcf6 <HAL_RCCEx_PeriphCLKConfig+0x125e>
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
3400d282:	4a98      	ldr	r2, [pc, #608]	@ (3400d4e4 <HAL_RCCEx_PeriphCLKConfig+0x2a4c>)
3400d284:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d286:	bf02      	ittt	eq
3400d288:	2240      	moveq	r2, #64	@ 0x40
3400d28a:	4b95      	ldreq	r3, [pc, #596]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d28c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d290:	f7fe bd33 	b.w	3400bcfa <HAL_RCCEx_PeriphCLKConfig+0x1262>
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
3400d294:	4a94      	ldr	r2, [pc, #592]	@ (3400d4e8 <HAL_RCCEx_PeriphCLKConfig+0x2a50>)
3400d296:	4293      	cmp	r3, r2
3400d298:	d123      	bne.n	3400d2e2 <HAL_RCCEx_PeriphCLKConfig+0x284a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400d29a:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400d29c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d2a0:	d004      	beq.n	3400d2ac <HAL_RCCEx_PeriphCLKConfig+0x2814>
3400d2a2:	f240 51c4 	movw	r1, #1476	@ 0x5c4
3400d2a6:	488d      	ldr	r0, [pc, #564]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d2a8:	f7f5 fcb2 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400d2ac:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400d2ae:	3b01      	subs	r3, #1
3400d2b0:	2bff      	cmp	r3, #255	@ 0xff
3400d2b2:	d904      	bls.n	3400d2be <HAL_RCCEx_PeriphCLKConfig+0x2826>
3400d2b4:	f240 51c5 	movw	r1, #1477	@ 0x5c5
3400d2b8:	4888      	ldr	r0, [pc, #544]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d2ba:	f7f5 fca9 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400d2be:	4a88      	ldr	r2, [pc, #544]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d2c0:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400d2c2:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400d2c6:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400d2c8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d2cc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d2d0:	3901      	subs	r1, #1
3400d2d2:	4303      	orrs	r3, r0
3400d2d4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d2d8:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400d2dc:	2380      	movs	r3, #128	@ 0x80
3400d2de:	f7fe bd4b 	b.w	3400bd78 <HAL_RCCEx_PeriphCLKConfig+0x12e0>
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
3400d2e2:	4a82      	ldr	r2, [pc, #520]	@ (3400d4ec <HAL_RCCEx_PeriphCLKConfig+0x2a54>)
3400d2e4:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d2e6:	bf02      	ittt	eq
3400d2e8:	2240      	moveq	r2, #64	@ 0x40
3400d2ea:	4b7d      	ldreq	r3, [pc, #500]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d2ec:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d2f0:	f7fe bd44 	b.w	3400bd7c <HAL_RCCEx_PeriphCLKConfig+0x12e4>
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
3400d2f4:	2b03      	cmp	r3, #3
3400d2f6:	d123      	bne.n	3400d340 <HAL_RCCEx_PeriphCLKConfig+0x28a8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400d2f8:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400d2fa:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d2fe:	d004      	beq.n	3400d30a <HAL_RCCEx_PeriphCLKConfig+0x2872>
3400d300:	f240 51f1 	movw	r1, #1521	@ 0x5f1
3400d304:	4875      	ldr	r0, [pc, #468]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d306:	f7f5 fc83 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400d30a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400d30c:	3b01      	subs	r3, #1
3400d30e:	2bff      	cmp	r3, #255	@ 0xff
3400d310:	d904      	bls.n	3400d31c <HAL_RCCEx_PeriphCLKConfig+0x2884>
3400d312:	f240 51f2 	movw	r1, #1522	@ 0x5f2
3400d316:	4871      	ldr	r0, [pc, #452]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d318:	f7f5 fc7a 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400d31c:	4a70      	ldr	r2, [pc, #448]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d31e:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400d320:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400d324:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400d326:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d32a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d32e:	3901      	subs	r1, #1
3400d330:	4303      	orrs	r3, r0
3400d332:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d336:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400d33a:	2380      	movs	r3, #128	@ 0x80
3400d33c:	f7fe bd55 	b.w	3400bdea <HAL_RCCEx_PeriphCLKConfig+0x1352>
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
3400d340:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d342:	bf02      	ittt	eq
3400d344:	2240      	moveq	r2, #64	@ 0x40
3400d346:	4b66      	ldreq	r3, [pc, #408]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d348:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d34c:	f7fe bd4f 	b.w	3400bdee <HAL_RCCEx_PeriphCLKConfig+0x1356>
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
3400d350:	4a67      	ldr	r2, [pc, #412]	@ (3400d4f0 <HAL_RCCEx_PeriphCLKConfig+0x2a58>)
3400d352:	4293      	cmp	r3, r2
3400d354:	d124      	bne.n	3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2908>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400d356:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400d358:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d35c:	d004      	beq.n	3400d368 <HAL_RCCEx_PeriphCLKConfig+0x28d0>
3400d35e:	f240 611e 	movw	r1, #1566	@ 0x61e
3400d362:	485e      	ldr	r0, [pc, #376]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d364:	f7f5 fc54 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400d368:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400d36a:	3b01      	subs	r3, #1
3400d36c:	2bff      	cmp	r3, #255	@ 0xff
3400d36e:	d904      	bls.n	3400d37a <HAL_RCCEx_PeriphCLKConfig+0x28e2>
3400d370:	f240 611f 	movw	r1, #1567	@ 0x61f
3400d374:	4859      	ldr	r0, [pc, #356]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d376:	f7f5 fc4b 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400d37a:	4a59      	ldr	r2, [pc, #356]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d37c:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400d37e:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400d382:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400d384:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d388:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d38c:	3901      	subs	r1, #1
3400d38e:	4303      	orrs	r3, r0
3400d390:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d394:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400d398:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400d39c:	f7fe bd72 	b.w	3400be84 <HAL_RCCEx_PeriphCLKConfig+0x13ec>
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
3400d3a0:	4a54      	ldr	r2, [pc, #336]	@ (3400d4f4 <HAL_RCCEx_PeriphCLKConfig+0x2a5c>)
3400d3a2:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d3a4:	bf02      	ittt	eq
3400d3a6:	2240      	moveq	r2, #64	@ 0x40
3400d3a8:	4b4d      	ldreq	r3, [pc, #308]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d3aa:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d3ae:	f7fe bd6b 	b.w	3400be88 <HAL_RCCEx_PeriphCLKConfig+0x13f0>
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
3400d3b2:	4a51      	ldr	r2, [pc, #324]	@ (3400d4f8 <HAL_RCCEx_PeriphCLKConfig+0x2a60>)
3400d3b4:	4293      	cmp	r3, r2
3400d3b6:	d124      	bne.n	3400d402 <HAL_RCCEx_PeriphCLKConfig+0x296a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400d3b8:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400d3ba:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d3be:	d004      	beq.n	3400d3ca <HAL_RCCEx_PeriphCLKConfig+0x2932>
3400d3c0:	f240 614b 	movw	r1, #1611	@ 0x64b
3400d3c4:	4845      	ldr	r0, [pc, #276]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d3c6:	f7f5 fc23 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400d3ca:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400d3cc:	3b01      	subs	r3, #1
3400d3ce:	2bff      	cmp	r3, #255	@ 0xff
3400d3d0:	d904      	bls.n	3400d3dc <HAL_RCCEx_PeriphCLKConfig+0x2944>
3400d3d2:	f240 614c 	movw	r1, #1612	@ 0x64c
3400d3d6:	4841      	ldr	r0, [pc, #260]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d3d8:	f7f5 fc1a 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400d3dc:	4a40      	ldr	r2, [pc, #256]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d3de:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400d3e0:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400d3e4:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400d3e6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d3ea:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d3ee:	3901      	subs	r1, #1
3400d3f0:	4303      	orrs	r3, r0
3400d3f2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d3f6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400d3fa:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400d3fe:	f7fe bd88 	b.w	3400bf12 <HAL_RCCEx_PeriphCLKConfig+0x147a>
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
3400d402:	4a3e      	ldr	r2, [pc, #248]	@ (3400d4fc <HAL_RCCEx_PeriphCLKConfig+0x2a64>)
3400d404:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d406:	bf02      	ittt	eq
3400d408:	2240      	moveq	r2, #64	@ 0x40
3400d40a:	4b35      	ldreq	r3, [pc, #212]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d40c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d410:	f7fe bd81 	b.w	3400bf16 <HAL_RCCEx_PeriphCLKConfig+0x147e>
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
3400d414:	4a3a      	ldr	r2, [pc, #232]	@ (3400d500 <HAL_RCCEx_PeriphCLKConfig+0x2a68>)
3400d416:	4293      	cmp	r3, r2
3400d418:	d124      	bne.n	3400d464 <HAL_RCCEx_PeriphCLKConfig+0x29cc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400d41a:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400d41c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d420:	d004      	beq.n	3400d42c <HAL_RCCEx_PeriphCLKConfig+0x2994>
3400d422:	f44f 61cf 	mov.w	r1, #1656	@ 0x678
3400d426:	482d      	ldr	r0, [pc, #180]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d428:	f7f5 fbf2 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400d42c:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400d42e:	3b01      	subs	r3, #1
3400d430:	2bff      	cmp	r3, #255	@ 0xff
3400d432:	d904      	bls.n	3400d43e <HAL_RCCEx_PeriphCLKConfig+0x29a6>
3400d434:	f240 6179 	movw	r1, #1657	@ 0x679
3400d438:	4828      	ldr	r0, [pc, #160]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d43a:	f7f5 fbe9 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400d43e:	4a28      	ldr	r2, [pc, #160]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d440:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400d442:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400d446:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400d448:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d44c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d450:	3901      	subs	r1, #1
3400d452:	4303      	orrs	r3, r0
3400d454:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d458:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400d45c:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400d460:	f7fe bdb8 	b.w	3400bfd4 <HAL_RCCEx_PeriphCLKConfig+0x153c>
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
3400d464:	4a27      	ldr	r2, [pc, #156]	@ (3400d504 <HAL_RCCEx_PeriphCLKConfig+0x2a6c>)
3400d466:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d468:	bf02      	ittt	eq
3400d46a:	2240      	moveq	r2, #64	@ 0x40
3400d46c:	4b1c      	ldreq	r3, [pc, #112]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d46e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d472:	f7fe bdb1 	b.w	3400bfd8 <HAL_RCCEx_PeriphCLKConfig+0x1540>
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
3400d476:	4a24      	ldr	r2, [pc, #144]	@ (3400d508 <HAL_RCCEx_PeriphCLKConfig+0x2a70>)
3400d478:	4293      	cmp	r3, r2
3400d47a:	d124      	bne.n	3400d4c6 <HAL_RCCEx_PeriphCLKConfig+0x2a2e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d47c:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d47e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d482:	d004      	beq.n	3400d48e <HAL_RCCEx_PeriphCLKConfig+0x29f6>
3400d484:	f240 61a5 	movw	r1, #1701	@ 0x6a5
3400d488:	4814      	ldr	r0, [pc, #80]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d48a:	f7f5 fbc1 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d48e:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d490:	3b01      	subs	r3, #1
3400d492:	2bff      	cmp	r3, #255	@ 0xff
3400d494:	d904      	bls.n	3400d4a0 <HAL_RCCEx_PeriphCLKConfig+0x2a08>
3400d496:	f240 61a6 	movw	r1, #1702	@ 0x6a6
3400d49a:	4810      	ldr	r0, [pc, #64]	@ (3400d4dc <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400d49c:	f7f5 fbb8 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d4a0:	4a0f      	ldr	r2, [pc, #60]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d4a2:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d4a4:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d4a8:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d4aa:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d4ae:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d4b2:	3901      	subs	r1, #1
3400d4b4:	4303      	orrs	r3, r0
3400d4b6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d4ba:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d4be:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d4c2:	f7fe bdcf 	b.w	3400c064 <HAL_RCCEx_PeriphCLKConfig+0x15cc>
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
3400d4c6:	4a11      	ldr	r2, [pc, #68]	@ (3400d50c <HAL_RCCEx_PeriphCLKConfig+0x2a74>)
3400d4c8:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d4ca:	bf02      	ittt	eq
3400d4cc:	2240      	moveq	r2, #64	@ 0x40
3400d4ce:	4b04      	ldreq	r3, [pc, #16]	@ (3400d4e0 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400d4d0:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d4d4:	f7fe bdc8 	b.w	3400c068 <HAL_RCCEx_PeriphCLKConfig+0x15d0>
3400d4d8:	07031418 	.word	0x07031418
3400d4dc:	3402044f 	.word	0x3402044f
3400d4e0:	56028000 	.word	0x56028000
3400d4e4:	07011418 	.word	0x07011418
3400d4e8:	07031818 	.word	0x07031818
3400d4ec:	07011818 	.word	0x07011818
3400d4f0:	07030420 	.word	0x07030420
3400d4f4:	07010420 	.word	0x07010420
3400d4f8:	07030820 	.word	0x07030820
3400d4fc:	07010820 	.word	0x07010820
3400d500:	07030c20 	.word	0x07030c20
3400d504:	07010c20 	.word	0x07010c20
3400d508:	07031020 	.word	0x07031020
3400d50c:	07011020 	.word	0x07011020
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
3400d510:	4aab      	ldr	r2, [pc, #684]	@ (3400d7c0 <HAL_RCCEx_PeriphCLKConfig+0x2d28>)
3400d512:	4293      	cmp	r3, r2
3400d514:	d124      	bne.n	3400d560 <HAL_RCCEx_PeriphCLKConfig+0x2ac8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d516:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d518:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d51c:	d004      	beq.n	3400d528 <HAL_RCCEx_PeriphCLKConfig+0x2a90>
3400d51e:	f240 61d2 	movw	r1, #1746	@ 0x6d2
3400d522:	48a8      	ldr	r0, [pc, #672]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d524:	f7f5 fb74 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d528:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d52a:	3b01      	subs	r3, #1
3400d52c:	2bff      	cmp	r3, #255	@ 0xff
3400d52e:	d904      	bls.n	3400d53a <HAL_RCCEx_PeriphCLKConfig+0x2aa2>
3400d530:	f240 61d3 	movw	r1, #1747	@ 0x6d3
3400d534:	48a3      	ldr	r0, [pc, #652]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d536:	f7f5 fb6b 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d53a:	4aa3      	ldr	r2, [pc, #652]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d53c:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d53e:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d542:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d544:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d548:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d54c:	3901      	subs	r1, #1
3400d54e:	4303      	orrs	r3, r0
3400d550:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d554:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d558:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d55c:	f7fe bdca 	b.w	3400c0f4 <HAL_RCCEx_PeriphCLKConfig+0x165c>
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
3400d560:	4a9a      	ldr	r2, [pc, #616]	@ (3400d7cc <HAL_RCCEx_PeriphCLKConfig+0x2d34>)
3400d562:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d564:	bf02      	ittt	eq
3400d566:	2240      	moveq	r2, #64	@ 0x40
3400d568:	4b97      	ldreq	r3, [pc, #604]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d56a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d56e:	f7fe bdc3 	b.w	3400c0f8 <HAL_RCCEx_PeriphCLKConfig+0x1660>
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
3400d572:	4a97      	ldr	r2, [pc, #604]	@ (3400d7d0 <HAL_RCCEx_PeriphCLKConfig+0x2d38>)
3400d574:	4293      	cmp	r3, r2
3400d576:	d124      	bne.n	3400d5c2 <HAL_RCCEx_PeriphCLKConfig+0x2b2a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400d578:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400d57a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d57e:	d004      	beq.n	3400d58a <HAL_RCCEx_PeriphCLKConfig+0x2af2>
3400d580:	f240 61ff 	movw	r1, #1791	@ 0x6ff
3400d584:	488f      	ldr	r0, [pc, #572]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d586:	f7f5 fb43 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400d58a:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400d58c:	3b01      	subs	r3, #1
3400d58e:	2bff      	cmp	r3, #255	@ 0xff
3400d590:	d904      	bls.n	3400d59c <HAL_RCCEx_PeriphCLKConfig+0x2b04>
3400d592:	f44f 61e0 	mov.w	r1, #1792	@ 0x700
3400d596:	488b      	ldr	r0, [pc, #556]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d598:	f7f5 fb3a 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400d59c:	4a8a      	ldr	r2, [pc, #552]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d59e:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400d5a0:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400d5a4:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400d5a6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d5aa:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d5ae:	3901      	subs	r1, #1
3400d5b0:	4303      	orrs	r3, r0
3400d5b2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d5b6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400d5ba:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400d5be:	f7fe bde0 	b.w	3400c182 <HAL_RCCEx_PeriphCLKConfig+0x16ea>
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
3400d5c2:	4a84      	ldr	r2, [pc, #528]	@ (3400d7d4 <HAL_RCCEx_PeriphCLKConfig+0x2d3c>)
3400d5c4:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d5c6:	bf02      	ittt	eq
3400d5c8:	2240      	moveq	r2, #64	@ 0x40
3400d5ca:	4b7f      	ldreq	r3, [pc, #508]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d5cc:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d5d0:	f7fe bdd9 	b.w	3400c186 <HAL_RCCEx_PeriphCLKConfig+0x16ee>
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
3400d5d4:	4a80      	ldr	r2, [pc, #512]	@ (3400d7d8 <HAL_RCCEx_PeriphCLKConfig+0x2d40>)
3400d5d6:	4293      	cmp	r3, r2
3400d5d8:	d124      	bne.n	3400d624 <HAL_RCCEx_PeriphCLKConfig+0x2b8c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d5da:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d5dc:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d5e0:	d004      	beq.n	3400d5ec <HAL_RCCEx_PeriphCLKConfig+0x2b54>
3400d5e2:	f240 712c 	movw	r1, #1836	@ 0x72c
3400d5e6:	4877      	ldr	r0, [pc, #476]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d5e8:	f7f5 fb12 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d5ec:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d5ee:	3b01      	subs	r3, #1
3400d5f0:	2bff      	cmp	r3, #255	@ 0xff
3400d5f2:	d904      	bls.n	3400d5fe <HAL_RCCEx_PeriphCLKConfig+0x2b66>
3400d5f4:	f240 712d 	movw	r1, #1837	@ 0x72d
3400d5f8:	4872      	ldr	r0, [pc, #456]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d5fa:	f7f5 fb09 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d5fe:	4a72      	ldr	r2, [pc, #456]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d600:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d602:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d606:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d608:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d60c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d610:	3901      	subs	r1, #1
3400d612:	4303      	orrs	r3, r0
3400d614:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d618:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d61c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d620:	f7fe bdf7 	b.w	3400c212 <HAL_RCCEx_PeriphCLKConfig+0x177a>
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
3400d624:	4a6d      	ldr	r2, [pc, #436]	@ (3400d7dc <HAL_RCCEx_PeriphCLKConfig+0x2d44>)
3400d626:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d628:	bf02      	ittt	eq
3400d62a:	2240      	moveq	r2, #64	@ 0x40
3400d62c:	4b66      	ldreq	r3, [pc, #408]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d62e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d632:	f7fe bdf0 	b.w	3400c216 <HAL_RCCEx_PeriphCLKConfig+0x177e>
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
3400d636:	4a6a      	ldr	r2, [pc, #424]	@ (3400d7e0 <HAL_RCCEx_PeriphCLKConfig+0x2d48>)
3400d638:	4293      	cmp	r3, r2
3400d63a:	d124      	bne.n	3400d686 <HAL_RCCEx_PeriphCLKConfig+0x2bee>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d63c:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d63e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d642:	d004      	beq.n	3400d64e <HAL_RCCEx_PeriphCLKConfig+0x2bb6>
3400d644:	f240 7159 	movw	r1, #1881	@ 0x759
3400d648:	485e      	ldr	r0, [pc, #376]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d64a:	f7f5 fae1 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d64e:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d650:	3b01      	subs	r3, #1
3400d652:	2bff      	cmp	r3, #255	@ 0xff
3400d654:	d904      	bls.n	3400d660 <HAL_RCCEx_PeriphCLKConfig+0x2bc8>
3400d656:	f240 715a 	movw	r1, #1882	@ 0x75a
3400d65a:	485a      	ldr	r0, [pc, #360]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d65c:	f7f5 fad8 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d660:	4a59      	ldr	r2, [pc, #356]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d662:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d664:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d668:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d66a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d66e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d672:	3901      	subs	r1, #1
3400d674:	4303      	orrs	r3, r0
3400d676:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d67a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d67e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d682:	f7fe be27 	b.w	3400c2d4 <HAL_RCCEx_PeriphCLKConfig+0x183c>
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
3400d686:	4a57      	ldr	r2, [pc, #348]	@ (3400d7e4 <HAL_RCCEx_PeriphCLKConfig+0x2d4c>)
3400d688:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d68a:	bf02      	ittt	eq
3400d68c:	2240      	moveq	r2, #64	@ 0x40
3400d68e:	4b4e      	ldreq	r3, [pc, #312]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d690:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d694:	f7fe be20 	b.w	3400c2d8 <HAL_RCCEx_PeriphCLKConfig+0x1840>
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
3400d698:	4a53      	ldr	r2, [pc, #332]	@ (3400d7e8 <HAL_RCCEx_PeriphCLKConfig+0x2d50>)
3400d69a:	4293      	cmp	r3, r2
3400d69c:	d124      	bne.n	3400d6e8 <HAL_RCCEx_PeriphCLKConfig+0x2c50>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d69e:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d6a0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d6a4:	d004      	beq.n	3400d6b0 <HAL_RCCEx_PeriphCLKConfig+0x2c18>
3400d6a6:	f240 7186 	movw	r1, #1926	@ 0x786
3400d6aa:	4846      	ldr	r0, [pc, #280]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d6ac:	f7f5 fab0 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d6b0:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d6b2:	3b01      	subs	r3, #1
3400d6b4:	2bff      	cmp	r3, #255	@ 0xff
3400d6b6:	d904      	bls.n	3400d6c2 <HAL_RCCEx_PeriphCLKConfig+0x2c2a>
3400d6b8:	f240 7187 	movw	r1, #1927	@ 0x787
3400d6bc:	4841      	ldr	r0, [pc, #260]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d6be:	f7f5 faa7 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d6c2:	4a41      	ldr	r2, [pc, #260]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d6c4:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d6c6:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d6ca:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d6cc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d6d0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d6d4:	3901      	subs	r1, #1
3400d6d6:	4303      	orrs	r3, r0
3400d6d8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d6dc:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d6e0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d6e4:	f7fe be3e 	b.w	3400c364 <HAL_RCCEx_PeriphCLKConfig+0x18cc>
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
3400d6e8:	4a40      	ldr	r2, [pc, #256]	@ (3400d7ec <HAL_RCCEx_PeriphCLKConfig+0x2d54>)
3400d6ea:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d6ec:	bf02      	ittt	eq
3400d6ee:	2240      	moveq	r2, #64	@ 0x40
3400d6f0:	4b35      	ldreq	r3, [pc, #212]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d6f2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d6f6:	f7fe be37 	b.w	3400c368 <HAL_RCCEx_PeriphCLKConfig+0x18d0>
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
3400d6fa:	4a3d      	ldr	r2, [pc, #244]	@ (3400d7f0 <HAL_RCCEx_PeriphCLKConfig+0x2d58>)
3400d6fc:	4293      	cmp	r3, r2
3400d6fe:	d124      	bne.n	3400d74a <HAL_RCCEx_PeriphCLKConfig+0x2cb2>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d700:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d702:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d706:	d004      	beq.n	3400d712 <HAL_RCCEx_PeriphCLKConfig+0x2c7a>
3400d708:	f240 71b3 	movw	r1, #1971	@ 0x7b3
3400d70c:	482d      	ldr	r0, [pc, #180]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d70e:	f7f5 fa7f 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d712:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d714:	3b01      	subs	r3, #1
3400d716:	2bff      	cmp	r3, #255	@ 0xff
3400d718:	d904      	bls.n	3400d724 <HAL_RCCEx_PeriphCLKConfig+0x2c8c>
3400d71a:	f240 71b4 	movw	r1, #1972	@ 0x7b4
3400d71e:	4829      	ldr	r0, [pc, #164]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d720:	f7f5 fa76 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d724:	4a28      	ldr	r2, [pc, #160]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d726:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d728:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d72c:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d72e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d732:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d736:	3901      	subs	r1, #1
3400d738:	4303      	orrs	r3, r0
3400d73a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d73e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d742:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d746:	f7fe be55 	b.w	3400c3f4 <HAL_RCCEx_PeriphCLKConfig+0x195c>
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
3400d74a:	4a2a      	ldr	r2, [pc, #168]	@ (3400d7f4 <HAL_RCCEx_PeriphCLKConfig+0x2d5c>)
3400d74c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d74e:	bf02      	ittt	eq
3400d750:	2240      	moveq	r2, #64	@ 0x40
3400d752:	4b1d      	ldreq	r3, [pc, #116]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d754:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d758:	f7fe be4e 	b.w	3400c3f8 <HAL_RCCEx_PeriphCLKConfig+0x1960>
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
3400d75c:	4a26      	ldr	r2, [pc, #152]	@ (3400d7f8 <HAL_RCCEx_PeriphCLKConfig+0x2d60>)
3400d75e:	4293      	cmp	r3, r2
3400d760:	d124      	bne.n	3400d7ac <HAL_RCCEx_PeriphCLKConfig+0x2d14>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d762:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d764:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d768:	d004      	beq.n	3400d774 <HAL_RCCEx_PeriphCLKConfig+0x2cdc>
3400d76a:	f44f 61fc 	mov.w	r1, #2016	@ 0x7e0
3400d76e:	4815      	ldr	r0, [pc, #84]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d770:	f7f5 fa4e 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d774:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d776:	3b01      	subs	r3, #1
3400d778:	2bff      	cmp	r3, #255	@ 0xff
3400d77a:	d904      	bls.n	3400d786 <HAL_RCCEx_PeriphCLKConfig+0x2cee>
3400d77c:	f240 71e1 	movw	r1, #2017	@ 0x7e1
3400d780:	4810      	ldr	r0, [pc, #64]	@ (3400d7c4 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d782:	f7f5 fa45 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d786:	4a10      	ldr	r2, [pc, #64]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d788:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d78a:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d78e:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d790:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d794:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d798:	3901      	subs	r1, #1
3400d79a:	4303      	orrs	r3, r0
3400d79c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d7a0:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d7a4:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d7a8:	f7fe be6c 	b.w	3400c484 <HAL_RCCEx_PeriphCLKConfig+0x19ec>
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
3400d7ac:	4a13      	ldr	r2, [pc, #76]	@ (3400d7fc <HAL_RCCEx_PeriphCLKConfig+0x2d64>)
3400d7ae:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d7b0:	bf02      	ittt	eq
3400d7b2:	2240      	moveq	r2, #64	@ 0x40
3400d7b4:	4b04      	ldreq	r3, [pc, #16]	@ (3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d7b6:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d7ba:	f7fe be65 	b.w	3400c488 <HAL_RCCEx_PeriphCLKConfig+0x19f0>
3400d7be:	bf00      	nop
3400d7c0:	07031420 	.word	0x07031420
3400d7c4:	3402044f 	.word	0x3402044f
3400d7c8:	56028000 	.word	0x56028000
3400d7cc:	07011420 	.word	0x07011420
3400d7d0:	07031820 	.word	0x07031820
3400d7d4:	07011820 	.word	0x07011820
3400d7d8:	07030030 	.word	0x07030030
3400d7dc:	07010030 	.word	0x07010030
3400d7e0:	07030430 	.word	0x07030430
3400d7e4:	07010430 	.word	0x07010430
3400d7e8:	07030830 	.word	0x07030830
3400d7ec:	07010830 	.word	0x07010830
3400d7f0:	07030c30 	.word	0x07030c30
3400d7f4:	07010c30 	.word	0x07010c30
3400d7f8:	07031030 	.word	0x07031030
3400d7fc:	07011030 	.word	0x07011030
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
3400d800:	4a8b      	ldr	r2, [pc, #556]	@ (3400da30 <HAL_RCCEx_PeriphCLKConfig+0x2f98>)
3400d802:	4293      	cmp	r3, r2
3400d804:	d124      	bne.n	3400d850 <HAL_RCCEx_PeriphCLKConfig+0x2db8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d806:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d808:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d80c:	d004      	beq.n	3400d818 <HAL_RCCEx_PeriphCLKConfig+0x2d80>
3400d80e:	f640 010d 	movw	r1, #2061	@ 0x80d
3400d812:	4888      	ldr	r0, [pc, #544]	@ (3400da34 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d814:	f7f5 f9fc 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d818:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d81a:	3b01      	subs	r3, #1
3400d81c:	2bff      	cmp	r3, #255	@ 0xff
3400d81e:	d904      	bls.n	3400d82a <HAL_RCCEx_PeriphCLKConfig+0x2d92>
3400d820:	f640 010e 	movw	r1, #2062	@ 0x80e
3400d824:	4883      	ldr	r0, [pc, #524]	@ (3400da34 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d826:	f7f5 f9f3 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d82a:	4a83      	ldr	r2, [pc, #524]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d82c:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d82e:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d832:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d834:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d838:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d83c:	3901      	subs	r1, #1
3400d83e:	4303      	orrs	r3, r0
3400d840:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d844:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d848:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d84c:	f7fe be62 	b.w	3400c514 <HAL_RCCEx_PeriphCLKConfig+0x1a7c>
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
3400d850:	4a7a      	ldr	r2, [pc, #488]	@ (3400da3c <HAL_RCCEx_PeriphCLKConfig+0x2fa4>)
3400d852:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d854:	bf02      	ittt	eq
3400d856:	2240      	moveq	r2, #64	@ 0x40
3400d858:	4b77      	ldreq	r3, [pc, #476]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d85a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d85e:	f7fe be5b 	b.w	3400c518 <HAL_RCCEx_PeriphCLKConfig+0x1a80>
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
3400d862:	4a77      	ldr	r2, [pc, #476]	@ (3400da40 <HAL_RCCEx_PeriphCLKConfig+0x2fa8>)
3400d864:	4293      	cmp	r3, r2
3400d866:	d124      	bne.n	3400d8b2 <HAL_RCCEx_PeriphCLKConfig+0x2e1a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d868:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d86a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d86e:	d004      	beq.n	3400d87a <HAL_RCCEx_PeriphCLKConfig+0x2de2>
3400d870:	f640 013a 	movw	r1, #2106	@ 0x83a
3400d874:	486f      	ldr	r0, [pc, #444]	@ (3400da34 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d876:	f7f5 f9cb 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d87a:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d87c:	3b01      	subs	r3, #1
3400d87e:	2bff      	cmp	r3, #255	@ 0xff
3400d880:	d904      	bls.n	3400d88c <HAL_RCCEx_PeriphCLKConfig+0x2df4>
3400d882:	f640 013b 	movw	r1, #2107	@ 0x83b
3400d886:	486b      	ldr	r0, [pc, #428]	@ (3400da34 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d888:	f7f5 f9c2 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d88c:	4a6a      	ldr	r2, [pc, #424]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d88e:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d890:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d894:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d896:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d89a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d89e:	3901      	subs	r1, #1
3400d8a0:	4303      	orrs	r3, r0
3400d8a2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d8a6:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d8aa:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d8ae:	f7fe be79 	b.w	3400c5a4 <HAL_RCCEx_PeriphCLKConfig+0x1b0c>
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
3400d8b2:	4a64      	ldr	r2, [pc, #400]	@ (3400da44 <HAL_RCCEx_PeriphCLKConfig+0x2fac>)
3400d8b4:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d8b6:	bf02      	ittt	eq
3400d8b8:	2240      	moveq	r2, #64	@ 0x40
3400d8ba:	4b5f      	ldreq	r3, [pc, #380]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d8bc:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d8c0:	f7fe be72 	b.w	3400c5a8 <HAL_RCCEx_PeriphCLKConfig+0x1b10>
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
3400d8c4:	4a60      	ldr	r2, [pc, #384]	@ (3400da48 <HAL_RCCEx_PeriphCLKConfig+0x2fb0>)
3400d8c6:	4293      	cmp	r3, r2
3400d8c8:	d124      	bne.n	3400d914 <HAL_RCCEx_PeriphCLKConfig+0x2e7c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d8ca:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d8cc:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d8d0:	d004      	beq.n	3400d8dc <HAL_RCCEx_PeriphCLKConfig+0x2e44>
3400d8d2:	f640 0167 	movw	r1, #2151	@ 0x867
3400d8d6:	4857      	ldr	r0, [pc, #348]	@ (3400da34 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d8d8:	f7f5 f99a 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d8dc:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d8de:	3b01      	subs	r3, #1
3400d8e0:	2bff      	cmp	r3, #255	@ 0xff
3400d8e2:	d904      	bls.n	3400d8ee <HAL_RCCEx_PeriphCLKConfig+0x2e56>
3400d8e4:	f640 0168 	movw	r1, #2152	@ 0x868
3400d8e8:	4852      	ldr	r0, [pc, #328]	@ (3400da34 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d8ea:	f7f5 f991 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d8ee:	4a52      	ldr	r2, [pc, #328]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d8f0:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d8f2:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d8f6:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d8f8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d8fc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d900:	3901      	subs	r1, #1
3400d902:	4303      	orrs	r3, r0
3400d904:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d908:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d90c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d910:	f7fe beac 	b.w	3400c66c <HAL_RCCEx_PeriphCLKConfig+0x1bd4>
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
3400d914:	4a4d      	ldr	r2, [pc, #308]	@ (3400da4c <HAL_RCCEx_PeriphCLKConfig+0x2fb4>)
3400d916:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d918:	bf02      	ittt	eq
3400d91a:	2240      	moveq	r2, #64	@ 0x40
3400d91c:	4b46      	ldreq	r3, [pc, #280]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d91e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d922:	f7fe bea5 	b.w	3400c670 <HAL_RCCEx_PeriphCLKConfig+0x1bd8>
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
3400d926:	4a4a      	ldr	r2, [pc, #296]	@ (3400da50 <HAL_RCCEx_PeriphCLKConfig+0x2fb8>)
3400d928:	4293      	cmp	r3, r2
3400d92a:	d124      	bne.n	3400d976 <HAL_RCCEx_PeriphCLKConfig+0x2ede>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d92c:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d92e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d932:	d004      	beq.n	3400d93e <HAL_RCCEx_PeriphCLKConfig+0x2ea6>
3400d934:	f640 0194 	movw	r1, #2196	@ 0x894
3400d938:	483e      	ldr	r0, [pc, #248]	@ (3400da34 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d93a:	f7f5 f969 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d93e:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d940:	3b01      	subs	r3, #1
3400d942:	2bff      	cmp	r3, #255	@ 0xff
3400d944:	d904      	bls.n	3400d950 <HAL_RCCEx_PeriphCLKConfig+0x2eb8>
3400d946:	f640 0195 	movw	r1, #2197	@ 0x895
3400d94a:	483a      	ldr	r0, [pc, #232]	@ (3400da34 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d94c:	f7f5 f960 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d950:	4a39      	ldr	r2, [pc, #228]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d952:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d954:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d958:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d95a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d95e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d962:	3901      	subs	r1, #1
3400d964:	4303      	orrs	r3, r0
3400d966:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d96a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d96e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d972:	f7fe bec3 	b.w	3400c6fc <HAL_RCCEx_PeriphCLKConfig+0x1c64>
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
3400d976:	4a37      	ldr	r2, [pc, #220]	@ (3400da54 <HAL_RCCEx_PeriphCLKConfig+0x2fbc>)
3400d978:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d97a:	bf02      	ittt	eq
3400d97c:	2240      	moveq	r2, #64	@ 0x40
3400d97e:	4b2e      	ldreq	r3, [pc, #184]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d980:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d984:	f7fe bebc 	b.w	3400c700 <HAL_RCCEx_PeriphCLKConfig+0x1c68>
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
3400d988:	4a33      	ldr	r2, [pc, #204]	@ (3400da58 <HAL_RCCEx_PeriphCLKConfig+0x2fc0>)
3400d98a:	4293      	cmp	r3, r2
3400d98c:	d124      	bne.n	3400d9d8 <HAL_RCCEx_PeriphCLKConfig+0x2f40>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d98e:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d990:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d994:	d004      	beq.n	3400d9a0 <HAL_RCCEx_PeriphCLKConfig+0x2f08>
3400d996:	f640 01c1 	movw	r1, #2241	@ 0x8c1
3400d99a:	4826      	ldr	r0, [pc, #152]	@ (3400da34 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d99c:	f7f5 f938 	bl	34002c10 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d9a0:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d9a2:	3b01      	subs	r3, #1
3400d9a4:	2bff      	cmp	r3, #255	@ 0xff
3400d9a6:	d904      	bls.n	3400d9b2 <HAL_RCCEx_PeriphCLKConfig+0x2f1a>
3400d9a8:	f640 01c2 	movw	r1, #2242	@ 0x8c2
3400d9ac:	4821      	ldr	r0, [pc, #132]	@ (3400da34 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d9ae:	f7f5 f92f 	bl	34002c10 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d9b2:	4a21      	ldr	r2, [pc, #132]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d9b4:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d9b6:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d9ba:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d9bc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d9c0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d9c4:	3901      	subs	r1, #1
3400d9c6:	4303      	orrs	r3, r0
3400d9c8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d9cc:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d9d0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d9d4:	f7fe beda 	b.w	3400c78c <HAL_RCCEx_PeriphCLKConfig+0x1cf4>
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
3400d9d8:	4a20      	ldr	r2, [pc, #128]	@ (3400da5c <HAL_RCCEx_PeriphCLKConfig+0x2fc4>)
3400d9da:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d9dc:	bf02      	ittt	eq
3400d9de:	2240      	moveq	r2, #64	@ 0x40
3400d9e0:	4b15      	ldreq	r3, [pc, #84]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d9e2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d9e6:	f7fe bed3 	b.w	3400c790 <HAL_RCCEx_PeriphCLKConfig+0x1cf8>
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
3400d9ea:	f7fc ff39 	bl	3400a860 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400d9ee:	f7fe bef5 	b.w	3400c7dc <HAL_RCCEx_PeriphCLKConfig+0x1d44>
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
3400d9f2:	f7fc ff35 	bl	3400a860 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400d9f6:	f7fe bf13 	b.w	3400c820 <HAL_RCCEx_PeriphCLKConfig+0x1d88>
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
3400d9fa:	4a19      	ldr	r2, [pc, #100]	@ (3400da60 <HAL_RCCEx_PeriphCLKConfig+0x2fc8>)
3400d9fc:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d9fe:	bf02      	ittt	eq
3400da00:	2240      	moveq	r2, #64	@ 0x40
3400da02:	4b0d      	ldreq	r3, [pc, #52]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400da04:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400da08:	f7fe bf4a 	b.w	3400c8a0 <HAL_RCCEx_PeriphCLKConfig+0x1e08>
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
3400da0c:	f7fc ff28 	bl	3400a860 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400da10:	f7fe bf53 	b.w	3400c8ba <HAL_RCCEx_PeriphCLKConfig+0x1e22>
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
3400da14:	4a13      	ldr	r2, [pc, #76]	@ (3400da64 <HAL_RCCEx_PeriphCLKConfig+0x2fcc>)
3400da16:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400da18:	bf02      	ittt	eq
3400da1a:	2240      	moveq	r2, #64	@ 0x40
3400da1c:	4b06      	ldreq	r3, [pc, #24]	@ (3400da38 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400da1e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400da22:	f7fe bfa5 	b.w	3400c970 <HAL_RCCEx_PeriphCLKConfig+0x1ed8>
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
3400da26:	f7fc ff1b 	bl	3400a860 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400da2a:	f7fe bfae 	b.w	3400c98a <HAL_RCCEx_PeriphCLKConfig+0x1ef2>
3400da2e:	bf00      	nop
3400da30:	07031430 	.word	0x07031430
3400da34:	3402044f 	.word	0x3402044f
3400da38:	56028000 	.word	0x56028000
3400da3c:	07011430 	.word	0x07011430
3400da40:	07031830 	.word	0x07031830
3400da44:	07011830 	.word	0x07011830
3400da48:	07031c30 	.word	0x07031c30
3400da4c:	07011c30 	.word	0x07011c30
3400da50:	07030034 	.word	0x07030034
3400da54:	07010034 	.word	0x07010034
3400da58:	07030434 	.word	0x07030434
3400da5c:	07010434 	.word	0x07010434
3400da60:	03010c14 	.word	0x03010c14
3400da64:	03011414 	.word	0x03011414

3400da68 <HAL_RCCEx_GetPLL1CLKFreq>:
{
3400da68:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3400da6a:	4c1e      	ldr	r4, [pc, #120]	@ (3400dae4 <HAL_RCCEx_GetPLL1CLKFreq+0x7c>)
3400da6c:	6863      	ldr	r3, [r4, #4]
3400da6e:	05d9      	lsls	r1, r3, #23
3400da70:	d506      	bpl.n	3400da80 <HAL_RCCEx_GetPLL1CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
3400da72:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
3400da76:	005a      	lsls	r2, r3, #1
3400da78:	d40f      	bmi.n	3400da9a <HAL_RCCEx_GetPLL1CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400da7a:	2000      	movs	r0, #0
}
3400da7c:	b003      	add	sp, #12
3400da7e:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3400da80:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
3400da84:	011b      	lsls	r3, r3, #4
3400da86:	d5f8      	bpl.n	3400da7a <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3400da88:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3400da8c:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400da90:	b003      	add	sp, #12
3400da92:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3400da96:	f7fc bf9d 	b.w	3400a9d4 <RCCEx_GetPLLSourceFreq>
3400da9a:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3400da9e:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400daa2:	f7fc ff97 	bl	3400a9d4 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400daa6:	2800      	cmp	r0, #0
3400daa8:	d0e7      	beq.n	3400da7a <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
3400daaa:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
        if (divm != 0U)
3400daae:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400dab2:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400dab6:	d0e0      	beq.n	3400da7a <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
3400dab8:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
3400dabc:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3400dac0:	f8d4 5088 	ldr.w	r5, [r4, #136]	@ 0x88
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3400dac4:	f8d4 4088 	ldr.w	r4, [r4, #136]	@ 0x88
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3400dac8:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3400dacc:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
3400dad0:	9401      	str	r4, [sp, #4]
3400dad2:	9500      	str	r5, [sp, #0]
3400dad4:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400dad8:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400dadc:	f7fc ffb0 	bl	3400aa40 <RCCEx_CalcPLLFreq>
3400dae0:	e7cc      	b.n	3400da7c <HAL_RCCEx_GetPLL1CLKFreq+0x14>
3400dae2:	bf00      	nop
3400dae4:	56028000 	.word	0x56028000

3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>:
{
3400dae8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3400daea:	4c1e      	ldr	r4, [pc, #120]	@ (3400db64 <HAL_RCCEx_GetPLL2CLKFreq+0x7c>)
3400daec:	6863      	ldr	r3, [r4, #4]
3400daee:	0599      	lsls	r1, r3, #22
3400daf0:	d506      	bpl.n	3400db00 <HAL_RCCEx_GetPLL2CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
3400daf2:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
3400daf6:	005a      	lsls	r2, r3, #1
3400daf8:	d40f      	bmi.n	3400db1a <HAL_RCCEx_GetPLL2CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400dafa:	2000      	movs	r0, #0
}
3400dafc:	b003      	add	sp, #12
3400dafe:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3400db00:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
3400db04:	011b      	lsls	r3, r3, #4
3400db06:	d5f8      	bpl.n	3400dafa <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3400db08:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3400db0c:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400db10:	b003      	add	sp, #12
3400db12:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3400db16:	f7fc bf5d 	b.w	3400a9d4 <RCCEx_GetPLLSourceFreq>
3400db1a:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3400db1e:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400db22:	f7fc ff57 	bl	3400a9d4 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400db26:	2800      	cmp	r0, #0
3400db28:	d0e7      	beq.n	3400dafa <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
3400db2a:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
        if (divm != 0U)
3400db2e:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400db32:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400db36:	d0e0      	beq.n	3400dafa <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
3400db38:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
3400db3c:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3400db40:	f8d4 5098 	ldr.w	r5, [r4, #152]	@ 0x98
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3400db44:	f8d4 4098 	ldr.w	r4, [r4, #152]	@ 0x98
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3400db48:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3400db4c:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
3400db50:	9401      	str	r4, [sp, #4]
3400db52:	9500      	str	r5, [sp, #0]
3400db54:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400db58:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400db5c:	f7fc ff70 	bl	3400aa40 <RCCEx_CalcPLLFreq>
3400db60:	e7cc      	b.n	3400dafc <HAL_RCCEx_GetPLL2CLKFreq+0x14>
3400db62:	bf00      	nop
3400db64:	56028000 	.word	0x56028000

3400db68 <HAL_RCCEx_GetPLL3CLKFreq>:
{
3400db68:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3400db6a:	4c1e      	ldr	r4, [pc, #120]	@ (3400dbe4 <HAL_RCCEx_GetPLL3CLKFreq+0x7c>)
3400db6c:	6863      	ldr	r3, [r4, #4]
3400db6e:	0559      	lsls	r1, r3, #21
3400db70:	d506      	bpl.n	3400db80 <HAL_RCCEx_GetPLL3CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
3400db72:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
3400db76:	005a      	lsls	r2, r3, #1
3400db78:	d40f      	bmi.n	3400db9a <HAL_RCCEx_GetPLL3CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400db7a:	2000      	movs	r0, #0
}
3400db7c:	b003      	add	sp, #12
3400db7e:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3400db80:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
3400db84:	011b      	lsls	r3, r3, #4
3400db86:	d5f8      	bpl.n	3400db7a <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3400db88:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3400db8c:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400db90:	b003      	add	sp, #12
3400db92:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3400db96:	f7fc bf1d 	b.w	3400a9d4 <RCCEx_GetPLLSourceFreq>
3400db9a:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3400db9e:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400dba2:	f7fc ff17 	bl	3400a9d4 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400dba6:	2800      	cmp	r0, #0
3400dba8:	d0e7      	beq.n	3400db7a <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
3400dbaa:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
        if (divm != 0U)
3400dbae:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400dbb2:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400dbb6:	d0e0      	beq.n	3400db7a <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
3400dbb8:	f8d4 20a0 	ldr.w	r2, [r4, #160]	@ 0xa0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
3400dbbc:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3400dbc0:	f8d4 50a8 	ldr.w	r5, [r4, #168]	@ 0xa8
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3400dbc4:	f8d4 40a8 	ldr.w	r4, [r4, #168]	@ 0xa8
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3400dbc8:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3400dbcc:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
3400dbd0:	9401      	str	r4, [sp, #4]
3400dbd2:	9500      	str	r5, [sp, #0]
3400dbd4:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400dbd8:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400dbdc:	f7fc ff30 	bl	3400aa40 <RCCEx_CalcPLLFreq>
3400dbe0:	e7cc      	b.n	3400db7c <HAL_RCCEx_GetPLL3CLKFreq+0x14>
3400dbe2:	bf00      	nop
3400dbe4:	56028000 	.word	0x56028000

3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>:
{
3400dbe8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3400dbea:	4c1e      	ldr	r4, [pc, #120]	@ (3400dc64 <HAL_RCCEx_GetPLL4CLKFreq+0x7c>)
3400dbec:	6863      	ldr	r3, [r4, #4]
3400dbee:	0519      	lsls	r1, r3, #20
3400dbf0:	d506      	bpl.n	3400dc00 <HAL_RCCEx_GetPLL4CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
3400dbf2:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
3400dbf6:	005a      	lsls	r2, r3, #1
3400dbf8:	d40f      	bmi.n	3400dc1a <HAL_RCCEx_GetPLL4CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400dbfa:	2000      	movs	r0, #0
}
3400dbfc:	b003      	add	sp, #12
3400dbfe:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3400dc00:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
3400dc04:	011b      	lsls	r3, r3, #4
3400dc06:	d5f8      	bpl.n	3400dbfa <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
3400dc08:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3400dc0c:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400dc10:	b003      	add	sp, #12
3400dc12:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3400dc16:	f7fc bedd 	b.w	3400a9d4 <RCCEx_GetPLLSourceFreq>
3400dc1a:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3400dc1e:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400dc22:	f7fc fed7 	bl	3400a9d4 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400dc26:	2800      	cmp	r0, #0
3400dc28:	d0e7      	beq.n	3400dbfa <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
3400dc2a:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
        if (divm != 0U)
3400dc2e:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400dc32:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400dc36:	d0e0      	beq.n	3400dbfa <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
3400dc38:	f8d4 20b0 	ldr.w	r2, [r4, #176]	@ 0xb0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
3400dc3c:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3400dc40:	f8d4 50b8 	ldr.w	r5, [r4, #184]	@ 0xb8
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3400dc44:	f8d4 40b8 	ldr.w	r4, [r4, #184]	@ 0xb8
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3400dc48:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3400dc4c:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
3400dc50:	9401      	str	r4, [sp, #4]
3400dc52:	9500      	str	r5, [sp, #0]
3400dc54:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400dc58:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400dc5c:	f7fc fef0 	bl	3400aa40 <RCCEx_CalcPLLFreq>
3400dc60:	e7cc      	b.n	3400dbfc <HAL_RCCEx_GetPLL4CLKFreq+0x14>
3400dc62:	bf00      	nop
3400dc64:	56028000 	.word	0x56028000

3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>:
  * @rmtoll MISCENR       PEREN         LL_RCC_CLKP_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CLKP_IsEnabled(void)
{
  return ((READ_BIT(RCC->MISCENR, RCC_MISCENR_PEREN) == RCC_MISCENR_PEREN) ? 1UL : 0UL);
3400dc68:	4b3e      	ldr	r3, [pc, #248]	@ (3400dd64 <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
  * @param  CLKPxSource This parameter can be one of the following values:
  *         @arg @ref RCCEx_CLKP_Clock_Source
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCLKPCLKFreq(uint32_t CLKPxSource)
3400dc6a:	b510      	push	{r4, lr}
3400dc6c:	f8d3 2248 	ldr.w	r2, [r3, #584]	@ 0x248
3400dc70:	0652      	lsls	r2, r2, #25
3400dc72:	d56b      	bpl.n	3400dd4c <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PERSEL));
3400dc74:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400dc78:	f002 0207 	and.w	r2, r2, #7
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  if (LL_RCC_CLKP_IsEnabled() == 1U)
  {
    switch (LL_RCC_GetCLKPClockSource(CLKPxSource))
3400dc7c:	3a01      	subs	r2, #1
3400dc7e:	2a06      	cmp	r2, #6
3400dc80:	d805      	bhi.n	3400dc8e <RCCEx_GetCLKPCLKFreq.constprop.0+0x26>
3400dc82:	e8df f002 	tbb	[pc, r2]
3400dc86:	150f      	.short	0x150f
3400dc88:	3e321b48 	.word	0x3e321b48
3400dc8c:	54          	.byte	0x54
3400dc8d:	00          	.byte	0x00
    {
      case LL_RCC_CLKP_CLKSOURCE_HSI:
        if (LL_RCC_HSI_IsReady() != 0U)
3400dc8e:	f7fc fe07 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400dc92:	2800      	cmp	r0, #0
3400dc94:	d05a      	beq.n	3400dd4c <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400dc96:	4b33      	ldr	r3, [pc, #204]	@ (3400dd64 <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
        {
          clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400dc98:	4833      	ldr	r0, [pc, #204]	@ (3400dd68 <RCCEx_GetCLKPCLKFreq.constprop.0+0x100>)
3400dc9a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400dc9c:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400dca0:	40d8      	lsrs	r0, r3
3400dca2:	e054      	b.n	3400dd4e <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
        }
        break;

      case LL_RCC_CLKP_CLKSOURCE_MSI:
        if (LL_RCC_MSI_IsReady() != 0U)
3400dca4:	f7fc fe04 	bl	3400a8b0 <LL_RCC_MSI_IsReady>
3400dca8:	2800      	cmp	r0, #0
3400dcaa:	d04f      	beq.n	3400dd4c <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
        {
          clkp_frequency = MSI_VALUE;
3400dcac:	482f      	ldr	r0, [pc, #188]	@ (3400dd6c <RCCEx_GetCLKPCLKFreq.constprop.0+0x104>)
3400dcae:	e04e      	b.n	3400dd4e <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
        }
        break;

      case LL_RCC_CLKP_CLKSOURCE_HSE:
        if (LL_RCC_HSE_IsReady() != 0U)
3400dcb0:	f7fc fdee 	bl	3400a890 <LL_RCC_HSE_IsReady>
3400dcb4:	2800      	cmp	r0, #0
3400dcb6:	d049      	beq.n	3400dd4c <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
        {
          clkp_frequency = HSE_VALUE;
3400dcb8:	482d      	ldr	r0, [pc, #180]	@ (3400dd70 <RCCEx_GetCLKPCLKFreq.constprop.0+0x108>)
        /* Unexpected case */
        break;
    }
  }

  return clkp_frequency;
3400dcba:	e048      	b.n	3400dd4e <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3400dcbc:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400dcc0:	06d4      	lsls	r4, r2, #27
3400dcc2:	d543      	bpl.n	3400dd4c <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400dcc4:	f8d3 00d4 	ldr.w	r0, [r3, #212]	@ 0xd4
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400dcc8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400dccc:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400dcd0:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400dcd2:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
          switch (LL_RCC_IC20_GetSource())
3400dcd6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400dcda:	d03c      	beq.n	3400dd56 <RCCEx_GetCLKPCLKFreq.constprop.0+0xee>
3400dcdc:	d833      	bhi.n	3400dd46 <RCCEx_GetCLKPCLKFreq.constprop.0+0xde>
3400dcde:	bbbb      	cbnz	r3, 3400dd50 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe8>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400dce0:	f7ff fec2 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
              clkp_frequency = clkp_frequency / ic_divider;
3400dce4:	fbb0 f0f4 	udiv	r0, r0, r4
              break;
3400dce8:	e031      	b.n	3400dd4e <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3400dcea:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400dcee:	0590      	lsls	r0, r2, #22
3400dcf0:	d52c      	bpl.n	3400dd4c <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400dcf2:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400dcf6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400dcfa:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400dcfe:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400dd00:	e7e7      	b.n	3400dcd2 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
        if (LL_RCC_IC15_IsEnabled() != 0U)
3400dd02:	f7fc fe4d 	bl	3400a9a0 <LL_RCC_IC15_IsEnabled>
3400dd06:	b308      	cbz	r0, 3400dd4c <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
          ic_divider = LL_RCC_IC15_GetDivider();
3400dd08:	f7fc fe52 	bl	3400a9b0 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400dd0c:	4b15      	ldr	r3, [pc, #84]	@ (3400dd64 <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
3400dd0e:	4604      	mov	r4, r0
3400dd10:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400dd14:	e7dd      	b.n	3400dcd2 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3400dd16:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400dd1a:	0351      	lsls	r1, r2, #13
3400dd1c:	d516      	bpl.n	3400dd4c <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400dd1e:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400dd22:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400dd26:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400dd2a:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400dd2c:	e7d1      	b.n	3400dcd2 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
3400dd2e:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400dd32:	0312      	lsls	r2, r2, #12
3400dd34:	d50a      	bpl.n	3400dd4c <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400dd36:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400dd3a:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400dd3e:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400dd42:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400dd44:	e7c5      	b.n	3400dcd2 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
          switch (LL_RCC_IC20_GetSource())
3400dd46:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400dd4a:	d007      	beq.n	3400dd5c <RCCEx_GetCLKPCLKFreq.constprop.0+0xf4>
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
3400dd4c:	2000      	movs	r0, #0
}
3400dd4e:	bd10      	pop	{r4, pc}
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400dd50:	f7ff feca 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400dd54:	e7c6      	b.n	3400dce4 <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400dd56:	f7ff ff07 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400dd5a:	e7c3      	b.n	3400dce4 <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400dd5c:	f7ff ff44 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400dd60:	e7c0      	b.n	3400dce4 <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
3400dd62:	bf00      	nop
3400dd64:	56028000 	.word	0x56028000
3400dd68:	03d09000 	.word	0x03d09000
3400dd6c:	003d0900 	.word	0x003d0900
3400dd70:	02dc6c00 	.word	0x02dc6c00

3400dd74 <RCCEx_GetSPDIFRXCLKFreq.constprop.0>:
  * @param  SPDIFRXxSource This parameter can be one of the following values:
  *         @arg @ref RCCEx_SPDIFRX1_Clock_Source
  * @retval SPDIF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPDIFRXCLKFreq(uint32_t SPDIFRXxSource)
3400dd74:	b538      	push	{r3, r4, r5, lr}
  return (uint32_t)(READ_BIT(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL));
3400dd76:	4d2b      	ldr	r5, [pc, #172]	@ (3400de24 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb0>)
3400dd78:	f8d5 3164 	ldr.w	r3, [r5, #356]	@ 0x164
3400dd7c:	f003 0307 	and.w	r3, r3, #7
{
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
3400dd80:	2b06      	cmp	r3, #6
3400dd82:	d835      	bhi.n	3400ddf0 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
3400dd84:	e8df f003 	tbb	[pc, r3]
3400dd88:	28110d04 	.word	0x28110d04
3400dd8c:	3c45      	.short	0x3c45
3400dd8e:	4b          	.byte	0x4b
3400dd8f:	00          	.byte	0x00
  {
    case LL_RCC_SPDIFRX1_CLKSOURCE_PCLK1:
      spdifrx_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400dd90:	f7fc fd48 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400dd94:	f7fc fe16 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400dd98:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400dd9a:	f003 0307 	and.w	r3, r3, #7
      break;

    case LL_RCC_SPDIFRX1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
      {
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400dd9e:	40d8      	lsrs	r0, r3
3400dda0:	e027      	b.n	3400ddf2 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
      /* Unexpected case */
      break;
  }

  return spdifrx_frequency;
}
3400dda2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      spdifrx_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400dda6:	f7ff bf5f 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400ddaa:	f7fc fdb1 	bl	3400a910 <LL_RCC_IC7_IsEnabled>
3400ddae:	b1f8      	cbz	r0, 3400ddf0 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        ic_divider = LL_RCC_IC7_GetDivider();
3400ddb0:	f7fc fdb6 	bl	3400a920 <LL_RCC_IC7_GetDivider>
3400ddb4:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400ddb6:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400ddba:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3400ddbe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ddc2:	d017      	beq.n	3400ddf4 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x80>
3400ddc4:	d811      	bhi.n	3400ddea <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x76>
3400ddc6:	b913      	cbnz	r3, 3400ddce <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5a>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400ddc8:	f7ff fe4e 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
3400ddcc:	e001      	b.n	3400ddd2 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400ddce:	f7ff fe8b 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3400ddd2:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400ddd6:	e00c      	b.n	3400ddf2 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400ddd8:	f7fc fdac 	bl	3400a934 <LL_RCC_IC8_IsEnabled>
3400dddc:	b140      	cbz	r0, 3400ddf0 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        ic_divider = LL_RCC_IC8_GetDivider();
3400ddde:	f7fc fdb1 	bl	3400a944 <LL_RCC_IC8_GetDivider>
3400dde2:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3400dde6:	4604      	mov	r4, r0
3400dde8:	e7e7      	b.n	3400ddba <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x46>
        switch (LL_RCC_IC8_GetSource())
3400ddea:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ddee:	d004      	beq.n	3400ddfa <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x86>
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
3400ddf0:	2000      	movs	r0, #0
}
3400ddf2:	bd38      	pop	{r3, r4, r5, pc}
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400ddf4:	f7ff feb8 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400ddf8:	e7eb      	b.n	3400ddd2 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400ddfa:	f7ff fef5 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400ddfe:	e7e8      	b.n	3400ddd2 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
      if (LL_RCC_HSI_IsReady() != 0U)
3400de00:	f7fc fd4e 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400de04:	2800      	cmp	r0, #0
3400de06:	d0f3      	beq.n	3400ddf0 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400de08:	6cab      	ldr	r3, [r5, #72]	@ 0x48
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400de0a:	4807      	ldr	r0, [pc, #28]	@ (3400de28 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb4>)
3400de0c:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400de10:	e7c5      	b.n	3400dd9e <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x2a>
      if (LL_RCC_MSI_IsReady() != 0U)
3400de12:	f7fc fd4d 	bl	3400a8b0 <LL_RCC_MSI_IsReady>
3400de16:	2800      	cmp	r0, #0
3400de18:	d0ea      	beq.n	3400ddf0 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        spdifrx_frequency = MSI_VALUE;
3400de1a:	4804      	ldr	r0, [pc, #16]	@ (3400de2c <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb8>)
3400de1c:	e7e9      	b.n	3400ddf2 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
3400de1e:	4804      	ldr	r0, [pc, #16]	@ (3400de30 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xbc>)
  return spdifrx_frequency;
3400de20:	e7e7      	b.n	3400ddf2 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
3400de22:	bf00      	nop
3400de24:	56028000 	.word	0x56028000
3400de28:	03d09000 	.word	0x03d09000
3400de2c:	003d0900 	.word	0x003d0900
3400de30:	00bb8000 	.word	0x00bb8000

3400de34 <RCCEx_GetXSPICLKFreq>:
  * @retval XSPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */

static uint32_t RCCEx_GetXSPICLKFreq(uint32_t XSPIxSource)
{
3400de34:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400de36:	f7fc fd5d 	bl	3400a8f4 <LL_RCC_GetClockSource>
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400de3a:	4b36      	ldr	r3, [pc, #216]	@ (3400df14 <RCCEx_GetXSPICLKFreq+0xe0>)
3400de3c:	4298      	cmp	r0, r3
3400de3e:	d028      	beq.n	3400de92 <RCCEx_GetXSPICLKFreq+0x5e>
3400de40:	d81b      	bhi.n	3400de7a <RCCEx_GetXSPICLKFreq+0x46>
3400de42:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400de46:	4298      	cmp	r0, r3
3400de48:	d013      	beq.n	3400de72 <RCCEx_GetXSPICLKFreq+0x3e>
3400de4a:	d80b      	bhi.n	3400de64 <RCCEx_GetXSPICLKFreq+0x30>
3400de4c:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400de50:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400de54:	429a      	cmp	r2, r3
3400de56:	d04a      	beq.n	3400deee <RCCEx_GetXSPICLKFreq+0xba>
3400de58:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400de5c:	4298      	cmp	r0, r3
3400de5e:	d046      	beq.n	3400deee <RCCEx_GetXSPICLKFreq+0xba>
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
3400de60:	2000      	movs	r0, #0
      /* Nothing to do */
      break;
  }

  return xspi_frequency;
}
3400de62:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400de64:	4b2c      	ldr	r3, [pc, #176]	@ (3400df18 <RCCEx_GetXSPICLKFreq+0xe4>)
3400de66:	4298      	cmp	r0, r3
3400de68:	d003      	beq.n	3400de72 <RCCEx_GetXSPICLKFreq+0x3e>
3400de6a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400de6e:	4298      	cmp	r0, r3
3400de70:	d1f6      	bne.n	3400de60 <RCCEx_GetXSPICLKFreq+0x2c>
}
3400de72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      xspi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400de76:	f7ff bef7 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400de7a:	4b28      	ldr	r3, [pc, #160]	@ (3400df1c <RCCEx_GetXSPICLKFreq+0xe8>)
3400de7c:	4298      	cmp	r0, r3
3400de7e:	d028      	beq.n	3400ded2 <RCCEx_GetXSPICLKFreq+0x9e>
3400de80:	d820      	bhi.n	3400dec4 <RCCEx_GetXSPICLKFreq+0x90>
3400de82:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400de86:	4298      	cmp	r0, r3
3400de88:	d003      	beq.n	3400de92 <RCCEx_GetXSPICLKFreq+0x5e>
3400de8a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400de8e:	4298      	cmp	r0, r3
3400de90:	d1e6      	bne.n	3400de60 <RCCEx_GetXSPICLKFreq+0x2c>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3400de92:	4b23      	ldr	r3, [pc, #140]	@ (3400df20 <RCCEx_GetXSPICLKFreq+0xec>)
3400de94:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400de98:	f010 0004 	ands.w	r0, r0, #4
3400de9c:	d0e1      	beq.n	3400de62 <RCCEx_GetXSPICLKFreq+0x2e>
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400de9e:	f8d3 00cc 	ldr.w	r0, [r3, #204]	@ 0xcc
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3400dea2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400dea6:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400deaa:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400deac:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC4_GetSource())
3400deb0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400deb4:	d02a      	beq.n	3400df0c <RCCEx_GetXSPICLKFreq+0xd8>
3400deb6:	d820      	bhi.n	3400defa <RCCEx_GetXSPICLKFreq+0xc6>
3400deb8:	bb2b      	cbnz	r3, 3400df06 <RCCEx_GetXSPICLKFreq+0xd2>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400deba:	f7ff fdd5 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
            xspi_frequency = xspi_frequency / ic_divider;
3400debe:	fbb0 f0f4 	udiv	r0, r0, r4
  return xspi_frequency;
3400dec2:	e7ce      	b.n	3400de62 <RCCEx_GetXSPICLKFreq+0x2e>
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400dec4:	4b17      	ldr	r3, [pc, #92]	@ (3400df24 <RCCEx_GetXSPICLKFreq+0xf0>)
3400dec6:	4298      	cmp	r0, r3
3400dec8:	d003      	beq.n	3400ded2 <RCCEx_GetXSPICLKFreq+0x9e>
3400deca:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dece:	4298      	cmp	r0, r3
3400ded0:	d1c6      	bne.n	3400de60 <RCCEx_GetXSPICLKFreq+0x2c>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3400ded2:	4b13      	ldr	r3, [pc, #76]	@ (3400df20 <RCCEx_GetXSPICLKFreq+0xec>)
3400ded4:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400ded8:	f010 0008 	ands.w	r0, r0, #8
3400dedc:	d0c1      	beq.n	3400de62 <RCCEx_GetXSPICLKFreq+0x2e>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400dede:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400dee2:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400dee6:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400deea:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400deec:	e7de      	b.n	3400deac <RCCEx_GetXSPICLKFreq+0x78>
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400deee:	f7fc fc99 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
}
3400def2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400def6:	f7fc bd65 	b.w	3400a9c4 <RCCEx_GetHCLKFreq>
        switch (LL_RCC_IC4_GetSource())
3400defa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400defe:	d1af      	bne.n	3400de60 <RCCEx_GetXSPICLKFreq+0x2c>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400df00:	f7ff fe72 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400df04:	e7db      	b.n	3400debe <RCCEx_GetXSPICLKFreq+0x8a>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400df06:	f7ff fdef 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400df0a:	e7d8      	b.n	3400debe <RCCEx_GetXSPICLKFreq+0x8a>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400df0c:	f7ff fe2c 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400df10:	e7d5      	b.n	3400debe <RCCEx_GetXSPICLKFreq+0x8a>
3400df12:	bf00      	nop
3400df14:	03020014 	.word	0x03020014
3400df18:	03010414 	.word	0x03010414
3400df1c:	03030014 	.word	0x03030014
3400df20:	56028000 	.word	0x56028000
3400df24:	03030414 	.word	0x03030414

3400df28 <RCCEx_GetOTGPHYCLKFreq>:
{
3400df28:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400df2a:	f7fc fce3 	bl	3400a8f4 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400df2e:	4b2b      	ldr	r3, [pc, #172]	@ (3400dfdc <RCCEx_GetOTGPHYCLKFreq+0xb4>)
3400df30:	4298      	cmp	r0, r3
3400df32:	d021      	beq.n	3400df78 <RCCEx_GetOTGPHYCLKFreq+0x50>
3400df34:	d815      	bhi.n	3400df62 <RCCEx_GetOTGPHYCLKFreq+0x3a>
3400df36:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400df3a:	4298      	cmp	r0, r3
3400df3c:	d00d      	beq.n	3400df5a <RCCEx_GetOTGPHYCLKFreq+0x32>
3400df3e:	d809      	bhi.n	3400df54 <RCCEx_GetOTGPHYCLKFreq+0x2c>
3400df40:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400df44:	4298      	cmp	r0, r3
3400df46:	d02d      	beq.n	3400dfa4 <RCCEx_GetOTGPHYCLKFreq+0x7c>
3400df48:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400df4c:	4298      	cmp	r0, r3
3400df4e:	d029      	beq.n	3400dfa4 <RCCEx_GetOTGPHYCLKFreq+0x7c>
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
3400df50:	2000      	movs	r0, #0
}
3400df52:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400df54:	4b22      	ldr	r3, [pc, #136]	@ (3400dfe0 <RCCEx_GetOTGPHYCLKFreq+0xb8>)
3400df56:	4298      	cmp	r0, r3
3400df58:	d1fa      	bne.n	3400df50 <RCCEx_GetOTGPHYCLKFreq+0x28>
}
3400df5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usb_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400df5e:	f7ff be83 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400df62:	4b20      	ldr	r3, [pc, #128]	@ (3400dfe4 <RCCEx_GetOTGPHYCLKFreq+0xbc>)
3400df64:	4298      	cmp	r0, r3
3400df66:	d023      	beq.n	3400dfb0 <RCCEx_GetOTGPHYCLKFreq+0x88>
3400df68:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400df6c:	4298      	cmp	r0, r3
3400df6e:	d01f      	beq.n	3400dfb0 <RCCEx_GetOTGPHYCLKFreq+0x88>
3400df70:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400df74:	4298      	cmp	r0, r3
3400df76:	d1eb      	bne.n	3400df50 <RCCEx_GetOTGPHYCLKFreq+0x28>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400df78:	f7fc fd12 	bl	3400a9a0 <LL_RCC_IC15_IsEnabled>
3400df7c:	2800      	cmp	r0, #0
3400df7e:	d0e7      	beq.n	3400df50 <RCCEx_GetOTGPHYCLKFreq+0x28>
        uint32_t ic_divider = LL_RCC_IC15_GetDivider();
3400df80:	f7fc fd16 	bl	3400a9b0 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400df84:	4b18      	ldr	r3, [pc, #96]	@ (3400dfe8 <RCCEx_GetOTGPHYCLKFreq+0xc0>)
3400df86:	4604      	mov	r4, r0
3400df88:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400df8c:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400df90:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400df94:	d01f      	beq.n	3400dfd6 <RCCEx_GetOTGPHYCLKFreq+0xae>
3400df96:	d815      	bhi.n	3400dfc4 <RCCEx_GetOTGPHYCLKFreq+0x9c>
3400df98:	b9d3      	cbnz	r3, 3400dfd0 <RCCEx_GetOTGPHYCLKFreq+0xa8>
            usb_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400df9a:	f7ff fd65 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
            usb_frequency = usb_frequency / ic_divider;
3400df9e:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400dfa2:	e7d6      	b.n	3400df52 <RCCEx_GetOTGPHYCLKFreq+0x2a>
      if (LL_RCC_HSE_IsReady() != 0U)
3400dfa4:	f7fc fc74 	bl	3400a890 <LL_RCC_HSE_IsReady>
3400dfa8:	2800      	cmp	r0, #0
3400dfaa:	d0d1      	beq.n	3400df50 <RCCEx_GetOTGPHYCLKFreq+0x28>
        usb_frequency = HSE_VALUE / 2U;
3400dfac:	480f      	ldr	r0, [pc, #60]	@ (3400dfec <RCCEx_GetOTGPHYCLKFreq+0xc4>)
3400dfae:	e7d0      	b.n	3400df52 <RCCEx_GetOTGPHYCLKFreq+0x2a>
      if (LL_RCC_HSE_IsReady() != 0U)
3400dfb0:	f7fc fc6e 	bl	3400a890 <LL_RCC_HSE_IsReady>
3400dfb4:	2800      	cmp	r0, #0
3400dfb6:	d0cb      	beq.n	3400df50 <RCCEx_GetOTGPHYCLKFreq+0x28>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3400dfb8:	f7fc fc62 	bl	3400a880 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
3400dfbc:	2800      	cmp	r0, #0
3400dfbe:	d1f5      	bne.n	3400dfac <RCCEx_GetOTGPHYCLKFreq+0x84>
          usb_frequency = HSE_VALUE;
3400dfc0:	480b      	ldr	r0, [pc, #44]	@ (3400dff0 <RCCEx_GetOTGPHYCLKFreq+0xc8>)
  return usb_frequency;
3400dfc2:	e7c6      	b.n	3400df52 <RCCEx_GetOTGPHYCLKFreq+0x2a>
        switch (LL_RCC_IC15_GetSource())
3400dfc4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400dfc8:	d1c2      	bne.n	3400df50 <RCCEx_GetOTGPHYCLKFreq+0x28>
            usb_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400dfca:	f7ff fe0d 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400dfce:	e7e6      	b.n	3400df9e <RCCEx_GetOTGPHYCLKFreq+0x76>
            usb_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400dfd0:	f7ff fd8a 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400dfd4:	e7e3      	b.n	3400df9e <RCCEx_GetOTGPHYCLKFreq+0x76>
            usb_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400dfd6:	f7ff fdc7 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400dfda:	e7e0      	b.n	3400df9e <RCCEx_GetOTGPHYCLKFreq+0x76>
3400dfdc:	03020c14 	.word	0x03020c14
3400dfe0:	03011414 	.word	0x03011414
3400dfe4:	03030c14 	.word	0x03030c14
3400dfe8:	56028000 	.word	0x56028000
3400dfec:	016e3600 	.word	0x016e3600
3400dff0:	02dc6c00 	.word	0x02dc6c00

3400dff4 <RCCEx_GetOTGPHYCKREFCLKFreq>:
{
3400dff4:	b508      	push	{r3, lr}
  return LL_RCC_GetClockSource(Periph);
3400dff6:	f7fc fc7d 	bl	3400a8f4 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
3400dffa:	4b11      	ldr	r3, [pc, #68]	@ (3400e040 <RCCEx_GetOTGPHYCKREFCLKFreq+0x4c>)
3400dffc:	4298      	cmp	r0, r3
3400dffe:	d01c      	beq.n	3400e03a <RCCEx_GetOTGPHYCKREFCLKFreq+0x46>
3400e000:	d805      	bhi.n	3400e00e <RCCEx_GetOTGPHYCKREFCLKFreq+0x1a>
3400e002:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e006:	4298      	cmp	r0, r3
3400e008:	d012      	beq.n	3400e030 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3c>
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e00a:	2000      	movs	r0, #0
}
3400e00c:	bd08      	pop	{r3, pc}
  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
3400e00e:	4b0d      	ldr	r3, [pc, #52]	@ (3400e044 <RCCEx_GetOTGPHYCKREFCLKFreq+0x50>)
3400e010:	f420 6000 	bic.w	r0, r0, #2048	@ 0x800
3400e014:	4298      	cmp	r0, r3
3400e016:	d1f8      	bne.n	3400e00a <RCCEx_GetOTGPHYCKREFCLKFreq+0x16>
      if (LL_RCC_HSE_IsReady() != 0U)
3400e018:	f7fc fc3a 	bl	3400a890 <LL_RCC_HSE_IsReady>
3400e01c:	2800      	cmp	r0, #0
3400e01e:	d0f4      	beq.n	3400e00a <RCCEx_GetOTGPHYCKREFCLKFreq+0x16>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3400e020:	f7fc fc2e 	bl	3400a880 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
          usb_frequency = HSE_VALUE;
3400e024:	4b08      	ldr	r3, [pc, #32]	@ (3400e048 <RCCEx_GetOTGPHYCKREFCLKFreq+0x54>)
3400e026:	2800      	cmp	r0, #0
3400e028:	4808      	ldr	r0, [pc, #32]	@ (3400e04c <RCCEx_GetOTGPHYCKREFCLKFreq+0x58>)
3400e02a:	bf08      	it	eq
3400e02c:	4618      	moveq	r0, r3
3400e02e:	e7ed      	b.n	3400e00c <RCCEx_GetOTGPHYCKREFCLKFreq+0x18>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
3400e030:	4807      	ldr	r0, [pc, #28]	@ (3400e050 <RCCEx_GetOTGPHYCKREFCLKFreq+0x5c>)
}
3400e032:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3400e036:	f7ff bf77 	b.w	3400df28 <RCCEx_GetOTGPHYCLKFreq>
3400e03a:	4806      	ldr	r0, [pc, #24]	@ (3400e054 <RCCEx_GetOTGPHYCKREFCLKFreq+0x60>)
3400e03c:	e7f9      	b.n	3400e032 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3e>
3400e03e:	bf00      	nop
3400e040:	01001814 	.word	0x01001814
3400e044:	01011014 	.word	0x01011014
3400e048:	02dc6c00 	.word	0x02dc6c00
3400e04c:	016e3600 	.word	0x016e3600
3400e050:	03000c14 	.word	0x03000c14
3400e054:	03001414 	.word	0x03001414

3400e058 <RCCEx_GetUSARTCLKFreq>:
{
3400e058:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e05a:	f7fc fc4b 	bl	3400a8f4 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400e05e:	4b6f      	ldr	r3, [pc, #444]	@ (3400e21c <RCCEx_GetUSARTCLKFreq+0x1c4>)
3400e060:	4298      	cmp	r0, r3
3400e062:	d039      	beq.n	3400e0d8 <RCCEx_GetUSARTCLKFreq+0x80>
3400e064:	d852      	bhi.n	3400e10c <RCCEx_GetUSARTCLKFreq+0xb4>
3400e066:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3400e06a:	4298      	cmp	r0, r3
3400e06c:	f000 80b5 	beq.w	3400e1da <RCCEx_GetUSARTCLKFreq+0x182>
3400e070:	d813      	bhi.n	3400e09a <RCCEx_GetUSARTCLKFreq+0x42>
3400e072:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400e076:	4298      	cmp	r0, r3
3400e078:	f000 80af 	beq.w	3400e1da <RCCEx_GetUSARTCLKFreq+0x182>
3400e07c:	d80b      	bhi.n	3400e096 <RCCEx_GetUSARTCLKFreq+0x3e>
3400e07e:	f2a3 4304 	subw	r3, r3, #1028	@ 0x404
3400e082:	4298      	cmp	r0, r3
3400e084:	f000 80a9 	beq.w	3400e1da <RCCEx_GetUSARTCLKFreq+0x182>
3400e088:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e08c:	4298      	cmp	r0, r3
3400e08e:	f000 80ae 	beq.w	3400e1ee <RCCEx_GetUSARTCLKFreq+0x196>
  uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e092:	2000      	movs	r0, #0
}
3400e094:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400e096:	4b62      	ldr	r3, [pc, #392]	@ (3400e220 <RCCEx_GetUSARTCLKFreq+0x1c8>)
3400e098:	e7f8      	b.n	3400e08c <RCCEx_GetUSARTCLKFreq+0x34>
3400e09a:	4b62      	ldr	r3, [pc, #392]	@ (3400e224 <RCCEx_GetUSARTCLKFreq+0x1cc>)
3400e09c:	4298      	cmp	r0, r3
3400e09e:	d00c      	beq.n	3400e0ba <RCCEx_GetUSARTCLKFreq+0x62>
3400e0a0:	d80f      	bhi.n	3400e0c2 <RCCEx_GetUSARTCLKFreq+0x6a>
3400e0a2:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400e0a6:	4298      	cmp	r0, r3
3400e0a8:	d007      	beq.n	3400e0ba <RCCEx_GetUSARTCLKFreq+0x62>
3400e0aa:	bf8e      	itee	hi
3400e0ac:	4b5e      	ldrhi	r3, [pc, #376]	@ (3400e228 <RCCEx_GetUSARTCLKFreq+0x1d0>)
3400e0ae:	f420 6080 	bicls.w	r0, r0, #1024	@ 0x400
3400e0b2:	f2a3 4304 	subwls	r3, r3, #1028	@ 0x404
3400e0b6:	4298      	cmp	r0, r3
3400e0b8:	d1eb      	bne.n	3400e092 <RCCEx_GetUSARTCLKFreq+0x3a>
}
3400e0ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e0be:	f7ff bdd3 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400e0c2:	4b5a      	ldr	r3, [pc, #360]	@ (3400e22c <RCCEx_GetUSARTCLKFreq+0x1d4>)
3400e0c4:	4298      	cmp	r0, r3
3400e0c6:	d007      	beq.n	3400e0d8 <RCCEx_GetUSARTCLKFreq+0x80>
3400e0c8:	bf8e      	itee	hi
3400e0ca:	4b59      	ldrhi	r3, [pc, #356]	@ (3400e230 <RCCEx_GetUSARTCLKFreq+0x1d8>)
3400e0cc:	f420 6080 	bicls.w	r0, r0, #1024	@ 0x400
3400e0d0:	f2a3 4304 	subwls	r3, r3, #1028	@ 0x404
3400e0d4:	4298      	cmp	r0, r3
3400e0d6:	d1dc      	bne.n	3400e092 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400e0d8:	f7fc fc3e 	bl	3400a958 <LL_RCC_IC9_IsEnabled>
3400e0dc:	2800      	cmp	r0, #0
3400e0de:	d0d8      	beq.n	3400e092 <RCCEx_GetUSARTCLKFreq+0x3a>
        ic_divider = LL_RCC_IC9_GetDivider();
3400e0e0:	f7fc fc42 	bl	3400a968 <LL_RCC_IC9_GetDivider>
3400e0e4:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400e0e6:	4b53      	ldr	r3, [pc, #332]	@ (3400e234 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400e0e8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400e0ec:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3400e0f0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e0f4:	f000 808e 	beq.w	3400e214 <RCCEx_GetUSARTCLKFreq+0x1bc>
3400e0f8:	f200 8082 	bhi.w	3400e200 <RCCEx_GetUSARTCLKFreq+0x1a8>
3400e0fc:	2b00      	cmp	r3, #0
3400e0fe:	f040 8086 	bne.w	3400e20e <RCCEx_GetUSARTCLKFreq+0x1b6>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e102:	f7ff fcb1 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
            usart_frequency = usart_frequency / ic_divider;
3400e106:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e10a:	e7c3      	b.n	3400e094 <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400e10c:	4b4a      	ldr	r3, [pc, #296]	@ (3400e238 <RCCEx_GetUSARTCLKFreq+0x1e0>)
3400e10e:	4298      	cmp	r0, r3
3400e110:	d045      	beq.n	3400e19e <RCCEx_GetUSARTCLKFreq+0x146>
3400e112:	d833      	bhi.n	3400e17c <RCCEx_GetUSARTCLKFreq+0x124>
3400e114:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e118:	4298      	cmp	r0, r3
3400e11a:	d028      	beq.n	3400e16e <RCCEx_GetUSARTCLKFreq+0x116>
3400e11c:	d81c      	bhi.n	3400e158 <RCCEx_GetUSARTCLKFreq+0x100>
3400e11e:	f5a3 437b 	sub.w	r3, r3, #64256	@ 0xfb00
3400e122:	3bfc      	subs	r3, #252	@ 0xfc
3400e124:	4298      	cmp	r0, r3
3400e126:	d006      	beq.n	3400e136 <RCCEx_GetUSARTCLKFreq+0xde>
3400e128:	d810      	bhi.n	3400e14c <RCCEx_GetUSARTCLKFreq+0xf4>
3400e12a:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e12e:	f2a3 4304 	subw	r3, r3, #1028	@ 0x404
3400e132:	4298      	cmp	r0, r3
3400e134:	d1ad      	bne.n	3400e092 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400e136:	f7fc fc21 	bl	3400a97c <LL_RCC_IC14_IsEnabled>
3400e13a:	2800      	cmp	r0, #0
3400e13c:	d0a9      	beq.n	3400e092 <RCCEx_GetUSARTCLKFreq+0x3a>
        ic_divider = LL_RCC_IC14_GetDivider();
3400e13e:	f7fc fc25 	bl	3400a98c <LL_RCC_IC14_GetDivider>
3400e142:	4b3c      	ldr	r3, [pc, #240]	@ (3400e234 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400e144:	4604      	mov	r4, r0
3400e146:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400e14a:	e7cf      	b.n	3400e0ec <RCCEx_GetUSARTCLKFreq+0x94>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400e14c:	4b3b      	ldr	r3, [pc, #236]	@ (3400e23c <RCCEx_GetUSARTCLKFreq+0x1e4>)
3400e14e:	4298      	cmp	r0, r3
3400e150:	d0f1      	beq.n	3400e136 <RCCEx_GetUSARTCLKFreq+0xde>
3400e152:	f503 6340 	add.w	r3, r3, #3072	@ 0xc00
3400e156:	e7ec      	b.n	3400e132 <RCCEx_GetUSARTCLKFreq+0xda>
3400e158:	4b39      	ldr	r3, [pc, #228]	@ (3400e240 <RCCEx_GetUSARTCLKFreq+0x1e8>)
3400e15a:	4298      	cmp	r0, r3
3400e15c:	d007      	beq.n	3400e16e <RCCEx_GetUSARTCLKFreq+0x116>
3400e15e:	bf8e      	itee	hi
3400e160:	4b38      	ldrhi	r3, [pc, #224]	@ (3400e244 <RCCEx_GetUSARTCLKFreq+0x1ec>)
3400e162:	f020 0004 	bicls.w	r0, r0, #4
3400e166:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3400e16a:	4298      	cmp	r0, r3
3400e16c:	d191      	bne.n	3400e092 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_LSE_IsReady() != 0U)
3400e16e:	f7fc fba7 	bl	3400a8c0 <LL_RCC_LSE_IsReady>
3400e172:	3800      	subs	r0, #0
3400e174:	bf18      	it	ne
3400e176:	2001      	movne	r0, #1
3400e178:	03c0      	lsls	r0, r0, #15
3400e17a:	e78b      	b.n	3400e094 <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400e17c:	4b32      	ldr	r3, [pc, #200]	@ (3400e248 <RCCEx_GetUSARTCLKFreq+0x1f0>)
3400e17e:	4298      	cmp	r0, r3
3400e180:	d020      	beq.n	3400e1c4 <RCCEx_GetUSARTCLKFreq+0x16c>
3400e182:	d813      	bhi.n	3400e1ac <RCCEx_GetUSARTCLKFreq+0x154>
3400e184:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400e188:	4298      	cmp	r0, r3
3400e18a:	d008      	beq.n	3400e19e <RCCEx_GetUSARTCLKFreq+0x146>
3400e18c:	bf8e      	itee	hi
3400e18e:	4b2f      	ldrhi	r3, [pc, #188]	@ (3400e24c <RCCEx_GetUSARTCLKFreq+0x1f4>)
3400e190:	f020 0004 	bicls.w	r0, r0, #4
3400e194:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3400e198:	4298      	cmp	r0, r3
3400e19a:	f47f af7a 	bne.w	3400e092 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_MSI_IsReady() != 0U)
3400e19e:	f7fc fb87 	bl	3400a8b0 <LL_RCC_MSI_IsReady>
3400e1a2:	2800      	cmp	r0, #0
3400e1a4:	f43f af75 	beq.w	3400e092 <RCCEx_GetUSARTCLKFreq+0x3a>
        usart_frequency = MSI_VALUE;
3400e1a8:	4829      	ldr	r0, [pc, #164]	@ (3400e250 <RCCEx_GetUSARTCLKFreq+0x1f8>)
  return usart_frequency;
3400e1aa:	e773      	b.n	3400e094 <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400e1ac:	4b29      	ldr	r3, [pc, #164]	@ (3400e254 <RCCEx_GetUSARTCLKFreq+0x1fc>)
3400e1ae:	4298      	cmp	r0, r3
3400e1b0:	d008      	beq.n	3400e1c4 <RCCEx_GetUSARTCLKFreq+0x16c>
3400e1b2:	bf8e      	itee	hi
3400e1b4:	4b28      	ldrhi	r3, [pc, #160]	@ (3400e258 <RCCEx_GetUSARTCLKFreq+0x200>)
3400e1b6:	f020 0004 	bicls.w	r0, r0, #4
3400e1ba:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3400e1be:	4298      	cmp	r0, r3
3400e1c0:	f47f af67 	bne.w	3400e092 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e1c4:	f7fc fb6c 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400e1c8:	2800      	cmp	r0, #0
3400e1ca:	f43f af62 	beq.w	3400e092 <RCCEx_GetUSARTCLKFreq+0x3a>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e1ce:	4b19      	ldr	r3, [pc, #100]	@ (3400e234 <RCCEx_GetUSARTCLKFreq+0x1dc>)
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e1d0:	4822      	ldr	r0, [pc, #136]	@ (3400e25c <RCCEx_GetUSARTCLKFreq+0x204>)
3400e1d2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e1d4:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400e1d8:	e007      	b.n	3400e1ea <RCCEx_GetUSARTCLKFreq+0x192>
      usart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e1da:	f7fc fb23 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400e1de:	f7fc fbf1 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400e1e2:	4b14      	ldr	r3, [pc, #80]	@ (3400e234 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400e1e4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400e1e6:	f3c3 1302 	ubfx	r3, r3, #4, #3
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e1ea:	40d8      	lsrs	r0, r3
3400e1ec:	e752      	b.n	3400e094 <RCCEx_GetUSARTCLKFreq+0x3c>
      usart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e1ee:	f7fc fb19 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400e1f2:	f7fc fbe7 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e1f6:	4b0f      	ldr	r3, [pc, #60]	@ (3400e234 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400e1f8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e1fa:	f003 0307 	and.w	r3, r3, #7
3400e1fe:	e7f4      	b.n	3400e1ea <RCCEx_GetUSARTCLKFreq+0x192>
        switch (LL_RCC_IC14_GetSource())
3400e200:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e204:	f47f af45 	bne.w	3400e092 <RCCEx_GetUSARTCLKFreq+0x3a>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e208:	f7ff fcee 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400e20c:	e77b      	b.n	3400e106 <RCCEx_GetUSARTCLKFreq+0xae>
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e20e:	f7ff fc6b 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400e212:	e778      	b.n	3400e106 <RCCEx_GetUSARTCLKFreq+0xae>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e214:	f7ff fca8 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400e218:	e775      	b.n	3400e106 <RCCEx_GetUSARTCLKFreq+0xae>
3400e21a:	bf00      	nop
3400e21c:	07021430 	.word	0x07021430
3400e220:	07000830 	.word	0x07000830
3400e224:	07011430 	.word	0x07011430
3400e228:	07010830 	.word	0x07010830
3400e22c:	07020434 	.word	0x07020434
3400e230:	07020830 	.word	0x07020830
3400e234:	56028000 	.word	0x56028000
3400e238:	07050030 	.word	0x07050030
3400e23c:	07030830 	.word	0x07030830
3400e240:	07040830 	.word	0x07040830
3400e244:	07041430 	.word	0x07041430
3400e248:	07060030 	.word	0x07060030
3400e24c:	07051430 	.word	0x07051430
3400e250:	003d0900 	.word	0x003d0900
3400e254:	07060830 	.word	0x07060830
3400e258:	07061430 	.word	0x07061430
3400e25c:	03d09000 	.word	0x03d09000

3400e260 <RCCEx_GetUARTCLKFreq>:
{
3400e260:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e262:	f7fc fb47 	bl	3400a8f4 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400e266:	4b77      	ldr	r3, [pc, #476]	@ (3400e444 <RCCEx_GetUARTCLKFreq+0x1e4>)
3400e268:	4298      	cmp	r0, r3
3400e26a:	d03e      	beq.n	3400e2ea <RCCEx_GetUARTCLKFreq+0x8a>
3400e26c:	d859      	bhi.n	3400e322 <RCCEx_GetUARTCLKFreq+0xc2>
3400e26e:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3400e272:	4298      	cmp	r0, r3
3400e274:	f000 80c6 	beq.w	3400e404 <RCCEx_GetUARTCLKFreq+0x1a4>
3400e278:	d814      	bhi.n	3400e2a4 <RCCEx_GetUARTCLKFreq+0x44>
3400e27a:	4b73      	ldr	r3, [pc, #460]	@ (3400e448 <RCCEx_GetUARTCLKFreq+0x1e8>)
3400e27c:	4298      	cmp	r0, r3
3400e27e:	f000 80cb 	beq.w	3400e418 <RCCEx_GetUARTCLKFreq+0x1b8>
3400e282:	3b01      	subs	r3, #1
3400e284:	4298      	cmp	r0, r3
3400e286:	d90b      	bls.n	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
3400e288:	f420 6200 	bic.w	r2, r0, #2048	@ 0x800
3400e28c:	f603 73fd 	addw	r3, r3, #4093	@ 0xffd
3400e290:	429a      	cmp	r2, r3
3400e292:	f000 80b7 	beq.w	3400e404 <RCCEx_GetUARTCLKFreq+0x1a4>
3400e296:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3400e29a:	4298      	cmp	r0, r3
3400e29c:	f000 80b2 	beq.w	3400e404 <RCCEx_GetUARTCLKFreq+0x1a4>
  uint32_t uart_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e2a0:	2000      	movs	r0, #0
}
3400e2a2:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400e2a4:	4b69      	ldr	r3, [pc, #420]	@ (3400e44c <RCCEx_GetUARTCLKFreq+0x1ec>)
3400e2a6:	4298      	cmp	r0, r3
3400e2a8:	d00d      	beq.n	3400e2c6 <RCCEx_GetUARTCLKFreq+0x66>
3400e2aa:	d812      	bhi.n	3400e2d2 <RCCEx_GetUARTCLKFreq+0x72>
3400e2ac:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400e2b0:	4298      	cmp	r0, r3
3400e2b2:	d008      	beq.n	3400e2c6 <RCCEx_GetUARTCLKFreq+0x66>
3400e2b4:	d80b      	bhi.n	3400e2ce <RCCEx_GetUARTCLKFreq+0x6e>
3400e2b6:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400e2ba:	4298      	cmp	r0, r3
3400e2bc:	d003      	beq.n	3400e2c6 <RCCEx_GetUARTCLKFreq+0x66>
3400e2be:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3400e2c2:	4298      	cmp	r0, r3
3400e2c4:	d1ec      	bne.n	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
}
3400e2c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      uart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e2ca:	f7ff bccd 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400e2ce:	4b60      	ldr	r3, [pc, #384]	@ (3400e450 <RCCEx_GetUARTCLKFreq+0x1f0>)
3400e2d0:	e7f7      	b.n	3400e2c2 <RCCEx_GetUARTCLKFreq+0x62>
3400e2d2:	4b60      	ldr	r3, [pc, #384]	@ (3400e454 <RCCEx_GetUARTCLKFreq+0x1f4>)
3400e2d4:	4298      	cmp	r0, r3
3400e2d6:	d008      	beq.n	3400e2ea <RCCEx_GetUARTCLKFreq+0x8a>
3400e2d8:	d821      	bhi.n	3400e31e <RCCEx_GetUARTCLKFreq+0xbe>
3400e2da:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400e2de:	4298      	cmp	r0, r3
3400e2e0:	d003      	beq.n	3400e2ea <RCCEx_GetUARTCLKFreq+0x8a>
3400e2e2:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3400e2e6:	4298      	cmp	r0, r3
3400e2e8:	d1da      	bne.n	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400e2ea:	f7fc fb35 	bl	3400a958 <LL_RCC_IC9_IsEnabled>
3400e2ee:	2800      	cmp	r0, #0
3400e2f0:	d0d6      	beq.n	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
        ic_divider = LL_RCC_IC9_GetDivider();
3400e2f2:	f7fc fb39 	bl	3400a968 <LL_RCC_IC9_GetDivider>
3400e2f6:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400e2f8:	4b57      	ldr	r3, [pc, #348]	@ (3400e458 <RCCEx_GetUARTCLKFreq+0x1f8>)
3400e2fa:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400e2fe:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3400e302:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e306:	f000 809a 	beq.w	3400e43e <RCCEx_GetUARTCLKFreq+0x1de>
3400e30a:	f200 808e 	bhi.w	3400e42a <RCCEx_GetUARTCLKFreq+0x1ca>
3400e30e:	2b00      	cmp	r3, #0
3400e310:	f040 8092 	bne.w	3400e438 <RCCEx_GetUARTCLKFreq+0x1d8>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e314:	f7ff fba8 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
            uart_frequency = uart_frequency / ic_divider;
3400e318:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e31c:	e7c1      	b.n	3400e2a2 <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400e31e:	4b4f      	ldr	r3, [pc, #316]	@ (3400e45c <RCCEx_GetUARTCLKFreq+0x1fc>)
3400e320:	e7e1      	b.n	3400e2e6 <RCCEx_GetUARTCLKFreq+0x86>
3400e322:	4b4f      	ldr	r3, [pc, #316]	@ (3400e460 <RCCEx_GetUARTCLKFreq+0x200>)
3400e324:	4298      	cmp	r0, r3
3400e326:	d04a      	beq.n	3400e3be <RCCEx_GetUARTCLKFreq+0x15e>
3400e328:	d836      	bhi.n	3400e398 <RCCEx_GetUARTCLKFreq+0x138>
3400e32a:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e32e:	4298      	cmp	r0, r3
3400e330:	d029      	beq.n	3400e386 <RCCEx_GetUARTCLKFreq+0x126>
3400e332:	d81c      	bhi.n	3400e36e <RCCEx_GetUARTCLKFreq+0x10e>
3400e334:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400e338:	3b04      	subs	r3, #4
3400e33a:	4298      	cmp	r0, r3
3400e33c:	d008      	beq.n	3400e350 <RCCEx_GetUARTCLKFreq+0xf0>
3400e33e:	d812      	bhi.n	3400e366 <RCCEx_GetUARTCLKFreq+0x106>
3400e340:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400e344:	4298      	cmp	r0, r3
3400e346:	d003      	beq.n	3400e350 <RCCEx_GetUARTCLKFreq+0xf0>
3400e348:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3400e34c:	4298      	cmp	r0, r3
3400e34e:	d1a7      	bne.n	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400e350:	f7fc fb14 	bl	3400a97c <LL_RCC_IC14_IsEnabled>
3400e354:	2800      	cmp	r0, #0
3400e356:	d0a3      	beq.n	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
        ic_divider = LL_RCC_IC14_GetDivider();
3400e358:	f7fc fb18 	bl	3400a98c <LL_RCC_IC14_GetDivider>
3400e35c:	4b3e      	ldr	r3, [pc, #248]	@ (3400e458 <RCCEx_GetUARTCLKFreq+0x1f8>)
3400e35e:	4604      	mov	r4, r0
3400e360:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400e364:	e7cb      	b.n	3400e2fe <RCCEx_GetUARTCLKFreq+0x9e>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400e366:	4b3f      	ldr	r3, [pc, #252]	@ (3400e464 <RCCEx_GetUARTCLKFreq+0x204>)
3400e368:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e36c:	e7ee      	b.n	3400e34c <RCCEx_GetUARTCLKFreq+0xec>
3400e36e:	4b3e      	ldr	r3, [pc, #248]	@ (3400e468 <RCCEx_GetUARTCLKFreq+0x208>)
3400e370:	4298      	cmp	r0, r3
3400e372:	d008      	beq.n	3400e386 <RCCEx_GetUARTCLKFreq+0x126>
3400e374:	d80e      	bhi.n	3400e394 <RCCEx_GetUARTCLKFreq+0x134>
3400e376:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400e37a:	4298      	cmp	r0, r3
3400e37c:	d003      	beq.n	3400e386 <RCCEx_GetUARTCLKFreq+0x126>
3400e37e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e382:	4298      	cmp	r0, r3
3400e384:	d18c      	bne.n	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_LSE_IsReady() != 0U)
3400e386:	f7fc fa9b 	bl	3400a8c0 <LL_RCC_LSE_IsReady>
3400e38a:	3800      	subs	r0, #0
3400e38c:	bf18      	it	ne
3400e38e:	2001      	movne	r0, #1
3400e390:	03c0      	lsls	r0, r0, #15
3400e392:	e786      	b.n	3400e2a2 <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400e394:	4b35      	ldr	r3, [pc, #212]	@ (3400e46c <RCCEx_GetUARTCLKFreq+0x20c>)
3400e396:	e7f4      	b.n	3400e382 <RCCEx_GetUARTCLKFreq+0x122>
3400e398:	4b35      	ldr	r3, [pc, #212]	@ (3400e470 <RCCEx_GetUARTCLKFreq+0x210>)
3400e39a:	4298      	cmp	r0, r3
3400e39c:	d025      	beq.n	3400e3ea <RCCEx_GetUARTCLKFreq+0x18a>
3400e39e:	d817      	bhi.n	3400e3d0 <RCCEx_GetUARTCLKFreq+0x170>
3400e3a0:	f5a3 4368 	sub.w	r3, r3, #59392	@ 0xe800
3400e3a4:	3b04      	subs	r3, #4
3400e3a6:	4298      	cmp	r0, r3
3400e3a8:	d009      	beq.n	3400e3be <RCCEx_GetUARTCLKFreq+0x15e>
3400e3aa:	d80f      	bhi.n	3400e3cc <RCCEx_GetUARTCLKFreq+0x16c>
3400e3ac:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400e3b0:	4298      	cmp	r0, r3
3400e3b2:	d004      	beq.n	3400e3be <RCCEx_GetUARTCLKFreq+0x15e>
3400e3b4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e3b8:	4298      	cmp	r0, r3
3400e3ba:	f47f af71 	bne.w	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_MSI_IsReady() != 0U)
3400e3be:	f7fc fa77 	bl	3400a8b0 <LL_RCC_MSI_IsReady>
3400e3c2:	2800      	cmp	r0, #0
3400e3c4:	f43f af6c 	beq.w	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
        uart_frequency = MSI_VALUE;
3400e3c8:	482a      	ldr	r0, [pc, #168]	@ (3400e474 <RCCEx_GetUARTCLKFreq+0x214>)
  return uart_frequency;
3400e3ca:	e76a      	b.n	3400e2a2 <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400e3cc:	4b2a      	ldr	r3, [pc, #168]	@ (3400e478 <RCCEx_GetUARTCLKFreq+0x218>)
3400e3ce:	e7f3      	b.n	3400e3b8 <RCCEx_GetUARTCLKFreq+0x158>
3400e3d0:	4b2a      	ldr	r3, [pc, #168]	@ (3400e47c <RCCEx_GetUARTCLKFreq+0x21c>)
3400e3d2:	4298      	cmp	r0, r3
3400e3d4:	d009      	beq.n	3400e3ea <RCCEx_GetUARTCLKFreq+0x18a>
3400e3d6:	d813      	bhi.n	3400e400 <RCCEx_GetUARTCLKFreq+0x1a0>
3400e3d8:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400e3dc:	4298      	cmp	r0, r3
3400e3de:	d004      	beq.n	3400e3ea <RCCEx_GetUARTCLKFreq+0x18a>
3400e3e0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e3e4:	4298      	cmp	r0, r3
3400e3e6:	f47f af5b 	bne.w	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e3ea:	f7fc fa59 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400e3ee:	2800      	cmp	r0, #0
3400e3f0:	f43f af56 	beq.w	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e3f4:	4b18      	ldr	r3, [pc, #96]	@ (3400e458 <RCCEx_GetUARTCLKFreq+0x1f8>)
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e3f6:	4822      	ldr	r0, [pc, #136]	@ (3400e480 <RCCEx_GetUARTCLKFreq+0x220>)
3400e3f8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e3fa:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400e3fe:	e009      	b.n	3400e414 <RCCEx_GetUARTCLKFreq+0x1b4>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400e400:	4b20      	ldr	r3, [pc, #128]	@ (3400e484 <RCCEx_GetUARTCLKFreq+0x224>)
3400e402:	e7ef      	b.n	3400e3e4 <RCCEx_GetUARTCLKFreq+0x184>
      uart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e404:	f7fc fa0e 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400e408:	f7fc fadc 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e40c:	4b12      	ldr	r3, [pc, #72]	@ (3400e458 <RCCEx_GetUARTCLKFreq+0x1f8>)
3400e40e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e410:	f003 0307 	and.w	r3, r3, #7
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e414:	40d8      	lsrs	r0, r3
3400e416:	e744      	b.n	3400e2a2 <RCCEx_GetUARTCLKFreq+0x42>
      uart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e418:	f7fc fa04 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400e41c:	f7fc fad2 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400e420:	4b0d      	ldr	r3, [pc, #52]	@ (3400e458 <RCCEx_GetUARTCLKFreq+0x1f8>)
3400e422:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400e424:	f3c3 1302 	ubfx	r3, r3, #4, #3
3400e428:	e7f4      	b.n	3400e414 <RCCEx_GetUARTCLKFreq+0x1b4>
        switch (LL_RCC_IC14_GetSource())
3400e42a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e42e:	f47f af37 	bne.w	3400e2a0 <RCCEx_GetUARTCLKFreq+0x40>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e432:	f7ff fbd9 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400e436:	e76f      	b.n	3400e318 <RCCEx_GetUARTCLKFreq+0xb8>
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e438:	f7ff fb56 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400e43c:	e76c      	b.n	3400e318 <RCCEx_GetUARTCLKFreq+0xb8>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e43e:	f7ff fb93 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400e442:	e769      	b.n	3400e318 <RCCEx_GetUARTCLKFreq+0xb8>
3400e444:	07021c30 	.word	0x07021c30
3400e448:	07000034 	.word	0x07000034
3400e44c:	07011c30 	.word	0x07011c30
3400e450:	07011830 	.word	0x07011830
3400e454:	07021030 	.word	0x07021030
3400e458:	56028000 	.word	0x56028000
3400e45c:	07021830 	.word	0x07021830
3400e460:	07050034 	.word	0x07050034
3400e464:	07031830 	.word	0x07031830
3400e468:	07041830 	.word	0x07041830
3400e46c:	07041c30 	.word	0x07041c30
3400e470:	07060034 	.word	0x07060034
3400e474:	003d0900 	.word	0x003d0900
3400e478:	07051c30 	.word	0x07051c30
3400e47c:	07061830 	.word	0x07061830
3400e480:	03d09000 	.word	0x03d09000
3400e484:	07061c30 	.word	0x07061c30

3400e488 <RCCEx_GetSPICLKFreq>:
{
3400e488:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e48a:	f7fc fa33 	bl	3400a8f4 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400e48e:	4b89      	ldr	r3, [pc, #548]	@ (3400e6b4 <RCCEx_GetSPICLKFreq+0x22c>)
3400e490:	4298      	cmp	r0, r3
3400e492:	d055      	beq.n	3400e540 <RCCEx_GetSPICLKFreq+0xb8>
3400e494:	d865      	bhi.n	3400e562 <RCCEx_GetSPICLKFreq+0xda>
3400e496:	f5a3 333c 	sub.w	r3, r3, #192512	@ 0x2f000
3400e49a:	4298      	cmp	r0, r3
3400e49c:	f000 80ca 	beq.w	3400e634 <RCCEx_GetSPICLKFreq+0x1ac>
3400e4a0:	d81e      	bhi.n	3400e4e0 <RCCEx_GetSPICLKFreq+0x58>
3400e4a2:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400e4a6:	4298      	cmp	r0, r3
3400e4a8:	f000 80ba 	beq.w	3400e620 <RCCEx_GetSPICLKFreq+0x198>
3400e4ac:	d80a      	bhi.n	3400e4c4 <RCCEx_GetSPICLKFreq+0x3c>
3400e4ae:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e4b2:	4298      	cmp	r0, r3
3400e4b4:	d00b      	beq.n	3400e4ce <RCCEx_GetSPICLKFreq+0x46>
3400e4b6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e4ba:	4298      	cmp	r0, r3
3400e4bc:	f000 80b0 	beq.w	3400e620 <RCCEx_GetSPICLKFreq+0x198>
  uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e4c0:	2000      	movs	r0, #0
}
3400e4c2:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400e4c4:	4b7c      	ldr	r3, [pc, #496]	@ (3400e6b8 <RCCEx_GetSPICLKFreq+0x230>)
3400e4c6:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e4ca:	4298      	cmp	r0, r3
3400e4cc:	d1f8      	bne.n	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
      spi_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e4ce:	f7fc f9a9 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400e4d2:	f7fc fa77 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400e4d6:	4b79      	ldr	r3, [pc, #484]	@ (3400e6bc <RCCEx_GetSPICLKFreq+0x234>)
3400e4d8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400e4da:	f3c3 1302 	ubfx	r3, r3, #4, #3
3400e4de:	e0a7      	b.n	3400e630 <RCCEx_GetSPICLKFreq+0x1a8>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400e4e0:	4b77      	ldr	r3, [pc, #476]	@ (3400e6c0 <RCCEx_GetSPICLKFreq+0x238>)
3400e4e2:	4298      	cmp	r0, r3
3400e4e4:	f000 80af 	beq.w	3400e646 <RCCEx_GetSPICLKFreq+0x1be>
3400e4e8:	d81d      	bhi.n	3400e526 <RCCEx_GetSPICLKFreq+0x9e>
3400e4ea:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400e4ee:	4298      	cmp	r0, r3
3400e4f0:	d00a      	beq.n	3400e508 <RCCEx_GetSPICLKFreq+0x80>
3400e4f2:	d80d      	bhi.n	3400e510 <RCCEx_GetSPICLKFreq+0x88>
3400e4f4:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e4f8:	4298      	cmp	r0, r3
3400e4fa:	d005      	beq.n	3400e508 <RCCEx_GetSPICLKFreq+0x80>
3400e4fc:	f420 6000 	bic.w	r0, r0, #2048	@ 0x800
3400e500:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3400e504:	4298      	cmp	r0, r3
3400e506:	d1db      	bne.n	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
}
3400e508:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      spi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e50c:	f7ff bbac 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400e510:	4b6c      	ldr	r3, [pc, #432]	@ (3400e6c4 <RCCEx_GetSPICLKFreq+0x23c>)
3400e512:	4298      	cmp	r0, r3
3400e514:	d0f8      	beq.n	3400e508 <RCCEx_GetSPICLKFreq+0x80>
3400e516:	f503 436c 	add.w	r3, r3, #60416	@ 0xec00
3400e51a:	4298      	cmp	r0, r3
3400e51c:	f000 8093 	beq.w	3400e646 <RCCEx_GetSPICLKFreq+0x1be>
3400e520:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400e524:	e7ee      	b.n	3400e504 <RCCEx_GetSPICLKFreq+0x7c>
3400e526:	4b68      	ldr	r3, [pc, #416]	@ (3400e6c8 <RCCEx_GetSPICLKFreq+0x240>)
3400e528:	4298      	cmp	r0, r3
3400e52a:	d009      	beq.n	3400e540 <RCCEx_GetSPICLKFreq+0xb8>
3400e52c:	d813      	bhi.n	3400e556 <RCCEx_GetSPICLKFreq+0xce>
3400e52e:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e532:	4298      	cmp	r0, r3
3400e534:	f000 8087 	beq.w	3400e646 <RCCEx_GetSPICLKFreq+0x1be>
3400e538:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e53c:	4298      	cmp	r0, r3
3400e53e:	d1bf      	bne.n	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400e540:	f7fc fa0a 	bl	3400a958 <LL_RCC_IC9_IsEnabled>
3400e544:	2800      	cmp	r0, #0
3400e546:	d0bb      	beq.n	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC9_GetDivider();
3400e548:	f7fc fa0e 	bl	3400a968 <LL_RCC_IC9_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400e54c:	4b5b      	ldr	r3, [pc, #364]	@ (3400e6bc <RCCEx_GetSPICLKFreq+0x234>)
3400e54e:	4604      	mov	r4, r0
3400e550:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400e554:	e082      	b.n	3400e65c <RCCEx_GetSPICLKFreq+0x1d4>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400e556:	4b5d      	ldr	r3, [pc, #372]	@ (3400e6cc <RCCEx_GetSPICLKFreq+0x244>)
3400e558:	4298      	cmp	r0, r3
3400e55a:	d074      	beq.n	3400e646 <RCCEx_GetSPICLKFreq+0x1be>
3400e55c:	f503 436c 	add.w	r3, r3, #60416	@ 0xec00
3400e560:	e7ec      	b.n	3400e53c <RCCEx_GetSPICLKFreq+0xb4>
3400e562:	4b5b      	ldr	r3, [pc, #364]	@ (3400e6d0 <RCCEx_GetSPICLKFreq+0x248>)
3400e564:	4298      	cmp	r0, r3
3400e566:	d043      	beq.n	3400e5f0 <RCCEx_GetSPICLKFreq+0x168>
3400e568:	d830      	bhi.n	3400e5cc <RCCEx_GetSPICLKFreq+0x144>
3400e56a:	f5a3 33fa 	sub.w	r3, r3, #128000	@ 0x1f400
3400e56e:	4298      	cmp	r0, r3
3400e570:	d0e6      	beq.n	3400e540 <RCCEx_GetSPICLKFreq+0xb8>
3400e572:	d808      	bhi.n	3400e586 <RCCEx_GetSPICLKFreq+0xfe>
3400e574:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400e578:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e57c:	429a      	cmp	r2, r3
3400e57e:	d079      	beq.n	3400e674 <RCCEx_GetSPICLKFreq+0x1ec>
3400e580:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3400e584:	e7da      	b.n	3400e53c <RCCEx_GetSPICLKFreq+0xb4>
3400e586:	4b53      	ldr	r3, [pc, #332]	@ (3400e6d4 <RCCEx_GetSPICLKFreq+0x24c>)
3400e588:	4298      	cmp	r0, r3
3400e58a:	d00d      	beq.n	3400e5a8 <RCCEx_GetSPICLKFreq+0x120>
3400e58c:	d814      	bhi.n	3400e5b8 <RCCEx_GetSPICLKFreq+0x130>
3400e58e:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e592:	4298      	cmp	r0, r3
3400e594:	d008      	beq.n	3400e5a8 <RCCEx_GetSPICLKFreq+0x120>
3400e596:	d80d      	bhi.n	3400e5b4 <RCCEx_GetSPICLKFreq+0x12c>
3400e598:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e59c:	4298      	cmp	r0, r3
3400e59e:	d003      	beq.n	3400e5a8 <RCCEx_GetSPICLKFreq+0x120>
3400e5a0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e5a4:	4298      	cmp	r0, r3
3400e5a6:	d18b      	bne.n	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_MSI_IsReady() != 0U)
3400e5a8:	f7fc f982 	bl	3400a8b0 <LL_RCC_MSI_IsReady>
3400e5ac:	2800      	cmp	r0, #0
3400e5ae:	d087      	beq.n	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
        spi_frequency = MSI_VALUE;
3400e5b0:	4849      	ldr	r0, [pc, #292]	@ (3400e6d8 <RCCEx_GetSPICLKFreq+0x250>)
  return spi_frequency;
3400e5b2:	e786      	b.n	3400e4c2 <RCCEx_GetSPICLKFreq+0x3a>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400e5b4:	4b49      	ldr	r3, [pc, #292]	@ (3400e6dc <RCCEx_GetSPICLKFreq+0x254>)
3400e5b6:	e7f5      	b.n	3400e5a4 <RCCEx_GetSPICLKFreq+0x11c>
3400e5b8:	4b49      	ldr	r3, [pc, #292]	@ (3400e6e0 <RCCEx_GetSPICLKFreq+0x258>)
3400e5ba:	4298      	cmp	r0, r3
3400e5bc:	d018      	beq.n	3400e5f0 <RCCEx_GetSPICLKFreq+0x168>
3400e5be:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e5c2:	4298      	cmp	r0, r3
3400e5c4:	d014      	beq.n	3400e5f0 <RCCEx_GetSPICLKFreq+0x168>
3400e5c6:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400e5ca:	e7eb      	b.n	3400e5a4 <RCCEx_GetSPICLKFreq+0x11c>
3400e5cc:	4b45      	ldr	r3, [pc, #276]	@ (3400e6e4 <RCCEx_GetSPICLKFreq+0x25c>)
3400e5ce:	4298      	cmp	r0, r3
3400e5d0:	d069      	beq.n	3400e6a6 <RCCEx_GetSPICLKFreq+0x21e>
3400e5d2:	d81e      	bhi.n	3400e612 <RCCEx_GetSPICLKFreq+0x18a>
3400e5d4:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400e5d8:	4298      	cmp	r0, r3
3400e5da:	d018      	beq.n	3400e60e <RCCEx_GetSPICLKFreq+0x186>
3400e5dc:	f420 6380 	bic.w	r3, r0, #1024	@ 0x400
3400e5e0:	d811      	bhi.n	3400e606 <RCCEx_GetSPICLKFreq+0x17e>
3400e5e2:	4a41      	ldr	r2, [pc, #260]	@ (3400e6e8 <RCCEx_GetSPICLKFreq+0x260>)
3400e5e4:	4293      	cmp	r3, r2
3400e5e6:	d003      	beq.n	3400e5f0 <RCCEx_GetSPICLKFreq+0x168>
3400e5e8:	4b40      	ldr	r3, [pc, #256]	@ (3400e6ec <RCCEx_GetSPICLKFreq+0x264>)
3400e5ea:	4298      	cmp	r0, r3
3400e5ec:	f47f af68 	bne.w	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e5f0:	f7fc f956 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400e5f4:	2800      	cmp	r0, #0
3400e5f6:	f43f af63 	beq.w	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e5fa:	4b30      	ldr	r3, [pc, #192]	@ (3400e6bc <RCCEx_GetSPICLKFreq+0x234>)
        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e5fc:	483c      	ldr	r0, [pc, #240]	@ (3400e6f0 <RCCEx_GetSPICLKFreq+0x268>)
3400e5fe:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e600:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400e604:	e014      	b.n	3400e630 <RCCEx_GetSPICLKFreq+0x1a8>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400e606:	4a3b      	ldr	r2, [pc, #236]	@ (3400e6f4 <RCCEx_GetSPICLKFreq+0x26c>)
3400e608:	4293      	cmp	r3, r2
3400e60a:	f47f af59 	bne.w	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
3400e60e:	483a      	ldr	r0, [pc, #232]	@ (3400e6f8 <RCCEx_GetSPICLKFreq+0x270>)
3400e610:	e757      	b.n	3400e4c2 <RCCEx_GetSPICLKFreq+0x3a>
3400e612:	4b3a      	ldr	r3, [pc, #232]	@ (3400e6fc <RCCEx_GetSPICLKFreq+0x274>)
3400e614:	4298      	cmp	r0, r3
3400e616:	d046      	beq.n	3400e6a6 <RCCEx_GetSPICLKFreq+0x21e>
3400e618:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e61c:	4298      	cmp	r0, r3
3400e61e:	e7f4      	b.n	3400e60a <RCCEx_GetSPICLKFreq+0x182>
      spi_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e620:	f7fc f900 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400e624:	f7fc f9ce 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e628:	4b24      	ldr	r3, [pc, #144]	@ (3400e6bc <RCCEx_GetSPICLKFreq+0x234>)
3400e62a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e62c:	f003 0307 	and.w	r3, r3, #7
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400e630:	40d8      	lsrs	r0, r3
      break;
3400e632:	e746      	b.n	3400e4c2 <RCCEx_GetSPICLKFreq+0x3a>
      spi_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e634:	f7fc f8f6 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400e638:	f7fc f9c4 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400e63c:	4b1f      	ldr	r3, [pc, #124]	@ (3400e6bc <RCCEx_GetSPICLKFreq+0x234>)
3400e63e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400e640:	f3c3 3302 	ubfx	r3, r3, #12, #3
3400e644:	e7f4      	b.n	3400e630 <RCCEx_GetSPICLKFreq+0x1a8>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400e646:	f7fc f975 	bl	3400a934 <LL_RCC_IC8_IsEnabled>
3400e64a:	2800      	cmp	r0, #0
3400e64c:	f43f af38 	beq.w	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC8_GetDivider();
3400e650:	f7fc f978 	bl	3400a944 <LL_RCC_IC8_GetDivider>
3400e654:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400e656:	4b19      	ldr	r3, [pc, #100]	@ (3400e6bc <RCCEx_GetSPICLKFreq+0x234>)
3400e658:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400e65c:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3400e660:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e664:	d01c      	beq.n	3400e6a0 <RCCEx_GetSPICLKFreq+0x218>
3400e666:	d811      	bhi.n	3400e68c <RCCEx_GetSPICLKFreq+0x204>
3400e668:	b9bb      	cbnz	r3, 3400e69a <RCCEx_GetSPICLKFreq+0x212>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e66a:	f7ff f9fd 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
            spi_frequency = spi_frequency / ic_divider;
3400e66e:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e672:	e726      	b.n	3400e4c2 <RCCEx_GetSPICLKFreq+0x3a>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400e674:	f7fc f982 	bl	3400a97c <LL_RCC_IC14_IsEnabled>
3400e678:	2800      	cmp	r0, #0
3400e67a:	f43f af21 	beq.w	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC14_GetDivider();
3400e67e:	f7fc f985 	bl	3400a98c <LL_RCC_IC14_GetDivider>
3400e682:	4b0e      	ldr	r3, [pc, #56]	@ (3400e6bc <RCCEx_GetSPICLKFreq+0x234>)
3400e684:	4604      	mov	r4, r0
3400e686:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400e68a:	e7e7      	b.n	3400e65c <RCCEx_GetSPICLKFreq+0x1d4>
        switch (LL_RCC_IC14_GetSource())
3400e68c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e690:	f47f af16 	bne.w	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e694:	f7ff faa8 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400e698:	e7e9      	b.n	3400e66e <RCCEx_GetSPICLKFreq+0x1e6>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e69a:	f7ff fa25 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400e69e:	e7e6      	b.n	3400e66e <RCCEx_GetSPICLKFreq+0x1e6>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e6a0:	f7ff fa62 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400e6a4:	e7e3      	b.n	3400e66e <RCCEx_GetSPICLKFreq+0x1e6>
      if (LL_RCC_HSE_IsReady() != 0U)
3400e6a6:	f7fc f8f3 	bl	3400a890 <LL_RCC_HSE_IsReady>
3400e6aa:	2800      	cmp	r0, #0
3400e6ac:	f43f af08 	beq.w	3400e4c0 <RCCEx_GetSPICLKFreq+0x38>
        spi_frequency = HSE_VALUE;
3400e6b0:	4813      	ldr	r0, [pc, #76]	@ (3400e700 <RCCEx_GetSPICLKFreq+0x278>)
3400e6b2:	e706      	b.n	3400e4c2 <RCCEx_GetSPICLKFreq+0x3a>
3400e6b4:	07030820 	.word	0x07030820
3400e6b8:	07001020 	.word	0x07001020
3400e6bc:	56028000 	.word	0x56028000
3400e6c0:	07020820 	.word	0x07020820
3400e6c4:	07011820 	.word	0x07011820
3400e6c8:	07021420 	.word	0x07021420
3400e6cc:	07021820 	.word	0x07021820
3400e6d0:	07050c20 	.word	0x07050c20
3400e6d4:	07041420 	.word	0x07041420
3400e6d8:	003d0900 	.word	0x003d0900
3400e6dc:	07041020 	.word	0x07041020
3400e6e0:	07050420 	.word	0x07050420
3400e6e4:	07061020 	.word	0x07061020
3400e6e8:	07051020 	.word	0x07051020
3400e6ec:	07051820 	.word	0x07051820
3400e6f0:	03d09000 	.word	0x03d09000
3400e6f4:	07060820 	.word	0x07060820
3400e6f8:	00bb8000 	.word	0x00bb8000
3400e6fc:	07061420 	.word	0x07061420
3400e700:	02dc6c00 	.word	0x02dc6c00

3400e704 <RCCEx_GetSAICLKFreq>:
{
3400e704:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e706:	f7fc f8f5 	bl	3400a8f4 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e70a:	4b49      	ldr	r3, [pc, #292]	@ (3400e830 <RCCEx_GetSAICLKFreq+0x12c>)
3400e70c:	4298      	cmp	r0, r3
3400e70e:	d04a      	beq.n	3400e7a6 <RCCEx_GetSAICLKFreq+0xa2>
3400e710:	d839      	bhi.n	3400e786 <RCCEx_GetSAICLKFreq+0x82>
3400e712:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3400e716:	4298      	cmp	r0, r3
3400e718:	d021      	beq.n	3400e75e <RCCEx_GetSAICLKFreq+0x5a>
3400e71a:	d815      	bhi.n	3400e748 <RCCEx_GetSAICLKFreq+0x44>
3400e71c:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e720:	4298      	cmp	r0, r3
3400e722:	d00d      	beq.n	3400e740 <RCCEx_GetSAICLKFreq+0x3c>
3400e724:	d809      	bhi.n	3400e73a <RCCEx_GetSAICLKFreq+0x36>
3400e726:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e72a:	4298      	cmp	r0, r3
3400e72c:	d04e      	beq.n	3400e7cc <RCCEx_GetSAICLKFreq+0xc8>
3400e72e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e732:	4298      	cmp	r0, r3
3400e734:	d04a      	beq.n	3400e7cc <RCCEx_GetSAICLKFreq+0xc8>
  uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e736:	2000      	movs	r0, #0
}
3400e738:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e73a:	4b3e      	ldr	r3, [pc, #248]	@ (3400e834 <RCCEx_GetSAICLKFreq+0x130>)
3400e73c:	4298      	cmp	r0, r3
3400e73e:	d1fa      	bne.n	3400e736 <RCCEx_GetSAICLKFreq+0x32>
}
3400e740:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sai_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e744:	f7ff ba90 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e748:	4b3b      	ldr	r3, [pc, #236]	@ (3400e838 <RCCEx_GetSAICLKFreq+0x134>)
3400e74a:	4298      	cmp	r0, r3
3400e74c:	d04d      	beq.n	3400e7ea <RCCEx_GetSAICLKFreq+0xe6>
3400e74e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e752:	4298      	cmp	r0, r3
3400e754:	d049      	beq.n	3400e7ea <RCCEx_GetSAICLKFreq+0xe6>
3400e756:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e75a:	4298      	cmp	r0, r3
3400e75c:	d1eb      	bne.n	3400e736 <RCCEx_GetSAICLKFreq+0x32>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400e75e:	f7fc f8d7 	bl	3400a910 <LL_RCC_IC7_IsEnabled>
3400e762:	2800      	cmp	r0, #0
3400e764:	d0e7      	beq.n	3400e736 <RCCEx_GetSAICLKFreq+0x32>
        ic_divider = LL_RCC_IC7_GetDivider();
3400e766:	f7fc f8db 	bl	3400a920 <LL_RCC_IC7_GetDivider>
3400e76a:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400e76c:	4b33      	ldr	r3, [pc, #204]	@ (3400e83c <RCCEx_GetSAICLKFreq+0x138>)
3400e76e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400e772:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3400e776:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e77a:	d047      	beq.n	3400e80c <RCCEx_GetSAICLKFreq+0x108>
3400e77c:	d840      	bhi.n	3400e800 <RCCEx_GetSAICLKFreq+0xfc>
3400e77e:	bb7b      	cbnz	r3, 3400e7e0 <RCCEx_GetSAICLKFreq+0xdc>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e780:	f7ff f972 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
3400e784:	e02e      	b.n	3400e7e4 <RCCEx_GetSAICLKFreq+0xe0>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e786:	4b2e      	ldr	r3, [pc, #184]	@ (3400e840 <RCCEx_GetSAICLKFreq+0x13c>)
3400e788:	4298      	cmp	r0, r3
3400e78a:	d01d      	beq.n	3400e7c8 <RCCEx_GetSAICLKFreq+0xc4>
3400e78c:	d811      	bhi.n	3400e7b2 <RCCEx_GetSAICLKFreq+0xae>
3400e78e:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e792:	4298      	cmp	r0, r3
3400e794:	d03d      	beq.n	3400e812 <RCCEx_GetSAICLKFreq+0x10e>
3400e796:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e79a:	4298      	cmp	r0, r3
3400e79c:	d039      	beq.n	3400e812 <RCCEx_GetSAICLKFreq+0x10e>
3400e79e:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e7a2:	4298      	cmp	r0, r3
3400e7a4:	d1c7      	bne.n	3400e736 <RCCEx_GetSAICLKFreq+0x32>
      if (LL_RCC_MSI_IsReady() != 0U)
3400e7a6:	f7fc f883 	bl	3400a8b0 <LL_RCC_MSI_IsReady>
3400e7aa:	2800      	cmp	r0, #0
3400e7ac:	d0c3      	beq.n	3400e736 <RCCEx_GetSAICLKFreq+0x32>
        sai_frequency = MSI_VALUE;
3400e7ae:	4825      	ldr	r0, [pc, #148]	@ (3400e844 <RCCEx_GetSAICLKFreq+0x140>)
  return sai_frequency;
3400e7b0:	e7c2      	b.n	3400e738 <RCCEx_GetSAICLKFreq+0x34>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e7b2:	4b25      	ldr	r3, [pc, #148]	@ (3400e848 <RCCEx_GetSAICLKFreq+0x144>)
3400e7b4:	4298      	cmp	r0, r3
3400e7b6:	d036      	beq.n	3400e826 <RCCEx_GetSAICLKFreq+0x122>
3400e7b8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e7bc:	4298      	cmp	r0, r3
3400e7be:	d032      	beq.n	3400e826 <RCCEx_GetSAICLKFreq+0x122>
3400e7c0:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e7c4:	4298      	cmp	r0, r3
3400e7c6:	d1b6      	bne.n	3400e736 <RCCEx_GetSAICLKFreq+0x32>
3400e7c8:	4820      	ldr	r0, [pc, #128]	@ (3400e84c <RCCEx_GetSAICLKFreq+0x148>)
3400e7ca:	e7b5      	b.n	3400e738 <RCCEx_GetSAICLKFreq+0x34>
      sai_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e7cc:	f7fc f82a 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400e7d0:	f7fc f8f8 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400e7d4:	4b19      	ldr	r3, [pc, #100]	@ (3400e83c <RCCEx_GetSAICLKFreq+0x138>)
3400e7d6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400e7d8:	f3c3 1302 	ubfx	r3, r3, #4, #3
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e7dc:	40d8      	lsrs	r0, r3
3400e7de:	e7ab      	b.n	3400e738 <RCCEx_GetSAICLKFreq+0x34>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e7e0:	f7ff f982 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
            sai_frequency = sai_frequency / ic_divider;
3400e7e4:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e7e8:	e7a6      	b.n	3400e738 <RCCEx_GetSAICLKFreq+0x34>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400e7ea:	f7fc f8a3 	bl	3400a934 <LL_RCC_IC8_IsEnabled>
3400e7ee:	2800      	cmp	r0, #0
3400e7f0:	d0a1      	beq.n	3400e736 <RCCEx_GetSAICLKFreq+0x32>
        ic_divider = LL_RCC_IC8_GetDivider();
3400e7f2:	f7fc f8a7 	bl	3400a944 <LL_RCC_IC8_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400e7f6:	4b11      	ldr	r3, [pc, #68]	@ (3400e83c <RCCEx_GetSAICLKFreq+0x138>)
3400e7f8:	4604      	mov	r4, r0
3400e7fa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400e7fe:	e7b8      	b.n	3400e772 <RCCEx_GetSAICLKFreq+0x6e>
        switch (LL_RCC_IC8_GetSource())
3400e800:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e804:	d197      	bne.n	3400e736 <RCCEx_GetSAICLKFreq+0x32>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e806:	f7ff f9ef 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400e80a:	e7eb      	b.n	3400e7e4 <RCCEx_GetSAICLKFreq+0xe0>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e80c:	f7ff f9ac 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400e810:	e7e8      	b.n	3400e7e4 <RCCEx_GetSAICLKFreq+0xe0>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e812:	f7fc f845 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400e816:	2800      	cmp	r0, #0
3400e818:	d08d      	beq.n	3400e736 <RCCEx_GetSAICLKFreq+0x32>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e81a:	4b08      	ldr	r3, [pc, #32]	@ (3400e83c <RCCEx_GetSAICLKFreq+0x138>)
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e81c:	480c      	ldr	r0, [pc, #48]	@ (3400e850 <RCCEx_GetSAICLKFreq+0x14c>)
3400e81e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e820:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400e824:	e7da      	b.n	3400e7dc <RCCEx_GetSAICLKFreq+0xd8>
}
3400e826:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sai_frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
3400e82a:	f7ff baa3 	b.w	3400dd74 <RCCEx_GetSPDIFRXCLKFreq.constprop.0>
3400e82e:	bf00      	nop
3400e830:	07041418 	.word	0x07041418
3400e834:	07011818 	.word	0x07011818
3400e838:	07031418 	.word	0x07031418
3400e83c:	56028000 	.word	0x56028000
3400e840:	07061418 	.word	0x07061418
3400e844:	003d0900 	.word	0x003d0900
3400e848:	07071418 	.word	0x07071418
3400e84c:	00bb8000 	.word	0x00bb8000
3400e850:	03d09000 	.word	0x03d09000

3400e854 <RCCEx_GetI3CCLKFreq>:
{
3400e854:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e856:	f7fc f84d 	bl	3400a8f4 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e85a:	4b3d      	ldr	r3, [pc, #244]	@ (3400e950 <RCCEx_GetI3CCLKFreq+0xfc>)
3400e85c:	4298      	cmp	r0, r3
3400e85e:	d060      	beq.n	3400e922 <RCCEx_GetI3CCLKFreq+0xce>
3400e860:	d830      	bhi.n	3400e8c4 <RCCEx_GetI3CCLKFreq+0x70>
3400e862:	f5a3 33fe 	sub.w	r3, r3, #130048	@ 0x1fc00
3400e866:	4298      	cmp	r0, r3
3400e868:	d057      	beq.n	3400e91a <RCCEx_GetI3CCLKFreq+0xc6>
3400e86a:	d80d      	bhi.n	3400e888 <RCCEx_GetI3CCLKFreq+0x34>
3400e86c:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e870:	4298      	cmp	r0, r3
3400e872:	d048      	beq.n	3400e906 <RCCEx_GetI3CCLKFreq+0xb2>
3400e874:	f503 437c 	add.w	r3, r3, #64512	@ 0xfc00
3400e878:	4298      	cmp	r0, r3
3400e87a:	d04e      	beq.n	3400e91a <RCCEx_GetI3CCLKFreq+0xc6>
3400e87c:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e880:	4298      	cmp	r0, r3
3400e882:	d040      	beq.n	3400e906 <RCCEx_GetI3CCLKFreq+0xb2>
  uint32_t i3c_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e884:	2000      	movs	r0, #0
}
3400e886:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e888:	4b32      	ldr	r3, [pc, #200]	@ (3400e954 <RCCEx_GetI3CCLKFreq+0x100>)
3400e88a:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e88e:	4298      	cmp	r0, r3
3400e890:	d1f8      	bne.n	3400e884 <RCCEx_GetI3CCLKFreq+0x30>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3400e892:	4b31      	ldr	r3, [pc, #196]	@ (3400e958 <RCCEx_GetI3CCLKFreq+0x104>)
3400e894:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400e898:	0592      	lsls	r2, r2, #22
3400e89a:	d5f3      	bpl.n	3400e884 <RCCEx_GetI3CCLKFreq+0x30>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400e89c:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400e8a0:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400e8a4:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400e8a8:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e8aa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400e8ae:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e8b2:	d04a      	beq.n	3400e94a <RCCEx_GetI3CCLKFreq+0xf6>
3400e8b4:	d840      	bhi.n	3400e938 <RCCEx_GetI3CCLKFreq+0xe4>
3400e8b6:	2b00      	cmp	r3, #0
3400e8b8:	d144      	bne.n	3400e944 <RCCEx_GetI3CCLKFreq+0xf0>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e8ba:	f7ff f8d5 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
            i3c_frequency = i3c_frequency / ic_divider;
3400e8be:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e8c2:	e7e0      	b.n	3400e886 <RCCEx_GetI3CCLKFreq+0x32>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e8c4:	4b25      	ldr	r3, [pc, #148]	@ (3400e95c <RCCEx_GetI3CCLKFreq+0x108>)
3400e8c6:	4298      	cmp	r0, r3
3400e8c8:	d008      	beq.n	3400e8dc <RCCEx_GetI3CCLKFreq+0x88>
3400e8ca:	d80d      	bhi.n	3400e8e8 <RCCEx_GetI3CCLKFreq+0x94>
3400e8cc:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e8d0:	4298      	cmp	r0, r3
3400e8d2:	d026      	beq.n	3400e922 <RCCEx_GetI3CCLKFreq+0xce>
3400e8d4:	f503 437c 	add.w	r3, r3, #64512	@ 0xfc00
3400e8d8:	4298      	cmp	r0, r3
3400e8da:	d1d3      	bne.n	3400e884 <RCCEx_GetI3CCLKFreq+0x30>
      if (LL_RCC_MSI_IsReady() != 0U)
3400e8dc:	f7fb ffe8 	bl	3400a8b0 <LL_RCC_MSI_IsReady>
3400e8e0:	2800      	cmp	r0, #0
3400e8e2:	d0cf      	beq.n	3400e884 <RCCEx_GetI3CCLKFreq+0x30>
        i3c_frequency = MSI_VALUE;
3400e8e4:	481e      	ldr	r0, [pc, #120]	@ (3400e960 <RCCEx_GetI3CCLKFreq+0x10c>)
  return i3c_frequency;
3400e8e6:	e7ce      	b.n	3400e886 <RCCEx_GetI3CCLKFreq+0x32>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e8e8:	4b1e      	ldr	r3, [pc, #120]	@ (3400e964 <RCCEx_GetI3CCLKFreq+0x110>)
3400e8ea:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e8ee:	4298      	cmp	r0, r3
3400e8f0:	d1c8      	bne.n	3400e884 <RCCEx_GetI3CCLKFreq+0x30>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e8f2:	f7fb ffd5 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400e8f6:	2800      	cmp	r0, #0
3400e8f8:	d0c4      	beq.n	3400e884 <RCCEx_GetI3CCLKFreq+0x30>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e8fa:	4b17      	ldr	r3, [pc, #92]	@ (3400e958 <RCCEx_GetI3CCLKFreq+0x104>)
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e8fc:	481a      	ldr	r0, [pc, #104]	@ (3400e968 <RCCEx_GetI3CCLKFreq+0x114>)
3400e8fe:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e900:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400e904:	e007      	b.n	3400e916 <RCCEx_GetI3CCLKFreq+0xc2>
      i3c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e906:	f7fb ff8d 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400e90a:	f7fc f85b 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e90e:	4b12      	ldr	r3, [pc, #72]	@ (3400e958 <RCCEx_GetI3CCLKFreq+0x104>)
3400e910:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e912:	f003 0307 	and.w	r3, r3, #7
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e916:	40d8      	lsrs	r0, r3
3400e918:	e7b5      	b.n	3400e886 <RCCEx_GetI3CCLKFreq+0x32>
}
3400e91a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i3c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e91e:	f7ff b9a3 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400e922:	f7fc f83d 	bl	3400a9a0 <LL_RCC_IC15_IsEnabled>
3400e926:	2800      	cmp	r0, #0
3400e928:	d0ac      	beq.n	3400e884 <RCCEx_GetI3CCLKFreq+0x30>
        ic_divider = LL_RCC_IC15_GetDivider();
3400e92a:	f7fc f841 	bl	3400a9b0 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e92e:	4b0a      	ldr	r3, [pc, #40]	@ (3400e958 <RCCEx_GetI3CCLKFreq+0x104>)
3400e930:	4604      	mov	r4, r0
3400e932:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400e936:	e7b8      	b.n	3400e8aa <RCCEx_GetI3CCLKFreq+0x56>
        switch (LL_RCC_IC15_GetSource())
3400e938:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e93c:	d1a2      	bne.n	3400e884 <RCCEx_GetI3CCLKFreq+0x30>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e93e:	f7ff f953 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400e942:	e7bc      	b.n	3400e8be <RCCEx_GetI3CCLKFreq+0x6a>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e944:	f7ff f8d0 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400e948:	e7b9      	b.n	3400e8be <RCCEx_GetI3CCLKFreq+0x6a>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e94a:	f7ff f90d 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400e94e:	e7b6      	b.n	3400e8be <RCCEx_GetI3CCLKFreq+0x6a>
3400e950:	0703100c 	.word	0x0703100c
3400e954:	0702100c 	.word	0x0702100c
3400e958:	56028000 	.word	0x56028000
3400e95c:	0704140c 	.word	0x0704140c
3400e960:	003d0900 	.word	0x003d0900
3400e964:	0705100c 	.word	0x0705100c
3400e968:	03d09000 	.word	0x03d09000

3400e96c <RCCEx_GetSDMMCCLKFreq>:
{
3400e96c:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e96e:	f7fb ffc1 	bl	3400a8f4 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3400e972:	4b2d      	ldr	r3, [pc, #180]	@ (3400ea28 <RCCEx_GetSDMMCCLKFreq+0xbc>)
3400e974:	4298      	cmp	r0, r3
3400e976:	d01d      	beq.n	3400e9b4 <RCCEx_GetSDMMCCLKFreq+0x48>
3400e978:	d813      	bhi.n	3400e9a2 <RCCEx_GetSDMMCCLKFreq+0x36>
3400e97a:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e97e:	4298      	cmp	r0, r3
3400e980:	d00b      	beq.n	3400e99a <RCCEx_GetSDMMCCLKFreq+0x2e>
3400e982:	d807      	bhi.n	3400e994 <RCCEx_GetSDMMCCLKFreq+0x28>
3400e984:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e988:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e98c:	4298      	cmp	r0, r3
3400e98e:	d02a      	beq.n	3400e9e6 <RCCEx_GetSDMMCCLKFreq+0x7a>
  uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e990:	2000      	movs	r0, #0
}
3400e992:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3400e994:	4b25      	ldr	r3, [pc, #148]	@ (3400ea2c <RCCEx_GetSDMMCCLKFreq+0xc0>)
3400e996:	4298      	cmp	r0, r3
3400e998:	d1fa      	bne.n	3400e990 <RCCEx_GetSDMMCCLKFreq+0x24>
}
3400e99a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sdmmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e99e:	f7ff b963 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3400e9a2:	4b23      	ldr	r3, [pc, #140]	@ (3400ea30 <RCCEx_GetSDMMCCLKFreq+0xc4>)
3400e9a4:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400e9a8:	429a      	cmp	r2, r3
3400e9aa:	d022      	beq.n	3400e9f2 <RCCEx_GetSDMMCCLKFreq+0x86>
3400e9ac:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400e9b0:	4298      	cmp	r0, r3
3400e9b2:	d1ed      	bne.n	3400e990 <RCCEx_GetSDMMCCLKFreq+0x24>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3400e9b4:	4b1f      	ldr	r3, [pc, #124]	@ (3400ea34 <RCCEx_GetSDMMCCLKFreq+0xc8>)
3400e9b6:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400e9ba:	f010 0008 	ands.w	r0, r0, #8
3400e9be:	d0e8      	beq.n	3400e992 <RCCEx_GetSDMMCCLKFreq+0x26>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400e9c0:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400e9c4:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400e9c8:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400e9cc:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400e9ce:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC5_GetSource())
3400e9d2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e9d6:	d023      	beq.n	3400ea20 <RCCEx_GetSDMMCCLKFreq+0xb4>
3400e9d8:	d819      	bhi.n	3400ea0e <RCCEx_GetSDMMCCLKFreq+0xa2>
3400e9da:	b9f3      	cbnz	r3, 3400ea1a <RCCEx_GetSDMMCCLKFreq+0xae>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e9dc:	f7ff f844 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3400e9e0:	fbb0 f0f4 	udiv	r0, r0, r4
  return sdmmc_frequency;
3400e9e4:	e7d5      	b.n	3400e992 <RCCEx_GetSDMMCCLKFreq+0x26>
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400e9e6:	f7fb ff1d 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
}
3400e9ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400e9ee:	f7fb bfe9 	b.w	3400a9c4 <RCCEx_GetHCLKFreq>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3400e9f2:	4b10      	ldr	r3, [pc, #64]	@ (3400ea34 <RCCEx_GetSDMMCCLKFreq+0xc8>)
3400e9f4:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400e9f8:	f010 0010 	ands.w	r0, r0, #16
3400e9fc:	d0c9      	beq.n	3400e992 <RCCEx_GetSDMMCCLKFreq+0x26>
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400e9fe:	f8d3 00d4 	ldr.w	r0, [r3, #212]	@ 0xd4
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400ea02:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400ea06:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400ea0a:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400ea0c:	e7df      	b.n	3400e9ce <RCCEx_GetSDMMCCLKFreq+0x62>
        switch (LL_RCC_IC5_GetSource())
3400ea0e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ea12:	d1bd      	bne.n	3400e990 <RCCEx_GetSDMMCCLKFreq+0x24>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400ea14:	f7ff f8e8 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400ea18:	e7e2      	b.n	3400e9e0 <RCCEx_GetSDMMCCLKFreq+0x74>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400ea1a:	f7ff f865 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400ea1e:	e7df      	b.n	3400e9e0 <RCCEx_GetSDMMCCLKFreq+0x74>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400ea20:	f7ff f8a2 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400ea24:	e7dc      	b.n	3400e9e0 <RCCEx_GetSDMMCCLKFreq+0x74>
3400ea26:	bf00      	nop
3400ea28:	0302001c 	.word	0x0302001c
3400ea2c:	0301041c 	.word	0x0301041c
3400ea30:	0303001c 	.word	0x0303001c
3400ea34:	56028000 	.word	0x56028000

3400ea38 <RCCEx_GetI2CCLKFreq>:
{
3400ea38:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400ea3a:	f7fb ff5b 	bl	3400a8f4 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400ea3e:	4b50      	ldr	r3, [pc, #320]	@ (3400eb80 <RCCEx_GetI2CCLKFreq+0x148>)
3400ea40:	4298      	cmp	r0, r3
3400ea42:	f000 8085 	beq.w	3400eb50 <RCCEx_GetI2CCLKFreq+0x118>
3400ea46:	d84b      	bhi.n	3400eae0 <RCCEx_GetI2CCLKFreq+0xa8>
3400ea48:	f5a3 33fc 	sub.w	r3, r3, #129024	@ 0x1f800
3400ea4c:	4298      	cmp	r0, r3
3400ea4e:	d01a      	beq.n	3400ea86 <RCCEx_GetI2CCLKFreq+0x4e>
3400ea50:	d81d      	bhi.n	3400ea8e <RCCEx_GetI2CCLKFreq+0x56>
3400ea52:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400ea56:	4298      	cmp	r0, r3
3400ea58:	d008      	beq.n	3400ea6c <RCCEx_GetI2CCLKFreq+0x34>
3400ea5a:	f420 6380 	bic.w	r3, r0, #1024	@ 0x400
3400ea5e:	d80f      	bhi.n	3400ea80 <RCCEx_GetI2CCLKFreq+0x48>
3400ea60:	4a48      	ldr	r2, [pc, #288]	@ (3400eb84 <RCCEx_GetI2CCLKFreq+0x14c>)
3400ea62:	4293      	cmp	r3, r2
3400ea64:	d002      	beq.n	3400ea6c <RCCEx_GetI2CCLKFreq+0x34>
3400ea66:	4b48      	ldr	r3, [pc, #288]	@ (3400eb88 <RCCEx_GetI2CCLKFreq+0x150>)
3400ea68:	4298      	cmp	r0, r3
3400ea6a:	d14a      	bne.n	3400eb02 <RCCEx_GetI2CCLKFreq+0xca>
      i2c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400ea6c:	f7fb feda 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400ea70:	f7fb ffa8 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400ea74:	4b45      	ldr	r3, [pc, #276]	@ (3400eb8c <RCCEx_GetI2CCLKFreq+0x154>)
3400ea76:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ea78:	f003 0307 	and.w	r3, r3, #7
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400ea7c:	40d8      	lsrs	r0, r3
3400ea7e:	e041      	b.n	3400eb04 <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400ea80:	4a43      	ldr	r2, [pc, #268]	@ (3400eb90 <RCCEx_GetI2CCLKFreq+0x158>)
3400ea82:	4293      	cmp	r3, r2
3400ea84:	d13d      	bne.n	3400eb02 <RCCEx_GetI2CCLKFreq+0xca>
}
3400ea86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i2c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400ea8a:	f7ff b8ed 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400ea8e:	4b41      	ldr	r3, [pc, #260]	@ (3400eb94 <RCCEx_GetI2CCLKFreq+0x15c>)
3400ea90:	4298      	cmp	r0, r3
3400ea92:	d008      	beq.n	3400eaa6 <RCCEx_GetI2CCLKFreq+0x6e>
3400ea94:	d820      	bhi.n	3400ead8 <RCCEx_GetI2CCLKFreq+0xa0>
3400ea96:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400ea9a:	4298      	cmp	r0, r3
3400ea9c:	d0f3      	beq.n	3400ea86 <RCCEx_GetI2CCLKFreq+0x4e>
3400ea9e:	f503 4374 	add.w	r3, r3, #62464	@ 0xf400
3400eaa2:	4298      	cmp	r0, r3
3400eaa4:	d12d      	bne.n	3400eb02 <RCCEx_GetI2CCLKFreq+0xca>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3400eaa6:	4b39      	ldr	r3, [pc, #228]	@ (3400eb8c <RCCEx_GetI2CCLKFreq+0x154>)
3400eaa8:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400eaac:	0592      	lsls	r2, r2, #22
3400eaae:	d528      	bpl.n	3400eb02 <RCCEx_GetI2CCLKFreq+0xca>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400eab0:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400eab4:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400eab8:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400eabc:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400eabe:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400eac2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400eac6:	d057      	beq.n	3400eb78 <RCCEx_GetI2CCLKFreq+0x140>
3400eac8:	d84d      	bhi.n	3400eb66 <RCCEx_GetI2CCLKFreq+0x12e>
3400eaca:	2b00      	cmp	r3, #0
3400eacc:	d151      	bne.n	3400eb72 <RCCEx_GetI2CCLKFreq+0x13a>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400eace:	f7fe ffcb 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
            i2c_frequency = i2c_frequency / ic_divider;
3400ead2:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400ead6:	e015      	b.n	3400eb04 <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400ead8:	4b2f      	ldr	r3, [pc, #188]	@ (3400eb98 <RCCEx_GetI2CCLKFreq+0x160>)
3400eada:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400eade:	e7e0      	b.n	3400eaa2 <RCCEx_GetI2CCLKFreq+0x6a>
3400eae0:	4b2e      	ldr	r3, [pc, #184]	@ (3400eb9c <RCCEx_GetI2CCLKFreq+0x164>)
3400eae2:	4298      	cmp	r0, r3
3400eae4:	d014      	beq.n	3400eb10 <RCCEx_GetI2CCLKFreq+0xd8>
3400eae6:	d819      	bhi.n	3400eb1c <RCCEx_GetI2CCLKFreq+0xe4>
3400eae8:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400eaec:	4298      	cmp	r0, r3
3400eaee:	d02f      	beq.n	3400eb50 <RCCEx_GetI2CCLKFreq+0x118>
3400eaf0:	d809      	bhi.n	3400eb06 <RCCEx_GetI2CCLKFreq+0xce>
3400eaf2:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400eaf6:	4298      	cmp	r0, r3
3400eaf8:	d02a      	beq.n	3400eb50 <RCCEx_GetI2CCLKFreq+0x118>
3400eafa:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400eafe:	4298      	cmp	r0, r3
3400eb00:	d026      	beq.n	3400eb50 <RCCEx_GetI2CCLKFreq+0x118>
  uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
3400eb02:	2000      	movs	r0, #0
}
3400eb04:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400eb06:	4b26      	ldr	r3, [pc, #152]	@ (3400eba0 <RCCEx_GetI2CCLKFreq+0x168>)
3400eb08:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400eb0c:	4298      	cmp	r0, r3
3400eb0e:	d1f8      	bne.n	3400eb02 <RCCEx_GetI2CCLKFreq+0xca>
      if (LL_RCC_MSI_IsReady() != 0U)
3400eb10:	f7fb fece 	bl	3400a8b0 <LL_RCC_MSI_IsReady>
3400eb14:	2800      	cmp	r0, #0
3400eb16:	d0f4      	beq.n	3400eb02 <RCCEx_GetI2CCLKFreq+0xca>
        i2c_frequency = MSI_VALUE;
3400eb18:	4822      	ldr	r0, [pc, #136]	@ (3400eba4 <RCCEx_GetI2CCLKFreq+0x16c>)
  return i2c_frequency;
3400eb1a:	e7f3      	b.n	3400eb04 <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400eb1c:	4b22      	ldr	r3, [pc, #136]	@ (3400eba8 <RCCEx_GetI2CCLKFreq+0x170>)
3400eb1e:	4298      	cmp	r0, r3
3400eb20:	d008      	beq.n	3400eb34 <RCCEx_GetI2CCLKFreq+0xfc>
3400eb22:	d811      	bhi.n	3400eb48 <RCCEx_GetI2CCLKFreq+0x110>
3400eb24:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400eb28:	4298      	cmp	r0, r3
3400eb2a:	d0f1      	beq.n	3400eb10 <RCCEx_GetI2CCLKFreq+0xd8>
3400eb2c:	f503 4374 	add.w	r3, r3, #62464	@ 0xf400
3400eb30:	4298      	cmp	r0, r3
3400eb32:	d1e6      	bne.n	3400eb02 <RCCEx_GetI2CCLKFreq+0xca>
      if (LL_RCC_HSI_IsReady() != 0U)
3400eb34:	f7fb feb4 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400eb38:	2800      	cmp	r0, #0
3400eb3a:	d0e2      	beq.n	3400eb02 <RCCEx_GetI2CCLKFreq+0xca>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400eb3c:	4b13      	ldr	r3, [pc, #76]	@ (3400eb8c <RCCEx_GetI2CCLKFreq+0x154>)
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400eb3e:	481b      	ldr	r0, [pc, #108]	@ (3400ebac <RCCEx_GetI2CCLKFreq+0x174>)
3400eb40:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400eb42:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400eb46:	e799      	b.n	3400ea7c <RCCEx_GetI2CCLKFreq+0x44>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400eb48:	4b19      	ldr	r3, [pc, #100]	@ (3400ebb0 <RCCEx_GetI2CCLKFreq+0x178>)
3400eb4a:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400eb4e:	e7ef      	b.n	3400eb30 <RCCEx_GetI2CCLKFreq+0xf8>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400eb50:	f7fb ff26 	bl	3400a9a0 <LL_RCC_IC15_IsEnabled>
3400eb54:	2800      	cmp	r0, #0
3400eb56:	d0d4      	beq.n	3400eb02 <RCCEx_GetI2CCLKFreq+0xca>
        ic_divider = LL_RCC_IC15_GetDivider();
3400eb58:	f7fb ff2a 	bl	3400a9b0 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400eb5c:	4b0b      	ldr	r3, [pc, #44]	@ (3400eb8c <RCCEx_GetI2CCLKFreq+0x154>)
3400eb5e:	4604      	mov	r4, r0
3400eb60:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400eb64:	e7ab      	b.n	3400eabe <RCCEx_GetI2CCLKFreq+0x86>
        switch (LL_RCC_IC15_GetSource())
3400eb66:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400eb6a:	d1ca      	bne.n	3400eb02 <RCCEx_GetI2CCLKFreq+0xca>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400eb6c:	f7ff f83c 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400eb70:	e7af      	b.n	3400ead2 <RCCEx_GetI2CCLKFreq+0x9a>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400eb72:	f7fe ffb9 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400eb76:	e7ac      	b.n	3400ead2 <RCCEx_GetI2CCLKFreq+0x9a>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400eb78:	f7fe fff6 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400eb7c:	e7a9      	b.n	3400ead2 <RCCEx_GetI2CCLKFreq+0x9a>
3400eb7e:	bf00      	nop
3400eb80:	0703000c 	.word	0x0703000c
3400eb84:	0700000c 	.word	0x0700000c
3400eb88:	0700080c 	.word	0x0700080c
3400eb8c:	56028000 	.word	0x56028000
3400eb90:	0701000c 	.word	0x0701000c
3400eb94:	0702040c 	.word	0x0702040c
3400eb98:	0702080c 	.word	0x0702080c
3400eb9c:	0704080c 	.word	0x0704080c
3400eba0:	0704000c 	.word	0x0704000c
3400eba4:	003d0900 	.word	0x003d0900
3400eba8:	0705040c 	.word	0x0705040c
3400ebac:	03d09000 	.word	0x03d09000
3400ebb0:	0705080c 	.word	0x0705080c

3400ebb4 <RCCEx_GetLPTIMCLKFreq>:
{
3400ebb4:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400ebb6:	f7fb fe9d 	bl	3400a8f4 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400ebba:	4b63      	ldr	r3, [pc, #396]	@ (3400ed48 <RCCEx_GetLPTIMCLKFreq+0x194>)
3400ebbc:	4298      	cmp	r0, r3
3400ebbe:	d03a      	beq.n	3400ec36 <RCCEx_GetLPTIMCLKFreq+0x82>
3400ebc0:	d850      	bhi.n	3400ec64 <RCCEx_GetLPTIMCLKFreq+0xb0>
3400ebc2:	f5a3 33fe 	sub.w	r3, r3, #130048	@ 0x1fc00
3400ebc6:	4298      	cmp	r0, r3
3400ebc8:	f000 80a7 	beq.w	3400ed1a <RCCEx_GetLPTIMCLKFreq+0x166>
3400ebcc:	d813      	bhi.n	3400ebf6 <RCCEx_GetLPTIMCLKFreq+0x42>
3400ebce:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400ebd2:	4298      	cmp	r0, r3
3400ebd4:	f000 8097 	beq.w	3400ed06 <RCCEx_GetLPTIMCLKFreq+0x152>
3400ebd8:	3b01      	subs	r3, #1
3400ebda:	4298      	cmp	r0, r3
3400ebdc:	d909      	bls.n	3400ebf2 <RCCEx_GetLPTIMCLKFreq+0x3e>
3400ebde:	f203 4301 	addw	r3, r3, #1025	@ 0x401
3400ebe2:	4298      	cmp	r0, r3
3400ebe4:	f000 8099 	beq.w	3400ed1a <RCCEx_GetLPTIMCLKFreq+0x166>
3400ebe8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400ebec:	4298      	cmp	r0, r3
3400ebee:	f000 8094 	beq.w	3400ed1a <RCCEx_GetLPTIMCLKFreq+0x166>
  uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
3400ebf2:	2000      	movs	r0, #0
}
3400ebf4:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400ebf6:	4b55      	ldr	r3, [pc, #340]	@ (3400ed4c <RCCEx_GetLPTIMCLKFreq+0x198>)
3400ebf8:	4298      	cmp	r0, r3
3400ebfa:	d015      	beq.n	3400ec28 <RCCEx_GetLPTIMCLKFreq+0x74>
3400ebfc:	d808      	bhi.n	3400ec10 <RCCEx_GetLPTIMCLKFreq+0x5c>
3400ebfe:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400ec02:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400ec06:	429a      	cmp	r2, r3
3400ec08:	d00e      	beq.n	3400ec28 <RCCEx_GetLPTIMCLKFreq+0x74>
3400ec0a:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400ec0e:	e7ed      	b.n	3400ebec <RCCEx_GetLPTIMCLKFreq+0x38>
3400ec10:	4b4f      	ldr	r3, [pc, #316]	@ (3400ed50 <RCCEx_GetLPTIMCLKFreq+0x19c>)
3400ec12:	4298      	cmp	r0, r3
3400ec14:	d00f      	beq.n	3400ec36 <RCCEx_GetLPTIMCLKFreq+0x82>
3400ec16:	d80b      	bhi.n	3400ec30 <RCCEx_GetLPTIMCLKFreq+0x7c>
3400ec18:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400ec1c:	4298      	cmp	r0, r3
3400ec1e:	d003      	beq.n	3400ec28 <RCCEx_GetLPTIMCLKFreq+0x74>
3400ec20:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400ec24:	4298      	cmp	r0, r3
3400ec26:	d1e4      	bne.n	3400ebf2 <RCCEx_GetLPTIMCLKFreq+0x3e>
}
3400ec28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      lptim_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400ec2c:	f7ff b81c 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400ec30:	4b48      	ldr	r3, [pc, #288]	@ (3400ed54 <RCCEx_GetLPTIMCLKFreq+0x1a0>)
3400ec32:	4298      	cmp	r0, r3
3400ec34:	d1dd      	bne.n	3400ebf2 <RCCEx_GetLPTIMCLKFreq+0x3e>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400ec36:	f7fb feb3 	bl	3400a9a0 <LL_RCC_IC15_IsEnabled>
3400ec3a:	2800      	cmp	r0, #0
3400ec3c:	d0d9      	beq.n	3400ebf2 <RCCEx_GetLPTIMCLKFreq+0x3e>
        ic_divider = LL_RCC_IC15_GetDivider();
3400ec3e:	f7fb feb7 	bl	3400a9b0 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400ec42:	4b45      	ldr	r3, [pc, #276]	@ (3400ed58 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400ec44:	4604      	mov	r4, r0
3400ec46:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400ec4a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400ec4e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ec52:	d075      	beq.n	3400ed40 <RCCEx_GetLPTIMCLKFreq+0x18c>
3400ec54:	d86a      	bhi.n	3400ed2c <RCCEx_GetLPTIMCLKFreq+0x178>
3400ec56:	2b00      	cmp	r3, #0
3400ec58:	d16f      	bne.n	3400ed3a <RCCEx_GetLPTIMCLKFreq+0x186>
            lptim_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400ec5a:	f7fe ff05 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
            lptim_frequency = lptim_frequency / ic_divider;
3400ec5e:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400ec62:	e7c7      	b.n	3400ebf4 <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400ec64:	4b3d      	ldr	r3, [pc, #244]	@ (3400ed5c <RCCEx_GetLPTIMCLKFreq+0x1a8>)
3400ec66:	4298      	cmp	r0, r3
3400ec68:	d034      	beq.n	3400ecd4 <RCCEx_GetLPTIMCLKFreq+0x120>
3400ec6a:	d824      	bhi.n	3400ecb6 <RCCEx_GetLPTIMCLKFreq+0x102>
3400ec6c:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400ec70:	4298      	cmp	r0, r3
3400ec72:	d00f      	beq.n	3400ec94 <RCCEx_GetLPTIMCLKFreq+0xe0>
3400ec74:	d815      	bhi.n	3400eca2 <RCCEx_GetLPTIMCLKFreq+0xee>
3400ec76:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400ec7a:	4298      	cmp	r0, r3
3400ec7c:	d00a      	beq.n	3400ec94 <RCCEx_GetLPTIMCLKFreq+0xe0>
3400ec7e:	d806      	bhi.n	3400ec8e <RCCEx_GetLPTIMCLKFreq+0xda>
3400ec80:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400ec84:	4298      	cmp	r0, r3
3400ec86:	d0d6      	beq.n	3400ec36 <RCCEx_GetLPTIMCLKFreq+0x82>
3400ec88:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400ec8c:	e7d1      	b.n	3400ec32 <RCCEx_GetLPTIMCLKFreq+0x7e>
3400ec8e:	4b34      	ldr	r3, [pc, #208]	@ (3400ed60 <RCCEx_GetLPTIMCLKFreq+0x1ac>)
3400ec90:	4298      	cmp	r0, r3
3400ec92:	d1ae      	bne.n	3400ebf2 <RCCEx_GetLPTIMCLKFreq+0x3e>
      if (LL_RCC_LSE_IsReady() != 0U)
3400ec94:	f7fb fe14 	bl	3400a8c0 <LL_RCC_LSE_IsReady>
3400ec98:	3800      	subs	r0, #0
3400ec9a:	bf18      	it	ne
3400ec9c:	2001      	movne	r0, #1
3400ec9e:	03c0      	lsls	r0, r0, #15
3400eca0:	e7a8      	b.n	3400ebf4 <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400eca2:	4b30      	ldr	r3, [pc, #192]	@ (3400ed64 <RCCEx_GetLPTIMCLKFreq+0x1b0>)
3400eca4:	4298      	cmp	r0, r3
3400eca6:	d0f5      	beq.n	3400ec94 <RCCEx_GetLPTIMCLKFreq+0xe0>
3400eca8:	f503 4370 	add.w	r3, r3, #61440	@ 0xf000
3400ecac:	4298      	cmp	r0, r3
3400ecae:	d011      	beq.n	3400ecd4 <RCCEx_GetLPTIMCLKFreq+0x120>
3400ecb0:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400ecb4:	e7ec      	b.n	3400ec90 <RCCEx_GetLPTIMCLKFreq+0xdc>
3400ecb6:	4b2c      	ldr	r3, [pc, #176]	@ (3400ed68 <RCCEx_GetLPTIMCLKFreq+0x1b4>)
3400ecb8:	4298      	cmp	r0, r3
3400ecba:	d015      	beq.n	3400ece8 <RCCEx_GetLPTIMCLKFreq+0x134>
3400ecbc:	d81b      	bhi.n	3400ecf6 <RCCEx_GetLPTIMCLKFreq+0x142>
3400ecbe:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400ecc2:	4298      	cmp	r0, r3
3400ecc4:	d006      	beq.n	3400ecd4 <RCCEx_GetLPTIMCLKFreq+0x120>
3400ecc6:	d80c      	bhi.n	3400ece2 <RCCEx_GetLPTIMCLKFreq+0x12e>
3400ecc8:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400eccc:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400ecd0:	4298      	cmp	r0, r3
3400ecd2:	d18e      	bne.n	3400ebf2 <RCCEx_GetLPTIMCLKFreq+0x3e>
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3400ecd4:	4b20      	ldr	r3, [pc, #128]	@ (3400ed58 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400ecd6:	685b      	ldr	r3, [r3, #4]
      if (LL_RCC_LSI_IsReady() != 0U)
3400ecd8:	07db      	lsls	r3, r3, #31
3400ecda:	d58a      	bpl.n	3400ebf2 <RCCEx_GetLPTIMCLKFreq+0x3e>
        lptim_frequency = LSI_VALUE;
3400ecdc:	f44f 40fa 	mov.w	r0, #32000	@ 0x7d00
  return lptim_frequency;
3400ece0:	e788      	b.n	3400ebf4 <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400ece2:	4b22      	ldr	r3, [pc, #136]	@ (3400ed6c <RCCEx_GetLPTIMCLKFreq+0x1b8>)
3400ece4:	4298      	cmp	r0, r3
3400ece6:	d184      	bne.n	3400ebf2 <RCCEx_GetLPTIMCLKFreq+0x3e>
      lptim_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
3400ece8:	f7fb fd9c 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3400ecec:	4b1a      	ldr	r3, [pc, #104]	@ (3400ed58 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400ecee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ecf0:	f3c3 6301 	ubfx	r3, r3, #24, #2
3400ecf4:	e00f      	b.n	3400ed16 <RCCEx_GetLPTIMCLKFreq+0x162>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400ecf6:	4b1e      	ldr	r3, [pc, #120]	@ (3400ed70 <RCCEx_GetLPTIMCLKFreq+0x1bc>)
3400ecf8:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400ecfc:	429a      	cmp	r2, r3
3400ecfe:	d0f3      	beq.n	3400ece8 <RCCEx_GetLPTIMCLKFreq+0x134>
3400ed00:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400ed04:	e7ee      	b.n	3400ece4 <RCCEx_GetLPTIMCLKFreq+0x130>
      lptim_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400ed06:	f7fb fd8d 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400ed0a:	f7fb fe5b 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400ed0e:	4b12      	ldr	r3, [pc, #72]	@ (3400ed58 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400ed10:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ed12:	f003 0307 	and.w	r3, r3, #7
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400ed16:	40d8      	lsrs	r0, r3
      break;
3400ed18:	e76c      	b.n	3400ebf4 <RCCEx_GetLPTIMCLKFreq+0x40>
      lptim_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400ed1a:	f7fb fd83 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400ed1e:	f7fb fe51 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400ed22:	4b0d      	ldr	r3, [pc, #52]	@ (3400ed58 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400ed24:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400ed26:	f3c3 3302 	ubfx	r3, r3, #12, #3
3400ed2a:	e7f4      	b.n	3400ed16 <RCCEx_GetLPTIMCLKFreq+0x162>
        switch (LL_RCC_IC15_GetSource())
3400ed2c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ed30:	f47f af5f 	bne.w	3400ebf2 <RCCEx_GetLPTIMCLKFreq+0x3e>
            lptim_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400ed34:	f7fe ff58 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400ed38:	e791      	b.n	3400ec5e <RCCEx_GetLPTIMCLKFreq+0xaa>
            lptim_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400ed3a:	f7fe fed5 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400ed3e:	e78e      	b.n	3400ec5e <RCCEx_GetLPTIMCLKFreq+0xaa>
            lptim_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400ed40:	f7fe ff12 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400ed44:	e78b      	b.n	3400ec5e <RCCEx_GetLPTIMCLKFreq+0xaa>
3400ed46:	bf00      	nop
3400ed48:	0702102c 	.word	0x0702102c
3400ed4c:	0701102c 	.word	0x0701102c
3400ed50:	0702082c 	.word	0x0702082c
3400ed54:	07020c2c 	.word	0x07020c2c
3400ed58:	56028000 	.word	0x56028000
3400ed5c:	07040c2c 	.word	0x07040c2c
3400ed60:	07030c2c 	.word	0x07030c2c
3400ed64:	0703182c 	.word	0x0703182c
3400ed68:	07050c2c 	.word	0x07050c2c
3400ed6c:	0705082c 	.word	0x0705082c
3400ed70:	0705102c 	.word	0x0705102c

3400ed74 <HAL_RCCEx_GetPeriphCLKFreq>:
{
3400ed74:	b538      	push	{r3, r4, r5, lr}
  switch (PeriphClk)
3400ed76:	f100 4360 	add.w	r3, r0, #3758096384	@ 0xe0000000
3400ed7a:	430b      	orrs	r3, r1
3400ed7c:	f000 8447 	beq.w	3400f60e <HAL_RCCEx_GetPeriphCLKFreq+0x89a>
3400ed80:	4bbf      	ldr	r3, [pc, #764]	@ (3400f080 <HAL_RCCEx_GetPeriphCLKFreq+0x30c>)
3400ed82:	4298      	cmp	r0, r3
3400ed84:	f171 0300 	sbcs.w	r3, r1, #0
3400ed88:	f080 80e6 	bcs.w	3400ef58 <HAL_RCCEx_GetPeriphCLKFreq+0x1e4>
3400ed8c:	f5a0 3380 	sub.w	r3, r0, #65536	@ 0x10000
3400ed90:	430b      	orrs	r3, r1
3400ed92:	f000 835b 	beq.w	3400f44c <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
3400ed96:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
3400ed9a:	f171 0300 	sbcs.w	r3, r1, #0
3400ed9e:	d26a      	bcs.n	3400ee76 <HAL_RCCEx_GetPeriphCLKFreq+0x102>
3400eda0:	f5a0 7300 	sub.w	r3, r0, #512	@ 0x200
3400eda4:	430b      	orrs	r3, r1
3400eda6:	f000 82b9 	beq.w	3400f31c <HAL_RCCEx_GetPeriphCLKFreq+0x5a8>
3400edaa:	f240 2301 	movw	r3, #513	@ 0x201
3400edae:	4298      	cmp	r0, r3
3400edb0:	f171 0300 	sbcs.w	r3, r1, #0
3400edb4:	d224      	bcs.n	3400ee00 <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
3400edb6:	2809      	cmp	r0, #9
3400edb8:	f171 0300 	sbcs.w	r3, r1, #0
3400edbc:	d215      	bcs.n	3400edea <HAL_RCCEx_GetPeriphCLKFreq+0x76>
3400edbe:	ea50 0301 	orrs.w	r3, r0, r1
3400edc2:	d01b      	beq.n	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3400edc4:	3801      	subs	r0, #1
3400edc6:	f141 31ff 	adc.w	r1, r1, #4294967295
3400edca:	2808      	cmp	r0, #8
3400edcc:	f171 0100 	sbcs.w	r1, r1, #0
3400edd0:	d214      	bcs.n	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3400edd2:	2807      	cmp	r0, #7
3400edd4:	d812      	bhi.n	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3400edd6:	e8df f010 	tbh	[pc, r0, lsl #1]
3400edda:	01a6      	.short	0x01a6
3400eddc:	0011020f 	.word	0x0011020f
3400ede0:	00110285 	.word	0x00110285
3400ede4:	00110011 	.word	0x00110011
3400ede8:	0235      	.short	0x0235
3400edea:	f1a0 0310 	sub.w	r3, r0, #16
3400edee:	430b      	orrs	r3, r1
3400edf0:	f000 8242 	beq.w	3400f278 <HAL_RCCEx_GetPeriphCLKFreq+0x504>
3400edf4:	3820      	subs	r0, #32
3400edf6:	4308      	orrs	r0, r1
3400edf8:	f000 8268 	beq.w	3400f2cc <HAL_RCCEx_GetPeriphCLKFreq+0x558>
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
3400edfc:	2000      	movs	r0, #0
3400edfe:	e219      	b.n	3400f234 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (PeriphClk)
3400ee00:	f5a0 5300 	sub.w	r3, r0, #8192	@ 0x2000
3400ee04:	430b      	orrs	r3, r1
3400ee06:	f000 831d 	beq.w	3400f444 <HAL_RCCEx_GetPeriphCLKFreq+0x6d0>
3400ee0a:	f242 0301 	movw	r3, #8193	@ 0x2001
3400ee0e:	4298      	cmp	r0, r3
3400ee10:	f171 0300 	sbcs.w	r3, r1, #0
3400ee14:	d224      	bcs.n	3400ee60 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
3400ee16:	f5a0 6300 	sub.w	r3, r0, #2048	@ 0x800
3400ee1a:	430b      	orrs	r3, r1
3400ee1c:	f000 82df 	beq.w	3400f3de <HAL_RCCEx_GetPeriphCLKFreq+0x66a>
3400ee20:	f5a0 5380 	sub.w	r3, r0, #4096	@ 0x1000
3400ee24:	430b      	orrs	r3, r1
3400ee26:	f000 8308 	beq.w	3400f43a <HAL_RCCEx_GetPeriphCLKFreq+0x6c6>
3400ee2a:	f5a0 6080 	sub.w	r0, r0, #1024	@ 0x400
3400ee2e:	4308      	orrs	r0, r1
3400ee30:	d1e4      	bne.n	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL));
3400ee32:	4d94      	ldr	r5, [pc, #592]	@ (3400f084 <HAL_RCCEx_GetPeriphCLKFreq+0x310>)
3400ee34:	f8d5 314c 	ldr.w	r3, [r5, #332]	@ 0x14c
3400ee38:	f003 0303 	and.w	r3, r3, #3
  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
3400ee3c:	2b02      	cmp	r3, #2
3400ee3e:	f000 82c1 	beq.w	3400f3c4 <HAL_RCCEx_GetPeriphCLKFreq+0x650>
3400ee42:	2b03      	cmp	r3, #3
3400ee44:	f000 8256 	beq.w	3400f2f4 <HAL_RCCEx_GetPeriphCLKFreq+0x580>
3400ee48:	2b01      	cmp	r3, #1
3400ee4a:	f000 824b 	beq.w	3400f2e4 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      fdcan_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400ee4e:	f7fb fce9 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400ee52:	f7fb fdb7 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400ee56:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400ee58:	f003 0307 	and.w	r3, r3, #7
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400ee5c:	40d8      	lsrs	r0, r3
3400ee5e:	e1e9      	b.n	3400f234 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (PeriphClk)
3400ee60:	f5a0 4380 	sub.w	r3, r0, #16384	@ 0x4000
3400ee64:	430b      	orrs	r3, r1
3400ee66:	f000 82ef 	beq.w	3400f448 <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>
3400ee6a:	f5a0 4000 	sub.w	r0, r0, #32768	@ 0x8000
3400ee6e:	4308      	orrs	r0, r1
3400ee70:	d1c4      	bne.n	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C4_CLKSOURCE);
3400ee72:	4885      	ldr	r0, [pc, #532]	@ (3400f088 <HAL_RCCEx_GetPeriphCLKFreq+0x314>)
3400ee74:	e2e2      	b.n	3400f43c <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
  switch (PeriphClk)
3400ee76:	f5a0 0300 	sub.w	r3, r0, #8388608	@ 0x800000
3400ee7a:	430b      	orrs	r3, r1
3400ee7c:	f000 82f6 	beq.w	3400f46c <HAL_RCCEx_GetPeriphCLKFreq+0x6f8>
3400ee80:	4b82      	ldr	r3, [pc, #520]	@ (3400f08c <HAL_RCCEx_GetPeriphCLKFreq+0x318>)
3400ee82:	4298      	cmp	r0, r3
3400ee84:	f171 0300 	sbcs.w	r3, r1, #0
3400ee88:	d224      	bcs.n	3400eed4 <HAL_RCCEx_GetPeriphCLKFreq+0x160>
3400ee8a:	f5a0 1380 	sub.w	r3, r0, #1048576	@ 0x100000
3400ee8e:	430b      	orrs	r3, r1
3400ee90:	f000 82e8 	beq.w	3400f464 <HAL_RCCEx_GetPeriphCLKFreq+0x6f0>
3400ee94:	4b7e      	ldr	r3, [pc, #504]	@ (3400f090 <HAL_RCCEx_GetPeriphCLKFreq+0x31c>)
3400ee96:	4298      	cmp	r0, r3
3400ee98:	f171 0300 	sbcs.w	r3, r1, #0
3400ee9c:	d20f      	bcs.n	3400eebe <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
3400ee9e:	f5a0 2380 	sub.w	r3, r0, #262144	@ 0x40000
3400eea2:	430b      	orrs	r3, r1
3400eea4:	f000 82d7 	beq.w	3400f456 <HAL_RCCEx_GetPeriphCLKFreq+0x6e2>
3400eea8:	f5a0 2300 	sub.w	r3, r0, #524288	@ 0x80000
3400eeac:	430b      	orrs	r3, r1
3400eeae:	f000 82d7 	beq.w	3400f460 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
3400eeb2:	f5a0 3000 	sub.w	r0, r0, #131072	@ 0x20000
3400eeb6:	4308      	orrs	r0, r1
3400eeb8:	d1a0      	bne.n	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
3400eeba:	4876      	ldr	r0, [pc, #472]	@ (3400f094 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
3400eebc:	e2c7      	b.n	3400f44e <HAL_RCCEx_GetPeriphCLKFreq+0x6da>
  switch (PeriphClk)
3400eebe:	f5a0 1300 	sub.w	r3, r0, #2097152	@ 0x200000
3400eec2:	430b      	orrs	r3, r1
3400eec4:	f000 82d0 	beq.w	3400f468 <HAL_RCCEx_GetPeriphCLKFreq+0x6f4>
3400eec8:	f5a0 0080 	sub.w	r0, r0, #4194304	@ 0x400000
3400eecc:	4308      	orrs	r0, r1
3400eece:	d195      	bne.n	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM5_CLKSOURCE);
3400eed0:	4871      	ldr	r0, [pc, #452]	@ (3400f098 <HAL_RCCEx_GetPeriphCLKFreq+0x324>)
3400eed2:	e2c1      	b.n	3400f458 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
  switch (PeriphClk)
3400eed4:	f100 437c 	add.w	r3, r0, #4227858432	@ 0xfc000000
3400eed8:	430b      	orrs	r3, r1
3400eeda:	f000 834d 	beq.w	3400f578 <HAL_RCCEx_GetPeriphCLKFreq+0x804>
3400eede:	4b6f      	ldr	r3, [pc, #444]	@ (3400f09c <HAL_RCCEx_GetPeriphCLKFreq+0x328>)
3400eee0:	4298      	cmp	r0, r3
3400eee2:	f171 0300 	sbcs.w	r3, r1, #0
3400eee6:	d228      	bcs.n	3400ef3a <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
3400eee8:	f100 437f 	add.w	r3, r0, #4278190080	@ 0xff000000
3400eeec:	430b      	orrs	r3, r1
3400eeee:	f000 8302 	beq.w	3400f4f6 <HAL_RCCEx_GetPeriphCLKFreq+0x782>
3400eef2:	f100 407e 	add.w	r0, r0, #4261412864	@ 0xfe000000
3400eef6:	4308      	orrs	r0, r1
3400eef8:	d180      	bne.n	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (uint32_t)(READ_BIT(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL));
3400eefa:	4d62      	ldr	r5, [pc, #392]	@ (3400f084 <HAL_RCCEx_GetPeriphCLKFreq+0x310>)
3400eefc:	f8d5 3154 	ldr.w	r3, [r5, #340]	@ 0x154
3400ef00:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400ef04:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400ef08:	f000 8195 	beq.w	3400f236 <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
3400ef0c:	f200 8319 	bhi.w	3400f542 <HAL_RCCEx_GetPeriphCLKFreq+0x7ce>
3400ef10:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400ef14:	f000 831f 	beq.w	3400f556 <HAL_RCCEx_GetPeriphCLKFreq+0x7e2>
3400ef18:	f240 81e1 	bls.w	3400f2de <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
3400ef1c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400ef20:	f47f af6c 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400ef24:	f7fb fd06 	bl	3400a934 <LL_RCC_IC8_IsEnabled>
3400ef28:	2800      	cmp	r0, #0
3400ef2a:	f43f af67 	beq.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC8_GetDivider();
3400ef2e:	f7fb fd09 	bl	3400a944 <LL_RCC_IC8_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400ef32:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3400ef36:	4604      	mov	r4, r0
3400ef38:	e191      	b.n	3400f25e <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  switch (PeriphClk)
3400ef3a:	f100 4378 	add.w	r3, r0, #4160749568	@ 0xf8000000
3400ef3e:	430b      	orrs	r3, r1
3400ef40:	f000 8344 	beq.w	3400f5cc <HAL_RCCEx_GetPeriphCLKFreq+0x858>
3400ef44:	f100 4070 	add.w	r0, r0, #4026531840	@ 0xf0000000
3400ef48:	4308      	orrs	r0, r1
3400ef4a:	f47f af57 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI1_CLKSOURCE);
3400ef4e:	4854      	ldr	r0, [pc, #336]	@ (3400f0a0 <HAL_RCCEx_GetPeriphCLKFreq+0x32c>)
}
3400ef50:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
3400ef54:	f7ff bbd6 	b.w	3400e704 <RCCEx_GetSAICLKFreq>
  switch (PeriphClk)
3400ef58:	2300      	movs	r3, #0
3400ef5a:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3400ef5e:	4291      	cmp	r1, r2
3400ef60:	bf08      	it	eq
3400ef62:	4298      	cmpeq	r0, r3
3400ef64:	f000 836f 	beq.w	3400f646 <HAL_RCCEx_GetPeriphCLKFreq+0x8d2>
3400ef68:	4283      	cmp	r3, r0
3400ef6a:	418a      	sbcs	r2, r1
3400ef6c:	d35f      	bcc.n	3400f02e <HAL_RCCEx_GetPeriphCLKFreq+0x2ba>
3400ef6e:	2210      	movs	r2, #16
3400ef70:	4291      	cmp	r1, r2
3400ef72:	bf08      	it	eq
3400ef74:	4298      	cmpeq	r0, r3
3400ef76:	f000 8359 	beq.w	3400f62c <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>
3400ef7a:	4283      	cmp	r3, r0
3400ef7c:	418a      	sbcs	r2, r1
3400ef7e:	d329      	bcc.n	3400efd4 <HAL_RCCEx_GetPeriphCLKFreq+0x260>
3400ef80:	2202      	movs	r2, #2
3400ef82:	4291      	cmp	r1, r2
3400ef84:	bf08      	it	eq
3400ef86:	4298      	cmpeq	r0, r3
3400ef88:	f000 8349 	beq.w	3400f61e <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
3400ef8c:	4283      	cmp	r3, r0
3400ef8e:	418a      	sbcs	r2, r1
3400ef90:	d314      	bcc.n	3400efbc <HAL_RCCEx_GetPeriphCLKFreq+0x248>
3400ef92:	4299      	cmp	r1, r3
3400ef94:	bf08      	it	eq
3400ef96:	f1b0 4f00 	cmpeq.w	r0, #2147483648	@ 0x80000000
3400ef9a:	f000 833a 	beq.w	3400f612 <HAL_RCCEx_GetPeriphCLKFreq+0x89e>
3400ef9e:	2901      	cmp	r1, #1
3400efa0:	bf08      	it	eq
3400efa2:	4298      	cmpeq	r0, r3
3400efa4:	f000 8337 	beq.w	3400f616 <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
3400efa8:	f100 4040 	add.w	r0, r0, #32####MQTT_PASS####5472	@ 0xc0000000
3400efac:	4308      	orrs	r0, r1
3400efae:	f47f af25 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC1_CLKSOURCE);
3400efb2:	483c      	ldr	r0, [pc, #240]	@ (3400f0a4 <HAL_RCCEx_GetPeriphCLKFreq+0x330>)
}
3400efb4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
3400efb8:	f7ff bcd8 	b.w	3400e96c <RCCEx_GetSDMMCCLKFreq>
  switch (PeriphClk)
3400efbc:	2904      	cmp	r1, #4
3400efbe:	bf08      	it	eq
3400efc0:	4298      	cmpeq	r0, r3
3400efc2:	f000 8331 	beq.w	3400f628 <HAL_RCCEx_GetPeriphCLKFreq+0x8b4>
3400efc6:	2908      	cmp	r1, #8
3400efc8:	bf08      	it	eq
3400efca:	4298      	cmpeq	r0, r3
3400efcc:	f47f af16 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI3_CLKSOURCE);
3400efd0:	4835      	ldr	r0, [pc, #212]	@ (3400f0a8 <HAL_RCCEx_GetPeriphCLKFreq+0x334>)
3400efd2:	e325      	b.n	3400f620 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
  switch (PeriphClk)
3400efd4:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400efd8:	4291      	cmp	r1, r2
3400efda:	bf08      	it	eq
3400efdc:	4298      	cmpeq	r0, r3
3400efde:	f000 832e 	beq.w	3400f63e <HAL_RCCEx_GetPeriphCLKFreq+0x8ca>
3400efe2:	4283      	cmp	r3, r0
3400efe4:	418a      	sbcs	r2, r1
3400efe6:	d311      	bcc.n	3400f00c <HAL_RCCEx_GetPeriphCLKFreq+0x298>
3400efe8:	2940      	cmp	r1, #64	@ 0x40
3400efea:	bf08      	it	eq
3400efec:	4298      	cmpeq	r0, r3
3400efee:	f000 831f 	beq.w	3400f630 <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>
3400eff2:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
3400eff6:	bf08      	it	eq
3400eff8:	4298      	cmpeq	r0, r3
3400effa:	f000 831b 	beq.w	3400f634 <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>
3400effe:	2920      	cmp	r1, #32
3400f000:	bf08      	it	eq
3400f002:	2800      	cmpeq	r0, #0
3400f004:	f47f aefa 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI5_CLKSOURCE);
3400f008:	4828      	ldr	r0, [pc, #160]	@ (3400f0ac <HAL_RCCEx_GetPeriphCLKFreq+0x338>)
3400f00a:	e309      	b.n	3400f620 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
  switch (PeriphClk)
3400f00c:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
3400f010:	bf08      	it	eq
3400f012:	4298      	cmpeq	r0, r3
3400f014:	f000 8315 	beq.w	3400f642 <HAL_RCCEx_GetPeriphCLKFreq+0x8ce>
3400f018:	f5b1 6f00 	cmp.w	r1, #2048	@ 0x800
3400f01c:	bf08      	it	eq
3400f01e:	4298      	cmpeq	r0, r3
3400f020:	f47f aeec 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART4_CLKSOURCE);
3400f024:	4822      	ldr	r0, [pc, #136]	@ (3400f0b0 <HAL_RCCEx_GetPeriphCLKFreq+0x33c>)
}
3400f026:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
3400f02a:	f7ff b919 	b.w	3400e260 <RCCEx_GetUARTCLKFreq>
  switch (PeriphClk)
3400f02e:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
3400f032:	4291      	cmp	r1, r2
3400f034:	bf08      	it	eq
3400f036:	4298      	cmpeq	r0, r3
3400f038:	f000 830f 	beq.w	3400f65a <HAL_RCCEx_GetPeriphCLKFreq+0x8e6>
3400f03c:	4283      	cmp	r3, r0
3400f03e:	418a      	sbcs	r2, r1
3400f040:	d34b      	bcc.n	3400f0da <HAL_RCCEx_GetPeriphCLKFreq+0x366>
3400f042:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3400f046:	4291      	cmp	r1, r2
3400f048:	bf08      	it	eq
3400f04a:	4298      	cmpeq	r0, r3
3400f04c:	f000 8301 	beq.w	3400f652 <HAL_RCCEx_GetPeriphCLKFreq+0x8de>
3400f050:	4283      	cmp	r3, r0
3400f052:	418a      	sbcs	r2, r1
3400f054:	d330      	bcc.n	3400f0b8 <HAL_RCCEx_GetPeriphCLKFreq+0x344>
3400f056:	f5b1 4f80 	cmp.w	r1, #16384	@ 0x4000
3400f05a:	bf08      	it	eq
3400f05c:	4298      	cmpeq	r0, r3
3400f05e:	f000 82f4 	beq.w	3400f64a <HAL_RCCEx_GetPeriphCLKFreq+0x8d6>
3400f062:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
3400f066:	bf08      	it	eq
3400f068:	4298      	cmpeq	r0, r3
3400f06a:	f000 82f0 	beq.w	3400f64e <HAL_RCCEx_GetPeriphCLKFreq+0x8da>
3400f06e:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
3400f072:	bf08      	it	eq
3400f074:	2800      	cmpeq	r0, #0
3400f076:	f47f aec1 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART6_CLKSOURCE);
3400f07a:	480e      	ldr	r0, [pc, #56]	@ (3400f0b4 <HAL_RCCEx_GetPeriphCLKFreq+0x340>)
3400f07c:	e2db      	b.n	3400f636 <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
3400f07e:	bf00      	nop
3400f080:	20000001 	.word	0x20000001
3400f084:	56028000 	.word	0x56028000
3400f088:	07000c0c 	.word	0x07000c0c
3400f08c:	00800001 	.word	0x00800001
3400f090:	00100001 	.word	0x00100001
3400f094:	0700140c 	.word	0x0700140c
3400f098:	0700182c 	.word	0x0700182c
3400f09c:	04000001 	.word	0x04000001
3400f0a0:	07001418 	.word	0x07001418
3400f0a4:	0300001c 	.word	0x0300001c
3400f0a8:	07000c20 	.word	0x07000c20
3400f0ac:	07001420 	.word	0x07001420
3400f0b0:	07000c30 	.word	0x07000c30
3400f0b4:	07001430 	.word	0x07001430
  switch (PeriphClk)
3400f0b8:	f5b1 3f00 	cmp.w	r1, #131072	@ 0x20000
3400f0bc:	bf08      	it	eq
3400f0be:	4298      	cmpeq	r0, r3
3400f0c0:	f000 82c9 	beq.w	3400f656 <HAL_RCCEx_GetPeriphCLKFreq+0x8e2>
3400f0c4:	f5b1 2f80 	cmp.w	r1, #262144	@ 0x40000
3400f0c8:	bf08      	it	eq
3400f0ca:	4298      	cmpeq	r0, r3
3400f0cc:	f47f ae96 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY1CKREF_CLKSOURCE);
3400f0d0:	48b4      	ldr	r0, [pc, #720]	@ (3400f3a4 <HAL_RCCEx_GetPeriphCLKFreq+0x630>)
}
3400f0d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
3400f0d6:	f7fe bf8d 	b.w	3400dff4 <RCCEx_GetOTGPHYCKREFCLKFreq>
  switch (PeriphClk)
3400f0da:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
3400f0de:	4291      	cmp	r1, r2
3400f0e0:	bf08      	it	eq
3400f0e2:	4298      	cmpeq	r0, r3
3400f0e4:	f000 82c0 	beq.w	3400f668 <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>
3400f0e8:	4283      	cmp	r3, r0
3400f0ea:	418a      	sbcs	r2, r1
3400f0ec:	d30d      	bcc.n	3400f10a <HAL_RCCEx_GetPeriphCLKFreq+0x396>
3400f0ee:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
3400f0f2:	bf08      	it	eq
3400f0f4:	4298      	cmpeq	r0, r3
3400f0f6:	f000 82b5 	beq.w	3400f664 <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>
3400f0fa:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
3400f0fe:	bf08      	it	eq
3400f100:	4298      	cmpeq	r0, r3
3400f102:	f47f ae7b 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3400f106:	48a8      	ldr	r0, [pc, #672]	@ (3400f3a8 <HAL_RCCEx_GetPeriphCLKFreq+0x634>)
3400f108:	e2a8      	b.n	3400f65c <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>
  switch (PeriphClk)
3400f10a:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
3400f10e:	bf08      	it	eq
3400f110:	4298      	cmpeq	r0, r3
3400f112:	f000 82ae 	beq.w	3400f672 <HAL_RCCEx_GetPeriphCLKFreq+0x8fe>
3400f116:	f1b1 7f80 	cmp.w	r1, #16777216	@ 0x1000000
3400f11a:	bf08      	it	eq
3400f11c:	4298      	cmpeq	r0, r3
3400f11e:	f47f ae6d 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
3400f122:	48a2      	ldr	r0, [pc, #648]	@ (3400f3ac <HAL_RCCEx_GetPeriphCLKFreq+0x638>)
3400f124:	e2a1      	b.n	3400f66a <HAL_RCCEx_GetPeriphCLKFreq+0x8f6>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADC12SEL));
3400f126:	4da2      	ldr	r5, [pc, #648]	@ (3400f3b0 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400f128:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3400f12c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400f130:	2b40      	cmp	r3, #64	@ 0x40
3400f132:	d053      	beq.n	3400f1dc <HAL_RCCEx_GetPeriphCLKFreq+0x468>
3400f134:	d814      	bhi.n	3400f160 <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
3400f136:	2b20      	cmp	r3, #32
3400f138:	d025      	beq.n	3400f186 <HAL_RCCEx_GetPeriphCLKFreq+0x412>
3400f13a:	d805      	bhi.n	3400f148 <HAL_RCCEx_GetPeriphCLKFreq+0x3d4>
3400f13c:	bb03      	cbnz	r3, 3400f180 <HAL_RCCEx_GetPeriphCLKFreq+0x40c>
      adc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400f13e:	f7fb fb71 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400f142:	f7fb fc3f 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
      break;
3400f146:	e002      	b.n	3400f14e <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400f148:	2b30      	cmp	r3, #48	@ 0x30
3400f14a:	d034      	beq.n	3400f1b6 <HAL_RCCEx_GetPeriphCLKFreq+0x442>
  uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
3400f14c:	2000      	movs	r0, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADCPRE) >> RCC_CCIPR1_ADCPRE_Pos);
3400f14e:	4b98      	ldr	r3, [pc, #608]	@ (3400f3b0 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400f150:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400f154:	f3c3 2307 	ubfx	r3, r3, #8, #8
  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
3400f158:	3301      	adds	r3, #1
3400f15a:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
3400f15e:	e069      	b.n	3400f234 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400f160:	2b60      	cmp	r3, #96	@ 0x60
3400f162:	d047      	beq.n	3400f1f4 <HAL_RCCEx_GetPeriphCLKFreq+0x480>
3400f164:	2b70      	cmp	r3, #112	@ 0x70
3400f166:	d03f      	beq.n	3400f1e8 <HAL_RCCEx_GetPeriphCLKFreq+0x474>
3400f168:	2b50      	cmp	r3, #80	@ 0x50
3400f16a:	d1ef      	bne.n	3400f14c <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
      if (LL_RCC_HSI_IsReady() != 0U)
3400f16c:	f7fb fb98 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400f170:	2800      	cmp	r0, #0
3400f172:	d0eb      	beq.n	3400f14c <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400f174:	6cab      	ldr	r3, [r5, #72]	@ 0x48
        adc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400f176:	488f      	ldr	r0, [pc, #572]	@ (3400f3b4 <HAL_RCCEx_GetPeriphCLKFreq+0x640>)
3400f178:	f3c3 13c1 	ubfx	r3, r3, #7, #2
      adc_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
3400f17c:	40d8      	lsrs	r0, r3
      break;
3400f17e:	e7e6      	b.n	3400f14e <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      adc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400f180:	f7fe fd72 	bl	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
      break;
3400f184:	e7e3      	b.n	3400f14e <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400f186:	f7fb fbc3 	bl	3400a910 <LL_RCC_IC7_IsEnabled>
3400f18a:	2800      	cmp	r0, #0
3400f18c:	d0de      	beq.n	3400f14c <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        ic_divider = LL_RCC_IC7_GetDivider();
3400f18e:	f7fb fbc7 	bl	3400a920 <LL_RCC_IC7_GetDivider>
3400f192:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400f194:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400f198:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3400f19c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f1a0:	d019      	beq.n	3400f1d6 <HAL_RCCEx_GetPeriphCLKFreq+0x462>
3400f1a2:	d812      	bhi.n	3400f1ca <HAL_RCCEx_GetPeriphCLKFreq+0x456>
3400f1a4:	b913      	cbnz	r3, 3400f1ac <HAL_RCCEx_GetPeriphCLKFreq+0x438>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400f1a6:	f7fe fc5f 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
3400f1aa:	e001      	b.n	3400f1b0 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400f1ac:	f7fe fc9c 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
            adc_frequency = adc_frequency / ic_divider;
3400f1b0:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400f1b4:	e7cb      	b.n	3400f14e <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400f1b6:	f7fb fbbd 	bl	3400a934 <LL_RCC_IC8_IsEnabled>
3400f1ba:	2800      	cmp	r0, #0
3400f1bc:	d0c6      	beq.n	3400f14c <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        ic_divider = LL_RCC_IC8_GetDivider();
3400f1be:	f7fb fbc1 	bl	3400a944 <LL_RCC_IC8_GetDivider>
3400f1c2:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3400f1c6:	4604      	mov	r4, r0
3400f1c8:	e7e6      	b.n	3400f198 <HAL_RCCEx_GetPeriphCLKFreq+0x424>
        switch (LL_RCC_IC8_GetSource())
3400f1ca:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f1ce:	d1bd      	bne.n	3400f14c <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400f1d0:	f7fe fd0a 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400f1d4:	e7ec      	b.n	3400f1b0 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400f1d6:	f7fe fcc7 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400f1da:	e7e9      	b.n	3400f1b0 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
      if (LL_RCC_MSI_IsReady() != 0U)
3400f1dc:	f7fb fb68 	bl	3400a8b0 <LL_RCC_MSI_IsReady>
3400f1e0:	2800      	cmp	r0, #0
3400f1e2:	d0b3      	beq.n	3400f14c <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        adc_frequency = MSI_VALUE;
3400f1e4:	4874      	ldr	r0, [pc, #464]	@ (3400f3b8 <HAL_RCCEx_GetPeriphCLKFreq+0x644>)
3400f1e6:	e7b2      	b.n	3400f14e <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      adc_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
3400f1e8:	f7fb fb1c 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3400f1ec:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400f1ee:	f3c3 6301 	ubfx	r3, r3, #24, #2
3400f1f2:	e7c3      	b.n	3400f17c <HAL_RCCEx_GetPeriphCLKFreq+0x408>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400f1f4:	4871      	ldr	r0, [pc, #452]	@ (3400f3bc <HAL_RCCEx_GetPeriphCLKFreq+0x648>)
3400f1f6:	e7aa      	b.n	3400f14e <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL));
3400f1f8:	4d6d      	ldr	r5, [pc, #436]	@ (3400f3b0 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400f1fa:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3400f1fe:	f003 0307 	and.w	r3, r3, #7
  switch (LL_RCC_GetADFClockSource(ADFxSource))
3400f202:	3b01      	subs	r3, #1
3400f204:	2b06      	cmp	r3, #6
3400f206:	f200 80f5 	bhi.w	3400f3f4 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
3400f20a:	a201      	add	r2, pc, #4	@ (adr r2, 3400f210 <HAL_RCCEx_GetPeriphCLKFreq+0x49c>)
3400f20c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400f210:	3400f2e5 	.word	0x3400f2e5
3400f214:	3400f557 	.word	0x3400f557
3400f218:	3400ef25 	.word	0x3400ef25
3400f21c:	3400f237 	.word	0x3400f237
3400f220:	3400f2a5 	.word	0x3400f2a5
3400f224:	3400f677 	.word	0x3400f677
3400f228:	3400f56d 	.word	0x3400f56d
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400f22c:	f7fe fc5c 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
            adf_frequency = adf_frequency / ic_divider;
3400f230:	fbb0 f0f4 	udiv	r0, r0, r4
}
3400f234:	bd38      	pop	{r3, r4, r5, pc}
      if (LL_RCC_MSI_IsReady() != 0U)
3400f236:	f7fb fb3b 	bl	3400a8b0 <LL_RCC_MSI_IsReady>
3400f23a:	2800      	cmp	r0, #0
3400f23c:	f43f adde 	beq.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        adf_frequency = MSI_VALUE;
3400f240:	485d      	ldr	r0, [pc, #372]	@ (3400f3b8 <HAL_RCCEx_GetPeriphCLKFreq+0x644>)
3400f242:	e7f7      	b.n	3400f234 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC18EN) == RCC_DIVENR_IC18EN) ? 1UL : 0UL);
3400f244:	4b5a      	ldr	r3, [pc, #360]	@ (3400f3b0 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400f246:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400f24a:	0395      	lsls	r5, r2, #14
3400f24c:	f57f add6 	bpl.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
3400f250:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
  return (uint32_t)(READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL));
3400f254:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
3400f258:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400f25c:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400f25e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC20_GetSource())
3400f262:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f266:	f000 81ae 	beq.w	3400f5c6 <HAL_RCCEx_GetPeriphCLKFreq+0x852>
3400f26a:	f200 81a5 	bhi.w	3400f5b8 <HAL_RCCEx_GetPeriphCLKFreq+0x844>
3400f26e:	2b00      	cmp	r3, #0
3400f270:	d1dc      	bne.n	3400f22c <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>
            pssi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400f272:	f7fe fbf9 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
3400f276:	e7db      	b.n	3400f230 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL));
3400f278:	4d4d      	ldr	r5, [pc, #308]	@ (3400f3b0 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400f27a:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3400f27e:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
3400f282:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400f286:	d014      	beq.n	3400f2b2 <HAL_RCCEx_GetPeriphCLKFreq+0x53e>
3400f288:	d808      	bhi.n	3400f29c <HAL_RCCEx_GetPeriphCLKFreq+0x528>
  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
3400f28a:	bb5b      	cbnz	r3, 3400f2e4 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      ltdc_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400f28c:	f7fb faca 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400f290:	f7fb fb98 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE5));
3400f294:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
  return LL_RCC_CALC_PCLK5_FREQ(HCLK_Frequency, LL_RCC_GetAPB5Prescaler());
3400f296:	f3c3 4302 	ubfx	r3, r3, #16, #3
3400f29a:	e5df      	b.n	3400ee5c <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
3400f29c:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400f2a0:	f47f adac 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3400f2a4:	f7fb fafc 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400f2a8:	2800      	cmp	r0, #0
3400f2aa:	f43f ada7 	beq.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400f2ae:	6cab      	ldr	r3, [r5, #72]	@ 0x48
3400f2b0:	e136      	b.n	3400f520 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC17EN) == RCC_DIVENR_IC17EN) ? 1UL : 0UL);
3400f2b2:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3400f2b6:	03dc      	lsls	r4, r3, #15
3400f2b8:	f57f ada0 	bpl.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3400f2bc:	f8d5 0104 	ldr.w	r0, [r5, #260]	@ 0x104
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
3400f2c0:	f8d5 3104 	ldr.w	r3, [r5, #260]	@ 0x104
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3400f2c4:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400f2c8:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
3400f2ca:	e7c8      	b.n	3400f25e <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL));
3400f2cc:	4a38      	ldr	r2, [pc, #224]	@ (3400f3b0 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400f2ce:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400f2d2:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
  switch (LL_RCC_GetETHClockSource(ETH1xSource))
3400f2d6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3400f2da:	d012      	beq.n	3400f302 <HAL_RCCEx_GetPeriphCLKFreq+0x58e>
3400f2dc:	d806      	bhi.n	3400f2ec <HAL_RCCEx_GetPeriphCLKFreq+0x578>
  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
3400f2de:	2b00      	cmp	r3, #0
3400f2e0:	f000 8088 	beq.w	3400f3f4 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
}
3400f2e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400f2e8:	f7fe bcbe 	b.w	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetETHClockSource(ETH1xSource))
3400f2ec:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3400f2f0:	f47f ad84 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSE_IsReady() != 0U)
3400f2f4:	f7fb facc 	bl	3400a890 <LL_RCC_HSE_IsReady>
3400f2f8:	2800      	cmp	r0, #0
3400f2fa:	f43f ad7f 	beq.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        eth1_frequency = HSE_VALUE;
3400f2fe:	4830      	ldr	r0, [pc, #192]	@ (3400f3c0 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
3400f300:	e798      	b.n	3400f234 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC12EN) == RCC_DIVENR_IC12EN) ? 1UL : 0UL);
3400f302:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3400f306:	0518      	lsls	r0, r3, #20
3400f308:	f57f ad78 	bpl.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
3400f30c:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
3400f310:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
3400f314:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400f318:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
3400f31a:	e7a0      	b.n	3400f25e <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPSEL));
3400f31c:	4a24      	ldr	r2, [pc, #144]	@ (3400f3b0 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400f31e:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400f322:	f003 0303 	and.w	r3, r3, #3
  switch (LL_RCC_GetETHPTPClockSource(ETH1PTPxSource))
3400f326:	2b02      	cmp	r3, #2
3400f328:	d010      	beq.n	3400f34c <HAL_RCCEx_GetPeriphCLKFreq+0x5d8>
3400f32a:	2b03      	cmp	r3, #3
3400f32c:	d034      	beq.n	3400f398 <HAL_RCCEx_GetPeriphCLKFreq+0x624>
3400f32e:	2b01      	cmp	r3, #1
3400f330:	d009      	beq.n	3400f346 <HAL_RCCEx_GetPeriphCLKFreq+0x5d2>
      eth1ptp_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400f332:	f7fb fa77 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400f336:	f7fb fb45 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPDIV));
3400f33a:	4b1d      	ldr	r3, [pc, #116]	@ (3400f3b0 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400f33c:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
3400f340:	f3c3 1303 	ubfx	r3, r3, #4, #4
3400f344:	e708      	b.n	3400f158 <HAL_RCCEx_GetPeriphCLKFreq+0x3e4>
      eth1ptp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400f346:	f7fe fc8f 	bl	3400dc68 <RCCEx_GetCLKPCLKFreq.constprop.0>
      break;
3400f34a:	e7f6      	b.n	3400f33a <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC13EN) == RCC_DIVENR_IC13EN) ? 1UL : 0UL);
3400f34c:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3400f350:	04d9      	lsls	r1, r3, #19
3400f352:	d516      	bpl.n	3400f382 <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3400f354:	f8d2 00f4 	ldr.w	r0, [r2, #244]	@ 0xf4
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
3400f358:	f8d2 30f4 	ldr.w	r3, [r2, #244]	@ 0xf4
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3400f35c:	f3c0 4007 	ubfx	r0, r0, #16, #8
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
3400f360:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC13_GetSource())
3400f364:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3400f368:	f100 0401 	add.w	r4, r0, #1
3400f36c:	d00e      	beq.n	3400f38c <HAL_RCCEx_GetPeriphCLKFreq+0x618>
3400f36e:	d805      	bhi.n	3400f37c <HAL_RCCEx_GetPeriphCLKFreq+0x608>
3400f370:	b94b      	cbnz	r3, 3400f386 <HAL_RCCEx_GetPeriphCLKFreq+0x612>
            eth1ptp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400f372:	f7fe fb79 	bl	3400da68 <HAL_RCCEx_GetPLL1CLKFreq>
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3400f376:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400f37a:	e7de      	b.n	3400f33a <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
        switch (LL_RCC_IC13_GetSource())
3400f37c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f380:	d007      	beq.n	3400f392 <HAL_RCCEx_GetPeriphCLKFreq+0x61e>
        eth1ptp_frequency = HSE_VALUE;
3400f382:	2000      	movs	r0, #0
3400f384:	e7d9      	b.n	3400f33a <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
            eth1ptp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400f386:	f7fe fbaf 	bl	3400dae8 <HAL_RCCEx_GetPLL2CLKFreq>
3400f38a:	e7f4      	b.n	3400f376 <HAL_RCCEx_GetPeriphCLKFreq+0x602>
            eth1ptp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400f38c:	f7fe fbec 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400f390:	e7f1      	b.n	3400f376 <HAL_RCCEx_GetPeriphCLKFreq+0x602>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400f392:	f7fe fc29 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400f396:	e7ee      	b.n	3400f376 <HAL_RCCEx_GetPeriphCLKFreq+0x602>
      if (LL_RCC_HSE_IsReady() != 0U)
3400f398:	f7fb fa7a 	bl	3400a890 <LL_RCC_HSE_IsReady>
3400f39c:	2800      	cmp	r0, #0
3400f39e:	d0f0      	beq.n	3400f382 <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
        eth1ptp_frequency = HSE_VALUE;
3400f3a0:	4807      	ldr	r0, [pc, #28]	@ (3400f3c0 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
3400f3a2:	e7ca      	b.n	3400f33a <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
3400f3a4:	01001014 	.word	0x01001014
3400f3a8:	03001414 	.word	0x03001414
3400f3ac:	03000814 	.word	0x03000814
3400f3b0:	56028000 	.word	0x56028000
3400f3b4:	03d09000 	.word	0x03d09000
3400f3b8:	003d0900 	.word	0x003d0900
3400f3bc:	00bb8000 	.word	0x00bb8000
3400f3c0:	02dc6c00 	.word	0x02dc6c00
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3400f3c4:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3400f3c8:	035b      	lsls	r3, r3, #13
3400f3ca:	f57f ad17 	bpl.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400f3ce:	f8d5 010c 	ldr.w	r0, [r5, #268]	@ 0x10c
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400f3d2:	f8d5 310c 	ldr.w	r3, [r5, #268]	@ 0x10c
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400f3d6:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400f3da:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400f3dc:	e73f      	b.n	3400f25e <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FMCSEL));
3400f3de:	4ba7      	ldr	r3, [pc, #668]	@ (3400f67c <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400f3e0:	f8d3 214c 	ldr.w	r2, [r3, #332]	@ 0x14c
3400f3e4:	f002 0230 	and.w	r2, r2, #48	@ 0x30
  switch (LL_RCC_GetFMCClockSource(FMCxSource))
3400f3e8:	2a20      	cmp	r2, #32
3400f3ea:	d019      	beq.n	3400f420 <HAL_RCCEx_GetPeriphCLKFreq+0x6ac>
3400f3ec:	d808      	bhi.n	3400f400 <HAL_RCCEx_GetPeriphCLKFreq+0x68c>
3400f3ee:	2a00      	cmp	r2, #0
3400f3f0:	f47f af78 	bne.w	3400f2e4 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400f3f4:	f7fb fa16 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
}
3400f3f8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400f3fc:	f7fb bae2 	b.w	3400a9c4 <RCCEx_GetHCLKFreq>
  switch (LL_RCC_GetFMCClockSource(FMCxSource))
3400f400:	2a30      	cmp	r2, #48	@ 0x30
3400f402:	f47f acfb 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3400f406:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400f40a:	0714      	lsls	r4, r2, #28
3400f40c:	f57f acf6 	bpl.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400f410:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400f414:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400f418:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400f41c:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400f41e:	e71e      	b.n	3400f25e <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3400f420:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400f424:	0755      	lsls	r5, r2, #29
3400f426:	f57f ace9 	bpl.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400f42a:	f8d3 00cc 	ldr.w	r0, [r3, #204]	@ 0xcc
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3400f42e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400f432:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400f436:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3400f438:	e711      	b.n	3400f25e <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C1_CLKSOURCE);
3400f43a:	4891      	ldr	r0, [pc, #580]	@ (3400f680 <HAL_RCCEx_GetPeriphCLKFreq+0x90c>)
}
3400f43c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C2_CLKSOURCE);
3400f440:	f7ff bafa 	b.w	3400ea38 <RCCEx_GetI2CCLKFreq>
3400f444:	488f      	ldr	r0, [pc, #572]	@ (3400f684 <HAL_RCCEx_GetPeriphCLKFreq+0x910>)
3400f446:	e7f9      	b.n	3400f43c <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C3_CLKSOURCE);
3400f448:	488f      	ldr	r0, [pc, #572]	@ (3400f688 <HAL_RCCEx_GetPeriphCLKFreq+0x914>)
3400f44a:	e7f7      	b.n	3400f43c <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C1_CLKSOURCE);
3400f44c:	488f      	ldr	r0, [pc, #572]	@ (3400f68c <HAL_RCCEx_GetPeriphCLKFreq+0x918>)
}
3400f44e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
3400f452:	f7ff b9ff 	b.w	3400e854 <RCCEx_GetI3CCLKFreq>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM1_CLKSOURCE);
3400f456:	488e      	ldr	r0, [pc, #568]	@ (3400f690 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>)
}
3400f458:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM2_CLKSOURCE);
3400f45c:	f7ff bbaa 	b.w	3400ebb4 <RCCEx_GetLPTIMCLKFreq>
3400f460:	488c      	ldr	r0, [pc, #560]	@ (3400f694 <HAL_RCCEx_GetPeriphCLKFreq+0x920>)
3400f462:	e7f9      	b.n	3400f458 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM3_CLKSOURCE);
3400f464:	488c      	ldr	r0, [pc, #560]	@ (3400f698 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
3400f466:	e7f7      	b.n	3400f458 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM4_CLKSOURCE);
3400f468:	488c      	ldr	r0, [pc, #560]	@ (3400f69c <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
3400f46a:	e7f5      	b.n	3400f458 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
  return (uint32_t)(READ_BIT(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL));
3400f46c:	4a83      	ldr	r2, [pc, #524]	@ (3400f67c <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400f46e:	f8d2 3178 	ldr.w	r3, [r2, #376]	@ 0x178
3400f472:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
3400f476:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400f47a:	d031      	beq.n	3400f4e0 <HAL_RCCEx_GetPeriphCLKFreq+0x76c>
3400f47c:	d812      	bhi.n	3400f4a4 <HAL_RCCEx_GetPeriphCLKFreq+0x730>
3400f47e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f482:	f43f af2f 	beq.w	3400f2e4 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
3400f486:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400f48a:	d01d      	beq.n	3400f4c8 <HAL_RCCEx_GetPeriphCLKFreq+0x754>
3400f48c:	2b00      	cmp	r3, #0
3400f48e:	f47f acb5 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      lpuart_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400f492:	f7fb f9c7 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
3400f496:	f7fb fa95 	bl	3400a9c4 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400f49a:	4b78      	ldr	r3, [pc, #480]	@ (3400f67c <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400f49c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400f49e:	f3c3 3302 	ubfx	r3, r3, #12, #3
3400f4a2:	e4db      	b.n	3400ee5c <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
3400f4a4:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
3400f4a8:	f43f aec5 	beq.w	3400f236 <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
3400f4ac:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3400f4b0:	d02f      	beq.n	3400f512 <HAL_RCCEx_GetPeriphCLKFreq+0x79e>
3400f4b2:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
  switch (LL_RCC_GetRTCClockSource())
3400f4b6:	f47f aca1 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_LSE_IsReady() != 0U)
3400f4ba:	f7fb fa01 	bl	3400a8c0 <LL_RCC_LSE_IsReady>
3400f4be:	3800      	subs	r0, #0
3400f4c0:	bf18      	it	ne
3400f4c2:	2001      	movne	r0, #1
3400f4c4:	03c0      	lsls	r0, r0, #15
3400f4c6:	e6b5      	b.n	3400f234 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400f4c8:	f7fb fa46 	bl	3400a958 <LL_RCC_IC9_IsEnabled>
3400f4cc:	2800      	cmp	r0, #0
3400f4ce:	f43f ac95 	beq.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC9_GetDivider();
3400f4d2:	f7fb fa49 	bl	3400a968 <LL_RCC_IC9_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400f4d6:	4b69      	ldr	r3, [pc, #420]	@ (3400f67c <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400f4d8:	4604      	mov	r4, r0
3400f4da:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400f4de:	e6be      	b.n	3400f25e <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400f4e0:	f7fb fa4c 	bl	3400a97c <LL_RCC_IC14_IsEnabled>
3400f4e4:	2800      	cmp	r0, #0
3400f4e6:	f43f ac89 	beq.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC14_GetDivider();
3400f4ea:	f7fb fa4f 	bl	3400a98c <LL_RCC_IC14_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400f4ee:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400f4f2:	4604      	mov	r4, r0
3400f4f4:	e6b3      	b.n	3400f25e <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL));
3400f4f6:	4d61      	ldr	r5, [pc, #388]	@ (3400f67c <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400f4f8:	f8d5 3150 	ldr.w	r3, [r5, #336]	@ 0x150
3400f4fc:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
3400f500:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400f504:	d010      	beq.n	3400f528 <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>
3400f506:	f67f aec0 	bls.w	3400f28a <HAL_RCCEx_GetPeriphCLKFreq+0x516>
3400f50a:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3400f50e:	f47f ac75 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3400f512:	f7fb f9c5 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400f516:	2800      	cmp	r0, #0
3400f518:	f43f ac70 	beq.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400f51c:	4b57      	ldr	r3, [pc, #348]	@ (3400f67c <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400f51e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400f520:	485f      	ldr	r0, [pc, #380]	@ (3400f6a0 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
3400f522:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400f526:	e499      	b.n	3400ee5c <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC16EN) == RCC_DIVENR_IC16EN) ? 1UL : 0UL);
3400f528:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3400f52c:	0418      	lsls	r0, r3, #16
3400f52e:	f57f ac65 	bpl.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3400f532:	f8d5 0100 	ldr.w	r0, [r5, #256]	@ 0x100
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3400f536:	f8d5 3100 	ldr.w	r3, [r5, #256]	@ 0x100
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3400f53a:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400f53e:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3400f540:	e68d      	b.n	3400f25e <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400f542:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3400f546:	f000 8096 	beq.w	3400f676 <HAL_RCCEx_GetPeriphCLKFreq+0x902>
3400f54a:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
3400f54e:	d00d      	beq.n	3400f56c <HAL_RCCEx_GetPeriphCLKFreq+0x7f8>
3400f550:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3400f554:	e6a4      	b.n	3400f2a0 <HAL_RCCEx_GetPeriphCLKFreq+0x52c>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400f556:	f7fb f9db 	bl	3400a910 <LL_RCC_IC7_IsEnabled>
3400f55a:	2800      	cmp	r0, #0
3400f55c:	f43f ac4e 	beq.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC7_GetDivider();
3400f560:	f7fb f9de 	bl	3400a920 <LL_RCC_IC7_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400f564:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
3400f568:	4604      	mov	r4, r0
3400f56a:	e678      	b.n	3400f25e <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      adf_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
3400f56c:	f7fb f95a 	bl	3400a824 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3400f570:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400f572:	f3c3 6301 	ubfx	r3, r3, #24, #2
3400f576:	e471      	b.n	3400ee5c <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PSSISEL));
3400f578:	4a40      	ldr	r2, [pc, #256]	@ (3400f67c <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400f57a:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400f57e:	f003 0330 	and.w	r3, r3, #48	@ 0x30
  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
3400f582:	2b20      	cmp	r3, #32
3400f584:	d00b      	beq.n	3400f59e <HAL_RCCEx_GetPeriphCLKFreq+0x82a>
3400f586:	f67f aeaa 	bls.w	3400f2de <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
3400f58a:	2b30      	cmp	r3, #48	@ 0x30
3400f58c:	f47f ac36 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3400f590:	f7fb f986 	bl	3400a8a0 <LL_RCC_HSI_IsReady>
3400f594:	2800      	cmp	r0, #0
3400f596:	f43f ac31 	beq.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400f59a:	6c93      	ldr	r3, [r2, #72]	@ 0x48
3400f59c:	e7c0      	b.n	3400f520 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
3400f59e:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3400f5a2:	0319      	lsls	r1, r3, #12
3400f5a4:	f57f ac2a 	bpl.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400f5a8:	f8d2 0110 	ldr.w	r0, [r2, #272]	@ 0x110
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400f5ac:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400f5b0:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400f5b4:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400f5b6:	e652      	b.n	3400f25e <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
        switch (LL_RCC_IC20_GetSource())
3400f5b8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f5bc:	f47f ac1e 	bne.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
            pssi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400f5c0:	f7fe fb12 	bl	3400dbe8 <HAL_RCCEx_GetPLL4CLKFreq>
3400f5c4:	e634      	b.n	3400f230 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
            pssi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400f5c6:	f7fe facf 	bl	3400db68 <HAL_RCCEx_GetPLL3CLKFreq>
3400f5ca:	e631      	b.n	3400f230 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3400f5cc:	4a2b      	ldr	r2, [pc, #172]	@ (3400f67c <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400f5ce:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400f5d2:	f403 7340 	and.w	r3, r3, #768	@ 0x300
  switch (LL_RCC_GetRTCClockSource())
3400f5d6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400f5da:	d005      	beq.n	3400f5e8 <HAL_RCCEx_GetPeriphCLKFreq+0x874>
3400f5dc:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400f5e0:	d009      	beq.n	3400f5f6 <HAL_RCCEx_GetPeriphCLKFreq+0x882>
3400f5e2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f5e6:	e766      	b.n	3400f4b6 <HAL_RCCEx_GetPeriphCLKFreq+0x742>
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3400f5e8:	6853      	ldr	r3, [r2, #4]
      if (LL_RCC_LSI_IsReady() != 0U)
3400f5ea:	07db      	lsls	r3, r3, #31
3400f5ec:	f57f ac06 	bpl.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        rtc_frequency = LSI_VALUE;
3400f5f0:	f44f 40fa 	mov.w	r0, #32000	@ 0x7d00
  return frequency;
3400f5f4:	e61e      	b.n	3400f234 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
      if (LL_RCC_HSE_IsReady() != 0U)
3400f5f6:	f7fb f94b 	bl	3400a890 <LL_RCC_HSE_IsReady>
3400f5fa:	2800      	cmp	r0, #0
3400f5fc:	f43f abfe 	beq.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
3400f600:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
        rtc_frequency = HSE_VALUE / prescaler;
3400f604:	4827      	ldr	r0, [pc, #156]	@ (3400f6a4 <HAL_RCCEx_GetPeriphCLKFreq+0x930>)
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
3400f606:	f3c3 3305 	ubfx	r3, r3, #12, #6
3400f60a:	3301      	adds	r3, #1
3400f60c:	e5a5      	b.n	3400f15a <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
3400f60e:	4826      	ldr	r0, [pc, #152]	@ (3400f6a8 <HAL_RCCEx_GetPeriphCLKFreq+0x934>)
3400f610:	e49e      	b.n	3400ef50 <HAL_RCCEx_GetPeriphCLKFreq+0x1dc>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
3400f612:	4826      	ldr	r0, [pc, #152]	@ (3400f6ac <HAL_RCCEx_GetPeriphCLKFreq+0x938>)
3400f614:	e4ce      	b.n	3400efb4 <HAL_RCCEx_GetPeriphCLKFreq+0x240>
}
3400f616:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
3400f61a:	f7fe bbab 	b.w	3400dd74 <RCCEx_GetSPDIFRXCLKFreq.constprop.0>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI1_CLKSOURCE);
3400f61e:	4824      	ldr	r0, [pc, #144]	@ (3400f6b0 <HAL_RCCEx_GetPeriphCLKFreq+0x93c>)
}
3400f620:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
3400f624:	f7fe bf30 	b.w	3400e488 <RCCEx_GetSPICLKFreq>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI2_CLKSOURCE);
3400f628:	4822      	ldr	r0, [pc, #136]	@ (3400f6b4 <HAL_RCCEx_GetPeriphCLKFreq+0x940>)
3400f62a:	e7f9      	b.n	3400f620 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI4_CLKSOURCE);
3400f62c:	4822      	ldr	r0, [pc, #136]	@ (3400f6b8 <HAL_RCCEx_GetPeriphCLKFreq+0x944>)
3400f62e:	e7f7      	b.n	3400f620 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
3400f630:	4822      	ldr	r0, [pc, #136]	@ (3400f6bc <HAL_RCCEx_GetPeriphCLKFreq+0x948>)
3400f632:	e7f5      	b.n	3400f620 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART1_CLKSOURCE);
3400f634:	4822      	ldr	r0, [pc, #136]	@ (3400f6c0 <HAL_RCCEx_GetPeriphCLKFreq+0x94c>)
}
3400f636:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
3400f63a:	f7fe bd0d 	b.w	3400e058 <RCCEx_GetUSARTCLKFreq>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART2_CLKSOURCE);
3400f63e:	4821      	ldr	r0, [pc, #132]	@ (3400f6c4 <HAL_RCCEx_GetPeriphCLKFreq+0x950>)
3400f640:	e7f9      	b.n	3400f636 <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART3_CLKSOURCE);
3400f642:	4821      	ldr	r0, [pc, #132]	@ (3400f6c8 <HAL_RCCEx_GetPeriphCLKFreq+0x954>)
3400f644:	e7f7      	b.n	3400f636 <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART5_CLKSOURCE);
3400f646:	4821      	ldr	r0, [pc, #132]	@ (3400f6cc <HAL_RCCEx_GetPeriphCLKFreq+0x958>)
3400f648:	e4ed      	b.n	3400f026 <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART7_CLKSOURCE);
3400f64a:	4821      	ldr	r0, [pc, #132]	@ (3400f6d0 <HAL_RCCEx_GetPeriphCLKFreq+0x95c>)
3400f64c:	e4eb      	b.n	3400f026 <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART8_CLKSOURCE);
3400f64e:	4821      	ldr	r0, [pc, #132]	@ (3400f6d4 <HAL_RCCEx_GetPeriphCLKFreq+0x960>)
3400f650:	e4e9      	b.n	3400f026 <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
3400f652:	4821      	ldr	r0, [pc, #132]	@ (3400f6d8 <HAL_RCCEx_GetPeriphCLKFreq+0x964>)
3400f654:	e4e7      	b.n	3400f026 <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
3400f656:	4821      	ldr	r0, [pc, #132]	@ (3400f6dc <HAL_RCCEx_GetPeriphCLKFreq+0x968>)
3400f658:	e7ed      	b.n	3400f636 <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
3400f65a:	4821      	ldr	r0, [pc, #132]	@ (3400f6e0 <HAL_RCCEx_GetPeriphCLKFreq+0x96c>)
}
3400f65c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3400f660:	f7fe bc62 	b.w	3400df28 <RCCEx_GetOTGPHYCLKFreq>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
3400f664:	481f      	ldr	r0, [pc, #124]	@ (3400f6e4 <HAL_RCCEx_GetPeriphCLKFreq+0x970>)
3400f666:	e534      	b.n	3400f0d2 <HAL_RCCEx_GetPeriphCLKFreq+0x35e>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI1_CLKSOURCE);
3400f668:	481f      	ldr	r0, [pc, #124]	@ (3400f6e8 <HAL_RCCEx_GetPeriphCLKFreq+0x974>)
}
3400f66a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
3400f66e:	f7fe bbe1 	b.w	3400de34 <RCCEx_GetXSPICLKFreq>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI2_CLKSOURCE);
3400f672:	481e      	ldr	r0, [pc, #120]	@ (3400f6ec <HAL_RCCEx_GetPeriphCLKFreq+0x978>)
3400f674:	e7f9      	b.n	3400f66a <HAL_RCCEx_GetPeriphCLKFreq+0x8f6>
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400f676:	481e      	ldr	r0, [pc, #120]	@ (3400f6f0 <HAL_RCCEx_GetPeriphCLKFreq+0x97c>)
3400f678:	e5dc      	b.n	3400f234 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
3400f67a:	bf00      	nop
3400f67c:	56028000 	.word	0x56028000
3400f680:	0700000c 	.word	0x0700000c
3400f684:	0700040c 	.word	0x0700040c
3400f688:	0700080c 	.word	0x0700080c
3400f68c:	0700100c 	.word	0x0700100c
3400f690:	0700082c 	.word	0x0700082c
3400f694:	07000c2c 	.word	0x07000c2c
3400f698:	0700102c 	.word	0x0700102c
3400f69c:	0700142c 	.word	0x0700142c
3400f6a0:	03d09000 	.word	0x03d09000
3400f6a4:	02dc6c00 	.word	0x02dc6c00
3400f6a8:	07001818 	.word	0x07001818
3400f6ac:	0300041c 	.word	0x0300041c
3400f6b0:	07000420 	.word	0x07000420
3400f6b4:	07000820 	.word	0x07000820
3400f6b8:	07001020 	.word	0x07001020
3400f6bc:	07001820 	.word	0x07001820
3400f6c0:	07000030 	.word	0x07000030
3400f6c4:	07000430 	.word	0x07000430
3400f6c8:	07000830 	.word	0x07000830
3400f6cc:	07001030 	.word	0x07001030
3400f6d0:	07001830 	.word	0x07001830
3400f6d4:	07001c30 	.word	0x07001c30
3400f6d8:	07000034 	.word	0x07000034
3400f6dc:	07000434 	.word	0x07000434
3400f6e0:	03000c14 	.word	0x03000c14
3400f6e4:	01001814 	.word	0x01001814
3400f6e8:	03000014 	.word	0x03000014
3400f6ec:	03000414 	.word	0x03000414
3400f6f0:	00bb8000 	.word	0x00bb8000

3400f6f4 <HAL_RIF_RIMC_ConfigMasterAttributes>:
  *         This parameter can be one of @ref RIF_MASTER_INDEX
  * @param  pConfig Pointer on Master Isolation configuration structure
  * @retval None
  */
void HAL_RIF_RIMC_ConfigMasterAttributes(uint32_t MasterId, const RIMC_MasterConfig_t *pConfig)
{
3400f6f4:	b538      	push	{r3, r4, r5, lr}
3400f6f6:	4604      	mov	r4, r0
  uint32_t master_cid;
  uint32_t rimc_attr_val;

  /* Check the parameter */
  assert_param(pConfig != (void *)NULL);
3400f6f8:	460d      	mov	r5, r1
3400f6fa:	b921      	cbnz	r1, 3400f706 <HAL_RIF_RIMC_ConfigMasterAttributes+0x12>
3400f6fc:	f240 1111 	movw	r1, #273	@ 0x111
3400f700:	4825      	ldr	r0, [pc, #148]	@ (3400f798 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400f702:	f7f3 fa85 	bl	34002c10 <assert_failed>
  assert_param(IS_RIF_MASTER_INDEX(MasterId));
3400f706:	2c0c      	cmp	r4, #12
3400f708:	d904      	bls.n	3400f714 <HAL_RIF_RIMC_ConfigMasterAttributes+0x20>
3400f70a:	f44f 7189 	mov.w	r1, #274	@ 0x112
3400f70e:	4822      	ldr	r0, [pc, #136]	@ (3400f798 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400f710:	f7f3 fa7e 	bl	34002c10 <assert_failed>
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
3400f714:	682b      	ldr	r3, [r5, #0]
3400f716:	2b20      	cmp	r3, #32
3400f718:	d838      	bhi.n	3400f78c <HAL_RIF_RIMC_ConfigMasterAttributes+0x98>
3400f71a:	2b03      	cmp	r3, #3
3400f71c:	d82a      	bhi.n	3400f774 <HAL_RIF_RIMC_ConfigMasterAttributes+0x80>
3400f71e:	3b01      	subs	r3, #1
3400f720:	2b01      	cmp	r3, #1
3400f722:	d82d      	bhi.n	3400f780 <HAL_RIF_RIMC_ConfigMasterAttributes+0x8c>
  assert_param(IS_RIF_MASTER_CID(pConfig->MasterCID));
3400f724:	682b      	ldr	r3, [r5, #0]
3400f726:	2b80      	cmp	r3, #128	@ 0x80
3400f728:	d001      	beq.n	3400f72e <HAL_RIF_RIMC_ConfigMasterAttributes+0x3a>
3400f72a:	2bff      	cmp	r3, #255	@ 0xff
3400f72c:	d904      	bls.n	3400f738 <HAL_RIF_RIMC_ConfigMasterAttributes+0x44>
3400f72e:	f44f 718a 	mov.w	r1, #276	@ 0x114
3400f732:	4819      	ldr	r0, [pc, #100]	@ (3400f798 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400f734:	f7f3 fa6c 	bl	34002c10 <assert_failed>
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(pConfig->SecPriv));
3400f738:	686b      	ldr	r3, [r5, #4]
3400f73a:	2b03      	cmp	r3, #3
3400f73c:	d904      	bls.n	3400f748 <HAL_RIF_RIMC_ConfigMasterAttributes+0x54>
3400f73e:	f240 1115 	movw	r1, #277	@ 0x115
3400f742:	4815      	ldr	r0, [pc, #84]	@ (3400f798 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400f744:	f7f3 fa64 	bl	34002c10 <assert_failed>
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
3400f748:	682b      	ldr	r3, [r5, #0]
3400f74a:	fa93 f3a3 	rbit	r3, r3
  return __builtin_clz(value);
3400f74e:	fab3 f283 	clz	r2, r3

  master_cid = POSITION_VAL(pConfig->MasterCID);
  rimc_attr_val = RIFSC->RIMC_ATTRx[MasterId];
3400f752:	00a0      	lsls	r0, r4, #2
3400f754:	f100 40a8 	add.w	r0, r0, #1409286144	@ 0x54000000
3400f758:	f500 3010 	add.w	r0, r0, #147456	@ 0x24000
3400f75c:	f8d0 3c10 	ldr.w	r3, [r0, #3088]	@ 0xc10
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
3400f760:	6869      	ldr	r1, [r5, #4]
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
3400f762:	f423 735c 	bic.w	r3, r3, #880	@ 0x370
3400f766:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
3400f76a:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
  RIFSC->RIMC_ATTRx[MasterId] = rimc_attr_val;
3400f76e:	f8c0 3c10 	str.w	r3, [r0, #3088]	@ 0xc10
}
3400f772:	bd38      	pop	{r3, r4, r5, pc}
3400f774:	4a09      	ldr	r2, [pc, #36]	@ (3400f79c <HAL_RIF_RIMC_ConfigMasterAttributes+0xa8>)
3400f776:	3b04      	subs	r3, #4
3400f778:	fa22 f303 	lsr.w	r3, r2, r3
3400f77c:	07db      	lsls	r3, r3, #31
3400f77e:	d4d1      	bmi.n	3400f724 <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
3400f780:	f240 1113 	movw	r1, #275	@ 0x113
3400f784:	4804      	ldr	r0, [pc, #16]	@ (3400f798 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400f786:	f7f3 fa43 	bl	34002c10 <assert_failed>
3400f78a:	e7cb      	b.n	3400f724 <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
3400f78c:	2b40      	cmp	r3, #64	@ 0x40
3400f78e:	d0c9      	beq.n	3400f724 <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
3400f790:	2b80      	cmp	r3, #128	@ 0x80
3400f792:	d1f5      	bne.n	3400f780 <HAL_RIF_RIMC_ConfigMasterAttributes+0x8c>
3400f794:	e7c6      	b.n	3400f724 <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
3400f796:	bf00      	nop
3400f798:	34020515 	.word	0x34020515
3400f79c:	10001011 	.word	0x10001011

3400f7a0 <HAL_RIF_RISC_SetSlaveSecureAttributes>:
  */
void HAL_RIF_RISC_SetSlaveSecureAttributes(uint32_t PeriphId, uint32_t SecPriv)
{
  __IO uint32_t sec_reg_val;

  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
3400f7a0:	4b38      	ldr	r3, [pc, #224]	@ (3400f884 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xe4>)
{
3400f7a2:	b537      	push	{r0, r1, r2, r4, r5, lr}
3400f7a4:	4298      	cmp	r0, r3
3400f7a6:	4604      	mov	r4, r0
3400f7a8:	460d      	mov	r5, r1
3400f7aa:	d85c      	bhi.n	3400f866 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xc6>
3400f7ac:	3b1e      	subs	r3, #30
3400f7ae:	4298      	cmp	r0, r3
3400f7b0:	d83b      	bhi.n	3400f82a <HAL_RIF_RISC_SetSlaveSecureAttributes+0x8a>
3400f7b2:	4b35      	ldr	r3, [pc, #212]	@ (3400f888 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xe8>)
3400f7b4:	4298      	cmp	r0, r3
3400f7b6:	d84b      	bhi.n	3400f850 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xb0>
3400f7b8:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
3400f7bc:	d23a      	bcs.n	3400f834 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x94>
3400f7be:	4b33      	ldr	r3, [pc, #204]	@ (3400f88c <HAL_RIF_RISC_SetSlaveSecureAttributes+0xec>)
3400f7c0:	4298      	cmp	r0, r3
3400f7c2:	d840      	bhi.n	3400f846 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa6>
3400f7c4:	1fc2      	subs	r2, r0, #7
3400f7c6:	3b22      	subs	r3, #34	@ 0x22
3400f7c8:	429a      	cmp	r2, r3
3400f7ca:	d937      	bls.n	3400f83c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x9c>
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(SecPriv));
3400f7cc:	2d03      	cmp	r5, #3
3400f7ce:	d904      	bls.n	3400f7da <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3a>
3400f7d0:	f44f 71ba 	mov.w	r1, #372	@ 0x174
3400f7d4:	482e      	ldr	r0, [pc, #184]	@ (3400f890 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf0>)
3400f7d6:	f7f3 fa1b 	bl	34002c10 <assert_failed>

  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
  sec_reg_val &= (~(1UL << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f7da:	2201      	movs	r2, #1
  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f7dc:	0f20      	lsrs	r0, r4, #28
3400f7de:	0080      	lsls	r0, r0, #2
3400f7e0:	f100 40a8 	add.w	r0, r0, #1409286144	@ 0x54000000
3400f7e4:	f500 3010 	add.w	r0, r0, #147456	@ 0x24000
3400f7e8:	6903      	ldr	r3, [r0, #16]
  sec_reg_val &= (~(1UL << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f7ea:	f004 041f 	and.w	r4, r4, #31
  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f7ee:	9301      	str	r3, [sp, #4]
  sec_reg_val &= (~(1UL << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f7f0:	9b01      	ldr	r3, [sp, #4]
3400f7f2:	40a2      	lsls	r2, r4
3400f7f4:	ea23 0302 	bic.w	r3, r3, r2
3400f7f8:	9301      	str	r3, [sp, #4]
  sec_reg_val |= ((SecPriv & RIF_ATTRIBUTE_SEC) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f7fa:	9901      	ldr	r1, [sp, #4]
3400f7fc:	f005 0301 	and.w	r3, r5, #1
3400f800:	40a3      	lsls	r3, r4
3400f802:	430b      	orrs	r3, r1
3400f804:	9301      	str	r3, [sp, #4]
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3400f806:	9b01      	ldr	r3, [sp, #4]

  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
  sec_reg_val &= (~(1UL << (PeriphId & RIF_PERIPH_BIT_POSITION)));
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f808:	f3c5 0140 	ubfx	r1, r5, #1, #1
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3400f80c:	6103      	str	r3, [r0, #16]
  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f80e:	6b03      	ldr	r3, [r0, #48]	@ 0x30
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f810:	40a1      	lsls	r1, r4
  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f812:	9301      	str	r3, [sp, #4]
  sec_reg_val &= (~(1UL << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f814:	9b01      	ldr	r3, [sp, #4]
3400f816:	ea23 0302 	bic.w	r3, r3, r2
3400f81a:	9301      	str	r3, [sp, #4]
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f81c:	9b01      	ldr	r3, [sp, #4]
3400f81e:	4319      	orrs	r1, r3
3400f820:	9101      	str	r1, [sp, #4]
  RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3400f822:	9b01      	ldr	r3, [sp, #4]
3400f824:	6303      	str	r3, [r0, #48]	@ 0x30
}
3400f826:	b003      	add	sp, #12
3400f828:	bd30      	pop	{r4, r5, pc}
3400f82a:	f100 4240 	add.w	r2, r0, #32####MQTT_PASS####5472	@ 0xc0000000
3400f82e:	4b19      	ldr	r3, [pc, #100]	@ (3400f894 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf4>)
3400f830:	3a02      	subs	r2, #2
3400f832:	e01d      	b.n	3400f870 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd0>
3400f834:	4b18      	ldr	r3, [pc, #96]	@ (3400f898 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf8>)
3400f836:	f100 4260 	add.w	r2, r0, #3758096384	@ 0xe0000000
3400f83a:	e019      	b.n	3400f870 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd0>
3400f83c:	f1a0 0308 	sub.w	r3, r0, #8
3400f840:	2b17      	cmp	r3, #23
3400f842:	d9c3      	bls.n	3400f7cc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f844:	e017      	b.n	3400f876 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f846:	f100 4370 	add.w	r3, r0, #4026531840	@ 0xf0000000
3400f84a:	3b1c      	subs	r3, #28
3400f84c:	2b02      	cmp	r3, #2
3400f84e:	e7f8      	b.n	3400f842 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa2>
3400f850:	4b12      	ldr	r3, [pc, #72]	@ (3400f89c <HAL_RIF_RISC_SetSlaveSecureAttributes+0xfc>)
3400f852:	4298      	cmp	r0, r3
3400f854:	d803      	bhi.n	3400f85e <HAL_RIF_RISC_SetSlaveSecureAttributes+0xbe>
3400f856:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
3400f85a:	d2b7      	bcs.n	3400f7cc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f85c:	e00b      	b.n	3400f876 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f85e:	4b10      	ldr	r3, [pc, #64]	@ (3400f8a0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x100>)
3400f860:	4298      	cmp	r0, r3
3400f862:	d0b3      	beq.n	3400f7cc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f864:	e007      	b.n	3400f876 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f866:	f100 4230 	add.w	r2, r0, #2952790016	@ 0xb0000000
3400f86a:	2a1e      	cmp	r2, #30
3400f86c:	d803      	bhi.n	3400f876 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f86e:	4b0d      	ldr	r3, [pc, #52]	@ (3400f8a4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x104>)
3400f870:	40d3      	lsrs	r3, r2
3400f872:	07db      	lsls	r3, r3, #31
3400f874:	d4aa      	bmi.n	3400f7cc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
3400f876:	f240 1173 	movw	r1, #371	@ 0x173
3400f87a:	4805      	ldr	r0, [pc, #20]	@ (3400f890 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf0>)
3400f87c:	f7f3 f9c8 	bl	34002c10 <assert_failed>
3400f880:	e7a4      	b.n	3400f7cc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f882:	bf00      	nop
3400f884:	4000001f 	.word	0x4000001f
3400f888:	2000001e 	.word	0x2000001e
3400f88c:	1000001a 	.word	0x1000001a
3400f890:	34020515 	.word	0x34020515
3400f894:	2e838c0b 	.word	0x2e838c0b
3400f898:	77dff03b 	.word	0x77dff03b
3400f89c:	30000008 	.word	0x30000008
3400f8a0:	3000000a 	.word	0x3000000a
3400f8a4:	49deef7f 	.word	0x49deef7f

3400f8a8 <XSPI_ConfigCmd>:
  __IO uint32_t *tcr_reg;
  __IO uint32_t *ir_reg;
  __IO uint32_t *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
3400f8a8:	6802      	ldr	r2, [r0, #0]
{
3400f8aa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
3400f8ae:	6813      	ldr	r3, [r2, #0]
{
3400f8b0:	4605      	mov	r5, r0
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
3400f8b2:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
3400f8b6:	6013      	str	r3, [r2, #0]

  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
3400f8b8:	6883      	ldr	r3, [r0, #8]
{
3400f8ba:	460c      	mov	r4, r1
  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
3400f8bc:	b97b      	cbnz	r3, 3400f8de <XSPI_ConfigCmd+0x36>
  {
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
3400f8be:	684b      	ldr	r3, [r1, #4]
3400f8c0:	f033 4340 	bics.w	r3, r3, #32####MQTT_PASS####5472	@ 0xc0000000
3400f8c4:	d004      	beq.n	3400f8d0 <XSPI_ConfigCmd+0x28>
3400f8c6:	f640 41a2 	movw	r1, #3234	@ 0xca2
3400f8ca:	4886      	ldr	r0, [pc, #536]	@ (3400fae4 <XSPI_ConfigCmd+0x23c>)
3400f8cc:	f7f3 f9a0 	bl	34002c10 <assert_failed>
    MODIFY_REG(hxspi->Instance->CR, XSPI_CR_MSEL, pCmd->IOSelect);
3400f8d0:	682a      	ldr	r2, [r5, #0]
3400f8d2:	6861      	ldr	r1, [r4, #4]
3400f8d4:	6813      	ldr	r3, [r2, #0]
3400f8d6:	f023 4340 	bic.w	r3, r3, #32####MQTT_PASS####5472	@ 0xc0000000
3400f8da:	430b      	orrs	r3, r1
3400f8dc:	6013      	str	r3, [r2, #0]
  }

  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
3400f8de:	6823      	ldr	r3, [r4, #0]
  {
    ccr_reg = &(hxspi->Instance->WCCR);
3400f8e0:	682a      	ldr	r2, [r5, #0]
  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
3400f8e2:	2b02      	cmp	r3, #2
3400f8e4:	d16f      	bne.n	3400f9c6 <XSPI_ConfigCmd+0x11e>
    ccr_reg = &(hxspi->Instance->WCCR);
3400f8e6:	f502 71c0 	add.w	r1, r2, #384	@ 0x180
    tcr_reg = &(hxspi->Instance->WTCR);
3400f8ea:	f502 76c4 	add.w	r6, r2, #392	@ 0x188
    ir_reg  = &(hxspi->Instance->WIR);
3400f8ee:	f502 70c8 	add.w	r0, r2, #400	@ 0x190
    abr_reg = &(hxspi->Instance->WABR);
3400f8f2:	f502 73d0 	add.w	r3, r2, #416	@ 0x1a0
    ir_reg  = &(hxspi->Instance->IR);
    abr_reg = &(hxspi->Instance->ABR);
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = pCmd->DQSMode;
3400f8f6:	6ca7      	ldr	r7, [r4, #72]	@ 0x48
3400f8f8:	600f      	str	r7, [r1, #0]

  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
3400f8fa:	6ae7      	ldr	r7, [r4, #44]	@ 0x2c
3400f8fc:	b167      	cbz	r7, 3400f918 <XSPI_ConfigCmd+0x70>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = pCmd->AlternateBytes;
3400f8fe:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
3400f900:	601f      	str	r7, [r3, #0]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (XSPI_CCR_ABMODE | XSPI_CCR_ABDTR | XSPI_CCR_ABSIZE),
3400f902:	6b67      	ldr	r7, [r4, #52]	@ 0x34
3400f904:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400f906:	f8d1 c000 	ldr.w	ip, [r1]
3400f90a:	433b      	orrs	r3, r7
3400f90c:	6b27      	ldr	r7, [r4, #48]	@ 0x30
3400f90e:	433b      	orrs	r3, r7
3400f910:	f42c 177c 	bic.w	r7, ip, #4128768	@ 0x3f0000
3400f914:	433b      	orrs	r3, r7
3400f916:	600b      	str	r3, [r1, #0]
               (pCmd->AlternateBytesMode | pCmd->AlternateBytesDTRMode | pCmd->AlternateBytesWidth));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), XSPI_TCR_DCYC, pCmd->DummyCycles);
3400f918:	6833      	ldr	r3, [r6, #0]
3400f91a:	6c67      	ldr	r7, [r4, #68]	@ 0x44
3400f91c:	f023 031f 	bic.w	r3, r3, #31
3400f920:	433b      	orrs	r3, r7
3400f922:	6033      	str	r3, [r6, #0]

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400f924:	f8d4 a038 	ldr.w	sl, [r4, #56]	@ 0x38
3400f928:	f1ba 0f00 	cmp.w	sl, #0
3400f92c:	d00e      	beq.n	3400f94c <XSPI_ConfigCmd+0xa4>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3400f92e:	6823      	ldr	r3, [r4, #0]
3400f930:	b913      	cbnz	r3, 3400f938 <XSPI_ConfigCmd+0x90>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
3400f932:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400f934:	3b01      	subs	r3, #1
3400f936:	6413      	str	r3, [r2, #64]	@ 0x40
  }

  /* Configure SSHIFT register to handle SDR/DTR data transfer */
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
  {
    if (pCmd->DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
3400f938:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400f93a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400f93e:	d156      	bne.n	3400f9ee <XSPI_ConfigCmd+0x146>
    {
      /* Deactivate sample shifting when receiving data in DTR mode (DDTR=1) */
      CLEAR_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3400f940:	f8d2 3108 	ldr.w	r3, [r2, #264]	@ 0x108
3400f944:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
    }
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
    {
      /* Configure sample shifting */
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3400f948:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
    {
      /* Do nothing */
    }
  }

  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
3400f94c:	68e3      	ldr	r3, [r4, #12]
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3400f94e:	f8d4 901c 	ldr.w	r9, [r4, #28]
  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
3400f952:	2b00      	cmp	r3, #0
3400f954:	f000 8097 	beq.w	3400fa86 <XSPI_ConfigCmd+0x1de>
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400f958:	e9d4 e804 	ldrd	lr, r8, [r4, #16]
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3400f95c:	f1b9 0f00 	cmp.w	r9, #0
3400f960:	d06d      	beq.n	3400fa3e <XSPI_ConfigCmd+0x196>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400f962:	e9d4 7c08 	ldrd	r7, ip, [r4, #32]
3400f966:	680e      	ldr	r6, [r1, #0]
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400f968:	f1ba 0f00 	cmp.w	sl, #0
3400f96c:	d048      	beq.n	3400fa00 <XSPI_ConfigCmd+0x158>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400f96e:	ea4a 0303 	orr.w	r3, sl, r3
3400f972:	ea43 0309 	orr.w	r3, r3, r9
3400f976:	ea43 0308 	orr.w	r3, r3, r8
3400f97a:	ea43 030e 	orr.w	r3, r3, lr
3400f97e:	ea43 030c 	orr.w	r3, r3, ip
3400f982:	433b      	orrs	r3, r7
3400f984:	6c27      	ldr	r7, [r4, #64]	@ 0x40
3400f986:	433b      	orrs	r3, r7
3400f988:	4f57      	ldr	r7, [pc, #348]	@ (3400fae8 <XSPI_ConfigCmd+0x240>)
3400f98a:	4037      	ands	r7, r6
3400f98c:	433b      	orrs	r3, r7
                    pCmd->AddressMode     | pCmd->AddressDTRMode     | pCmd->AddressWidth));

        /* DDTR bit should be activated */
        if (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE)
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400f98e:	600b      	str	r3, [r1, #0]
        }
      }
      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
3400f990:	68a3      	ldr	r3, [r4, #8]
3400f992:	6003      	str	r3, [r0, #0]

      /* Configure the AR register with the address value */
      hxspi->Instance->AR = pCmd->Address;
3400f994:	69a3      	ldr	r3, [r4, #24]

      if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3400f996:	6821      	ldr	r1, [r4, #0]
      hxspi->Instance->AR = pCmd->Address;
3400f998:	6493      	str	r3, [r2, #72]	@ 0x48
      if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3400f99a:	2900      	cmp	r1, #0
3400f99c:	d046      	beq.n	3400fa2c <XSPI_ConfigCmd+0x184>
  HAL_StatusTypeDef status = HAL_OK;
3400f99e:	2600      	movs	r6, #0
      status = HAL_ERROR;
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
    }
  }

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400f9a0:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400f9a2:	b16b      	cbz	r3, 3400f9c0 <XSPI_ConfigCmd+0x118>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3400f9a4:	6823      	ldr	r3, [r4, #0]
3400f9a6:	b95b      	cbnz	r3, 3400f9c0 <XSPI_ConfigCmd+0x118>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
3400f9a8:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400f9aa:	682a      	ldr	r2, [r5, #0]
3400f9ac:	3b01      	subs	r3, #1
3400f9ae:	6413      	str	r3, [r2, #64]	@ 0x40

      /* Verify if programmed data fit with requirement of Reference Manual 28.5 chapter */
      assert_param(IS_XSPI_PROG_DATA(hxspi->Instance->DLR, (pCmd->DataLength - 1U)));
3400f9b0:	6c12      	ldr	r2, [r2, #64]	@ 0x40
3400f9b2:	4293      	cmp	r3, r2
3400f9b4:	d004      	beq.n	3400f9c0 <XSPI_ConfigCmd+0x118>
3400f9b6:	f640 5164 	movw	r1, #3428	@ 0xd64
3400f9ba:	484a      	ldr	r0, [pc, #296]	@ (3400fae4 <XSPI_ConfigCmd+0x23c>)
3400f9bc:	f7f3 f928 	bl	34002c10 <assert_failed>
    }
  }

  return status;
}
3400f9c0:	4630      	mov	r0, r6
3400f9c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG)
3400f9c6:	2b03      	cmp	r3, #3
    ccr_reg = &(hxspi->Instance->WPCCR);
3400f9c8:	bf01      	itttt	eq
3400f9ca:	f502 71a0 	addeq.w	r1, r2, #320	@ 0x140
    tcr_reg = &(hxspi->Instance->WPTCR);
3400f9ce:	f502 76a4 	addeq.w	r6, r2, #328	@ 0x148
    ir_reg  = &(hxspi->Instance->WPIR);
3400f9d2:	f502 70a8 	addeq.w	r0, r2, #336	@ 0x150
    abr_reg = &(hxspi->Instance->WPABR);
3400f9d6:	f502 73b0 	addeq.w	r3, r2, #352	@ 0x160
    ccr_reg = &(hxspi->Instance->CCR);
3400f9da:	bf1f      	itttt	ne
3400f9dc:	f502 7180 	addne.w	r1, r2, #256	@ 0x100
    tcr_reg = &(hxspi->Instance->TCR);
3400f9e0:	f502 7684 	addne.w	r6, r2, #264	@ 0x108
    ir_reg  = &(hxspi->Instance->IR);
3400f9e4:	f502 7088 	addne.w	r0, r2, #272	@ 0x110
    abr_reg = &(hxspi->Instance->ABR);
3400f9e8:	f502 7390 	addne.w	r3, r2, #288	@ 0x120
3400f9ec:	e783      	b.n	3400f8f6 <XSPI_ConfigCmd+0x4e>
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
3400f9ee:	6aab      	ldr	r3, [r5, #40]	@ 0x28
3400f9f0:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400f9f4:	d1aa      	bne.n	3400f94c <XSPI_ConfigCmd+0xa4>
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3400f9f6:	f8d2 3108 	ldr.w	r3, [r2, #264]	@ 0x108
3400f9fa:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3400f9fe:	e7a3      	b.n	3400f948 <XSPI_ConfigCmd+0xa0>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fa00:	ea43 0309 	orr.w	r3, r3, r9
3400fa04:	ea43 0308 	orr.w	r3, r3, r8
3400fa08:	ea43 030e 	orr.w	r3, r3, lr
3400fa0c:	ea43 030c 	orr.w	r3, r3, ip
3400fa10:	f426 567c 	bic.w	r6, r6, #16128	@ 0x3f00
3400fa14:	433b      	orrs	r3, r7
3400fa16:	f026 063f 	bic.w	r6, r6, #63	@ 0x3f
3400fa1a:	4333      	orrs	r3, r6
3400fa1c:	600b      	str	r3, [r1, #0]
        if (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE)
3400fa1e:	6963      	ldr	r3, [r4, #20]
3400fa20:	2b08      	cmp	r3, #8
3400fa22:	d1b5      	bne.n	3400f990 <XSPI_ConfigCmd+0xe8>
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400fa24:	680b      	ldr	r3, [r1, #0]
3400fa26:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
3400fa2a:	e7b0      	b.n	3400f98e <XSPI_ConfigCmd+0xe6>
        assert_param(IS_XSPI_PROG_ADDR(hxspi->Instance->AR, pCmd->Address));
3400fa2c:	6c92      	ldr	r2, [r2, #72]	@ 0x48
3400fa2e:	4293      	cmp	r3, r2
3400fa30:	d0b5      	beq.n	3400f99e <XSPI_ConfigCmd+0xf6>
3400fa32:	f640 5111 	movw	r1, #3345	@ 0xd11
        assert_param(IS_XSPI_PROG_ADDR(hxspi->Instance->AR, pCmd->Address));
3400fa36:	482b      	ldr	r0, [pc, #172]	@ (3400fae4 <XSPI_ConfigCmd+0x23c>)
3400fa38:	f7f3 f8ea 	bl	34002c10 <assert_failed>
3400fa3c:	e7af      	b.n	3400f99e <XSPI_ConfigCmd+0xf6>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
3400fa3e:	680a      	ldr	r2, [r1, #0]
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400fa40:	f1ba 0f00 	cmp.w	sl, #0
3400fa44:	d010      	beq.n	3400fa68 <XSPI_ConfigCmd+0x1c0>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
3400fa46:	ea4a 0303 	orr.w	r3, sl, r3
3400fa4a:	6c26      	ldr	r6, [r4, #64]	@ 0x40
3400fa4c:	ea43 0308 	orr.w	r3, r3, r8
3400fa50:	ea43 030e 	orr.w	r3, r3, lr
3400fa54:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
3400fa58:	4333      	orrs	r3, r6
3400fa5a:	f022 023f 	bic.w	r2, r2, #63	@ 0x3f
3400fa5e:	4313      	orrs	r3, r2
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400fa60:	600b      	str	r3, [r1, #0]
      *ir_reg = pCmd->Instruction;
3400fa62:	68a3      	ldr	r3, [r4, #8]
3400fa64:	6003      	str	r3, [r0, #0]
3400fa66:	e79a      	b.n	3400f99e <XSPI_ConfigCmd+0xf6>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE),
3400fa68:	ea43 0308 	orr.w	r3, r3, r8
3400fa6c:	ea43 030e 	orr.w	r3, r3, lr
3400fa70:	f022 023f 	bic.w	r2, r2, #63	@ 0x3f
3400fa74:	4313      	orrs	r3, r2
3400fa76:	600b      	str	r3, [r1, #0]
        if (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE)
3400fa78:	6963      	ldr	r3, [r4, #20]
3400fa7a:	2b08      	cmp	r3, #8
3400fa7c:	d1f1      	bne.n	3400fa62 <XSPI_ConfigCmd+0x1ba>
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400fa7e:	680b      	ldr	r3, [r1, #0]
3400fa80:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
3400fa84:	e7ec      	b.n	3400fa60 <XSPI_ConfigCmd+0x1b8>
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3400fa86:	f1b9 0f00 	cmp.w	r9, #0
3400fa8a:	d027      	beq.n	3400fadc <XSPI_ConfigCmd+0x234>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fa8c:	e9d4 7008 	ldrd	r7, r0, [r4, #32]
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400fa90:	f1ba 0f00 	cmp.w	sl, #0
3400fa94:	d019      	beq.n	3400faca <XSPI_ConfigCmd+0x222>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE |
3400fa96:	ea4a 0309 	orr.w	r3, sl, r9
3400fa9a:	680e      	ldr	r6, [r1, #0]
3400fa9c:	4303      	orrs	r3, r0
3400fa9e:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400faa0:	433b      	orrs	r3, r7
3400faa2:	4303      	orrs	r3, r0
3400faa4:	f026 6070 	bic.w	r0, r6, #251658240	@ 0xf000000
3400faa8:	f420 507c 	bic.w	r0, r0, #16128	@ 0x3f00
3400faac:	4303      	orrs	r3, r0
3400faae:	600b      	str	r3, [r1, #0]
      hxspi->Instance->AR = pCmd->Address;
3400fab0:	69a3      	ldr	r3, [r4, #24]
      if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3400fab2:	6821      	ldr	r1, [r4, #0]
      hxspi->Instance->AR = pCmd->Address;
3400fab4:	6493      	str	r3, [r2, #72]	@ 0x48
      if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3400fab6:	2900      	cmp	r1, #0
3400fab8:	f47f af71 	bne.w	3400f99e <XSPI_ConfigCmd+0xf6>
        assert_param(IS_XSPI_PROG_ADDR(hxspi->Instance->AR, pCmd->Address));
3400fabc:	6c92      	ldr	r2, [r2, #72]	@ 0x48
3400fabe:	4293      	cmp	r3, r2
3400fac0:	f43f af6d 	beq.w	3400f99e <XSPI_ConfigCmd+0xf6>
3400fac4:	f640 5151 	movw	r1, #3409	@ 0xd51
3400fac8:	e7b5      	b.n	3400fa36 <XSPI_ConfigCmd+0x18e>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
3400faca:	680b      	ldr	r3, [r1, #0]
3400facc:	ea40 0009 	orr.w	r0, r0, r9
3400fad0:	4338      	orrs	r0, r7
3400fad2:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
3400fad6:	4318      	orrs	r0, r3
3400fad8:	6008      	str	r0, [r1, #0]
3400fada:	e7e9      	b.n	3400fab0 <XSPI_ConfigCmd+0x208>
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3400fadc:	2308      	movs	r3, #8
      status = HAL_ERROR;
3400fade:	2601      	movs	r6, #1
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3400fae0:	65eb      	str	r3, [r5, #92]	@ 0x5c
3400fae2:	e75d      	b.n	3400f9a0 <XSPI_ConfigCmd+0xf8>
3400fae4:	340205d8 	.word	0x340205d8
3400fae8:	f0ffc0c0 	.word	0xf0ffc0c0

3400faec <XSPI_WaitFlagStateUntilTimeout>:
{
3400faec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400faf0:	4604      	mov	r4, r0
3400faf2:	460e      	mov	r6, r1
3400faf4:	4615      	mov	r5, r2
3400faf6:	461f      	mov	r7, r3
3400faf8:	f8dd 8018 	ldr.w	r8, [sp, #24]
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
3400fafc:	6822      	ldr	r2, [r4, #0]
3400fafe:	6a13      	ldr	r3, [r2, #32]
3400fb00:	4233      	tst	r3, r6
3400fb02:	bf14      	ite	ne
3400fb04:	2301      	movne	r3, #1
3400fb06:	2300      	moveq	r3, #0
3400fb08:	42ab      	cmp	r3, r5
3400fb0a:	d101      	bne.n	3400fb10 <XSPI_WaitFlagStateUntilTimeout+0x24>
  return HAL_OK;
3400fb0c:	2000      	movs	r0, #0
3400fb0e:	e00e      	b.n	3400fb2e <XSPI_WaitFlagStateUntilTimeout+0x42>
    if (Timeout != HAL_MAX_DELAY)
3400fb10:	f1b8 3fff 	cmp.w	r8, #4294967295
3400fb14:	d0f3      	beq.n	3400fafe <XSPI_WaitFlagStateUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400fb16:	f7f5 f9b1 	bl	34004e7c <HAL_GetTick>
3400fb1a:	1bc0      	subs	r0, r0, r7
3400fb1c:	4540      	cmp	r0, r8
3400fb1e:	d908      	bls.n	3400fb32 <XSPI_WaitFlagStateUntilTimeout+0x46>
        hxspi->State     = HAL_XSPI_STATE_READY;
3400fb20:	2302      	movs	r3, #2
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
3400fb22:	2003      	movs	r0, #3
        hxspi->State     = HAL_XSPI_STATE_READY;
3400fb24:	65a3      	str	r3, [r4, #88]	@ 0x58
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
3400fb26:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
3400fb28:	f043 0301 	orr.w	r3, r3, #1
3400fb2c:	65e3      	str	r3, [r4, #92]	@ 0x5c
}
3400fb2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400fb32:	f1b8 0f00 	cmp.w	r8, #0
3400fb36:	d1e1      	bne.n	3400fafc <XSPI_WaitFlagStateUntilTimeout+0x10>
3400fb38:	e7f2      	b.n	3400fb20 <XSPI_WaitFlagStateUntilTimeout+0x34>

3400fb3a <HAL_XSPI_MspInit>:
}
3400fb3a:	4770      	bx	lr

3400fb3c <HAL_XSPI_Init>:
{
3400fb3c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400fb3e:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
3400fb40:	f7f5 f99c 	bl	34004e7c <HAL_GetTick>
3400fb44:	4606      	mov	r6, r0
  if (hxspi == NULL)
3400fb46:	2c00      	cmp	r4, #0
3400fb48:	f000 811f 	beq.w	3400fd8a <HAL_XSPI_Init+0x24e>
    assert_param(IS_XSPI_MEMORY_MODE(hxspi->Init.MemoryMode));
3400fb4c:	68a3      	ldr	r3, [r4, #8]
3400fb4e:	f033 0340 	bics.w	r3, r3, #64	@ 0x40
3400fb52:	d004      	beq.n	3400fb5e <HAL_XSPI_Init+0x22>
3400fb54:	f240 1161 	movw	r1, #353	@ 0x161
3400fb58:	488d      	ldr	r0, [pc, #564]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fb5a:	f7f3 f859 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_MEMORY_TYPE(hxspi->Init.MemoryType));
3400fb5e:	68e3      	ldr	r3, [r4, #12]
3400fb60:	f033 7240 	bics.w	r2, r3, #50331648	@ 0x3000000
3400fb64:	d009      	beq.n	3400fb7a <HAL_XSPI_Init+0x3e>
3400fb66:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
3400fb6a:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3400fb6e:	d004      	beq.n	3400fb7a <HAL_XSPI_Init+0x3e>
3400fb70:	f44f 71b1 	mov.w	r1, #354	@ 0x162
3400fb74:	4886      	ldr	r0, [pc, #536]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fb76:	f7f3 f84b 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_MEMORY_SIZE(hxspi->Init.MemorySize));
3400fb7a:	6923      	ldr	r3, [r4, #16]
3400fb7c:	2b1f      	cmp	r3, #31
3400fb7e:	d904      	bls.n	3400fb8a <HAL_XSPI_Init+0x4e>
3400fb80:	f240 1163 	movw	r1, #355	@ 0x163
3400fb84:	4882      	ldr	r0, [pc, #520]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fb86:	f7f3 f843 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_CS_HIGH_TIME_CYCLE(hxspi->Init.ChipSelectHighTimeCycle));
3400fb8a:	6963      	ldr	r3, [r4, #20]
3400fb8c:	3b01      	subs	r3, #1
3400fb8e:	2b3f      	cmp	r3, #63	@ 0x3f
3400fb90:	d904      	bls.n	3400fb9c <HAL_XSPI_Init+0x60>
3400fb92:	f44f 71b2 	mov.w	r1, #356	@ 0x164
3400fb96:	487e      	ldr	r0, [pc, #504]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fb98:	f7f3 f83a 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_FREE_RUN_CLK(hxspi->Init.FreeRunningClock));
3400fb9c:	69a3      	ldr	r3, [r4, #24]
3400fb9e:	f033 0302 	bics.w	r3, r3, #2
3400fba2:	d004      	beq.n	3400fbae <HAL_XSPI_Init+0x72>
3400fba4:	f240 1165 	movw	r1, #357	@ 0x165
3400fba8:	4879      	ldr	r0, [pc, #484]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fbaa:	f7f3 f831 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_CLOCK_MODE(hxspi->Init.ClockMode));
3400fbae:	69e3      	ldr	r3, [r4, #28]
3400fbb0:	2b01      	cmp	r3, #1
3400fbb2:	d904      	bls.n	3400fbbe <HAL_XSPI_Init+0x82>
3400fbb4:	f44f 71b3 	mov.w	r1, #358	@ 0x166
3400fbb8:	4875      	ldr	r0, [pc, #468]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fbba:	f7f3 f829 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_WRAP_SIZE(hxspi->Init.WrapSize));
3400fbbe:	6a23      	ldr	r3, [r4, #32]
3400fbc0:	f433 3200 	bics.w	r2, r3, #131072	@ 0x20000
3400fbc4:	d00c      	beq.n	3400fbe0 <HAL_XSPI_Init+0xa4>
3400fbc6:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400fbca:	d009      	beq.n	3400fbe0 <HAL_XSPI_Init+0xa4>
3400fbcc:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400fbd0:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400fbd4:	d004      	beq.n	3400fbe0 <HAL_XSPI_Init+0xa4>
3400fbd6:	f240 1167 	movw	r1, #359	@ 0x167
3400fbda:	486d      	ldr	r0, [pc, #436]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fbdc:	f7f3 f818 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_CLK_PRESCALER(hxspi->Init.ClockPrescaler));
3400fbe0:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400fbe2:	2bff      	cmp	r3, #255	@ 0xff
3400fbe4:	d904      	bls.n	3400fbf0 <HAL_XSPI_Init+0xb4>
3400fbe6:	f44f 71b4 	mov.w	r1, #360	@ 0x168
3400fbea:	4869      	ldr	r0, [pc, #420]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fbec:	f7f3 f810 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_SAMPLE_SHIFTING(hxspi->Init.SampleShifting));
3400fbf0:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400fbf2:	f033 4380 	bics.w	r3, r3, #1073741824	@ 0x40000000
3400fbf6:	d004      	beq.n	3400fc02 <HAL_XSPI_Init+0xc6>
3400fbf8:	f240 1169 	movw	r1, #361	@ 0x169
3400fbfc:	4864      	ldr	r0, [pc, #400]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fbfe:	f7f3 f807 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_CS_BOUND(hxspi->Init.ChipSelectBoundary));
3400fc02:	6b23      	ldr	r3, [r4, #48]	@ 0x30
3400fc04:	2b1f      	cmp	r3, #31
3400fc06:	d904      	bls.n	3400fc12 <HAL_XSPI_Init+0xd6>
3400fc08:	f44f 71b5 	mov.w	r1, #362	@ 0x16a
3400fc0c:	4860      	ldr	r0, [pc, #384]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fc0e:	f7f2 ffff 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_FIFO_THRESHOLD_BYTE(hxspi->Init.FifoThresholdByte));
3400fc12:	6863      	ldr	r3, [r4, #4]
3400fc14:	3b01      	subs	r3, #1
3400fc16:	2b3f      	cmp	r3, #63	@ 0x3f
3400fc18:	d904      	bls.n	3400fc24 <HAL_XSPI_Init+0xe8>
3400fc1a:	f240 116b 	movw	r1, #363	@ 0x16b
3400fc1e:	485c      	ldr	r0, [pc, #368]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fc20:	f7f2 fff6 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_MAXTRAN(hxspi->Init.MaxTran));
3400fc24:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3400fc26:	2bff      	cmp	r3, #255	@ 0xff
3400fc28:	d904      	bls.n	3400fc34 <HAL_XSPI_Init+0xf8>
3400fc2a:	f44f 71b6 	mov.w	r1, #364	@ 0x16c
3400fc2e:	4858      	ldr	r0, [pc, #352]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fc30:	f7f2 ffee 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_CSSEL(hxspi->Init.MemorySelect));
3400fc34:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400fc36:	f033 7380 	bics.w	r3, r3, #16777216	@ 0x1000000
3400fc3a:	d004      	beq.n	3400fc46 <HAL_XSPI_Init+0x10a>
3400fc3c:	f240 116d 	movw	r1, #365	@ 0x16d
3400fc40:	4853      	ldr	r0, [pc, #332]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fc42:	f7f2 ffe5 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_EXTENDMEM(hxspi->Init.MemoryExtended));
3400fc46:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400fc48:	f433 1300 	bics.w	r3, r3, #2097152	@ 0x200000
3400fc4c:	d004      	beq.n	3400fc58 <HAL_XSPI_Init+0x11c>
3400fc4e:	f44f 71b7 	mov.w	r1, #366	@ 0x16e
3400fc52:	484f      	ldr	r0, [pc, #316]	@ (3400fd90 <HAL_XSPI_Init+0x254>)
3400fc54:	f7f2 ffdc 	bl	34002c10 <assert_failed>
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
3400fc58:	2300      	movs	r3, #0
3400fc5a:	65e3      	str	r3, [r4, #92]	@ 0x5c
    if (hxspi->State == HAL_XSPI_STATE_RESET)
3400fc5c:	6da7      	ldr	r7, [r4, #88]	@ 0x58
3400fc5e:	2f00      	cmp	r7, #0
3400fc60:	f040 8085 	bne.w	3400fd6e <HAL_XSPI_Init+0x232>
      HAL_XSPI_MspInit(hxspi);
3400fc64:	4620      	mov	r0, r4
3400fc66:	f7ff ff68 	bl	3400fb3a <HAL_XSPI_MspInit>
  hxspi->Timeout = Timeout;
3400fc6a:	f241 3288 	movw	r2, #5000	@ 0x1388
      MODIFY_REG(hxspi->Instance->DCR1,
3400fc6e:	69e3      	ldr	r3, [r4, #28]
3400fc70:	68e5      	ldr	r5, [r4, #12]
3400fc72:	6821      	ldr	r1, [r4, #0]
3400fc74:	431d      	orrs	r5, r3
3400fc76:	6923      	ldr	r3, [r4, #16]
3400fc78:	6888      	ldr	r0, [r1, #8]
3400fc7a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
3400fc7e:	4b45      	ldr	r3, [pc, #276]	@ (3400fd94 <HAL_XSPI_Init+0x258>)
  hxspi->Timeout = Timeout;
3400fc80:	6622      	str	r2, [r4, #96]	@ 0x60
      MODIFY_REG(hxspi->Instance->DCR1,
3400fc82:	4003      	ands	r3, r0
3400fc84:	431d      	orrs	r5, r3
3400fc86:	6963      	ldr	r3, [r4, #20]
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
3400fc88:	6a20      	ldr	r0, [r4, #32]
      MODIFY_REG(hxspi->Instance->DCR1,
3400fc8a:	3b01      	subs	r3, #1
3400fc8c:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
3400fc90:	608d      	str	r5, [r1, #8]
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
3400fc92:	68cb      	ldr	r3, [r1, #12]
3400fc94:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400fc98:	4303      	orrs	r3, r0
3400fc9a:	60cb      	str	r3, [r1, #12]
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
3400fc9c:	690b      	ldr	r3, [r1, #16]
3400fc9e:	6b20      	ldr	r0, [r4, #48]	@ 0x30
3400fca0:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
3400fca4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3400fca8:	610b      	str	r3, [r1, #16]
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
3400fcaa:	690b      	ldr	r3, [r1, #16]
3400fcac:	6b60      	ldr	r0, [r4, #52]	@ 0x34
3400fcae:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3400fcb2:	4303      	orrs	r3, r0
3400fcb4:	610b      	str	r3, [r1, #16]
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3400fcb6:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
3400fcb8:	6860      	ldr	r0, [r4, #4]
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3400fcba:	614b      	str	r3, [r1, #20]
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
3400fcbc:	680b      	ldr	r3, [r1, #0]
3400fcbe:	3801      	subs	r0, #1
3400fcc0:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
3400fcc4:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
3400fcc8:	600b      	str	r3, [r1, #0]
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3400fcca:	4620      	mov	r0, r4
3400fccc:	9200      	str	r2, [sp, #0]
3400fcce:	4633      	mov	r3, r6
3400fcd0:	463a      	mov	r2, r7
3400fcd2:	2120      	movs	r1, #32
3400fcd4:	f7ff ff0a 	bl	3400faec <XSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
3400fcd8:	2800      	cmp	r0, #0
3400fcda:	d154      	bne.n	3400fd86 <HAL_XSPI_Init+0x24a>
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
3400fcdc:	6823      	ldr	r3, [r4, #0]
3400fcde:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400fce0:	68da      	ldr	r2, [r3, #12]
3400fce2:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
3400fce6:	430a      	orrs	r2, r1
3400fce8:	60da      	str	r2, [r3, #12]
        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
3400fcea:	4a2b      	ldr	r2, [pc, #172]	@ (3400fd98 <HAL_XSPI_Init+0x25c>)
3400fcec:	4293      	cmp	r3, r2
3400fcee:	d040      	beq.n	3400fd72 <HAL_XSPI_Init+0x236>
3400fcf0:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fcf4:	4293      	cmp	r3, r2
3400fcf6:	d03c      	beq.n	3400fd72 <HAL_XSPI_Init+0x236>
3400fcf8:	4a28      	ldr	r2, [pc, #160]	@ (3400fd9c <HAL_XSPI_Init+0x260>)
3400fcfa:	4293      	cmp	r3, r2
3400fcfc:	d039      	beq.n	3400fd72 <HAL_XSPI_Init+0x236>
3400fcfe:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fd02:	4293      	cmp	r3, r2
3400fd04:	d035      	beq.n	3400fd72 <HAL_XSPI_Init+0x236>
3400fd06:	4a26      	ldr	r2, [pc, #152]	@ (3400fda0 <HAL_XSPI_Init+0x264>)
3400fd08:	4293      	cmp	r3, r2
3400fd0a:	d032      	beq.n	3400fd72 <HAL_XSPI_Init+0x236>
3400fd0c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fd10:	4293      	cmp	r3, r2
3400fd12:	d02e      	beq.n	3400fd72 <HAL_XSPI_Init+0x236>
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
3400fd14:	6823      	ldr	r3, [r4, #0]
3400fd16:	68a2      	ldr	r2, [r4, #8]
3400fd18:	6819      	ldr	r1, [r3, #0]
3400fd1a:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
3400fd1c:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
3400fd20:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
3400fd24:	4302      	orrs	r2, r0
3400fd26:	430a      	orrs	r2, r1
3400fd28:	601a      	str	r2, [r3, #0]
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT), hxspi->Init.SampleShifting);
3400fd2a:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400fd2e:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
3400fd30:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
3400fd34:	430a      	orrs	r2, r1
3400fd36:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
        HAL_XSPI_ENABLE(hxspi);
3400fd3a:	681a      	ldr	r2, [r3, #0]
3400fd3c:	f042 0201 	orr.w	r2, r2, #1
3400fd40:	601a      	str	r2, [r3, #0]
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
3400fd42:	69a2      	ldr	r2, [r4, #24]
3400fd44:	2a02      	cmp	r2, #2
3400fd46:	d103      	bne.n	3400fd50 <HAL_XSPI_Init+0x214>
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
3400fd48:	689a      	ldr	r2, [r3, #8]
3400fd4a:	f042 0202 	orr.w	r2, r2, #2
3400fd4e:	609a      	str	r2, [r3, #8]
        if (hxspi->Init.MemoryExtended == HAL_XSPI_CSSEL_HW)
3400fd50:	6c22      	ldr	r2, [r4, #64]	@ 0x40
3400fd52:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_EXTENDMEM);
3400fd56:	bf02      	ittt	eq
3400fd58:	689a      	ldreq	r2, [r3, #8]
3400fd5a:	f442 1200 	orreq.w	r2, r2, #2097152	@ 0x200000
3400fd5e:	609a      	streq	r2, [r3, #8]
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3400fd60:	68e3      	ldr	r3, [r4, #12]
3400fd62:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
3400fd66:	bf0c      	ite	eq
3400fd68:	2301      	moveq	r3, #1
          hxspi->State = HAL_XSPI_STATE_READY;
3400fd6a:	2302      	movne	r3, #2
3400fd6c:	65a3      	str	r3, [r4, #88]	@ 0x58
  HAL_StatusTypeDef status = HAL_OK;
3400fd6e:	2000      	movs	r0, #0
3400fd70:	e009      	b.n	3400fd86 <HAL_XSPI_Init+0x24a>
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3400fd72:	6e23      	ldr	r3, [r4, #96]	@ 0x60
3400fd74:	2200      	movs	r2, #0
3400fd76:	9300      	str	r3, [sp, #0]
3400fd78:	2120      	movs	r1, #32
3400fd7a:	4633      	mov	r3, r6
3400fd7c:	4620      	mov	r0, r4
3400fd7e:	f7ff feb5 	bl	3400faec <XSPI_WaitFlagStateUntilTimeout>
          if (status != HAL_OK)
3400fd82:	2800      	cmp	r0, #0
3400fd84:	d0c6      	beq.n	3400fd14 <HAL_XSPI_Init+0x1d8>
}
3400fd86:	b003      	add	sp, #12
3400fd88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = HAL_ERROR;
3400fd8a:	2001      	movs	r0, #1
3400fd8c:	e7fb      	b.n	3400fd86 <HAL_XSPI_Init+0x24a>
3400fd8e:	bf00      	nop
3400fd90:	340205d8 	.word	0x340205d8
3400fd94:	f8e0c0fc 	.word	0xf8e0c0fc
3400fd98:	58025000 	.word	0x58025000
3400fd9c:	5802a000 	.word	0x5802a000
3400fda0:	5802d000 	.word	0x5802d000

3400fda4 <HAL_XSPI_Command>:
{
3400fda4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400fda6:	460c      	mov	r4, r1
3400fda8:	4605      	mov	r5, r0
3400fdaa:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
3400fdac:	f7f5 f866 	bl	34004e7c <HAL_GetTick>
  assert_param(IS_XSPI_OPERATION_TYPE(pCmd->OperationType));
3400fdb0:	6823      	ldr	r3, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
3400fdb2:	4606      	mov	r6, r0
  assert_param(IS_XSPI_OPERATION_TYPE(pCmd->OperationType));
3400fdb4:	2b03      	cmp	r3, #3
3400fdb6:	d904      	bls.n	3400fdc2 <HAL_XSPI_Command+0x1e>
3400fdb8:	f44f 714f 	mov.w	r1, #828	@ 0x33c
3400fdbc:	4884      	ldr	r0, [pc, #528]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fdbe:	f7f2 ff27 	bl	34002c10 <assert_failed>
  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
3400fdc2:	68ab      	ldr	r3, [r5, #8]
3400fdc4:	b943      	cbnz	r3, 3400fdd8 <HAL_XSPI_Command+0x34>
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
3400fdc6:	6863      	ldr	r3, [r4, #4]
3400fdc8:	f033 4340 	bics.w	r3, r3, #32####MQTT_PASS####5472	@ 0xc0000000
3400fdcc:	d004      	beq.n	3400fdd8 <HAL_XSPI_Command+0x34>
3400fdce:	f240 313f 	movw	r1, #831	@ 0x33f
3400fdd2:	487f      	ldr	r0, [pc, #508]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fdd4:	f7f2 ff1c 	bl	34002c10 <assert_failed>
  assert_param(IS_XSPI_INSTRUCTION_MODE(pCmd->InstructionMode));
3400fdd8:	68e3      	ldr	r3, [r4, #12]
3400fdda:	2b04      	cmp	r3, #4
3400fddc:	d904      	bls.n	3400fde8 <HAL_XSPI_Command+0x44>
3400fdde:	f240 3142 	movw	r1, #834	@ 0x342
3400fde2:	487b      	ldr	r0, [pc, #492]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fde4:	f7f2 ff14 	bl	34002c10 <assert_failed>
  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
3400fde8:	68e3      	ldr	r3, [r4, #12]
3400fdea:	b18b      	cbz	r3, 3400fe10 <HAL_XSPI_Command+0x6c>
    assert_param(IS_XSPI_INSTRUCTION_WIDTH(pCmd->InstructionWidth));
3400fdec:	6923      	ldr	r3, [r4, #16]
3400fdee:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400fdf2:	d004      	beq.n	3400fdfe <HAL_XSPI_Command+0x5a>
3400fdf4:	f240 3145 	movw	r1, #837	@ 0x345
3400fdf8:	4875      	ldr	r0, [pc, #468]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fdfa:	f7f2 ff09 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_INSTRUCTION_DTR_MODE(pCmd->InstructionDTRMode));
3400fdfe:	6963      	ldr	r3, [r4, #20]
3400fe00:	f033 0308 	bics.w	r3, r3, #8
3400fe04:	d004      	beq.n	3400fe10 <HAL_XSPI_Command+0x6c>
3400fe06:	f240 3146 	movw	r1, #838	@ 0x346
3400fe0a:	4871      	ldr	r0, [pc, #452]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fe0c:	f7f2 ff00 	bl	34002c10 <assert_failed>
  assert_param(IS_XSPI_ADDRESS_MODE(pCmd->AddressMode));
3400fe10:	69e3      	ldr	r3, [r4, #28]
3400fe12:	b303      	cbz	r3, 3400fe56 <HAL_XSPI_Command+0xb2>
3400fe14:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3400fe18:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
3400fe1c:	d10d      	bne.n	3400fe3a <HAL_XSPI_Command+0x96>
    assert_param(IS_XSPI_ADDRESS_WIDTH(pCmd->AddressWidth));
3400fe1e:	6a23      	ldr	r3, [r4, #32]
3400fe20:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
3400fe24:	d12c      	bne.n	3400fe80 <HAL_XSPI_Command+0xdc>
    assert_param(IS_XSPI_ADDRESS_DTR_MODE(pCmd->AddressDTRMode));
3400fe26:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400fe28:	f433 6300 	bics.w	r3, r3, #2048	@ 0x800
3400fe2c:	d013      	beq.n	3400fe56 <HAL_XSPI_Command+0xb2>
3400fe2e:	f240 314d 	movw	r1, #845	@ 0x34d
3400fe32:	4867      	ldr	r0, [pc, #412]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fe34:	f7f2 feec 	bl	34002c10 <assert_failed>
3400fe38:	e00d      	b.n	3400fe56 <HAL_XSPI_Command+0xb2>
  assert_param(IS_XSPI_ADDRESS_MODE(pCmd->AddressMode));
3400fe3a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400fe3e:	d0ee      	beq.n	3400fe1e <HAL_XSPI_Command+0x7a>
3400fe40:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3400fe44:	d0eb      	beq.n	3400fe1e <HAL_XSPI_Command+0x7a>
3400fe46:	f240 3149 	movw	r1, #841	@ 0x349
3400fe4a:	4861      	ldr	r0, [pc, #388]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fe4c:	f7f2 fee0 	bl	34002c10 <assert_failed>
  if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3400fe50:	69e3      	ldr	r3, [r4, #28]
3400fe52:	2b00      	cmp	r3, #0
3400fe54:	d1e3      	bne.n	3400fe1e <HAL_XSPI_Command+0x7a>
  assert_param(IS_XSPI_ALT_BYTES_MODE(pCmd->AlternateBytesMode));
3400fe56:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400fe58:	b333      	cbz	r3, 3400fea8 <HAL_XSPI_Command+0x104>
3400fe5a:	f423 3200 	bic.w	r2, r3, #131072	@ 0x20000
3400fe5e:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
3400fe62:	d113      	bne.n	3400fe8c <HAL_XSPI_Command+0xe8>
    assert_param(IS_XSPI_ALT_BYTES_WIDTH(pCmd->AlternateBytesWidth));
3400fe64:	6b23      	ldr	r3, [r4, #48]	@ 0x30
3400fe66:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
3400fe6a:	d13d      	bne.n	3400fee8 <HAL_XSPI_Command+0x144>
    assert_param(IS_XSPI_ALT_BYTES_DTR_MODE(pCmd->AlternateBytesDTRMode));
3400fe6c:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3400fe6e:	f433 2300 	bics.w	r3, r3, #524288	@ 0x80000
3400fe72:	d019      	beq.n	3400fea8 <HAL_XSPI_Command+0x104>
3400fe74:	f44f 7155 	mov.w	r1, #852	@ 0x354
3400fe78:	4855      	ldr	r0, [pc, #340]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fe7a:	f7f2 fec9 	bl	34002c10 <assert_failed>
3400fe7e:	e013      	b.n	3400fea8 <HAL_XSPI_Command+0x104>
    assert_param(IS_XSPI_ADDRESS_WIDTH(pCmd->AddressWidth));
3400fe80:	f44f 7153 	mov.w	r1, #844	@ 0x34c
3400fe84:	4852      	ldr	r0, [pc, #328]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fe86:	f7f2 fec3 	bl	34002c10 <assert_failed>
3400fe8a:	e7cc      	b.n	3400fe26 <HAL_XSPI_Command+0x82>
  assert_param(IS_XSPI_ALT_BYTES_MODE(pCmd->AlternateBytesMode));
3400fe8c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400fe90:	d0e8      	beq.n	3400fe64 <HAL_XSPI_Command+0xc0>
3400fe92:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400fe96:	d0e5      	beq.n	3400fe64 <HAL_XSPI_Command+0xc0>
3400fe98:	f44f 7154 	mov.w	r1, #848	@ 0x350
3400fe9c:	484c      	ldr	r0, [pc, #304]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fe9e:	f7f2 feb7 	bl	34002c10 <assert_failed>
  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
3400fea2:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400fea4:	2b00      	cmp	r3, #0
3400fea6:	d1dd      	bne.n	3400fe64 <HAL_XSPI_Command+0xc0>
  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));
3400fea8:	68eb      	ldr	r3, [r5, #12]
3400feaa:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
3400feac:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3400feb0:	d120      	bne.n	3400fef4 <HAL_XSPI_Command+0x150>
3400feb2:	b389      	cbz	r1, 3400ff18 <HAL_XSPI_Command+0x174>
3400feb4:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
3400feb8:	f1b1 6f80 	cmp.w	r1, #67108864	@ 0x4000000
3400febc:	d124      	bne.n	3400ff08 <HAL_XSPI_Command+0x164>
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3400febe:	6823      	ldr	r3, [r4, #0]
3400fec0:	2b00      	cmp	r3, #0
3400fec2:	d03d      	beq.n	3400ff40 <HAL_XSPI_Command+0x19c>
    assert_param(IS_XSPI_DATA_DTR_MODE(pCmd->DataDTRMode));
3400fec4:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400fec6:	f033 6300 	bics.w	r3, r3, #134217728	@ 0x8000000
3400feca:	d004      	beq.n	3400fed6 <HAL_XSPI_Command+0x132>
3400fecc:	f240 315f 	movw	r1, #863	@ 0x35f
3400fed0:	483f      	ldr	r0, [pc, #252]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fed2:	f7f2 fe9d 	bl	34002c10 <assert_failed>
    assert_param(IS_XSPI_DUMMY_CYCLES(pCmd->DummyCycles));
3400fed6:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400fed8:	2b1f      	cmp	r3, #31
3400feda:	d91d      	bls.n	3400ff18 <HAL_XSPI_Command+0x174>
3400fedc:	f44f 7158 	mov.w	r1, #864	@ 0x360
3400fee0:	483b      	ldr	r0, [pc, #236]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400fee2:	f7f2 fe95 	bl	34002c10 <assert_failed>
3400fee6:	e017      	b.n	3400ff18 <HAL_XSPI_Command+0x174>
    assert_param(IS_XSPI_ALT_BYTES_WIDTH(pCmd->AlternateBytesWidth));
3400fee8:	f240 3153 	movw	r1, #851	@ 0x353
3400feec:	4838      	ldr	r0, [pc, #224]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400feee:	f7f2 fe8f 	bl	34002c10 <assert_failed>
3400fef2:	e7bb      	b.n	3400fe6c <HAL_XSPI_Command+0xc8>
  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));
3400fef4:	b181      	cbz	r1, 3400ff18 <HAL_XSPI_Command+0x174>
3400fef6:	f021 7300 	bic.w	r3, r1, #33554432	@ 0x2000000
3400fefa:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3400fefe:	d0de      	beq.n	3400febe <HAL_XSPI_Command+0x11a>
3400ff00:	f1b1 7f00 	cmp.w	r1, #33554432	@ 0x2000000
3400ff04:	d1d6      	bne.n	3400feb4 <HAL_XSPI_Command+0x110>
3400ff06:	e7da      	b.n	3400febe <HAL_XSPI_Command+0x11a>
3400ff08:	f240 3157 	movw	r1, #855	@ 0x357
3400ff0c:	4830      	ldr	r0, [pc, #192]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400ff0e:	f7f2 fe7f 	bl	34002c10 <assert_failed>
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400ff12:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400ff14:	2b00      	cmp	r3, #0
3400ff16:	d1d2      	bne.n	3400febe <HAL_XSPI_Command+0x11a>
  assert_param(IS_XSPI_DQS_MODE(pCmd->DQSMode));
3400ff18:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400ff1a:	f033 5300 	bics.w	r3, r3, #536870912	@ 0x20000000
3400ff1e:	d004      	beq.n	3400ff2a <HAL_XSPI_Command+0x186>
3400ff20:	f240 3163 	movw	r1, #867	@ 0x363
3400ff24:	482a      	ldr	r0, [pc, #168]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400ff26:	f7f2 fe73 	bl	34002c10 <assert_failed>
  state = hxspi->State;
3400ff2a:	6dab      	ldr	r3, [r5, #88]	@ 0x58
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
3400ff2c:	2b02      	cmp	r3, #2
3400ff2e:	d110      	bne.n	3400ff52 <HAL_XSPI_Command+0x1ae>
3400ff30:	68eb      	ldr	r3, [r5, #12]
3400ff32:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3400ff36:	d112      	bne.n	3400ff5e <HAL_XSPI_Command+0x1ba>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3400ff38:	2310      	movs	r3, #16
    status = HAL_ERROR;
3400ff3a:	2001      	movs	r0, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3400ff3c:	65eb      	str	r3, [r5, #92]	@ 0x5c
3400ff3e:	e028      	b.n	3400ff92 <HAL_XSPI_Command+0x1ee>
      assert_param(IS_XSPI_DATA_LENGTH(pCmd->DataLength));
3400ff40:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400ff42:	2b00      	cmp	r3, #0
3400ff44:	d1be      	bne.n	3400fec4 <HAL_XSPI_Command+0x120>
3400ff46:	f240 315d 	movw	r1, #861	@ 0x35d
3400ff4a:	4821      	ldr	r0, [pc, #132]	@ (3400ffd0 <HAL_XSPI_Command+0x22c>)
3400ff4c:	f7f2 fe60 	bl	34002c10 <assert_failed>
3400ff50:	e7b8      	b.n	3400fec4 <HAL_XSPI_Command+0x120>
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
3400ff52:	2b14      	cmp	r3, #20
3400ff54:	d11f      	bne.n	3400ff96 <HAL_XSPI_Command+0x1f2>
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
3400ff56:	6823      	ldr	r3, [r4, #0]
3400ff58:	3b02      	subs	r3, #2
3400ff5a:	2b01      	cmp	r3, #1
3400ff5c:	d8ec      	bhi.n	3400ff38 <HAL_XSPI_Command+0x194>
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
3400ff5e:	4633      	mov	r3, r6
3400ff60:	2200      	movs	r2, #0
3400ff62:	2120      	movs	r1, #32
3400ff64:	4628      	mov	r0, r5
3400ff66:	9700      	str	r7, [sp, #0]
3400ff68:	f7ff fdc0 	bl	3400faec <XSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
3400ff6c:	bb70      	cbnz	r0, 3400ffcc <HAL_XSPI_Command+0x228>
      hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
3400ff6e:	65e8      	str	r0, [r5, #92]	@ 0x5c
      status = XSPI_ConfigCmd(hxspi, pCmd);
3400ff70:	4621      	mov	r1, r4
3400ff72:	4628      	mov	r0, r5
3400ff74:	f7ff fc98 	bl	3400f8a8 <XSPI_ConfigCmd>
      if (status == HAL_OK)
3400ff78:	b958      	cbnz	r0, 3400ff92 <HAL_XSPI_Command+0x1ee>
        if (pCmd->DataMode == HAL_XSPI_DATA_NONE)
3400ff7a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400ff7c:	b99b      	cbnz	r3, 3400ffa6 <HAL_XSPI_Command+0x202>
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
3400ff7e:	4602      	mov	r2, r0
3400ff80:	4633      	mov	r3, r6
3400ff82:	2120      	movs	r1, #32
3400ff84:	4628      	mov	r0, r5
3400ff86:	9700      	str	r7, [sp, #0]
3400ff88:	f7ff fdb0 	bl	3400faec <XSPI_WaitFlagStateUntilTimeout>
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
3400ff8c:	2202      	movs	r2, #2
3400ff8e:	682b      	ldr	r3, [r5, #0]
3400ff90:	625a      	str	r2, [r3, #36]	@ 0x24
}
3400ff92:	b003      	add	sp, #12
3400ff94:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
3400ff96:	2b24      	cmp	r3, #36	@ 0x24
3400ff98:	d1ce      	bne.n	3400ff38 <HAL_XSPI_Command+0x194>
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
3400ff9a:	6823      	ldr	r3, [r4, #0]
3400ff9c:	f023 0302 	bic.w	r3, r3, #2
3400ffa0:	2b01      	cmp	r3, #1
3400ffa2:	d1c9      	bne.n	3400ff38 <HAL_XSPI_Command+0x194>
3400ffa4:	e7db      	b.n	3400ff5e <HAL_XSPI_Command+0x1ba>
          if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3400ffa6:	6823      	ldr	r3, [r4, #0]
3400ffa8:	b90b      	cbnz	r3, 3400ffae <HAL_XSPI_Command+0x20a>
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
3400ffaa:	2304      	movs	r3, #4
3400ffac:	e005      	b.n	3400ffba <HAL_XSPI_Command+0x216>
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)
3400ffae:	2b01      	cmp	r3, #1
3400ffb0:	d105      	bne.n	3400ffbe <HAL_XSPI_Command+0x21a>
            if (hxspi->State == HAL_XSPI_STATE_WRITE_CMD_CFG)
3400ffb2:	6dab      	ldr	r3, [r5, #88]	@ 0x58
3400ffb4:	2b24      	cmp	r3, #36	@ 0x24
3400ffb6:	d0f8      	beq.n	3400ffaa <HAL_XSPI_Command+0x206>
              hxspi->State = HAL_XSPI_STATE_READ_CMD_CFG;
3400ffb8:	2314      	movs	r3, #20
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
3400ffba:	65ab      	str	r3, [r5, #88]	@ 0x58
3400ffbc:	e7e9      	b.n	3400ff92 <HAL_XSPI_Command+0x1ee>
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
3400ffbe:	2b02      	cmp	r3, #2
3400ffc0:	d1e7      	bne.n	3400ff92 <HAL_XSPI_Command+0x1ee>
            if (hxspi->State == HAL_XSPI_STATE_READ_CMD_CFG)
3400ffc2:	6dab      	ldr	r3, [r5, #88]	@ 0x58
3400ffc4:	2b14      	cmp	r3, #20
3400ffc6:	d0f0      	beq.n	3400ffaa <HAL_XSPI_Command+0x206>
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
3400ffc8:	2324      	movs	r3, #36	@ 0x24
3400ffca:	e7f6      	b.n	3400ffba <HAL_XSPI_Command+0x216>
      status = HAL_BUSY;
3400ffcc:	2002      	movs	r0, #2
3400ffce:	e7e0      	b.n	3400ff92 <HAL_XSPI_Command+0x1ee>
3400ffd0:	340205d8 	.word	0x340205d8

3400ffd4 <HAL_XSPI_Transmit>:
{
3400ffd4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
3400ffd8:	4604      	mov	r4, r0
3400ffda:	4688      	mov	r8, r1
3400ffdc:	4616      	mov	r6, r2
  uint32_t tickstart = HAL_GetTick();
3400ffde:	f7f4 ff4d 	bl	34004e7c <HAL_GetTick>
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
3400ffe2:	6827      	ldr	r7, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
3400ffe4:	4605      	mov	r5, r0
  if (pData == NULL)
3400ffe6:	f1b8 0f00 	cmp.w	r8, #0
3400ffea:	d103      	bne.n	3400fff4 <HAL_XSPI_Transmit+0x20>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3400ffec:	2308      	movs	r3, #8
    status = HAL_ERROR;
3400ffee:	2001      	movs	r0, #1
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3400fff0:	65e3      	str	r3, [r4, #92]	@ 0x5c
3400fff2:	e02e      	b.n	34010052 <HAL_XSPI_Transmit+0x7e>
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
3400fff4:	6da3      	ldr	r3, [r4, #88]	@ 0x58
3400fff6:	2b04      	cmp	r3, #4
3400fff8:	d12e      	bne.n	34010058 <HAL_XSPI_Transmit+0x84>
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
3400fffa:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
      hxspi->pBuffPtr  = (uint8_t *)pData;
3400fffc:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
34010000:	3301      	adds	r3, #1
34010002:	64e3      	str	r3, [r4, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
34010004:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
34010006:	64a3      	str	r3, [r4, #72]	@ 0x48
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
34010008:	683b      	ldr	r3, [r7, #0]
3401000a:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
3401000e:	603b      	str	r3, [r7, #0]
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_FT, SET, tickstart, Timeout);
34010010:	462b      	mov	r3, r5
34010012:	2201      	movs	r2, #1
34010014:	2104      	movs	r1, #4
34010016:	4620      	mov	r0, r4
34010018:	9600      	str	r6, [sp, #0]
3401001a:	f7ff fd67 	bl	3400faec <XSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
3401001e:	b9c0      	cbnz	r0, 34010052 <HAL_XSPI_Transmit+0x7e>
        *((__IO uint8_t *)data_reg) = *hxspi->pBuffPtr;
34010020:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34010022:	781b      	ldrb	r3, [r3, #0]
34010024:	f887 3050 	strb.w	r3, [r7, #80]	@ 0x50
        hxspi->pBuffPtr++;
34010028:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3401002a:	3301      	adds	r3, #1
3401002c:	6463      	str	r3, [r4, #68]	@ 0x44
        hxspi->XferCount--;
3401002e:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
34010030:	3b01      	subs	r3, #1
34010032:	64e3      	str	r3, [r4, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
34010034:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
34010036:	2b00      	cmp	r3, #0
34010038:	d1ea      	bne.n	34010010 <HAL_XSPI_Transmit+0x3c>
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
3401003a:	462b      	mov	r3, r5
3401003c:	2201      	movs	r2, #1
3401003e:	2102      	movs	r1, #2
34010040:	4620      	mov	r0, r4
34010042:	9600      	str	r6, [sp, #0]
34010044:	f7ff fd52 	bl	3400faec <XSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
34010048:	b918      	cbnz	r0, 34010052 <HAL_XSPI_Transmit+0x7e>
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
3401004a:	2302      	movs	r3, #2
3401004c:	6822      	ldr	r2, [r4, #0]
3401004e:	6253      	str	r3, [r2, #36]	@ 0x24
          hxspi->State = HAL_XSPI_STATE_READY;
34010050:	65a3      	str	r3, [r4, #88]	@ 0x58
}
34010052:	b002      	add	sp, #8
34010054:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34010058:	2310      	movs	r3, #16
3401005a:	e7c8      	b.n	3400ffee <HAL_XSPI_Transmit+0x1a>

3401005c <HAL_XSPI_Receive>:
{
3401005c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
34010060:	4604      	mov	r4, r0
34010062:	4616      	mov	r6, r2
34010064:	4688      	mov	r8, r1
  uint32_t tickstart = HAL_GetTick();
34010066:	f7f4 ff09 	bl	34004e7c <HAL_GetTick>
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
3401006a:	6825      	ldr	r5, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
3401006c:	4607      	mov	r7, r0
  uint32_t addr_reg = hxspi->Instance->AR;
3401006e:	6caa      	ldr	r2, [r5, #72]	@ 0x48
  uint32_t ir_reg = hxspi->Instance->IR;
34010070:	f8d5 0110 	ldr.w	r0, [r5, #272]	@ 0x110
  if (pData == NULL)
34010074:	f1b8 0f00 	cmp.w	r8, #0
34010078:	d103      	bne.n	34010082 <HAL_XSPI_Receive+0x26>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3401007a:	2308      	movs	r3, #8
    status = HAL_ERROR;
3401007c:	2001      	movs	r0, #1
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401007e:	65e3      	str	r3, [r4, #92]	@ 0x5c
34010080:	e035      	b.n	340100ee <HAL_XSPI_Receive+0x92>
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
34010082:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34010084:	2b04      	cmp	r3, #4
34010086:	d13d      	bne.n	34010104 <HAL_XSPI_Receive+0xa8>
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
34010088:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
      hxspi->pBuffPtr  = pData;
3401008a:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
3401008e:	3301      	adds	r3, #1
34010090:	64e3      	str	r3, [r4, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
34010092:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
34010094:	64a3      	str	r3, [r4, #72]	@ 0x48
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
34010096:	6829      	ldr	r1, [r5, #0]
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34010098:	68e3      	ldr	r3, [r4, #12]
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
3401009a:	f021 5140 	bic.w	r1, r1, #805306368	@ 0x30000000
3401009e:	f041 5180 	orr.w	r1, r1, #268435456	@ 0x10000000
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
340100a2:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
340100a6:	6029      	str	r1, [r5, #0]
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
340100a8:	d124      	bne.n	340100f4 <HAL_XSPI_Receive+0x98>
          WRITE_REG(hxspi->Instance->AR, addr_reg);
340100aa:	64aa      	str	r2, [r5, #72]	@ 0x48
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, (HAL_XSPI_FLAG_FT | HAL_XSPI_FLAG_TC), SET, tickstart, Timeout);
340100ac:	463b      	mov	r3, r7
340100ae:	2201      	movs	r2, #1
340100b0:	2106      	movs	r1, #6
340100b2:	4620      	mov	r0, r4
340100b4:	9600      	str	r6, [sp, #0]
340100b6:	f7ff fd19 	bl	3400faec <XSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
340100ba:	b9c0      	cbnz	r0, 340100ee <HAL_XSPI_Receive+0x92>
        *hxspi->pBuffPtr = *((__IO uint8_t *)data_reg);
340100bc:	f895 2050 	ldrb.w	r2, [r5, #80]	@ 0x50
340100c0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
340100c2:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
340100c4:	6c63      	ldr	r3, [r4, #68]	@ 0x44
340100c6:	3301      	adds	r3, #1
340100c8:	6463      	str	r3, [r4, #68]	@ 0x44
        hxspi->XferCount--;
340100ca:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
340100cc:	3b01      	subs	r3, #1
340100ce:	64e3      	str	r3, [r4, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
340100d0:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
340100d2:	2b00      	cmp	r3, #0
340100d4:	d1ea      	bne.n	340100ac <HAL_XSPI_Receive+0x50>
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
340100d6:	463b      	mov	r3, r7
340100d8:	2201      	movs	r2, #1
340100da:	2102      	movs	r1, #2
340100dc:	4620      	mov	r0, r4
340100de:	9600      	str	r6, [sp, #0]
340100e0:	f7ff fd04 	bl	3400faec <XSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
340100e4:	b918      	cbnz	r0, 340100ee <HAL_XSPI_Receive+0x92>
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
340100e6:	2302      	movs	r3, #2
340100e8:	6822      	ldr	r2, [r4, #0]
340100ea:	6253      	str	r3, [r2, #36]	@ 0x24
          hxspi->State = HAL_XSPI_STATE_READY;
340100ec:	65a3      	str	r3, [r4, #88]	@ 0x58
}
340100ee:	b002      	add	sp, #8
340100f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
340100f4:	f8d5 3100 	ldr.w	r3, [r5, #256]	@ 0x100
340100f8:	f413 6fe0 	tst.w	r3, #1792	@ 0x700
340100fc:	d1d5      	bne.n	340100aa <HAL_XSPI_Receive+0x4e>
          WRITE_REG(hxspi->Instance->IR, ir_reg);
340100fe:	f8c5 0110 	str.w	r0, [r5, #272]	@ 0x110
34010102:	e7d3      	b.n	340100ac <HAL_XSPI_Receive+0x50>
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34010104:	2310      	movs	r3, #16
34010106:	e7b9      	b.n	3401007c <HAL_XSPI_Receive+0x20>

34010108 <HAL_XSPI_AutoPolling>:
{
34010108:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
3401010c:	4604      	mov	r4, r0
3401010e:	460d      	mov	r5, r1
34010110:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
34010112:	f7f4 feb3 	bl	34004e7c <HAL_GetTick>
  uint32_t addr_reg = hxspi->Instance->AR;
34010116:	6823      	ldr	r3, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
34010118:	4606      	mov	r6, r0
  uint32_t addr_reg = hxspi->Instance->AR;
3401011a:	f8d3 8048 	ldr.w	r8, [r3, #72]	@ 0x48
  uint32_t ir_reg = hxspi->Instance->IR;
3401011e:	f8d3 9110 	ldr.w	r9, [r3, #272]	@ 0x110
  uint32_t dlr_reg = hxspi->Instance->DLR;
34010122:	f8d3 a040 	ldr.w	sl, [r3, #64]	@ 0x40
  assert_param(IS_XSPI_MATCH_MODE(pCfg->MatchMode));
34010126:	68ab      	ldr	r3, [r5, #8]
34010128:	f433 0300 	bics.w	r3, r3, #8388608	@ 0x800000
3401012c:	d004      	beq.n	34010138 <HAL_XSPI_AutoPolling+0x30>
3401012e:	f240 7132 	movw	r1, #1842	@ 0x732
34010132:	4832      	ldr	r0, [pc, #200]	@ (340101fc <HAL_XSPI_AutoPolling+0xf4>)
34010134:	f7f2 fd6c 	bl	34002c10 <assert_failed>
  assert_param(IS_XSPI_AUTOMATIC_STOP(pCfg->AutomaticStop));
34010138:	68eb      	ldr	r3, [r5, #12]
3401013a:	f433 0380 	bics.w	r3, r3, #4194304	@ 0x400000
3401013e:	d004      	beq.n	3401014a <HAL_XSPI_AutoPolling+0x42>
34010140:	f240 7133 	movw	r1, #1843	@ 0x733
34010144:	482d      	ldr	r0, [pc, #180]	@ (340101fc <HAL_XSPI_AutoPolling+0xf4>)
34010146:	f7f2 fd63 	bl	34002c10 <assert_failed>
  assert_param(IS_XSPI_INTERVAL(pCfg->IntervalTime));
3401014a:	692b      	ldr	r3, [r5, #16]
3401014c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34010150:	d304      	bcc.n	3401015c <HAL_XSPI_AutoPolling+0x54>
34010152:	f240 7134 	movw	r1, #1844	@ 0x734
34010156:	4829      	ldr	r0, [pc, #164]	@ (340101fc <HAL_XSPI_AutoPolling+0xf4>)
34010158:	f7f2 fd5a 	bl	34002c10 <assert_failed>
  assert_param(IS_XSPI_STATUS_BYTES_SIZE(dlr_reg + 1U));
3401015c:	f1ba 0f03 	cmp.w	sl, #3
34010160:	d904      	bls.n	3401016c <HAL_XSPI_AutoPolling+0x64>
34010162:	f240 7135 	movw	r1, #1845	@ 0x735
34010166:	4825      	ldr	r0, [pc, #148]	@ (340101fc <HAL_XSPI_AutoPolling+0xf4>)
34010168:	f7f2 fd52 	bl	34002c10 <assert_failed>
  if ((hxspi->State == HAL_XSPI_STATE_CMD_CFG) && (pCfg->AutomaticStop == HAL_XSPI_AUTOMATIC_STOP_ENABLE))
3401016c:	6da3      	ldr	r3, [r4, #88]	@ 0x58
3401016e:	2b04      	cmp	r3, #4
34010170:	d13e      	bne.n	340101f0 <HAL_XSPI_AutoPolling+0xe8>
34010172:	68eb      	ldr	r3, [r5, #12]
34010174:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
34010178:	d13a      	bne.n	340101f0 <HAL_XSPI_AutoPolling+0xe8>
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
3401017a:	4633      	mov	r3, r6
3401017c:	2200      	movs	r2, #0
3401017e:	2120      	movs	r1, #32
34010180:	4620      	mov	r0, r4
34010182:	9700      	str	r7, [sp, #0]
34010184:	f7ff fcb2 	bl	3400faec <XSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
34010188:	2800      	cmp	r0, #0
3401018a:	d135      	bne.n	340101f8 <HAL_XSPI_AutoPolling+0xf0>
      WRITE_REG(hxspi->Instance->PSMAR, pCfg->MatchValue);
3401018c:	682b      	ldr	r3, [r5, #0]
3401018e:	6821      	ldr	r1, [r4, #0]
34010190:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
      WRITE_REG(hxspi->Instance->PSMKR, pCfg->MatchMask);
34010194:	686b      	ldr	r3, [r5, #4]
34010196:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
      WRITE_REG(hxspi->Instance->PIR,   pCfg->IntervalTime);
3401019a:	692b      	ldr	r3, [r5, #16]
3401019c:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
340101a0:	680a      	ldr	r2, [r1, #0]
340101a2:	e9d5 3502 	ldrd	r3, r5, [r5, #8]
340101a6:	431d      	orrs	r5, r3
340101a8:	f022 5343 	bic.w	r3, r2, #817889280	@ 0x30c00000
340101ac:	431d      	orrs	r5, r3
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
340101ae:	68e3      	ldr	r3, [r4, #12]
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
340101b0:	f045 5500 	orr.w	r5, r5, #536870912	@ 0x20000000
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
340101b4:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
340101b8:	600d      	str	r5, [r1, #0]
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
340101ba:	d111      	bne.n	340101e0 <HAL_XSPI_AutoPolling+0xd8>
          WRITE_REG(hxspi->Instance->AR, addr_reg);
340101bc:	f8c1 8048 	str.w	r8, [r1, #72]	@ 0x48
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_SM, SET, tickstart, Timeout);
340101c0:	4633      	mov	r3, r6
340101c2:	2201      	movs	r2, #1
340101c4:	2108      	movs	r1, #8
340101c6:	4620      	mov	r0, r4
340101c8:	9700      	str	r7, [sp, #0]
340101ca:	f7ff fc8f 	bl	3400faec <XSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
340101ce:	b920      	cbnz	r0, 340101da <HAL_XSPI_AutoPolling+0xd2>
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_SM);
340101d0:	2208      	movs	r2, #8
340101d2:	6823      	ldr	r3, [r4, #0]
340101d4:	625a      	str	r2, [r3, #36]	@ 0x24
        hxspi->State = HAL_XSPI_STATE_READY;
340101d6:	2302      	movs	r3, #2
340101d8:	65a3      	str	r3, [r4, #88]	@ 0x58
}
340101da:	b002      	add	sp, #8
340101dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
340101e0:	f8d1 3100 	ldr.w	r3, [r1, #256]	@ 0x100
340101e4:	f413 6fe0 	tst.w	r3, #1792	@ 0x700
340101e8:	d1e8      	bne.n	340101bc <HAL_XSPI_AutoPolling+0xb4>
          WRITE_REG(hxspi->Instance->IR, ir_reg);
340101ea:	f8c1 9110 	str.w	r9, [r1, #272]	@ 0x110
340101ee:	e7e7      	b.n	340101c0 <HAL_XSPI_AutoPolling+0xb8>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340101f0:	2310      	movs	r3, #16
    status = HAL_ERROR;
340101f2:	2001      	movs	r0, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340101f4:	65e3      	str	r3, [r4, #92]	@ 0x5c
340101f6:	e7f0      	b.n	340101da <HAL_XSPI_AutoPolling+0xd2>
      status = HAL_BUSY;
340101f8:	2002      	movs	r0, #2
340101fa:	e7ee      	b.n	340101da <HAL_XSPI_AutoPolling+0xd2>
340101fc:	340205d8 	.word	0x340205d8

34010200 <HAL_XSPI_MemoryMapped>:
{
34010200:	b573      	push	{r0, r1, r4, r5, r6, lr}
34010202:	460c      	mov	r4, r1
34010204:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
34010206:	f7f4 fe39 	bl	34004e7c <HAL_GetTick>
  assert_param(IS_XSPI_TIMEOUT_ACTIVATION(pCfg->TimeOutActivation));
3401020a:	6823      	ldr	r3, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
3401020c:	4606      	mov	r6, r0
  assert_param(IS_XSPI_TIMEOUT_ACTIVATION(pCfg->TimeOutActivation));
3401020e:	f033 0308 	bics.w	r3, r3, #8
34010212:	d004      	beq.n	3401021e <HAL_XSPI_MemoryMapped+0x1e>
34010214:	f240 71c6 	movw	r1, #1990	@ 0x7c6
34010218:	482f      	ldr	r0, [pc, #188]	@ (340102d8 <HAL_XSPI_MemoryMapped+0xd8>)
3401021a:	f7f2 fcf9 	bl	34002c10 <assert_failed>
  assert_param(IS_XSPI_NO_PREFETCH_DATA(pCfg->NoPrefetchData));
3401021e:	68a3      	ldr	r3, [r4, #8]
34010220:	f033 7300 	bics.w	r3, r3, #33554432	@ 0x2000000
34010224:	d004      	beq.n	34010230 <HAL_XSPI_MemoryMapped+0x30>
34010226:	f240 71c7 	movw	r1, #1991	@ 0x7c7
3401022a:	482b      	ldr	r0, [pc, #172]	@ (340102d8 <HAL_XSPI_MemoryMapped+0xd8>)
3401022c:	f7f2 fcf0 	bl	34002c10 <assert_failed>
  if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
34010230:	6dab      	ldr	r3, [r5, #88]	@ 0x58
34010232:	2b04      	cmp	r3, #4
34010234:	d14b      	bne.n	340102ce <HAL_XSPI_MemoryMapped+0xce>
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34010236:	6e2b      	ldr	r3, [r5, #96]	@ 0x60
34010238:	2200      	movs	r2, #0
3401023a:	9300      	str	r3, [sp, #0]
3401023c:	2120      	movs	r1, #32
3401023e:	4633      	mov	r3, r6
34010240:	4628      	mov	r0, r5
34010242:	f7ff fc53 	bl	3400faec <XSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
34010246:	4606      	mov	r6, r0
34010248:	bb58      	cbnz	r0, 340102a2 <HAL_XSPI_MemoryMapped+0xa2>
      hxspi->State = HAL_XSPI_STATE_BUSY_MEM_MAPPED;
3401024a:	2388      	movs	r3, #136	@ 0x88
3401024c:	65ab      	str	r3, [r5, #88]	@ 0x58
      if (pCfg->NoPrefetchData == HAL_XSPI_AUTOMATIC_PREFETCH_DISABLE)
3401024e:	68a3      	ldr	r3, [r4, #8]
34010250:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34010254:	d128      	bne.n	340102a8 <HAL_XSPI_MemoryMapped+0xa8>
        MODIFY_REG(hxspi->Instance->CR, XSPI_CR_NOPREF, pCfg->NoPrefetchData);
34010256:	682a      	ldr	r2, [r5, #0]
34010258:	6813      	ldr	r3, [r2, #0]
3401025a:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
3401025e:	6013      	str	r3, [r2, #0]
      if (pCfg->TimeOutActivation == HAL_XSPI_TIMEOUT_COUNTER_ENABLE)
34010260:	6823      	ldr	r3, [r4, #0]
34010262:	2b08      	cmp	r3, #8
34010264:	d112      	bne.n	3401028c <HAL_XSPI_MemoryMapped+0x8c>
        assert_param(IS_XSPI_TIMEOUT_PERIOD(pCfg->TimeoutPeriodClock));
34010266:	6863      	ldr	r3, [r4, #4]
34010268:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3401026c:	d304      	bcc.n	34010278 <HAL_XSPI_MemoryMapped+0x78>
3401026e:	f240 71e3 	movw	r1, #2019	@ 0x7e3
34010272:	4819      	ldr	r0, [pc, #100]	@ (340102d8 <HAL_XSPI_MemoryMapped+0xd8>)
34010274:	f7f2 fccc 	bl	34002c10 <assert_failed>
        WRITE_REG(hxspi->Instance->LPTR, pCfg->TimeoutPeriodClock);
34010278:	682b      	ldr	r3, [r5, #0]
3401027a:	6862      	ldr	r2, [r4, #4]
3401027c:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TO);
34010280:	2210      	movs	r2, #16
34010282:	625a      	str	r2, [r3, #36]	@ 0x24
        HAL_XSPI_ENABLE_IT(hxspi, HAL_XSPI_IT_TO);
34010284:	681a      	ldr	r2, [r3, #0]
34010286:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
3401028a:	601a      	str	r2, [r3, #0]
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_TCEN | XSPI_CR_FMODE),
3401028c:	682a      	ldr	r2, [r5, #0]
3401028e:	6821      	ldr	r1, [r4, #0]
34010290:	6813      	ldr	r3, [r2, #0]
34010292:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
34010296:	f023 0308 	bic.w	r3, r3, #8
3401029a:	430b      	orrs	r3, r1
3401029c:	f043 5340 	orr.w	r3, r3, #805306368	@ 0x30000000
340102a0:	6013      	str	r3, [r2, #0]
}
340102a2:	4630      	mov	r0, r6
340102a4:	b002      	add	sp, #8
340102a6:	bd70      	pop	{r4, r5, r6, pc}
        assert_param(IS_XSPI_NO_PREFETCH_AXI(pCfg->NoPrefetchAXI));
340102a8:	68e3      	ldr	r3, [r4, #12]
340102aa:	f033 6380 	bics.w	r3, r3, #67108864	@ 0x4000000
340102ae:	d004      	beq.n	340102ba <HAL_XSPI_MemoryMapped+0xba>
340102b0:	f240 71db 	movw	r1, #2011	@ 0x7db
340102b4:	4808      	ldr	r0, [pc, #32]	@ (340102d8 <HAL_XSPI_MemoryMapped+0xd8>)
340102b6:	f7f2 fcab 	bl	34002c10 <assert_failed>
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_NOPREF | XSPI_CR_NOPREF_AXI),
340102ba:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
340102be:	6829      	ldr	r1, [r5, #0]
340102c0:	4303      	orrs	r3, r0
340102c2:	680a      	ldr	r2, [r1, #0]
340102c4:	f022 62c0 	bic.w	r2, r2, #100663296	@ 0x6000000
340102c8:	4313      	orrs	r3, r2
340102ca:	600b      	str	r3, [r1, #0]
340102cc:	e7c8      	b.n	34010260 <HAL_XSPI_MemoryMapped+0x60>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340102ce:	2310      	movs	r3, #16
    status = HAL_ERROR;
340102d0:	2601      	movs	r6, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340102d2:	65eb      	str	r3, [r5, #92]	@ 0x5c
340102d4:	e7e5      	b.n	340102a2 <HAL_XSPI_MemoryMapped+0xa2>
340102d6:	bf00      	nop
340102d8:	340205d8 	.word	0x340205d8

340102dc <HAL_XSPI_SetClockPrescaler>:
  assert_param(IS_XSPI_CLK_PRESCALER(Prescaler));
340102dc:	29ff      	cmp	r1, #255	@ 0xff
{
340102de:	b538      	push	{r3, r4, r5, lr}
340102e0:	4604      	mov	r4, r0
340102e2:	460d      	mov	r5, r1
  assert_param(IS_XSPI_CLK_PRESCALER(Prescaler));
340102e4:	d904      	bls.n	340102f0 <HAL_XSPI_SetClockPrescaler+0x14>
340102e6:	f640 2191 	movw	r1, #2705	@ 0xa91
340102ea:	4809      	ldr	r0, [pc, #36]	@ (34010310 <HAL_XSPI_SetClockPrescaler+0x34>)
340102ec:	f7f2 fc90 	bl	34002c10 <assert_failed>
  if ((hxspi->State & XSPI_BUSY_STATE_MASK) == 0U)
340102f0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
340102f2:	f010 0008 	ands.w	r0, r0, #8
340102f6:	d107      	bne.n	34010308 <HAL_XSPI_SetClockPrescaler+0x2c>
    MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
340102f8:	6822      	ldr	r2, [r4, #0]
    hxspi->Init.ClockPrescaler = Prescaler;
340102fa:	6265      	str	r5, [r4, #36]	@ 0x24
    MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
340102fc:	68d3      	ldr	r3, [r2, #12]
340102fe:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
34010302:	432b      	orrs	r3, r5
34010304:	60d3      	str	r3, [r2, #12]
}
34010306:	bd38      	pop	{r3, r4, r5, pc}
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34010308:	2310      	movs	r3, #16
    status = HAL_ERROR;
3401030a:	2001      	movs	r0, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401030c:	65e3      	str	r3, [r4, #92]	@ 0x5c
3401030e:	e7fa      	b.n	34010306 <HAL_XSPI_SetClockPrescaler+0x2a>
34010310:	340205d8 	.word	0x340205d8

34010314 <CB_ISP_GetSensorGain>:
  * @param  Gain     Gain in mdB
  * @retval CMW status
  */
int CMW_CAMERA_GetGain(int32_t *Gain)
{
  *Gain = Camera_Ctx.Gain;
34010314:	4b02      	ldr	r3, [pc, #8]	@ (34010320 <CB_ISP_GetSensorGain+0xc>)
{
  if (CMW_CAMERA_GetGain(gain) != CMW_ERROR_NONE)
    return ISP_ERR_SENSORGAIN;

  return ISP_OK;
}
34010316:	2000      	movs	r0, #0
  *Gain = Camera_Ctx.Gain;
34010318:	6a1b      	ldr	r3, [r3, #32]
3401031a:	600b      	str	r3, [r1, #0]
}
3401031c:	4770      	bx	lr
3401031e:	bf00      	nop
34010320:	340ce148 	.word	0x340ce148

34010324 <CB_ISP_GetSensorExposure>:
  *exposure = Camera_Ctx.Exposure;
34010324:	4b02      	ldr	r3, [pc, #8]	@ (34010330 <CB_ISP_GetSensorExposure+0xc>)
{
  if (CMW_CAMERA_GetExposure(exposure) != CMW_ERROR_NONE)
    return ISP_ERR_SENSOREXPOSURE;

  return ISP_OK;
}
34010326:	2000      	movs	r0, #0
  *exposure = Camera_Ctx.Exposure;
34010328:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401032a:	600b      	str	r3, [r1, #0]
}
3401032c:	4770      	bx	lr
3401032e:	bf00      	nop
34010330:	340ce148 	.word	0x340ce148

34010334 <CB_ISP_GetSensorInfo>:

static ISP_StatusTypeDef CB_ISP_GetSensorInfo(uint32_t camera_instance, ISP_SensorInfoTypeDef *Info)
{
34010334:	b508      	push	{r3, lr}
  if(Camera_Drv.GetSensorInfo != NULL)
34010336:	4b05      	ldr	r3, [pc, #20]	@ (3401034c <CB_ISP_GetSensorInfo+0x18>)
34010338:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3401033a:	b113      	cbz	r3, 34010342 <CB_ISP_GetSensorInfo+0xe>
  {
    if (Camera_Drv.GetSensorInfo(&camera_bsp, Info) != CMW_ERROR_NONE)
3401033c:	4804      	ldr	r0, [pc, #16]	@ (34010350 <CB_ISP_GetSensorInfo+0x1c>)
3401033e:	4798      	blx	r3
34010340:	b908      	cbnz	r0, 34010346 <CB_ISP_GetSensorInfo+0x12>
      return ISP_ERR_SENSOREXPOSURE;
  }
  return ISP_OK;
34010342:	2000      	movs	r0, #0
}
34010344:	bd08      	pop	{r3, pc}
      return ISP_ERR_SENSOREXPOSURE;
34010346:	2083      	movs	r0, #131	@ 0x83
34010348:	e7fc      	b.n	34010344 <CB_ISP_GetSensorInfo+0x10>
3401034a:	bf00      	nop
3401034c:	340ce0d4 	.word	0x340ce0d4
34010350:	340cdf94 	.word	0x340cdf94

34010354 <CMW_CAMERA_EnablePin>:
  HAL_GPIO_WritePin(EN_CAM_PORT, EN_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
34010354:	1e02      	subs	r2, r0, #0
34010356:	bf18      	it	ne
34010358:	2201      	movne	r2, #1
3401035a:	2104      	movs	r1, #4
3401035c:	4801      	ldr	r0, [pc, #4]	@ (34010364 <CMW_CAMERA_EnablePin+0x10>)
3401035e:	f7f7 bfe5 	b.w	3400832c <HAL_GPIO_WritePin>
34010362:	bf00      	nop
34010364:	56020c00 	.word	0x56020c00

34010368 <CMW_CAMERA_ShutdownPin>:
  HAL_GPIO_WritePin(NRST_CAM_PORT, NRST_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
34010368:	1e02      	subs	r2, r0, #0
3401036a:	bf18      	it	ne
3401036c:	2201      	movne	r2, #1
3401036e:	f44f 7180 	mov.w	r1, #256	@ 0x100
34010372:	4801      	ldr	r0, [pc, #4]	@ (34010378 <CMW_CAMERA_ShutdownPin+0x10>)
34010374:	f7f7 bfda 	b.w	3400832c <HAL_GPIO_WritePin>
34010378:	56020800 	.word	0x56020800

3401037c <CMW_CAMERA_Probe_Sensor.constprop.0>:

#if defined(USE_VD55G1_SENSOR)
static int32_t CMW_CAMERA_VD55G1_Init( CMW_Sensor_Init_t *initSensors_params)
{
  int32_t ret = CMW_ERROR_NONE;
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3401037c:	2100      	movs	r1, #0
static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName)
3401037e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };

  memset(&camera_bsp, 0, sizeof(camera_bsp));
34010382:	4c6c      	ldr	r4, [pc, #432]	@ (34010534 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1b8>)
static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName)
34010384:	b099      	sub	sp, #100	@ 0x64
34010386:	4605      	mov	r5, r0
  memset(&camera_bsp, 0, sizeof(camera_bsp));
34010388:	f44f 72a0 	mov.w	r2, #320	@ 0x140
3401038c:	4620      	mov	r0, r4
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3401038e:	e9cd 1103 	strd	r1, r1, [sp, #12]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
34010392:	e9cd 1105 	strd	r1, r1, [sp, #20]
34010396:	e9cd 1107 	strd	r1, r1, [sp, #28]
  memset(&camera_bsp, 0, sizeof(camera_bsp));
3401039a:	f009 fec3 	bl	3401a124 <memset>
  camera_bsp.vd55g1_bsp.Address     = CAMERA_VD55G1_ADDRESS;
3401039e:	2320      	movs	r3, #32
  camera_bsp.vd55g1_bsp.Init        = CMW_I2C_INIT;
340103a0:	f8df b1c0 	ldr.w	fp, [pc, #448]	@ 34010564 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1e8>
  camera_bsp.vd55g1_bsp.DeInit      = CMW_I2C_DEINIT;
340103a4:	f8df a1c0 	ldr.w	sl, [pc, #448]	@ 34010568 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1ec>
  camera_bsp.vd55g1_bsp.WriteReg    = CMW_I2C_WRITEREG16;
340103a8:	f8df 81c0 	ldr.w	r8, [pc, #448]	@ 3401056c <CMW_CAMERA_Probe_Sensor.constprop.0+0x1f0>
  camera_bsp.vd55g1_bsp.ReadReg     = CMW_I2C_READREG16;
340103ac:	f8df 91c0 	ldr.w	r9, [pc, #448]	@ 34010570 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1f4>
  camera_bsp.vd55g1_bsp.Delay       = HAL_Delay;
340103b0:	4f61      	ldr	r7, [pc, #388]	@ (34010538 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1bc>)
  camera_bsp.vd55g1_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
340103b2:	4e62      	ldr	r6, [pc, #392]	@ (3401053c <CMW_CAMERA_Probe_Sensor.constprop.0+0x1c0>)
  camera_bsp.vd55g1_bsp.Address     = CAMERA_VD55G1_ADDRESS;
340103b4:	8023      	strh	r3, [r4, #0]
  camera_bsp.vd55g1_bsp.EnablePin   = CMW_CAMERA_EnablePin;
340103b6:	4b62      	ldr	r3, [pc, #392]	@ (34010540 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1c4>)

  ret = CMW_VD55G1_Probe(&camera_bsp.vd55g1_bsp, &Camera_Drv);
340103b8:	4620      	mov	r0, r4
340103ba:	4962      	ldr	r1, [pc, #392]	@ (34010544 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1c8>)
  camera_bsp.vd55g1_bsp.Init        = CMW_I2C_INIT;
340103bc:	f8c4 b070 	str.w	fp, [r4, #112]	@ 0x70
  camera_bsp.vd55g1_bsp.DeInit      = CMW_I2C_DEINIT;
340103c0:	f8c4 a074 	str.w	sl, [r4, #116]	@ 0x74
  camera_bsp.vd55g1_bsp.WriteReg    = CMW_I2C_WRITEREG16;
340103c4:	f8c4 8078 	str.w	r8, [r4, #120]	@ 0x78
  camera_bsp.vd55g1_bsp.ReadReg     = CMW_I2C_READREG16;
340103c8:	f8c4 907c 	str.w	r9, [r4, #124]	@ 0x7c
  camera_bsp.vd55g1_bsp.Delay       = HAL_Delay;
340103cc:	f8c4 7084 	str.w	r7, [r4, #132]	@ 0x84
  camera_bsp.vd55g1_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
340103d0:	f8c4 6088 	str.w	r6, [r4, #136]	@ 0x88
  camera_bsp.vd55g1_bsp.EnablePin   = CMW_CAMERA_EnablePin;
340103d4:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  ret = CMW_VD55G1_Probe(&camera_bsp.vd55g1_bsp, &Camera_Drv);
340103d8:	f000 ff64 	bl	340112a4 <CMW_VD55G1_Probe>
  if (ret != CMW_ERROR_NONE)
340103dc:	2800      	cmp	r0, #0
340103de:	d13f      	bne.n	34010460 <CMW_CAMERA_Probe_Sensor.constprop.0+0xe4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  if ((connected_sensor != CMW_VD55G1_Sensor) && (connected_sensor != CMW_NOTKNOWN_Sensor))
340103e0:	4b59      	ldr	r3, [pc, #356]	@ (34010548 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1cc>)
340103e2:	781b      	ldrb	r3, [r3, #0]
340103e4:	2b03      	cmp	r3, #3
340103e6:	d001      	beq.n	340103ec <CMW_CAMERA_Probe_Sensor.constprop.0+0x70>
340103e8:	2b00      	cmp	r3, #0
340103ea:	d139      	bne.n	34010460 <CMW_CAMERA_Probe_Sensor.constprop.0+0xe4>
    /* If the selected sensor in the application side has selected a different sensors than VD55G1 */
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
340103ec:	682b      	ldr	r3, [r5, #0]
340103ee:	4a55      	ldr	r2, [pc, #340]	@ (34010544 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1c8>)
340103f0:	b10b      	cbz	r3, 340103f6 <CMW_CAMERA_Probe_Sensor.constprop.0+0x7a>
340103f2:	686b      	ldr	r3, [r5, #4]
340103f4:	b943      	cbnz	r3, 34010408 <CMW_CAMERA_Probe_Sensor.constprop.0+0x8c>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
340103f6:	6e13      	ldr	r3, [r2, #96]	@ 0x60
340103f8:	484e      	ldr	r0, [pc, #312]	@ (34010534 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1b8>)
340103fa:	a909      	add	r1, sp, #36	@ 0x24
340103fc:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
340103fe:	9b12      	ldr	r3, [sp, #72]	@ 0x48
    initSensors_params->height = sensor_info.height;
34010400:	4a50      	ldr	r2, [pc, #320]	@ (34010544 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1c8>)
    initSensors_params->width = sensor_info.width;
34010402:	602b      	str	r3, [r5, #0]
    initSensors_params->height = sensor_info.height;
34010404:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
34010406:	606b      	str	r3, [r5, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
34010408:	4629      	mov	r1, r5
3401040a:	6813      	ldr	r3, [r2, #0]
3401040c:	4849      	ldr	r0, [pc, #292]	@ (34010534 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1b8>)
3401040e:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010410:	bb30      	cbnz	r0, 34010460 <CMW_CAMERA_Probe_Sensor.constprop.0+0xe4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_ONE_DATA_LANE;
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
34010412:	f44f 7080 	mov.w	r0, #256	@ 0x100
34010416:	2301      	movs	r3, #1
34010418:	e9cd 0303 	strd	r0, r3, [sp, #12]
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
3401041c:	231c      	movs	r3, #28
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3401041e:	a903      	add	r1, sp, #12
34010420:	484a      	ldr	r0, [pc, #296]	@ (3401054c <CMW_CAMERA_Probe_Sensor.constprop.0+0x1d0>)
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
34010422:	9305      	str	r3, [sp, #20]
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
34010424:	f7f5 f81e 	bl	34005464 <HAL_DCMIPP_CSI_SetConfig>
  if (ret != HAL_OK)
34010428:	4601      	mov	r1, r0
3401042a:	b9c8      	cbnz	r0, 34010460 <CMW_CAMERA_Probe_Sensor.constprop.0+0xe4>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP8);
3401042c:	2202      	movs	r2, #2
3401042e:	4847      	ldr	r0, [pc, #284]	@ (3401054c <CMW_CAMERA_Probe_Sensor.constprop.0+0x1d0>)
34010430:	f7f5 f988 	bl	34005744 <HAL_DCMIPP_CSI_SetVCConfig>
  if (ret != HAL_OK)
34010434:	4601      	mov	r1, r0
34010436:	b998      	cbnz	r0, 34010460 <CMW_CAMERA_Probe_Sensor.constprop.0+0xe4>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW8;
34010438:	232a      	movs	r3, #42	@ 0x2a
  csi_pipe_conf.DataTypeIDB = 0;
3401043a:	e9cd 3007 	strd	r3, r0, [sp, #28]
  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
3401043e:	9006      	str	r0, [sp, #24]
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
34010440:	4842      	ldr	r0, [pc, #264]	@ (3401054c <CMW_CAMERA_Probe_Sensor.constprop.0+0x1d0>)
34010442:	aa06      	add	r2, sp, #24
34010444:	9101      	str	r1, [sp, #4]
34010446:	f7f5 f8c9 	bl	340055dc <HAL_DCMIPP_CSI_PIPE_SetConfig>
    if (ret != HAL_OK)
3401044a:	b948      	cbnz	r0, 34010460 <CMW_CAMERA_Probe_Sensor.constprop.0+0xe4>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3401044c:	9901      	ldr	r1, [sp, #4]
3401044e:	3101      	adds	r1, #1
34010450:	2903      	cmp	r1, #3
34010452:	d1f5      	bne.n	34010440 <CMW_CAMERA_Probe_Sensor.constprop.0+0xc4>
    return ret;
34010454:	2000      	movs	r0, #0
    *sensorName = CMW_VD66GY_Sensor;
34010456:	4b3c      	ldr	r3, [pc, #240]	@ (34010548 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1cc>)
34010458:	7019      	strb	r1, [r3, #0]
}
3401045a:	b019      	add	sp, #100	@ 0x64
3401045c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

#if defined(USE_VD66GY_SENSOR)
static int32_t CMW_CAMERA_VD66GY_Init( CMW_Sensor_Init_t *initSensors_params)
{
  int32_t ret = CMW_ERROR_NONE;
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
34010460:	2100      	movs	r1, #0
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };

  memset(&camera_bsp, 0, sizeof(camera_bsp));
34010462:	f44f 72a0 	mov.w	r2, #320	@ 0x140
34010466:	4833      	ldr	r0, [pc, #204]	@ (34010534 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1b8>)
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
34010468:	e9cd 1103 	strd	r1, r1, [sp, #12]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
3401046c:	e9cd 1105 	strd	r1, r1, [sp, #20]
34010470:	e9cd 1107 	strd	r1, r1, [sp, #28]
  memset(&camera_bsp, 0, sizeof(camera_bsp));
34010474:	f009 fe56 	bl	3401a124 <memset>
  camera_bsp.vd66gy_bsp.Address     = CAMERA_VD66GY_ADDRESS;
34010478:	2320      	movs	r3, #32
3401047a:	8023      	strh	r3, [r4, #0]
  camera_bsp.vd66gy_bsp.DeInit      = CMW_I2C_DEINIT;
  camera_bsp.vd66gy_bsp.ReadReg     = CMW_I2C_READREG16;
  camera_bsp.vd66gy_bsp.WriteReg    = CMW_I2C_WRITEREG16;
  camera_bsp.vd66gy_bsp.Delay       = HAL_Delay;
  camera_bsp.vd66gy_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
  camera_bsp.vd66gy_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3401047c:	4b30      	ldr	r3, [pc, #192]	@ (34010540 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1c4>)
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;

  ret = CMW_VD66GY_Probe(&camera_bsp.vd66gy_bsp, &Camera_Drv);
3401047e:	4931      	ldr	r1, [pc, #196]	@ (34010544 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1c8>)
  camera_bsp.vd66gy_bsp.EnablePin   = CMW_CAMERA_EnablePin;
34010480:	f8c4 313c 	str.w	r3, [r4, #316]	@ 0x13c
  camera_bsp.vd66gy_bsp.hdcmipp     = &hcamera_dcmipp;
34010484:	4b31      	ldr	r3, [pc, #196]	@ (3401054c <CMW_CAMERA_Probe_Sensor.constprop.0+0x1d0>)
  ret = CMW_VD66GY_Probe(&camera_bsp.vd66gy_bsp, &Camera_Drv);
34010486:	482b      	ldr	r0, [pc, #172]	@ (34010534 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1b8>)
  camera_bsp.vd66gy_bsp.hdcmipp     = &hcamera_dcmipp;
34010488:	f8c4 3118 	str.w	r3, [r4, #280]	@ 0x118
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
3401048c:	4b30      	ldr	r3, [pc, #192]	@ (34010550 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1d4>)
  camera_bsp.vd66gy_bsp.DeInit      = CMW_I2C_DEINIT;
3401048e:	e9c4 ba48 	strd	fp, sl, [r4, #288]	@ 0x120
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
34010492:	f8c4 3104 	str.w	r3, [r4, #260]	@ 0x104
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
34010496:	4b2f      	ldr	r3, [pc, #188]	@ (34010554 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1d8>)
  camera_bsp.vd66gy_bsp.WriteReg    = CMW_I2C_WRITEREG16;
34010498:	e9c4 894a 	strd	r8, r9, [r4, #296]	@ 0x128
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
3401049c:	f8c4 3108 	str.w	r3, [r4, #264]	@ 0x108
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
340104a0:	4b2d      	ldr	r3, [pc, #180]	@ (34010558 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1dc>)
  camera_bsp.vd66gy_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
340104a2:	e9c4 764d 	strd	r7, r6, [r4, #308]	@ 0x134
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
340104a6:	f8c4 310c 	str.w	r3, [r4, #268]	@ 0x10c
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
340104aa:	4b2c      	ldr	r3, [pc, #176]	@ (3401055c <CMW_CAMERA_Probe_Sensor.constprop.0+0x1e0>)
340104ac:	f8c4 3110 	str.w	r3, [r4, #272]	@ 0x110
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
340104b0:	4b2b      	ldr	r3, [pc, #172]	@ (34010560 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1e4>)
340104b2:	f8c4 3100 	str.w	r3, [r4, #256]	@ 0x100
  ret = CMW_VD66GY_Probe(&camera_bsp.vd66gy_bsp, &Camera_Drv);
340104b6:	f001 fac7 	bl	34011a48 <CMW_VD66GY_Probe>
  if (ret != CMW_ERROR_NONE)
340104ba:	2800      	cmp	r0, #0
340104bc:	d15a      	bne.n	34010574 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1f8>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  if ((connected_sensor != CMW_VD66GY_Sensor) && (connected_sensor != CMW_NOTKNOWN_Sensor))
340104be:	4b22      	ldr	r3, [pc, #136]	@ (34010548 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1cc>)
340104c0:	781b      	ldrb	r3, [r3, #0]
340104c2:	2b01      	cmp	r3, #1
340104c4:	d856      	bhi.n	34010574 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1f8>
    /* If the selected sensor in the application side has selected a different sensors than VD66GY */
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
340104c6:	682b      	ldr	r3, [r5, #0]
340104c8:	b10b      	cbz	r3, 340104ce <CMW_CAMERA_Probe_Sensor.constprop.0+0x152>
340104ca:	686b      	ldr	r3, [r5, #4]
340104cc:	b943      	cbnz	r3, 340104e0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x164>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
340104ce:	4b1d      	ldr	r3, [pc, #116]	@ (34010544 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1c8>)
340104d0:	4818      	ldr	r0, [pc, #96]	@ (34010534 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1b8>)
340104d2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
340104d4:	a909      	add	r1, sp, #36	@ 0x24
340104d6:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
340104d8:	9b12      	ldr	r3, [sp, #72]	@ 0x48
340104da:	602b      	str	r3, [r5, #0]
    initSensors_params->height = sensor_info.height;
340104dc:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
340104de:	606b      	str	r3, [r5, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
340104e0:	4b18      	ldr	r3, [pc, #96]	@ (34010544 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1c8>)
340104e2:	4629      	mov	r1, r5
340104e4:	681b      	ldr	r3, [r3, #0]
340104e6:	4813      	ldr	r0, [pc, #76]	@ (34010534 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1b8>)
340104e8:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
340104ea:	2800      	cmp	r0, #0
340104ec:	d142      	bne.n	34010574 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1f8>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
340104ee:	f44f 7100 	mov.w	r1, #512	@ 0x200
340104f2:	2301      	movs	r3, #1
340104f4:	e9cd 1303 	strd	r1, r3, [sp, #12]
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
340104f8:	231c      	movs	r3, #28
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
340104fa:	a903      	add	r1, sp, #12
340104fc:	4813      	ldr	r0, [pc, #76]	@ (3401054c <CMW_CAMERA_Probe_Sensor.constprop.0+0x1d0>)
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
340104fe:	9305      	str	r3, [sp, #20]
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
34010500:	f7f4 ffb0 	bl	34005464 <HAL_DCMIPP_CSI_SetConfig>
  if (ret != HAL_OK)
34010504:	4601      	mov	r1, r0
34010506:	bba8      	cbnz	r0, 34010574 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1f8>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP8);
34010508:	2202      	movs	r2, #2
3401050a:	4810      	ldr	r0, [pc, #64]	@ (3401054c <CMW_CAMERA_Probe_Sensor.constprop.0+0x1d0>)
3401050c:	f7f5 f91a 	bl	34005744 <HAL_DCMIPP_CSI_SetVCConfig>
  if (ret != HAL_OK)
34010510:	bb80      	cbnz	r0, 34010574 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1f8>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW8;
34010512:	232a      	movs	r3, #42	@ 0x2a
  csi_pipe_conf.DataTypeIDB = 0;
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
34010514:	4601      	mov	r1, r0
  csi_pipe_conf.DataTypeIDB = 0;
34010516:	e9cd 3007 	strd	r3, r0, [sp, #28]
  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
3401051a:	9006      	str	r0, [sp, #24]
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
3401051c:	480b      	ldr	r0, [pc, #44]	@ (3401054c <CMW_CAMERA_Probe_Sensor.constprop.0+0x1d0>)
3401051e:	aa06      	add	r2, sp, #24
34010520:	9101      	str	r1, [sp, #4]
34010522:	f7f5 f85b 	bl	340055dc <HAL_DCMIPP_CSI_PIPE_SetConfig>
    if (ret != HAL_OK)
34010526:	bb28      	cbnz	r0, 34010574 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1f8>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
34010528:	9901      	ldr	r1, [sp, #4]
3401052a:	3101      	adds	r1, #1
3401052c:	2903      	cmp	r1, #3
3401052e:	d1f5      	bne.n	3401051c <CMW_CAMERA_Probe_Sensor.constprop.0+0x1a0>
    return ret;
34010530:	2101      	movs	r1, #1
34010532:	e78f      	b.n	34010454 <CMW_CAMERA_Probe_Sensor.constprop.0+0xd8>
34010534:	340cdf94 	.word	0x340cdf94
34010538:	34004e89 	.word	0x34004e89
3401053c:	34010369 	.word	0x34010369
34010540:	34010355 	.word	0x34010355
34010544:	340ce0d4 	.word	0x340ce0d4
34010548:	340ce188 	.word	0x340ce188
3401054c:	340ce13c 	.word	0x340ce13c
34010550:	34010915 	.word	0x34010915
34010554:	34010315 	.word	0x34010315
34010558:	34010959 	.word	0x34010959
3401055c:	34010325 	.word	0x34010325
34010560:	34010335 	.word	0x34010335
34010564:	34003a11 	.word	0x34003a11
34010568:	34003981 	.word	0x34003981
3401056c:	34003ad1 	.word	0x34003ad1
34010570:	34003b09 	.word	0x34003b09

#if defined(USE_IMX335_SENSOR)
static int32_t CMW_CAMERA_IMX335_Init(CMW_Sensor_Init_t *initSensors_params)
{
  int32_t ret = CMW_ERROR_NONE;
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
34010574:	2100      	movs	r1, #0
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };

  memset(&camera_bsp, 0, sizeof(camera_bsp));
34010576:	f44f 72a0 	mov.w	r2, #320	@ 0x140
3401057a:	483b      	ldr	r0, [pc, #236]	@ (34010668 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2ec>)
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3401057c:	e9cd 1103 	strd	r1, r1, [sp, #12]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
34010580:	e9cd 1105 	strd	r1, r1, [sp, #20]
34010584:	e9cd 1107 	strd	r1, r1, [sp, #28]
  memset(&camera_bsp, 0, sizeof(camera_bsp));
34010588:	f009 fdcc 	bl	3401a124 <memset>
  camera_bsp.imx335_bsp.Address     = CAMERA_IMX335_ADDRESS;
3401058c:	2334      	movs	r3, #52	@ 0x34
3401058e:	8023      	strh	r3, [r4, #0]
  camera_bsp.imx335_bsp.Init        = CMW_I2C_INIT;
  camera_bsp.imx335_bsp.DeInit      = CMW_I2C_DEINIT;
  camera_bsp.imx335_bsp.ReadReg     = CMW_I2C_READREG16;
  camera_bsp.imx335_bsp.WriteReg    = CMW_I2C_WRITEREG16;
  camera_bsp.imx335_bsp.GetTick     = BSP_GetTick;
34010590:	4b36      	ldr	r3, [pc, #216]	@ (3401066c <CMW_CAMERA_Probe_Sensor.constprop.0+0x2f0>)
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
  camera_bsp.imx335_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
  camera_bsp.imx335_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
  camera_bsp.imx335_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;

  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
34010592:	4937      	ldr	r1, [pc, #220]	@ (34010670 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2f4>)
  camera_bsp.imx335_bsp.Delay       = HAL_Delay;
34010594:	e9c4 373d 	strd	r3, r7, [r4, #244]	@ 0xf4
  camera_bsp.imx335_bsp.EnablePin   = CMW_CAMERA_EnablePin;
34010598:	4b36      	ldr	r3, [pc, #216]	@ (34010674 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2f8>)
  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
3401059a:	4833      	ldr	r0, [pc, #204]	@ (34010668 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2ec>)
  camera_bsp.imx335_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3401059c:	f8c4 3100 	str.w	r3, [r4, #256]	@ 0x100
  camera_bsp.imx335_bsp.hdcmipp     = &hcamera_dcmipp;
340105a0:	4b35      	ldr	r3, [pc, #212]	@ (34010678 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2fc>)
  camera_bsp.imx335_bsp.DeInit      = CMW_I2C_DEINIT;
340105a2:	e9c4 ba39 	strd	fp, sl, [r4, #228]	@ 0xe4
  camera_bsp.imx335_bsp.hdcmipp     = &hcamera_dcmipp;
340105a6:	f8c4 30dc 	str.w	r3, [r4, #220]	@ 0xdc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
340105aa:	4b34      	ldr	r3, [pc, #208]	@ (3401067c <CMW_CAMERA_Probe_Sensor.constprop.0+0x300>)
  camera_bsp.imx335_bsp.WriteReg    = CMW_I2C_WRITEREG16;
340105ac:	e9c4 893b 	strd	r8, r9, [r4, #236]	@ 0xec
  camera_bsp.imx335_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
340105b0:	f8c4 30c8 	str.w	r3, [r4, #200]	@ 0xc8
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
340105b4:	4b32      	ldr	r3, [pc, #200]	@ (34010680 <CMW_CAMERA_Probe_Sensor.constprop.0+0x304>)
  camera_bsp.imx335_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
340105b6:	f8c4 60fc 	str.w	r6, [r4, #252]	@ 0xfc
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
340105ba:	f8c4 30cc 	str.w	r3, [r4, #204]	@ 0xcc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
340105be:	4b31      	ldr	r3, [pc, #196]	@ (34010684 <CMW_CAMERA_Probe_Sensor.constprop.0+0x308>)
340105c0:	f8c4 30d0 	str.w	r3, [r4, #208]	@ 0xd0
  camera_bsp.imx335_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
340105c4:	4b30      	ldr	r3, [pc, #192]	@ (34010688 <CMW_CAMERA_Probe_Sensor.constprop.0+0x30c>)
340105c6:	f8c4 30d4 	str.w	r3, [r4, #212]	@ 0xd4
  camera_bsp.imx335_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
340105ca:	4b30      	ldr	r3, [pc, #192]	@ (3401068c <CMW_CAMERA_Probe_Sensor.constprop.0+0x310>)
340105cc:	f8c4 30c4 	str.w	r3, [r4, #196]	@ 0xc4
  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
340105d0:	f000 fca8 	bl	34010f24 <CMW_IMX335_Probe>
  if (ret != CMW_ERROR_NONE)
340105d4:	2800      	cmp	r0, #0
340105d6:	d143      	bne.n	34010660 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2e4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  if ((connected_sensor != CMW_IMX335_Sensor) && (connected_sensor != CMW_NOTKNOWN_Sensor))
340105d8:	4b2d      	ldr	r3, [pc, #180]	@ (34010690 <CMW_CAMERA_Probe_Sensor.constprop.0+0x314>)
340105da:	781b      	ldrb	r3, [r3, #0]
340105dc:	f013 0ffd 	tst.w	r3, #253	@ 0xfd
340105e0:	d13e      	bne.n	34010660 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2e4>
    /* If the selected sensor in the application side has selected a different sensors than IMX335 */
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
340105e2:	682b      	ldr	r3, [r5, #0]
340105e4:	4c22      	ldr	r4, [pc, #136]	@ (34010670 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2f4>)
340105e6:	b10b      	cbz	r3, 340105ec <CMW_CAMERA_Probe_Sensor.constprop.0+0x270>
340105e8:	686b      	ldr	r3, [r5, #4]
340105ea:	b93b      	cbnz	r3, 340105fc <CMW_CAMERA_Probe_Sensor.constprop.0+0x280>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
340105ec:	6e23      	ldr	r3, [r4, #96]	@ 0x60
340105ee:	481e      	ldr	r0, [pc, #120]	@ (34010668 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2ec>)
340105f0:	a909      	add	r1, sp, #36	@ 0x24
340105f2:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
340105f4:	9b12      	ldr	r3, [sp, #72]	@ 0x48
340105f6:	602b      	str	r3, [r5, #0]
    initSensors_params->height = sensor_info.height;
340105f8:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
340105fa:	606b      	str	r3, [r5, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
340105fc:	4629      	mov	r1, r5
340105fe:	6823      	ldr	r3, [r4, #0]
34010600:	4819      	ldr	r0, [pc, #100]	@ (34010668 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2ec>)
34010602:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010604:	bb60      	cbnz	r0, 34010660 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2e4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  ret = Camera_Drv.SetFrequency(&camera_bsp, IMX335_INCK_24MHZ);
34010606:	2102      	movs	r1, #2
34010608:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3401060a:	4817      	ldr	r0, [pc, #92]	@ (34010668 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2ec>)
3401060c:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
3401060e:	bb38      	cbnz	r0, 34010660 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2e4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  ret = Camera_Drv.SetFramerate(&camera_bsp, initSensors_params->fps);
34010610:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34010612:	68a9      	ldr	r1, [r5, #8]
34010614:	4814      	ldr	r0, [pc, #80]	@ (34010668 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2ec>)
34010616:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010618:	bb10      	cbnz	r0, 34010660 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2e4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
3401061a:	f44f 7200 	mov.w	r2, #512	@ 0x200
3401061e:	2301      	movs	r3, #1
34010620:	e9cd 2303 	strd	r2, r3, [sp, #12]
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_1600;
34010624:	232c      	movs	r3, #44	@ 0x2c
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
34010626:	a903      	add	r1, sp, #12
34010628:	4813      	ldr	r0, [pc, #76]	@ (34010678 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2fc>)
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_1600;
3401062a:	9305      	str	r3, [sp, #20]
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3401062c:	f7f4 ff1a 	bl	34005464 <HAL_DCMIPP_CSI_SetConfig>
  if (ret != HAL_OK)
34010630:	4601      	mov	r1, r0
34010632:	b9a8      	cbnz	r0, 34010660 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2e4>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP10);
34010634:	2203      	movs	r2, #3
34010636:	4810      	ldr	r0, [pc, #64]	@ (34010678 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2fc>)
34010638:	f7f5 f884 	bl	34005744 <HAL_DCMIPP_CSI_SetVCConfig>
  if (ret != HAL_OK)
3401063c:	4604      	mov	r4, r0
3401063e:	b978      	cbnz	r0, 34010660 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2e4>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW10;
34010640:	232b      	movs	r3, #43	@ 0x2b
  csi_pipe_conf.DataTypeIDB = 0;
34010642:	e9cd 3007 	strd	r3, r0, [sp, #28]
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
34010646:	4d0c      	ldr	r5, [pc, #48]	@ (34010678 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2fc>)
  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
34010648:	9006      	str	r0, [sp, #24]
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
3401064a:	4621      	mov	r1, r4
3401064c:	4628      	mov	r0, r5
3401064e:	aa06      	add	r2, sp, #24
34010650:	f7f4 ffc4 	bl	340055dc <HAL_DCMIPP_CSI_PIPE_SetConfig>
    if (ret != HAL_OK)
34010654:	b920      	cbnz	r0, 34010660 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2e4>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
34010656:	3401      	adds	r4, #1
34010658:	2c03      	cmp	r4, #3
3401065a:	d1f6      	bne.n	3401064a <CMW_CAMERA_Probe_Sensor.constprop.0+0x2ce>
    return ret;
3401065c:	2102      	movs	r1, #2
3401065e:	e6f9      	b.n	34010454 <CMW_CAMERA_Probe_Sensor.constprop.0+0xd8>
    return CMW_ERROR_UNKNOWN_COMPONENT;
34010660:	f06f 0006 	mvn.w	r0, #6
34010664:	e6f9      	b.n	3401045a <CMW_CAMERA_Probe_Sensor.constprop.0+0xde>
34010666:	bf00      	nop
34010668:	340cdf94 	.word	0x340cdf94
3401066c:	34003b41 	.word	0x34003b41
34010670:	340ce0d4 	.word	0x340ce0d4
34010674:	34010355 	.word	0x34010355
34010678:	340ce13c 	.word	0x340ce13c
3401067c:	34010915 	.word	0x34010915
34010680:	34010315 	.word	0x34010315
34010684:	34010959 	.word	0x34010959
34010688:	34010325 	.word	0x34010325
3401068c:	34010335 	.word	0x34010335
34010690:	340ce188 	.word	0x340ce188

34010694 <CMW_CAMERA_EnableGPIOs>:
{
34010694:	b570      	push	{r4, r5, r6, lr}
34010696:	b088      	sub	sp, #32
  GPIO_InitTypeDef gpio_init_structure = {0};
34010698:	2214      	movs	r2, #20
3401069a:	2100      	movs	r1, #0
3401069c:	a803      	add	r0, sp, #12
3401069e:	f009 fd41 	bl	3401a124 <memset>
  WRITE_REG(RCC->AHB4ENSR, Periphs);
340106a2:	2308      	movs	r3, #8
340106a4:	4c13      	ldr	r4, [pc, #76]	@ (340106f4 <CMW_CAMERA_EnableGPIOs+0x60>)
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
340106a6:	2501      	movs	r5, #1
340106a8:	f8c4 3a5c 	str.w	r3, [r4, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
340106ac:	f8d4 325c 	ldr.w	r3, [r4, #604]	@ 0x25c
340106b0:	2600      	movs	r6, #0
340106b2:	9302      	str	r3, [sp, #8]
  (void)tmpreg;
340106b4:	9b02      	ldr	r3, [sp, #8]
  NRST_CAM_GPIO_ENABLE_VDDIO();
340106b6:	f7f9 f80d 	bl	340096d4 <HAL_PWREx_EnableVddIO4>
  WRITE_REG(RCC->AHB4ENSR, Periphs);
340106ba:	2304      	movs	r3, #4
340106bc:	f8c4 3a5c 	str.w	r3, [r4, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
340106c0:	f8d4 225c 	ldr.w	r2, [r4, #604]	@ 0x25c
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
340106c4:	2403      	movs	r4, #3
340106c6:	9201      	str	r2, [sp, #4]
  HAL_GPIO_Init(EN_CAM_PORT, &gpio_init_structure);
340106c8:	a903      	add	r1, sp, #12
340106ca:	480b      	ldr	r0, [pc, #44]	@ (340106f8 <CMW_CAMERA_EnableGPIOs+0x64>)
  (void)tmpreg;
340106cc:	9a01      	ldr	r2, [sp, #4]
  gpio_init_structure.Pin       = EN_CAM_PIN;
340106ce:	9303      	str	r3, [sp, #12]
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
340106d0:	e9cd 5604 	strd	r5, r6, [sp, #16]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
340106d4:	9406      	str	r4, [sp, #24]
  HAL_GPIO_Init(EN_CAM_PORT, &gpio_init_structure);
340106d6:	f7f7 fae3 	bl	34007ca0 <HAL_GPIO_Init>
  gpio_init_structure.Pin       = NRST_CAM_PIN;
340106da:	f44f 7380 	mov.w	r3, #256	@ 0x100
  HAL_GPIO_Init(NRST_CAM_PORT, &gpio_init_structure);
340106de:	4807      	ldr	r0, [pc, #28]	@ (340106fc <CMW_CAMERA_EnableGPIOs+0x68>)
340106e0:	a903      	add	r1, sp, #12
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
340106e2:	e9cd 5604 	strd	r5, r6, [sp, #16]
  gpio_init_structure.Pin       = NRST_CAM_PIN;
340106e6:	9303      	str	r3, [sp, #12]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
340106e8:	9406      	str	r4, [sp, #24]
  HAL_GPIO_Init(NRST_CAM_PORT, &gpio_init_structure);
340106ea:	f7f7 fad9 	bl	34007ca0 <HAL_GPIO_Init>
}
340106ee:	b008      	add	sp, #32
340106f0:	bd70      	pop	{r4, r5, r6, pc}
340106f2:	bf00      	nop
340106f4:	56028000 	.word	0x56028000
340106f8:	56020c00 	.word	0x56020c00
340106fc:	56020800 	.word	0x56020800

34010700 <CMW_CAMERA_GetDCMIPPHandle>:
}
34010700:	4800      	ldr	r0, [pc, #0]	@ (34010704 <CMW_CAMERA_GetDCMIPPHandle+0x4>)
34010702:	4770      	bx	lr
34010704:	340ce13c 	.word	0x340ce13c

34010708 <CMW_CAMERA_SetPipeConfig>:
{
34010708:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
}
#endif

static int32_t CMW_CAMERA_SetPipe(DCMIPP_HandleTypeDef *hdcmipp, uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch)
{
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
3401070c:	2600      	movs	r6, #0
{
3401070e:	4604      	mov	r4, r0
34010710:	b093      	sub	sp, #76	@ 0x4c
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
34010712:	f10d 0830 	add.w	r8, sp, #48	@ 0x30
{
34010716:	460d      	mov	r5, r1
34010718:	4617      	mov	r7, r2
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
3401071a:	4631      	mov	r1, r6
3401071c:	2218      	movs	r2, #24
3401071e:	4640      	mov	r0, r8
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
34010720:	e9cd 6604 	strd	r6, r6, [sp, #16]
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
34010724:	9602      	str	r6, [sp, #8]
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
34010726:	9606      	str	r6, [sp, #24]
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
34010728:	9603      	str	r6, [sp, #12]
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
3401072a:	f009 fcfb 	bl	3401a124 <memset>
  DCMIPP_CropConfTypeDef crop_conf = { 0 };
3401072e:	2214      	movs	r2, #20
34010730:	4631      	mov	r1, r6
34010732:	a807      	add	r0, sp, #28
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
34010734:	f10d 0908 	add.w	r9, sp, #8
  DCMIPP_CropConfTypeDef crop_conf = { 0 };
34010738:	f009 fcf4 	bl	3401a124 <memset>
  int ret;

  /* specific case for pipe0 which is only a dump pipe */
  if (pipe == DCMIPP_PIPE0)
3401073c:	b95c      	cbnz	r4, 34010756 <CMW_CAMERA_SetPipeConfig+0x4e>
  {
    /*  TODO: properly configure the dump pipe with decimation and crop */
    pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
3401073e:	4621      	mov	r1, r4
34010740:	484f      	ldr	r0, [pc, #316]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
34010742:	aa04      	add	r2, sp, #16
34010744:	f7f5 f836 	bl	340057b4 <HAL_DCMIPP_PIPE_SetConfig>
    if (ret != HAL_OK)
34010748:	2800      	cmp	r0, #0
3401074a:	d07c      	beq.n	34010846 <CMW_CAMERA_SetPipeConfig+0x13e>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401074c:	f06f 0004 	mvn.w	r0, #4
}
34010750:	b013      	add	sp, #76	@ 0x4c
34010752:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }

    return HAL_OK;
  }

  CMW_UTILS_GetPipeConfig(camera_conf.width, camera_conf.height, p_conf, &crop_conf, &dec_conf, &down_conf);
34010756:	e9cd 9800 	strd	r9, r8, [sp]
3401075a:	484a      	ldr	r0, [pc, #296]	@ (34010884 <CMW_CAMERA_SetPipeConfig+0x17c>)
3401075c:	462a      	mov	r2, r5
3401075e:	e9d0 0100 	ldrd	r0, r1, [r0]
34010762:	ab07      	add	r3, sp, #28
34010764:	f000 fa1c 	bl	34010ba0 <CMW_UTILS_GetPipeConfig>

  if (crop_conf.VSize != 0 || crop_conf.HSize != 0)
34010768:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	@ 0x24
3401076c:	4313      	orrs	r3, r2
3401076e:	d015      	beq.n	3401079c <CMW_CAMERA_SetPipeConfig+0x94>
  {
    ret = HAL_DCMIPP_PIPE_SetCropConfig(hdcmipp, pipe, &crop_conf);
34010770:	4621      	mov	r1, r4
34010772:	4843      	ldr	r0, [pc, #268]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
34010774:	aa07      	add	r2, sp, #28
34010776:	f7f5 fd87 	bl	34006288 <HAL_DCMIPP_PIPE_SetCropConfig>
    if (ret != HAL_OK)
3401077a:	2800      	cmp	r0, #0
3401077c:	d1e6      	bne.n	3401074c <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }

    ret = HAL_DCMIPP_PIPE_EnableCrop(hdcmipp, pipe);
3401077e:	4621      	mov	r1, r4
34010780:	483f      	ldr	r0, [pc, #252]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
34010782:	f7f5 fe27 	bl	340063d4 <HAL_DCMIPP_PIPE_EnableCrop>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableCrop(hdcmipp, pipe);
    if (ret != HAL_OK)
34010786:	2800      	cmp	r0, #0
34010788:	d1e0      	bne.n	3401074c <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }

  if (dec_conf.VRatio != 0 || dec_conf.HRatio != 0)
3401078a:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
3401078e:	4313      	orrs	r3, r2
34010790:	d109      	bne.n	340107a6 <CMW_CAMERA_SetPipeConfig+0x9e>
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableDecimation(hdcmipp, pipe);
34010792:	4621      	mov	r1, r4
34010794:	483a      	ldr	r0, [pc, #232]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
34010796:	f7f5 ff4b 	bl	34006630 <HAL_DCMIPP_PIPE_DisableDecimation>
3401079a:	e00f      	b.n	340107bc <CMW_CAMERA_SetPipeConfig+0xb4>
    ret = HAL_DCMIPP_PIPE_DisableCrop(hdcmipp, pipe);
3401079c:	4621      	mov	r1, r4
3401079e:	4838      	ldr	r0, [pc, #224]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
340107a0:	f7f5 fe58 	bl	34006454 <HAL_DCMIPP_PIPE_DisableCrop>
340107a4:	e7ef      	b.n	34010786 <CMW_CAMERA_SetPipeConfig+0x7e>
    ret = HAL_DCMIPP_PIPE_SetDecimationConfig(hdcmipp, pipe, &dec_conf);
340107a6:	464a      	mov	r2, r9
340107a8:	4621      	mov	r1, r4
340107aa:	4835      	ldr	r0, [pc, #212]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
340107ac:	f7f5 fed2 	bl	34006554 <HAL_DCMIPP_PIPE_SetDecimationConfig>
    if (ret != HAL_OK)
340107b0:	2800      	cmp	r0, #0
340107b2:	d1cb      	bne.n	3401074c <CMW_CAMERA_SetPipeConfig+0x44>
    ret = HAL_DCMIPP_PIPE_EnableDecimation(hdcmipp, pipe);
340107b4:	4621      	mov	r1, r4
340107b6:	4832      	ldr	r0, [pc, #200]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
340107b8:	f7f5 ff18 	bl	340065ec <HAL_DCMIPP_PIPE_EnableDecimation>
    if (ret != HAL_OK)
340107bc:	2800      	cmp	r0, #0
340107be:	d1c5      	bne.n	3401074c <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }

  ret = HAL_DCMIPP_PIPE_SetDownsizeConfig(hdcmipp, pipe, &down_conf);
340107c0:	4642      	mov	r2, r8
340107c2:	4621      	mov	r1, r4
340107c4:	482e      	ldr	r0, [pc, #184]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
340107c6:	f7f5 ff55 	bl	34006674 <HAL_DCMIPP_PIPE_SetDownsizeConfig>
  if (ret != HAL_OK)
340107ca:	4e2d      	ldr	r6, [pc, #180]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
340107cc:	2800      	cmp	r0, #0
340107ce:	d1bd      	bne.n	3401074c <CMW_CAMERA_SetPipeConfig+0x44>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  ret = HAL_DCMIPP_PIPE_EnableDownsize(hdcmipp, pipe);
340107d0:	4621      	mov	r1, r4
340107d2:	4630      	mov	r0, r6
340107d4:	f7f5 ffdc 	bl	34006790 <HAL_DCMIPP_PIPE_EnableDownsize>
  if (ret != HAL_OK)
340107d8:	2800      	cmp	r0, #0
340107da:	d1b7      	bne.n	3401074c <CMW_CAMERA_SetPipeConfig+0x44>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  if (p_conf->enable_swap)
340107dc:	692b      	ldr	r3, [r5, #16]
  {
    /* Config pipe */
    ret = HAL_DCMIPP_PIPE_EnableRedBlueSwap(hdcmipp, pipe);
340107de:	4621      	mov	r1, r4
340107e0:	4630      	mov	r0, r6
  if (p_conf->enable_swap)
340107e2:	2b00      	cmp	r3, #0
340107e4:	d031      	beq.n	3401084a <CMW_CAMERA_SetPipeConfig+0x142>
    ret = HAL_DCMIPP_PIPE_EnableRedBlueSwap(hdcmipp, pipe);
340107e6:	f7f6 fe7b 	bl	340074e0 <HAL_DCMIPP_PIPE_EnableRedBlueSwap>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableRedBlueSwap(hdcmipp, pipe);
    if (ret != HAL_OK)
340107ea:	2800      	cmp	r0, #0
340107ec:	d1ae      	bne.n	3401074c <CMW_CAMERA_SetPipeConfig+0x44>
  }

  /* Ignore the configuration of gamma if -1
   * Activation is then done by the ISP Library
   */
  if (p_conf->enable_gamma_conversion > -1)
340107ee:	696b      	ldr	r3, [r5, #20]
340107f0:	2b00      	cmp	r3, #0
340107f2:	da2d      	bge.n	34010850 <CMW_CAMERA_SetPipeConfig+0x148>
        return CMW_ERROR_COMPONENT_FAILURE;
      }
    }
  }

  if (pipe == DCMIPP_PIPE2)
340107f4:	2c02      	cmp	r4, #2
340107f6:	d10f      	bne.n	34010818 <CMW_CAMERA_SetPipeConfig+0x110>
  {
    if (!is_pipe1_2_shared)
340107f8:	f8df 808c 	ldr.w	r8, [pc, #140]	@ 34010888 <CMW_CAMERA_SetPipeConfig+0x180>
340107fc:	f8d8 3000 	ldr.w	r3, [r8]
34010800:	b953      	cbnz	r3, 34010818 <CMW_CAMERA_SetPipeConfig+0x110>
    {
      ret = HAL_DCMIPP_PIPE_CSI_EnableShare(hdcmipp, pipe);
34010802:	4621      	mov	r1, r4
34010804:	481e      	ldr	r0, [pc, #120]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
34010806:	f7f6 febb 	bl	34007580 <HAL_DCMIPP_PIPE_CSI_EnableShare>
      if (ret != HAL_OK)
3401080a:	2800      	cmp	r0, #0
3401080c:	d19e      	bne.n	3401074c <CMW_CAMERA_SetPipeConfig+0x44>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
      }
      is_pipe1_2_shared++;
3401080e:	f8d8 3000 	ldr.w	r3, [r8]
34010812:	3301      	adds	r3, #1
34010814:	f8c8 3000 	str.w	r3, [r8]
    }
  }

  pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
34010818:	2300      	movs	r3, #0
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
3401081a:	68ea      	ldr	r2, [r5, #12]
  pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
3401081c:	9304      	str	r3, [sp, #16]
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
3401081e:	682b      	ldr	r3, [r5, #0]
  /* Hardware constraint, pitch must be multiple of 16 */
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
  pipe_conf.PixelPackerFormat = p_conf->output_format;
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
34010820:	4426      	add	r6, r4
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
34010822:	4353      	muls	r3, r2
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
34010824:	330f      	adds	r3, #15
34010826:	f023 030f 	bic.w	r3, r3, #15
  pipe_conf.PixelPackerFormat = p_conf->output_format;
3401082a:	68aa      	ldr	r2, [r5, #8]
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
3401082c:	9305      	str	r3, [sp, #20]
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
3401082e:	7973      	ldrb	r3, [r6, #5]
  pipe_conf.PixelPackerFormat = p_conf->output_format;
34010830:	9206      	str	r2, [sp, #24]
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
34010832:	b9c3      	cbnz	r3, 34010866 <CMW_CAMERA_SetPipeConfig+0x15e>
  {
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
34010834:	4621      	mov	r1, r4
34010836:	4812      	ldr	r0, [pc, #72]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
34010838:	aa04      	add	r2, sp, #16
3401083a:	f7f4 ffbb 	bl	340057b4 <HAL_DCMIPP_PIPE_SetConfig>
    if (HAL_DCMIPP_PIPE_SetPixelPackerFormat(hdcmipp, pipe, pipe_conf.PixelPackerFormat) != HAL_OK)
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }

    if (HAL_DCMIPP_PIPE_SetPitch(hdcmipp, pipe, pipe_conf.PixelPipePitch) != HAL_OK)
3401083e:	2800      	cmp	r0, #0
34010840:	d184      	bne.n	3401074c <CMW_CAMERA_SetPipeConfig+0x44>
    }
  }

  /* Update the pitch field so that application can use this information for
   * buffer alignement */
  *pitch = pipe_conf.PixelPipePitch;
34010842:	9b05      	ldr	r3, [sp, #20]
34010844:	603b      	str	r3, [r7, #0]
    return HAL_OK;
34010846:	2000      	movs	r0, #0
  return CMW_CAMERA_SetPipe(&hcamera_dcmipp, pipe, p_conf, pitch);
34010848:	e782      	b.n	34010750 <CMW_CAMERA_SetPipeConfig+0x48>
    ret = HAL_DCMIPP_PIPE_DisableRedBlueSwap(hdcmipp, pipe);
3401084a:	f7f6 fe71 	bl	34007530 <HAL_DCMIPP_PIPE_DisableRedBlueSwap>
3401084e:	e7cc      	b.n	340107ea <CMW_CAMERA_SetPipeConfig+0xe2>
      ret = HAL_DCMIPP_PIPE_EnableGammaConversion(hdcmipp, pipe);
34010850:	4621      	mov	r1, r4
34010852:	480b      	ldr	r0, [pc, #44]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
    if (p_conf->enable_gamma_conversion)
34010854:	d004      	beq.n	34010860 <CMW_CAMERA_SetPipeConfig+0x158>
      ret = HAL_DCMIPP_PIPE_EnableGammaConversion(hdcmipp, pipe);
34010856:	f7f5 ffbd 	bl	340067d4 <HAL_DCMIPP_PIPE_EnableGammaConversion>
      if (ret != HAL_OK)
3401085a:	2800      	cmp	r0, #0
3401085c:	d0ca      	beq.n	340107f4 <CMW_CAMERA_SetPipeConfig+0xec>
3401085e:	e775      	b.n	3401074c <CMW_CAMERA_SetPipeConfig+0x44>
      ret = HAL_DCMIPP_PIPE_DisableGammaConversion(hdcmipp, pipe);
34010860:	f7f5 ffda 	bl	34006818 <HAL_DCMIPP_PIPE_DisableGammaConversion>
34010864:	e7f9      	b.n	3401085a <CMW_CAMERA_SetPipeConfig+0x152>
    if (HAL_DCMIPP_PIPE_SetPixelPackerFormat(hdcmipp, pipe, pipe_conf.PixelPackerFormat) != HAL_OK)
34010866:	4621      	mov	r1, r4
34010868:	4805      	ldr	r0, [pc, #20]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
3401086a:	f7f6 fe07 	bl	3400747c <HAL_DCMIPP_PIPE_SetPixelPackerFormat>
3401086e:	2800      	cmp	r0, #0
34010870:	f47f af6c 	bne.w	3401074c <CMW_CAMERA_SetPipeConfig+0x44>
    if (HAL_DCMIPP_PIPE_SetPitch(hdcmipp, pipe, pipe_conf.PixelPipePitch) != HAL_OK)
34010874:	4621      	mov	r1, r4
34010876:	9a05      	ldr	r2, [sp, #20]
34010878:	4801      	ldr	r0, [pc, #4]	@ (34010880 <CMW_CAMERA_SetPipeConfig+0x178>)
3401087a:	f7f6 fdcd 	bl	34007418 <HAL_DCMIPP_PIPE_SetPitch>
3401087e:	e7de      	b.n	3401083e <CMW_CAMERA_SetPipeConfig+0x136>
34010880:	340ce13c 	.word	0x340ce13c
34010884:	340ce18c 	.word	0x340ce18c
34010888:	340cdf88 	.word	0x340cdf88

3401088c <CMW_CAMERA_Start>:
  if (pipe >= DCMIPP_NUM_OF_PIPES)
3401088c:	2802      	cmp	r0, #2
{
3401088e:	460b      	mov	r3, r1
34010890:	b513      	push	{r0, r1, r4, lr}
  if (pipe >= DCMIPP_NUM_OF_PIPES)
34010892:	d815      	bhi.n	340108c0 <CMW_CAMERA_Start+0x34>
  ret = HAL_DCMIPP_CSI_PIPE_Start(&hcamera_dcmipp, pipe, DCMIPP_VIRTUAL_CHANNEL0, (uint32_t)pbuff, mode);
34010894:	4601      	mov	r1, r0
34010896:	9200      	str	r2, [sp, #0]
34010898:	480e      	ldr	r0, [pc, #56]	@ (340108d4 <CMW_CAMERA_Start+0x48>)
3401089a:	2200      	movs	r2, #0
3401089c:	f7f5 f828 	bl	340058f0 <HAL_DCMIPP_CSI_PIPE_Start>
  if (ret != HAL_OK)
340108a0:	b988      	cbnz	r0, 340108c6 <CMW_CAMERA_Start+0x3a>
  if (!is_camera_started)
340108a2:	4c0d      	ldr	r4, [pc, #52]	@ (340108d8 <CMW_CAMERA_Start+0x4c>)
340108a4:	6823      	ldr	r3, [r4, #0]
340108a6:	b113      	cbz	r3, 340108ae <CMW_CAMERA_Start+0x22>
  return ret;
340108a8:	2000      	movs	r0, #0
}
340108aa:	b002      	add	sp, #8
340108ac:	bd10      	pop	{r4, pc}
    ret = Camera_Drv.Start(&camera_bsp);
340108ae:	4b0b      	ldr	r3, [pc, #44]	@ (340108dc <CMW_CAMERA_Start+0x50>)
340108b0:	480b      	ldr	r0, [pc, #44]	@ (340108e0 <CMW_CAMERA_Start+0x54>)
340108b2:	689b      	ldr	r3, [r3, #8]
340108b4:	4798      	blx	r3
    if (ret != CMW_ERROR_NONE)
340108b6:	b948      	cbnz	r0, 340108cc <CMW_CAMERA_Start+0x40>
    is_camera_started++;
340108b8:	6823      	ldr	r3, [r4, #0]
340108ba:	3301      	adds	r3, #1
340108bc:	6023      	str	r3, [r4, #0]
340108be:	e7f3      	b.n	340108a8 <CMW_CAMERA_Start+0x1c>
    return CMW_ERROR_WRONG_PARAM;
340108c0:	f06f 0001 	mvn.w	r0, #1
340108c4:	e7f1      	b.n	340108aa <CMW_CAMERA_Start+0x1e>
    return CMW_ERROR_PERIPH_FAILURE;
340108c6:	f06f 0003 	mvn.w	r0, #3
340108ca:	e7ee      	b.n	340108aa <CMW_CAMERA_Start+0x1e>
      return CMW_ERROR_COMPONENT_FAILURE;
340108cc:	f06f 0004 	mvn.w	r0, #4
340108d0:	e7eb      	b.n	340108aa <CMW_CAMERA_Start+0x1e>
340108d2:	bf00      	nop
340108d4:	340ce13c 	.word	0x340ce13c
340108d8:	340cdf8c 	.word	0x340cdf8c
340108dc:	340ce0d4 	.word	0x340ce0d4
340108e0:	340cdf94 	.word	0x340cdf94

340108e4 <CMW_CAMERA_SetGain>:
  if(Camera_Drv.SetGain == NULL)
340108e4:	4b08      	ldr	r3, [pc, #32]	@ (34010908 <CMW_CAMERA_SetGain+0x24>)
{
340108e6:	b510      	push	{r4, lr}
  if(Camera_Drv.SetGain == NULL)
340108e8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
{
340108ea:	4604      	mov	r4, r0
  if(Camera_Drv.SetGain == NULL)
340108ec:	b133      	cbz	r3, 340108fc <CMW_CAMERA_SetGain+0x18>
  ret = Camera_Drv.SetGain(&camera_bsp, Gain);
340108ee:	4601      	mov	r1, r0
340108f0:	4806      	ldr	r0, [pc, #24]	@ (3401090c <CMW_CAMERA_SetGain+0x28>)
340108f2:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
340108f4:	b928      	cbnz	r0, 34010902 <CMW_CAMERA_SetGain+0x1e>
  Camera_Ctx.Gain = Gain;
340108f6:	4b06      	ldr	r3, [pc, #24]	@ (34010910 <CMW_CAMERA_SetGain+0x2c>)
340108f8:	621c      	str	r4, [r3, #32]
}
340108fa:	bd10      	pop	{r4, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
340108fc:	f06f 000a 	mvn.w	r0, #10
34010900:	e7fb      	b.n	340108fa <CMW_CAMERA_SetGain+0x16>
    return CMW_ERROR_COMPONENT_FAILURE;
34010902:	f06f 0004 	mvn.w	r0, #4
34010906:	e7f8      	b.n	340108fa <CMW_CAMERA_SetGain+0x16>
34010908:	340ce0d4 	.word	0x340ce0d4
3401090c:	340cdf94 	.word	0x340cdf94
34010910:	340ce148 	.word	0x340ce148

34010914 <CB_ISP_SetSensorGain>:
  if (CMW_CAMERA_SetGain(gain) != CMW_ERROR_NONE)
34010914:	4608      	mov	r0, r1
{
34010916:	b508      	push	{r3, lr}
  if (CMW_CAMERA_SetGain(gain) != CMW_ERROR_NONE)
34010918:	f7ff ffe4 	bl	340108e4 <CMW_CAMERA_SetGain>
  return ISP_OK;
3401091c:	2800      	cmp	r0, #0
}
3401091e:	bf14      	ite	ne
34010920:	2079      	movne	r0, #121	@ 0x79
34010922:	2000      	moveq	r0, #0
34010924:	bd08      	pop	{r3, pc}
	...

34010928 <CMW_CAMERA_SetExposure>:
  if(Camera_Drv.SetExposure == NULL)
34010928:	4b08      	ldr	r3, [pc, #32]	@ (3401094c <CMW_CAMERA_SetExposure+0x24>)
{
3401092a:	b510      	push	{r4, lr}
  if(Camera_Drv.SetExposure == NULL)
3401092c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
{
3401092e:	4604      	mov	r4, r0
  if(Camera_Drv.SetExposure == NULL)
34010930:	b133      	cbz	r3, 34010940 <CMW_CAMERA_SetExposure+0x18>
  ret = Camera_Drv.SetExposure(&camera_bsp, exposure);
34010932:	4601      	mov	r1, r0
34010934:	4806      	ldr	r0, [pc, #24]	@ (34010950 <CMW_CAMERA_SetExposure+0x28>)
34010936:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010938:	b928      	cbnz	r0, 34010946 <CMW_CAMERA_SetExposure+0x1e>
  Camera_Ctx.Exposure = exposure;
3401093a:	4b06      	ldr	r3, [pc, #24]	@ (34010954 <CMW_CAMERA_SetExposure+0x2c>)
3401093c:	625c      	str	r4, [r3, #36]	@ 0x24
}
3401093e:	bd10      	pop	{r4, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
34010940:	f06f 000a 	mvn.w	r0, #10
34010944:	e7fb      	b.n	3401093e <CMW_CAMERA_SetExposure+0x16>
    return CMW_ERROR_COMPONENT_FAILURE;
34010946:	f06f 0004 	mvn.w	r0, #4
3401094a:	e7f8      	b.n	3401093e <CMW_CAMERA_SetExposure+0x16>
3401094c:	340ce0d4 	.word	0x340ce0d4
34010950:	340cdf94 	.word	0x340cdf94
34010954:	340ce148 	.word	0x340ce148

34010958 <CB_ISP_SetSensorExposure>:
  if (CMW_CAMERA_SetExposure(exposure) != CMW_ERROR_NONE)
34010958:	4608      	mov	r0, r1
{
3401095a:	b508      	push	{r3, lr}
  if (CMW_CAMERA_SetExposure(exposure) != CMW_ERROR_NONE)
3401095c:	f7ff ffe4 	bl	34010928 <CMW_CAMERA_SetExposure>
  return ISP_OK;
34010960:	2800      	cmp	r0, #0
}
34010962:	bf14      	ite	ne
34010964:	2083      	movne	r0, #131	@ 0x83
34010966:	2000      	moveq	r0, #0
34010968:	bd08      	pop	{r3, pc}
	...

3401096c <CMW_CAMERA_GetSensorInfo>:
{
3401096c:	b508      	push	{r3, lr}
  if(Camera_Drv.GetSensorInfo == NULL)
3401096e:	4b07      	ldr	r3, [pc, #28]	@ (3401098c <CMW_CAMERA_GetSensorInfo+0x20>)
{
34010970:	4601      	mov	r1, r0
  if(Camera_Drv.GetSensorInfo == NULL)
34010972:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34010974:	b133      	cbz	r3, 34010984 <CMW_CAMERA_GetSensorInfo+0x18>
  ret = Camera_Drv.GetSensorInfo(&camera_bsp, info);
34010976:	4806      	ldr	r0, [pc, #24]	@ (34010990 <CMW_CAMERA_GetSensorInfo+0x24>)
34010978:	4798      	blx	r3
    return CMW_ERROR_COMPONENT_FAILURE;
3401097a:	2800      	cmp	r0, #0
3401097c:	bf18      	it	ne
3401097e:	f06f 0004 	mvnne.w	r0, #4
}
34010982:	bd08      	pop	{r3, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
34010984:	f06f 000a 	mvn.w	r0, #10
34010988:	e7fb      	b.n	34010982 <CMW_CAMERA_GetSensorInfo+0x16>
3401098a:	bf00      	nop
3401098c:	340ce0d4 	.word	0x340ce0d4
34010990:	340cdf94 	.word	0x340cdf94

34010994 <CMW_CAMERA_Init>:
{
34010994:	b570      	push	{r4, r5, r6, lr}
34010996:	4604      	mov	r4, r0
34010998:	460d      	mov	r5, r1
  CMW_Sensor_Init_t initValues = {0};
3401099a:	2100      	movs	r1, #0
{
3401099c:	b096      	sub	sp, #88	@ 0x58
  ISP_SensorInfoTypeDef info = {0};
3401099e:	223c      	movs	r2, #60	@ 0x3c
340109a0:	a807      	add	r0, sp, #28
  CMW_Sensor_Init_t initValues = {0};
340109a2:	9106      	str	r1, [sp, #24]
  ISP_SensorInfoTypeDef info = {0};
340109a4:	f009 fbbe 	bl	3401a124 <memset>
  initValues.width = initConf->width;
340109a8:	6823      	ldr	r3, [r4, #0]
340109aa:	9301      	str	r3, [sp, #4]
  initValues.height = initConf->height;
340109ac:	6863      	ldr	r3, [r4, #4]
340109ae:	9302      	str	r3, [sp, #8]
  initValues.fps = initConf->fps;
340109b0:	68a3      	ldr	r3, [r4, #8]
340109b2:	9303      	str	r3, [sp, #12]
  initValues.pixel_format = initConf->pixel_format;
340109b4:	68e3      	ldr	r3, [r4, #12]
340109b6:	9304      	str	r3, [sp, #16]
  initValues.mirrorFlip = initConf->mirror_flip;
340109b8:	6963      	ldr	r3, [r4, #20]
340109ba:	9305      	str	r3, [sp, #20]
  if ((sensor_config != NULL) && (sensor_config->selected_sensor != CMW_NOTKNOWN_Sensor))
340109bc:	4b21      	ldr	r3, [pc, #132]	@ (34010a44 <CMW_CAMERA_Init+0xb0>)
340109be:	b185      	cbz	r5, 340109e2 <CMW_CAMERA_Init+0x4e>
340109c0:	782a      	ldrb	r2, [r5, #0]
340109c2:	b172      	cbz	r2, 340109e2 <CMW_CAMERA_Init+0x4e>
    initValues.sensor_config = (void *) &sensor_config->config;
340109c4:	3504      	adds	r5, #4
    connected_sensor = sensor_config->selected_sensor; // Assume The sensor is the one selected by the application. Check during probe
340109c6:	701a      	strb	r2, [r3, #0]
    initValues.sensor_config = (void *) &sensor_config->config;
340109c8:	9506      	str	r5, [sp, #24]
  hcamera_dcmipp.Instance = DCMIPP;
340109ca:	4d1f      	ldr	r5, [pc, #124]	@ (34010a48 <CMW_CAMERA_Init+0xb4>)
340109cc:	4b1f      	ldr	r3, [pc, #124]	@ (34010a4c <CMW_CAMERA_Init+0xb8>)
  ret = MX_DCMIPP_ClockConfig(&hcamera_dcmipp);
340109ce:	4628      	mov	r0, r5
  hcamera_dcmipp.Instance = DCMIPP;
340109d0:	602b      	str	r3, [r5, #0]
  ret = MX_DCMIPP_ClockConfig(&hcamera_dcmipp);
340109d2:	f7f2 f8de 	bl	34002b92 <MX_DCMIPP_ClockConfig>
  if (ret != HAL_OK)
340109d6:	b138      	cbz	r0, 340109e8 <CMW_CAMERA_Init+0x54>
    return CMW_ERROR_PERIPH_FAILURE;
340109d8:	f06f 0603 	mvn.w	r6, #3
}
340109dc:	4630      	mov	r0, r6
340109de:	b016      	add	sp, #88	@ 0x58
340109e0:	bd70      	pop	{r4, r5, r6, pc}
    connected_sensor = CMW_NOTKNOWN_Sensor;
340109e2:	2200      	movs	r2, #0
340109e4:	701a      	strb	r2, [r3, #0]
    initValues.sensor_config = NULL;
340109e6:	e7f0      	b.n	340109ca <CMW_CAMERA_Init+0x36>
  ret = HAL_DCMIPP_Init(&hcamera_dcmipp);
340109e8:	4628      	mov	r0, r5
340109ea:	f7f4 fd15 	bl	34005418 <HAL_DCMIPP_Init>
  if (ret != HAL_OK)
340109ee:	2800      	cmp	r0, #0
340109f0:	d1f2      	bne.n	340109d8 <CMW_CAMERA_Init+0x44>
  CMW_CAMERA_EnableGPIOs();
340109f2:	f7ff fe4f 	bl	34010694 <CMW_CAMERA_EnableGPIOs>
  ret = CMW_CAMERA_Probe_Sensor(&initValues, &connected_sensor);
340109f6:	a801      	add	r0, sp, #4
340109f8:	f7ff fcc0 	bl	3401037c <CMW_CAMERA_Probe_Sensor.constprop.0>
  if (ret != CMW_ERROR_NONE)
340109fc:	4606      	mov	r6, r0
340109fe:	b110      	cbz	r0, 34010a06 <CMW_CAMERA_Init+0x72>
    return CMW_ERROR_UNKNOWN_COMPONENT;
34010a00:	f06f 0606 	mvn.w	r6, #6
34010a04:	e7ea      	b.n	340109dc <CMW_CAMERA_Init+0x48>
  ret = CMW_CAMERA_GetSensorInfo(&info);
34010a06:	a807      	add	r0, sp, #28
34010a08:	f7ff ffb0 	bl	3401096c <CMW_CAMERA_GetSensorInfo>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
34010a0c:	3005      	adds	r0, #5
34010a0e:	d0f7      	beq.n	34010a00 <CMW_CAMERA_Init+0x6c>
  ret = CMW_CAMERA_SetExposure(info.exposure_min);
34010a10:	9814      	ldr	r0, [sp, #80]	@ 0x50
34010a12:	f7ff ff89 	bl	34010928 <CMW_CAMERA_SetExposure>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
34010a16:	3005      	adds	r0, #5
34010a18:	d0f2      	beq.n	34010a00 <CMW_CAMERA_Init+0x6c>
  ret = CMW_CAMERA_SetGain(info.gain_min);
34010a1a:	9812      	ldr	r0, [sp, #72]	@ 0x48
34010a1c:	f7ff ff62 	bl	340108e4 <CMW_CAMERA_SetGain>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
34010a20:	3005      	adds	r0, #5
34010a22:	d0ed      	beq.n	34010a00 <CMW_CAMERA_Init+0x6c>
  initConf->width = initValues.width;
34010a24:	9b01      	ldr	r3, [sp, #4]
  camera_conf = *initConf;
34010a26:	4d0a      	ldr	r5, [pc, #40]	@ (34010a50 <CMW_CAMERA_Init+0xbc>)
  initConf->width = initValues.width;
34010a28:	6023      	str	r3, [r4, #0]
  initConf->height = initValues.height ;
34010a2a:	9b02      	ldr	r3, [sp, #8]
34010a2c:	6063      	str	r3, [r4, #4]
  camera_conf = *initConf;
34010a2e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34010a30:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  is_camera_init++;
34010a32:	4a08      	ldr	r2, [pc, #32]	@ (34010a54 <CMW_CAMERA_Init+0xc0>)
  camera_conf = *initConf;
34010a34:	e894 0003 	ldmia.w	r4, {r0, r1}
  is_camera_init++;
34010a38:	6813      	ldr	r3, [r2, #0]
  camera_conf = *initConf;
34010a3a:	e885 0003 	stmia.w	r5, {r0, r1}
  is_camera_init++;
34010a3e:	3301      	adds	r3, #1
34010a40:	6013      	str	r3, [r2, #0]
  return ret;
34010a42:	e7cb      	b.n	340109dc <CMW_CAMERA_Init+0x48>
34010a44:	340ce188 	.word	0x340ce188
34010a48:	340ce13c 	.word	0x340ce13c
34010a4c:	58002000 	.word	0x58002000
34010a50:	340ce18c 	.word	0x340ce18c
34010a54:	340cdf90 	.word	0x340cdf90

34010a58 <CMW_CAMERA_Run>:
  if(Camera_Drv.Run != NULL)
34010a58:	4b03      	ldr	r3, [pc, #12]	@ (34010a68 <CMW_CAMERA_Run+0x10>)
34010a5a:	68db      	ldr	r3, [r3, #12]
34010a5c:	b10b      	cbz	r3, 34010a62 <CMW_CAMERA_Run+0xa>
      return Camera_Drv.Run(&camera_bsp);
34010a5e:	4803      	ldr	r0, [pc, #12]	@ (34010a6c <CMW_CAMERA_Run+0x14>)
34010a60:	4718      	bx	r3
}
34010a62:	4618      	mov	r0, r3
34010a64:	4770      	bx	lr
34010a66:	bf00      	nop
34010a68:	340ce0d4 	.word	0x340ce0d4
34010a6c:	340cdf94 	.word	0x340cdf94

34010a70 <CMW_CAMERA_PIPE_VsyncEventCallback>:
__weak int CMW_CAMERA_PIPE_VsyncEventCallback(uint32_t pipe)
34010a70:	2000      	movs	r0, #0
34010a72:	4770      	bx	lr

34010a74 <HAL_DCMIPP_PIPE_VsyncEventCallback>:
  if(Camera_Drv.VsyncEventCallback != NULL)
34010a74:	4b05      	ldr	r3, [pc, #20]	@ (34010a8c <HAL_DCMIPP_PIPE_VsyncEventCallback+0x18>)
{
34010a76:	b510      	push	{r4, lr}
  if(Camera_Drv.VsyncEventCallback != NULL)
34010a78:	691b      	ldr	r3, [r3, #16]
{
34010a7a:	460c      	mov	r4, r1
  if(Camera_Drv.VsyncEventCallback != NULL)
34010a7c:	b10b      	cbz	r3, 34010a82 <HAL_DCMIPP_PIPE_VsyncEventCallback+0xe>
      Camera_Drv.VsyncEventCallback(&camera_bsp, Pipe);
34010a7e:	4804      	ldr	r0, [pc, #16]	@ (34010a90 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x1c>)
34010a80:	4798      	blx	r3
  CMW_CAMERA_PIPE_VsyncEventCallback(Pipe);
34010a82:	4620      	mov	r0, r4
34010a84:	f7ff fff4 	bl	34010a70 <CMW_CAMERA_PIPE_VsyncEventCallback>
}
34010a88:	bd10      	pop	{r4, pc}
34010a8a:	bf00      	nop
34010a8c:	340ce0d4 	.word	0x340ce0d4
34010a90:	340cdf94 	.word	0x340cdf94

34010a94 <HAL_DCMIPP_PIPE_FrameEventCallback>:
  if(Camera_Drv.FrameEventCallback != NULL)
34010a94:	4b05      	ldr	r3, [pc, #20]	@ (34010aac <HAL_DCMIPP_PIPE_FrameEventCallback+0x18>)
{
34010a96:	b510      	push	{r4, lr}
  if(Camera_Drv.FrameEventCallback != NULL)
34010a98:	695b      	ldr	r3, [r3, #20]
{
34010a9a:	460c      	mov	r4, r1
  if(Camera_Drv.FrameEventCallback != NULL)
34010a9c:	b10b      	cbz	r3, 34010aa2 <HAL_DCMIPP_PIPE_FrameEventCallback+0xe>
      Camera_Drv.FrameEventCallback(&camera_bsp, Pipe);
34010a9e:	4804      	ldr	r0, [pc, #16]	@ (34010ab0 <HAL_DCMIPP_PIPE_FrameEventCallback+0x1c>)
34010aa0:	4798      	blx	r3
  CMW_CAMERA_PIPE_FrameEventCallback(Pipe);
34010aa2:	4620      	mov	r0, r4
34010aa4:	f7f1 f8fe 	bl	34001ca4 <CMW_CAMERA_PIPE_FrameEventCallback>
}
34010aa8:	bd10      	pop	{r4, pc}
34010aaa:	bf00      	nop
34010aac:	340ce0d4 	.word	0x340ce0d4
34010ab0:	340cdf94 	.word	0x340cdf94

34010ab4 <HAL_DCMIPP_MspInit>:
  WRITE_REG(RCC->APB5ENSR, Periphs);
34010ab4:	2304      	movs	r3, #4
{
34010ab6:	b530      	push	{r4, r5, lr}
34010ab8:	4c1b      	ldr	r4, [pc, #108]	@ (34010b28 <HAL_DCMIPP_MspInit+0x74>)
34010aba:	b085      	sub	sp, #20
34010abc:	f8c4 3a7c 	str.w	r3, [r4, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
34010ac0:	f8d4 227c 	ldr.w	r2, [r4, #636]	@ 0x27c
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34010ac4:	f504 5580 	add.w	r5, r4, #4096	@ 0x1000
  tmpreg = READ_REG(RCC->APB5ENR);
34010ac8:	9203      	str	r2, [sp, #12]
  (void)tmpreg;
34010aca:	9a03      	ldr	r2, [sp, #12]
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34010acc:	f8c4 3abc 	str.w	r3, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
34010ad0:	f8d4 22bc 	ldr.w	r2, [r4, #700]	@ 0x2bc
  HAL_NVIC_SetPriority(DCMIPP_IRQn, 0x07, 0);
34010ad4:	2107      	movs	r1, #7
34010ad6:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
34010ad8:	9a02      	ldr	r2, [sp, #8]
34010ada:	2030      	movs	r0, #48	@ 0x30
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34010adc:	f8c4 3a3c 	str.w	r3, [r4, #2620]	@ 0xa3c
34010ae0:	2200      	movs	r2, #0
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34010ae2:	f8c5 323c 	str.w	r3, [r5, #572]	@ 0x23c
34010ae6:	f7f4 fb15 	bl	34005114 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DCMIPP_IRQn);
34010aea:	2030      	movs	r0, #48	@ 0x30
34010aec:	f7f4 fb70 	bl	340051d0 <HAL_NVIC_EnableIRQ>
  WRITE_REG(RCC->APB5ENSR, Periphs);
34010af0:	2340      	movs	r3, #64	@ 0x40
34010af2:	f8c4 3a7c 	str.w	r3, [r4, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
34010af6:	f8d4 227c 	ldr.w	r2, [r4, #636]	@ 0x27c
  HAL_NVIC_SetPriority(CSI_IRQn, 0x07, 0);
34010afa:	2107      	movs	r1, #7
34010afc:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
34010afe:	9a01      	ldr	r2, [sp, #4]
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34010b00:	f8c4 3abc 	str.w	r3, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
34010b04:	f8d4 22bc 	ldr.w	r2, [r4, #700]	@ 0x2bc
34010b08:	202f      	movs	r0, #47	@ 0x2f
34010b0a:	9200      	str	r2, [sp, #0]
  (void)tmpreg;
34010b0c:	9a00      	ldr	r2, [sp, #0]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34010b0e:	f8c4 3a3c 	str.w	r3, [r4, #2620]	@ 0xa3c
34010b12:	2200      	movs	r2, #0
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34010b14:	f8c5 323c 	str.w	r3, [r5, #572]	@ 0x23c
34010b18:	f7f4 fafc 	bl	34005114 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(CSI_IRQn);
34010b1c:	202f      	movs	r0, #47	@ 0x2f
}
34010b1e:	b005      	add	sp, #20
34010b20:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  HAL_NVIC_EnableIRQ(CSI_IRQn);
34010b24:	f7f4 bb54 	b.w	340051d0 <HAL_NVIC_EnableIRQ>
34010b28:	56028000 	.word	0x56028000

34010b2c <CMW_UTILS_get_dec_ratio_and_update>:

  return is_vertical ? DCMIPP_VDEC_ALL : DCMIPP_HDEC_ALL;
}

static uint32_t CMW_UTILS_get_dec_ratio_and_update(float *ratio, int is_vertical)
{
34010b2c:	b508      	push	{r3, lr}
  int dec_ratio = 1;

  while (*ratio >= 8) {
34010b2e:	eeb2 7a00 	vmov.f32	s14, #32	@ 0x41000000  8.0
  int dec_ratio = 1;
34010b32:	2301      	movs	r3, #1
    dec_ratio *= 2;
    *ratio /= 2;
34010b34:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
  while (*ratio >= 8) {
34010b38:	edd0 7a00 	vldr	s15, [r0]
34010b3c:	eef4 7ac7 	vcmpe.f32	s15, s14
34010b40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010b44:	da08      	bge.n	34010b58 <CMW_UTILS_get_dec_ratio_and_update+0x2c>
  switch (dec_ratio) {
34010b46:	3b01      	subs	r3, #1
34010b48:	2b07      	cmp	r3, #7
34010b4a:	d81a      	bhi.n	34010b82 <CMW_UTILS_get_dec_ratio_and_update+0x56>
34010b4c:	e8df f003 	tbb	[pc, r3]
34010b50:	0f190a1f 	.word	0x0f190a1f
34010b54:	14191919 	.word	0x14191919
    *ratio /= 2;
34010b58:	ee67 7aa6 	vmul.f32	s15, s15, s13
    dec_ratio *= 2;
34010b5c:	005b      	lsls	r3, r3, #1
    *ratio /= 2;
34010b5e:	edc0 7a00 	vstr	s15, [r0]
34010b62:	e7e9      	b.n	34010b38 <CMW_UTILS_get_dec_ratio_and_update+0xc>
    return is_vertical ? DCMIPP_VDEC_1_OUT_2 : DCMIPP_HDEC_1_OUT_2;
34010b64:	2900      	cmp	r1, #0
34010b66:	bf0c      	ite	eq
34010b68:	2002      	moveq	r0, #2
34010b6a:	2008      	movne	r0, #8
  }

  return CMW_UTILS_get_dec_ratio_from_decimal_ratio(dec_ratio, is_vertical);
}
34010b6c:	bd08      	pop	{r3, pc}
    return is_vertical ? DCMIPP_VDEC_1_OUT_4 : DCMIPP_HDEC_1_OUT_4;
34010b6e:	2900      	cmp	r1, #0
34010b70:	bf0c      	ite	eq
34010b72:	2004      	moveq	r0, #4
34010b74:	2010      	movne	r0, #16
34010b76:	e7f9      	b.n	34010b6c <CMW_UTILS_get_dec_ratio_and_update+0x40>
    return is_vertical ? DCMIPP_VDEC_1_OUT_8 : DCMIPP_HDEC_1_OUT_8;
34010b78:	2900      	cmp	r1, #0
34010b7a:	bf0c      	ite	eq
34010b7c:	2006      	moveq	r0, #6
34010b7e:	2018      	movne	r0, #24
34010b80:	e7f4      	b.n	34010b6c <CMW_UTILS_get_dec_ratio_and_update+0x40>
    assert(0);
34010b82:	2177      	movs	r1, #119	@ 0x77
34010b84:	4b03      	ldr	r3, [pc, #12]	@ (34010b94 <CMW_UTILS_get_dec_ratio_and_update+0x68>)
34010b86:	4a04      	ldr	r2, [pc, #16]	@ (34010b98 <CMW_UTILS_get_dec_ratio_and_update+0x6c>)
34010b88:	4804      	ldr	r0, [pc, #16]	@ (34010b9c <CMW_UTILS_get_dec_ratio_and_update+0x70>)
34010b8a:	f008 f967 	bl	34018e5c <__assert_func>
  switch (dec_ratio) {
34010b8e:	2000      	movs	r0, #0
34010b90:	e7ec      	b.n	34010b6c <CMW_UTILS_get_dec_ratio_and_update+0x40>
34010b92:	bf00      	nop
34010b94:	340217f8 	.word	0x340217f8
34010b98:	340a6dce 	.word	0x340a6dce
34010b9c:	3402069c 	.word	0x3402069c

34010ba0 <CMW_UTILS_GetPipeConfig>:
{
34010ba0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34010ba2:	4614      	mov	r4, r2
34010ba4:	e9dd 5608 	ldrd	r5, r6, [sp, #32]
    CMW_UTILS_get_crop_config(cam_width, cam_height, p_conf->output_width, p_conf->output_height, crop);
34010ba8:	6867      	ldr	r7, [r4, #4]
  if (p_conf->mode == CMW_Aspect_ratio_crop)
34010baa:	6992      	ldr	r2, [r2, #24]
  const float ratio_height = (float)cam_height / pipe_height;
34010bac:	ee06 7a90 	vmov	s13, r7
{
34010bb0:	ee07 0a10 	vmov	s14, r0
34010bb4:	ee07 1a90 	vmov	s15, r1
  const float ratio_height = (float)cam_height / pipe_height;
34010bb8:	eeb8 5a66 	vcvt.f32.u32	s10, s13
  if (p_conf->mode == CMW_Aspect_ratio_crop)
34010bbc:	2a00      	cmp	r2, #0
34010bbe:	f040 808e 	bne.w	34010cde <CMW_UTILS_GetPipeConfig+0x13e>
  const float ratio_width = (float)cam_width / pipe_width ;
34010bc2:	edd4 6a00 	vldr	s13, [r4]
34010bc6:	eeb8 6a47 	vcvt.f32.u32	s12, s14
34010bca:	eef8 4a66 	vcvt.f32.u32	s9, s13
  const float ratio_height = (float)cam_height / pipe_height;
34010bce:	eef8 6a67 	vcvt.f32.u32	s13, s15
  const float ratio_width = (float)cam_width / pipe_width ;
34010bd2:	ee86 4a24 	vdiv.f32	s8, s12, s9
  const float ratio_height = (float)cam_height / pipe_height;
34010bd6:	eec6 5a85 	vdiv.f32	s11, s13, s10
  const float ratio = MIN(ratio_width, ratio_height);
34010bda:	eeb4 4a65 	vcmp.f32	s8, s11
34010bde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010be2:	bf48      	it	mi
34010be4:	eef0 5a44 	vmovmi.f32	s11, s8
  assert(ratio >= 1);
34010be8:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
34010bec:	eef4 5ac4 	vcmpe.f32	s11, s8
34010bf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010bf4:	da05      	bge.n	34010c02 <CMW_UTILS_GetPipeConfig+0x62>
34010bf6:	214f      	movs	r1, #79	@ 0x4f
34010bf8:	4b4f      	ldr	r3, [pc, #316]	@ (34010d38 <CMW_UTILS_GetPipeConfig+0x198>)
34010bfa:	4a50      	ldr	r2, [pc, #320]	@ (34010d3c <CMW_UTILS_GetPipeConfig+0x19c>)
  assert(ratio < 64);
34010bfc:	4850      	ldr	r0, [pc, #320]	@ (34010d40 <CMW_UTILS_GetPipeConfig+0x1a0>)
34010bfe:	f008 f92d 	bl	34018e5c <__assert_func>
34010c02:	ed9f 4a50 	vldr	s8, [pc, #320]	@ 34010d44 <CMW_UTILS_GetPipeConfig+0x1a4>
34010c06:	eef4 5ac4 	vcmpe.f32	s11, s8
34010c0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010c0e:	d403      	bmi.n	34010c18 <CMW_UTILS_GetPipeConfig+0x78>
34010c10:	2150      	movs	r1, #80	@ 0x50
34010c12:	4b4d      	ldr	r3, [pc, #308]	@ (34010d48 <CMW_UTILS_GetPipeConfig+0x1a8>)
34010c14:	4a49      	ldr	r2, [pc, #292]	@ (34010d3c <CMW_UTILS_GetPipeConfig+0x19c>)
34010c16:	e7f1      	b.n	34010bfc <CMW_UTILS_GetPipeConfig+0x5c>
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010c18:	ee24 4aa5 	vmul.f32	s8, s9, s11
34010c1c:	eeb4 6ac4 	vcmpe.f32	s12, s8
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010c20:	ee65 5a25 	vmul.f32	s11, s10, s11
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010c24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010c28:	eef4 6ae5 	vcmpe.f32	s13, s11
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010c2c:	bfcc      	ite	gt
34010c2e:	eebc 6ac4 	vcvtgt.u32.f32	s12, s8
34010c32:	eebc 6ac6 	vcvtle.u32.f32	s12, s12
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010c36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  crop->HStart = (cam_width - crop->HSize + 1) / 2;
34010c3a:	4601      	mov	r1, r0
34010c3c:	ee16 2a10 	vmov	r2, s12
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010c40:	bfcc      	ite	gt
34010c42:	eefc 6ae5 	vcvtgt.u32.f32	s13, s11
34010c46:	eefc 6ae6 	vcvtle.u32.f32	s13, s13
  crop->HStart = (cam_width - crop->HSize + 1) / 2;
34010c4a:	3101      	adds	r1, #1
34010c4c:	1a89      	subs	r1, r1, r2
34010c4e:	0849      	lsrs	r1, r1, #1
34010c50:	6059      	str	r1, [r3, #4]
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
34010c52:	ee17 1a90 	vmov	r1, s15
34010c56:	ee16 2a90 	vmov	r2, s13
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010c5a:	ed83 6a03 	vstr	s12, [r3, #12]
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010c5e:	edc3 6a02 	vstr	s13, [r3, #8]
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010c62:	eeb8 6a46 	vcvt.f32.u32	s12, s12
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010c66:	eef8 6a66 	vcvt.f32.u32	s13, s13
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
34010c6a:	3101      	adds	r1, #1
34010c6c:	1a89      	subs	r1, r1, r2
  crop->PipeArea = DCMIPP_POSITIVE_AREA;
34010c6e:	2200      	movs	r2, #0
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010c70:	eec6 5a24 	vdiv.f32	s11, s12, s9
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010c74:	ee86 7a85 	vdiv.f32	s14, s13, s10
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
34010c78:	0849      	lsrs	r1, r1, #1
34010c7a:	6019      	str	r1, [r3, #0]
  crop->PipeArea = DCMIPP_POSITIVE_AREA;
34010c7c:	611a      	str	r2, [r3, #16]

static void CMW_UTILS_get_scale_configs(CMW_DCMIPP_Conf_t *p_conf, float ratio_width, float ratio_height,
                                       DCMIPP_DecimationConfTypeDef *dec, DCMIPP_DownsizeTypeDef *down)
{
  dec->HRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_width, 0);
34010c7e:	2100      	movs	r1, #0
34010c80:	4668      	mov	r0, sp
34010c82:	ed8d 7a01 	vstr	s14, [sp, #4]
34010c86:	edcd 5a00 	vstr	s11, [sp]
34010c8a:	f7ff ff4f 	bl	34010b2c <CMW_UTILS_get_dec_ratio_and_update>
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
34010c8e:	2101      	movs	r1, #1
  dec->HRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_width, 0);
34010c90:	6068      	str	r0, [r5, #4]
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
34010c92:	a801      	add	r0, sp, #4
34010c94:	f7ff ff4a 	bl	34010b2c <CMW_UTILS_get_dec_ratio_and_update>
  down->HRatio = (uint32_t) (8192 * ratio_width);
34010c98:	ed9f 7a2c 	vldr	s14, [pc, #176]	@ 34010d4c <CMW_UTILS_GetPipeConfig+0x1ac>
34010c9c:	eddd 7a00 	vldr	s15, [sp]
34010ca0:	ee67 7a87 	vmul.f32	s15, s15, s14
34010ca4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
34010ca8:	6028      	str	r0, [r5, #0]
  down->HRatio = (uint32_t) (8192 * ratio_width);
34010caa:	ee17 3a90 	vmov	r3, s15
  CMW_UTILS_get_down_config(ratio_width, ratio_height, p_conf->output_width, p_conf->output_height, down);
34010cae:	6820      	ldr	r0, [r4, #0]
  down->HRatio = (uint32_t) (8192 * ratio_width);
34010cb0:	edc6 7a03 	vstr	s15, [r6, #12]
  down->VRatio = (uint32_t) (8192 * ratio_height);
34010cb4:	eddd 7a01 	vldr	s15, [sp, #4]
34010cb8:	ee67 7a87 	vmul.f32	s15, s15, s14
34010cbc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34010cc0:	ee17 2a90 	vmov	r2, s15
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
34010cc4:	4922      	ldr	r1, [pc, #136]	@ (34010d50 <CMW_UTILS_GetPipeConfig+0x1b0>)
  down->VRatio = (uint32_t) (8192 * ratio_height);
34010cc6:	edc6 7a02 	vstr	s15, [r6, #8]
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
34010cca:	fbb1 f3f3 	udiv	r3, r1, r3
  down->VDivFactor = (1024 * 8192 - 1) / down->VRatio;
34010cce:	fbb1 f1f2 	udiv	r1, r1, r2
  down->VSize = height;
34010cd2:	e9c6 7000 	strd	r7, r0, [r6]
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
34010cd6:	6173      	str	r3, [r6, #20]
  down->VDivFactor = (1024 * 8192 - 1) / down->VRatio;
34010cd8:	6131      	str	r1, [r6, #16]
}
34010cda:	b003      	add	sp, #12
34010cdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (p_conf->mode == CMW_Aspect_ratio_fit)
34010cde:	2a01      	cmp	r2, #1
34010ce0:	d10c      	bne.n	34010cfc <CMW_UTILS_GetPipeConfig+0x15c>
    ratio_width = (float)cam_width / p_conf->output_width;
34010ce2:	edd4 6a00 	vldr	s13, [r4]
34010ce6:	eeb8 7a47 	vcvt.f32.u32	s14, s14
34010cea:	eef8 6a66 	vcvt.f32.u32	s13, s13
34010cee:	eec7 5a26 	vdiv.f32	s11, s14, s13
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010cf2:	eef8 7a67 	vcvt.f32.u32	s15, s15
34010cf6:	ee87 7a85 	vdiv.f32	s14, s15, s10
34010cfa:	e7c0      	b.n	34010c7e <CMW_UTILS_GetPipeConfig+0xde>
  else if (p_conf->mode == CMW_Aspect_ratio_fullscreen)
34010cfc:	2a02      	cmp	r2, #2
34010cfe:	d106      	bne.n	34010d0e <CMW_UTILS_GetPipeConfig+0x16e>
    ratio_height = (float) cam_height / p_conf->output_height;
34010d00:	eef8 7a67 	vcvt.f32.u32	s15, s15
34010d04:	ee87 7a85 	vdiv.f32	s14, s15, s10
    ratio_width = (float) ratio_height;
34010d08:	eef0 5a47 	vmov.f32	s11, s14
34010d0c:	e7b7      	b.n	34010c7e <CMW_UTILS_GetPipeConfig+0xde>
  crop->HSize = roi->width;
34010d0e:	69e1      	ldr	r1, [r4, #28]
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010d10:	ed94 7a00 	vldr	s14, [r4]
34010d14:	ee07 1a90 	vmov	s15, r1
34010d18:	eeb8 7a47 	vcvt.f32.u32	s14, s14
34010d1c:	eef8 7a67 	vcvt.f32.u32	s15, s15
  crop->HStart = roi->offset_x;
34010d20:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  crop->VSize = roi->height;
34010d22:	6a22      	ldr	r2, [r4, #32]
  crop->HStart = roi->offset_x;
34010d24:	6058      	str	r0, [r3, #4]
  crop->VStart = roi->offset_y;
34010d26:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010d28:	eec7 5a87 	vdiv.f32	s11, s15, s14
  crop->HSize = roi->width;
34010d2c:	60d9      	str	r1, [r3, #12]
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010d2e:	ee07 2a90 	vmov	s15, r2
  crop->VSize = roi->height;
34010d32:	609a      	str	r2, [r3, #8]
  crop->VStart = roi->offset_y;
34010d34:	6018      	str	r0, [r3, #0]
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010d36:	e7dc      	b.n	34010cf2 <CMW_UTILS_GetPipeConfig+0x152>
34010d38:	34020744 	.word	0x34020744
34010d3c:	340a6df9 	.word	0x340a6df9
34010d40:	3402069c 	.word	0x3402069c
34010d44:	42800000 	.word	0x42800000
34010d48:	3402074f 	.word	0x3402074f
34010d4c:	46000000 	.word	0x46000000
34010d50:	007fffff 	.word	0x007fffff

34010d54 <CMW_IMX335_FrameEventCallback>:
#endif
}

static void CMW_IMX335_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
}
34010d54:	4770      	bx	lr

34010d56 <CMW_IMX335_SetWBRefMode>:
{
34010d56:	b508      	push	{r3, lr}
  ret = ISP_SetWBRefMode(&((CMW_IMX335_t *)io_ctx)->hIsp, Automatic, RefColorTemp);
34010d58:	3030      	adds	r0, #48	@ 0x30
34010d5a:	f003 fc64 	bl	34014626 <ISP_SetWBRefMode>
  return CMW_ERROR_NONE;
34010d5e:	2800      	cmp	r0, #0
}
34010d60:	bf14      	ite	ne
34010d62:	f06f 0003 	mvnne.w	r0, #3
34010d66:	2000      	moveq	r0, #0
34010d68:	bd08      	pop	{r3, pc}

34010d6a <CMW_IMX335_ListWBRefModes>:
{
34010d6a:	b508      	push	{r3, lr}
  ret = ISP_ListWBRefModes(&((CMW_IMX335_t *)io_ctx)->hIsp, RefColorTemp);
34010d6c:	3030      	adds	r0, #48	@ 0x30
34010d6e:	f003 fc47 	bl	34014600 <ISP_ListWBRefModes>
  return CMW_ERROR_NONE;
34010d72:	2800      	cmp	r0, #0
}
34010d74:	bf14      	ite	ne
34010d76:	f06f 0003 	mvnne.w	r0, #3
34010d7a:	2000      	moveq	r0, #0
34010d7c:	bd08      	pop	{r3, pc}

34010d7e <CMW_IMX335_ReadID>:
  return IMX335_ReadID(&((CMW_IMX335_t *)io_ctx)->ctx_driver, Id);
34010d7e:	3008      	adds	r0, #8
34010d80:	f000 bf7a 	b.w	34011c78 <IMX335_ReadID>

34010d84 <CMW_IMX335_SetTestPattern>:
  return IMX335_SetTestPattern(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mode);
34010d84:	3008      	adds	r0, #8
34010d86:	f001 b883 	b.w	34011e90 <IMX335_SetTestPattern>
	...

34010d8c <CMW_IMX335_GetSensorInfo>:
{
34010d8c:	b508      	push	{r3, lr}
34010d8e:	460b      	mov	r3, r1
  if ((io_ctx ==  NULL) || (info == NULL))
34010d90:	b1c8      	cbz	r0, 34010dc6 <CMW_IMX335_GetSensorInfo+0x3a>
34010d92:	b1c1      	cbz	r1, 34010dc6 <CMW_IMX335_GetSensorInfo+0x3a>
    strcpy(info->name, IMX335_NAME);
34010d94:	4618      	mov	r0, r3
34010d96:	490d      	ldr	r1, [pc, #52]	@ (34010dcc <CMW_IMX335_GetSensorInfo+0x40>)
34010d98:	f009 fc45 	bl	3401a626 <strcpy>
  info->bayer_pattern = IMX335_BAYER_PATTERN;
34010d9c:	f44f 6220 	mov.w	r2, #2560	@ 0xa00
  info->height = IMX335_HEIGHT;
34010da0:	f44f 6122 	mov.w	r1, #2592	@ 0xa20
  info->bayer_pattern = IMX335_BAYER_PATTERN;
34010da4:	8402      	strh	r2, [r0, #32]
  info->height = IMX335_HEIGHT;
34010da6:	f44f 62f3 	mov.w	r2, #1944	@ 0x798
    strcpy(info->name, IMX335_NAME);
34010daa:	4603      	mov	r3, r0
  info->height = IMX335_HEIGHT;
34010dac:	e9c0 1209 	strd	r1, r2, [r0, #36]	@ 0x24
  info->gain_max = IMX335_GAIN_MAX;
34010db0:	2000      	movs	r0, #0
34010db2:	4a07      	ldr	r2, [pc, #28]	@ (34010dd0 <CMW_IMX335_GetSensorInfo+0x44>)
  info->exposure_max = IMX335_EXPOSURE_MAX;
34010db4:	f04f 0c08 	mov.w	ip, #8
  info->gain_max = IMX335_GAIN_MAX;
34010db8:	e9c3 020b 	strd	r0, r2, [r3, #44]	@ 0x2c
  info->exposure_max = IMX335_EXPOSURE_MAX;
34010dbc:	f248 12f2 	movw	r2, #33266	@ 0x81f2
34010dc0:	e9c3 c20d 	strd	ip, r2, [r3, #52]	@ 0x34
}
34010dc4:	bd08      	pop	{r3, pc}
    return CMW_ERROR_WRONG_PARAM;
34010dc6:	f06f 0001 	mvn.w	r0, #1
34010dca:	e7fb      	b.n	34010dc4 <CMW_IMX335_GetSensorInfo+0x38>
34010dcc:	3402075a 	.word	0x3402075a
34010dd0:	00011940 	.word	0x00011940

34010dd4 <CMW_IMX335_SetMirrorFlip>:
  return IMX335_MirrorFlipConfig(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mirrorFlip);
34010dd4:	2903      	cmp	r1, #3
34010dd6:	bf28      	it	cs
34010dd8:	2103      	movcs	r1, #3
34010dda:	3008      	adds	r0, #8
34010ddc:	f001 b83e 	b.w	34011e5c <IMX335_MirrorFlipConfig>

34010de0 <CMW_IMX335_SetFramerate>:
{
34010de0:	b4f0      	push	{r4, r5, r6, r7}
  const int32_t available_imx335_fps[] = {10, 15, 20, 25, 30};
34010de2:	4d0e      	ldr	r5, [pc, #56]	@ (34010e1c <CMW_IMX335_SetFramerate+0x3c>)
{
34010de4:	b086      	sub	sp, #24
  const int32_t available_imx335_fps[] = {10, 15, 20, 25, 30};
34010de6:	ac01      	add	r4, sp, #4
{
34010de8:	4607      	mov	r7, r0
34010dea:	460e      	mov	r6, r1
  const int32_t available_imx335_fps[] = {10, 15, 20, 25, 30};
34010dec:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34010dee:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34010df0:	682b      	ldr	r3, [r5, #0]
34010df2:	aa01      	add	r2, sp, #4
34010df4:	6023      	str	r3, [r4, #0]
  for (int i = 0; i < ARRAY_SIZE(available_imx335_fps); i++)
34010df6:	2305      	movs	r3, #5
    if (framerate == available_imx335_fps[i])
34010df8:	f852 1b04 	ldr.w	r1, [r2], #4
34010dfc:	42b1      	cmp	r1, r6
34010dfe:	d106      	bne.n	34010e0e <CMW_IMX335_SetFramerate+0x2e>
      return IMX335_SetFramerate(&((CMW_IMX335_t *)io_ctx)->ctx_driver, framerate);
34010e00:	4631      	mov	r1, r6
34010e02:	f107 0008 	add.w	r0, r7, #8
}
34010e06:	b006      	add	sp, #24
34010e08:	bcf0      	pop	{r4, r5, r6, r7}
      return IMX335_SetFramerate(&((CMW_IMX335_t *)io_ctx)->ctx_driver, framerate);
34010e0a:	f000 bffb 	b.w	34011e04 <IMX335_SetFramerate>
  for (int i = 0; i < ARRAY_SIZE(available_imx335_fps); i++)
34010e0e:	3b01      	subs	r3, #1
34010e10:	d1f2      	bne.n	34010df8 <CMW_IMX335_SetFramerate+0x18>
}
34010e12:	f06f 0001 	mvn.w	r0, #1
34010e16:	b006      	add	sp, #24
34010e18:	bcf0      	pop	{r4, r5, r6, r7}
34010e1a:	4770      	bx	lr
34010e1c:	3401d398 	.word	0x3401d398

34010e20 <CMW_IMX335_SetFrequency>:
  return IMX335_SetFrequency(&((CMW_IMX335_t *)io_ctx)->ctx_driver, frequency);
34010e20:	3008      	adds	r0, #8
34010e22:	f000 bfcb 	b.w	34011dbc <IMX335_SetFrequency>

34010e26 <CMW_IMX335_SetExposure>:
  return IMX335_SetExposure(&((CMW_IMX335_t *)io_ctx)->ctx_driver, exposure);
34010e26:	3008      	adds	r0, #8
34010e28:	f000 bf76 	b.w	34011d18 <IMX335_SetExposure>

34010e2c <CMW_IMX335_SetGain>:
  return IMX335_SetGain(&((CMW_IMX335_t *)io_ctx)->ctx_driver, gain);
34010e2c:	3008      	adds	r0, #8
34010e2e:	f000 bf3b 	b.w	34011ca8 <IMX335_SetGain>

34010e32 <CMW_IMX335_Run>:
{
34010e32:	b508      	push	{r3, lr}
  ret = ISP_BackgroundProcess(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010e34:	3030      	adds	r0, #48	@ 0x30
34010e36:	f003 fbd3 	bl	340145e0 <ISP_BackgroundProcess>
  return CMW_ERROR_NONE;
34010e3a:	2800      	cmp	r0, #0
}
34010e3c:	bf14      	ite	ne
34010e3e:	f06f 0003 	mvnne.w	r0, #3
34010e42:	2000      	moveq	r0, #0
34010e44:	bd08      	pop	{r3, pc}

34010e46 <CMW_IMX335_DeInit>:
{
34010e46:	b510      	push	{r4, lr}
34010e48:	4604      	mov	r4, r0
  ret = ISP_DeInit(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010e4a:	3030      	adds	r0, #48	@ 0x30
34010e4c:	f003 fb16 	bl	3401447c <ISP_DeInit>
  if (ret)
34010e50:	b110      	cbz	r0, 34010e58 <CMW_IMX335_DeInit+0x12>
    return CMW_ERROR_COMPONENT_FAILURE;
34010e52:	f06f 0004 	mvn.w	r0, #4
}
34010e56:	bd10      	pop	{r4, pc}
  ret = IMX335_DeInit(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
34010e58:	f104 0008 	add.w	r0, r4, #8
34010e5c:	f000 ff03 	bl	34011c66 <IMX335_DeInit>
  if (ret)
34010e60:	2800      	cmp	r0, #0
34010e62:	d0f8      	beq.n	34010e56 <CMW_IMX335_DeInit+0x10>
34010e64:	e7f5      	b.n	34010e52 <CMW_IMX335_DeInit+0xc>
	...

34010e68 <CMW_IMX335_Start>:
{
34010e68:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = ISP_Init(&((CMW_IMX335_t *)io_ctx)->hIsp, ((CMW_IMX335_t *)io_ctx)->hdcmipp, 0, &((CMW_IMX335_t *)io_ctx)->appliHelpers, &ISP_IQParamCacheInit_IMX335);
34010e6a:	4b10      	ldr	r3, [pc, #64]	@ (34010eac <CMW_IMX335_Start+0x44>)
34010e6c:	f100 0530 	add.w	r5, r0, #48	@ 0x30
34010e70:	9300      	str	r3, [sp, #0]
{
34010e72:	4604      	mov	r4, r0
  ret = ISP_Init(&((CMW_IMX335_t *)io_ctx)->hIsp, ((CMW_IMX335_t *)io_ctx)->hdcmipp, 0, &((CMW_IMX335_t *)io_ctx)->appliHelpers, &ISP_IQParamCacheInit_IMX335);
34010e74:	f8d0 10dc 	ldr.w	r1, [r0, #220]	@ 0xdc
34010e78:	f100 03b8 	add.w	r3, r0, #184	@ 0xb8
34010e7c:	2200      	movs	r2, #0
34010e7e:	4628      	mov	r0, r5
34010e80:	f003 fa80 	bl	34014384 <ISP_Init>
  if (ret != ISP_OK)
34010e84:	b950      	cbnz	r0, 34010e9c <CMW_IMX335_Start+0x34>
  ret = ISP_Start(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010e86:	4628      	mov	r0, r5
34010e88:	f003 fb0a 	bl	340144a0 <ISP_Start>
  if (ret != ISP_OK)
34010e8c:	b950      	cbnz	r0, 34010ea4 <CMW_IMX335_Start+0x3c>
  return IMX335_Start(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
34010e8e:	f104 0008 	add.w	r0, r4, #8
}
34010e92:	b003      	add	sp, #12
34010e94:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  return IMX335_Start(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
34010e98:	f000 bec8 	b.w	34011c2c <IMX335_Start>
    return CMW_ERROR_COMPONENT_FAILURE;
34010e9c:	f06f 0004 	mvn.w	r0, #4
}
34010ea0:	b003      	add	sp, #12
34010ea2:	bd30      	pop	{r4, r5, pc}
      return CMW_ERROR_PERIPH_FAILURE;
34010ea4:	f06f 0003 	mvn.w	r0, #3
34010ea8:	e7fa      	b.n	34010ea0 <CMW_IMX335_Start+0x38>
34010eaa:	bf00      	nop
34010eac:	340a6e14 	.word	0x340a6e14

34010eb0 <CMW_IMX335_Init>:
{
34010eb0:	b538      	push	{r3, r4, r5, lr}
  if (width == 2592 && height == 1944)
34010eb2:	e9d1 2300 	ldrd	r2, r3, [r1]
34010eb6:	f5b2 6f22 	cmp.w	r2, #2592	@ 0xa20
{
34010eba:	4605      	mov	r5, r0
34010ebc:	460c      	mov	r4, r1
  if (width == 2592 && height == 1944)
34010ebe:	d002      	beq.n	34010ec6 <CMW_IMX335_Init+0x16>
    return CMW_ERROR_WRONG_PARAM;
34010ec0:	f06f 0001 	mvn.w	r0, #1
}
34010ec4:	bd38      	pop	{r3, r4, r5, pc}
  if (width == 2592 && height == 1944)
34010ec6:	f5b3 6ff3 	cmp.w	r3, #1944	@ 0x798
34010eca:	d1f9      	bne.n	34010ec0 <CMW_IMX335_Init+0x10>
  ret = CMW_IMX335_SetMirrorFlip(io_ctx, initSensor->mirrorFlip);
34010ecc:	6909      	ldr	r1, [r1, #16]
34010ece:	f7ff ff81 	bl	34010dd4 <CMW_IMX335_SetMirrorFlip>
  if (ret)
34010ed2:	2800      	cmp	r0, #0
34010ed4:	d1f4      	bne.n	34010ec0 <CMW_IMX335_Init+0x10>
  ret = IMX335_Init(&((CMW_IMX335_t *)io_ctx)->ctx_driver, resolution, initSensor->pixel_format);
34010ed6:	2106      	movs	r1, #6
34010ed8:	68e2      	ldr	r2, [r4, #12]
34010eda:	f105 0008 	add.w	r0, r5, #8
34010ede:	f000 fe85 	bl	34011bec <IMX335_Init>
    return CMW_ERROR_COMPONENT_FAILURE;
34010ee2:	2800      	cmp	r0, #0
34010ee4:	bf18      	it	ne
34010ee6:	f06f 0004 	mvnne.w	r0, #4
34010eea:	e7eb      	b.n	34010ec4 <CMW_IMX335_Init+0x14>

34010eec <CMW_IMX335_VsyncEventCallback>:
  switch (pipe)
34010eec:	2901      	cmp	r1, #1
{
34010eee:	b510      	push	{r4, lr}
  switch (pipe)
34010ef0:	d007      	beq.n	34010f02 <CMW_IMX335_VsyncEventCallback+0x16>
34010ef2:	2902      	cmp	r1, #2
34010ef4:	d00f      	beq.n	34010f16 <CMW_IMX335_VsyncEventCallback+0x2a>
34010ef6:	b999      	cbnz	r1, 34010f20 <CMW_IMX335_VsyncEventCallback+0x34>
}
34010ef8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncDumpFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010efc:	3030      	adds	r0, #48	@ 0x30
34010efe:	f003 bbec 	b.w	340146da <ISP_IncDumpFrameId>
      ISP_IncMainFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010f02:	f100 0430 	add.w	r4, r0, #48	@ 0x30
34010f06:	4620      	mov	r0, r4
34010f08:	f003 fbe3 	bl	340146d2 <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010f0c:	4620      	mov	r0, r4
}
34010f0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_GatherStatistics(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010f12:	f003 bbdc 	b.w	340146ce <ISP_GatherStatistics>
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010f16:	3030      	adds	r0, #48	@ 0x30
}
34010f18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010f1c:	f003 bbdb 	b.w	340146d6 <ISP_IncAncillaryFrameId>
}
34010f20:	bd10      	pop	{r4, pc}
	...

34010f24 <CMW_IMX335_Probe>:

int CMW_IMX335_Probe(CMW_IMX335_t *io_ctx, CMW_Sensor_if_t *imx335_if)
{
34010f24:	b573      	push	{r0, r1, r4, r5, r6, lr}
34010f26:	4604      	mov	r4, r0
  int ret = CMW_ERROR_NONE;
  uint32_t id;
  io_ctx->ctx_driver.IO.Address = io_ctx->Address;
34010f28:	8803      	ldrh	r3, [r0, #0]
{
34010f2a:	460d      	mov	r5, r1
  io_ctx->ctx_driver.IO.Address = io_ctx->Address;
34010f2c:	8203      	strh	r3, [r0, #16]
  io_ctx->ctx_driver.IO.Init = io_ctx->Init;
34010f2e:	f8d0 30e4 	ldr.w	r3, [r0, #228]	@ 0xe4
  io_ctx->ctx_driver.IO.ReadReg = io_ctx->ReadReg;
  io_ctx->ctx_driver.IO.WriteReg = io_ctx->WriteReg;

  CMW_IMX335_PowerOn(io_ctx);

  ret = IMX335_RegisterBusIO(&io_ctx->ctx_driver, &io_ctx->ctx_driver.IO);
34010f32:	3408      	adds	r4, #8
  io_ctx->ctx_driver.IO.Init = io_ctx->Init;
34010f34:	6083      	str	r3, [r0, #8]
  io_ctx->ctx_driver.IO.DeInit = io_ctx->DeInit;
34010f36:	f8d0 30e8 	ldr.w	r3, [r0, #232]	@ 0xe8
34010f3a:	60c3      	str	r3, [r0, #12]
  io_ctx->ctx_driver.IO.GetTick = io_ctx->GetTick;
34010f3c:	f8d0 30f4 	ldr.w	r3, [r0, #244]	@ 0xf4
34010f40:	61c3      	str	r3, [r0, #28]
  io_ctx->ctx_driver.IO.ReadReg = io_ctx->ReadReg;
34010f42:	f8d0 30f0 	ldr.w	r3, [r0, #240]	@ 0xf0
34010f46:	6183      	str	r3, [r0, #24]
  io_ctx->ctx_driver.IO.WriteReg = io_ctx->WriteReg;
34010f48:	f8d0 30ec 	ldr.w	r3, [r0, #236]	@ 0xec
34010f4c:	6143      	str	r3, [r0, #20]
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
34010f4e:	f8d0 30fc 	ldr.w	r3, [r0, #252]	@ 0xfc
34010f52:	2000      	movs	r0, #0
34010f54:	4798      	blx	r3
  io_ctx->Delay(100);
34010f56:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
34010f5a:	2064      	movs	r0, #100	@ 0x64
34010f5c:	4798      	blx	r3
  io_ctx->EnablePin(0);  /* RESET low (reset active low) */
34010f5e:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
34010f62:	2000      	movs	r0, #0
34010f64:	4798      	blx	r3
  io_ctx->Delay(100);
34010f66:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
34010f6a:	2064      	movs	r0, #100	@ 0x64
34010f6c:	4798      	blx	r3
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
34010f6e:	f8d4 30f4 	ldr.w	r3, [r4, #244]	@ 0xf4
34010f72:	2001      	movs	r0, #1
34010f74:	4798      	blx	r3
  io_ctx->Delay(100);
34010f76:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
34010f7a:	2064      	movs	r0, #100	@ 0x64
34010f7c:	4798      	blx	r3
  io_ctx->EnablePin(1);  /* RESET low (reset active low) */
34010f7e:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
34010f82:	2001      	movs	r0, #1
34010f84:	4798      	blx	r3
  io_ctx->Delay(100);
34010f86:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
34010f8a:	2064      	movs	r0, #100	@ 0x64
34010f8c:	4798      	blx	r3
  ret = IMX335_RegisterBusIO(&io_ctx->ctx_driver, &io_ctx->ctx_driver.IO);
34010f8e:	4621      	mov	r1, r4
34010f90:	4620      	mov	r0, r4
34010f92:	f000 fe0f 	bl	34011bb4 <IMX335_RegisterBusIO>
  if (ret != IMX335_OK)
34010f96:	4606      	mov	r6, r0
34010f98:	b120      	cbz	r0, 34010fa4 <CMW_IMX335_Probe+0x80>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
34010f9a:	f06f 0404 	mvn.w	r4, #4
  imx335_if->SetFramerate = CMW_IMX335_SetFramerate;
  imx335_if->SetMirrorFlip = CMW_IMX335_SetMirrorFlip;
  imx335_if->GetSensorInfo = CMW_IMX335_GetSensorInfo;
  imx335_if->SetTestPattern = CMW_IMX335_SetTestPattern;
  return ret;
}
34010f9e:	4620      	mov	r0, r4
34010fa0:	b002      	add	sp, #8
34010fa2:	bd70      	pop	{r4, r5, r6, pc}
  ret = IMX335_ReadID(&io_ctx->ctx_driver, &id);
34010fa4:	4620      	mov	r0, r4
34010fa6:	a901      	add	r1, sp, #4
34010fa8:	f000 fe66 	bl	34011c78 <IMX335_ReadID>
  if (ret != IMX335_OK)
34010fac:	4604      	mov	r4, r0
34010fae:	2800      	cmp	r0, #0
34010fb0:	d1f3      	bne.n	34010f9a <CMW_IMX335_Probe+0x76>
  if (id != IMX335_CHIP_ID)
34010fb2:	9b01      	ldr	r3, [sp, #4]
  memset(imx335_if, 0, sizeof(*imx335_if));
34010fb4:	2250      	movs	r2, #80	@ 0x50
      ret = CMW_ERROR_UNKNOWN_COMPONENT;
34010fb6:	2b00      	cmp	r3, #0
34010fb8:	bf08      	it	eq
34010fba:	4604      	moveq	r4, r0
  memset(imx335_if, 0, sizeof(*imx335_if));
34010fbc:	4631      	mov	r1, r6
34010fbe:	f105 0018 	add.w	r0, r5, #24
      ret = CMW_ERROR_UNKNOWN_COMPONENT;
34010fc2:	bf18      	it	ne
34010fc4:	f06f 0406 	mvnne.w	r4, #6
  memset(imx335_if, 0, sizeof(*imx335_if));
34010fc8:	f009 f8ac 	bl	3401a124 <memset>
  imx335_if->Init = CMW_IMX335_Init;
34010fcc:	4b10      	ldr	r3, [pc, #64]	@ (34011010 <CMW_IMX335_Probe+0xec>)
34010fce:	602b      	str	r3, [r5, #0]
  imx335_if->Start = CMW_IMX335_Start;
34010fd0:	4b10      	ldr	r3, [pc, #64]	@ (34011014 <CMW_IMX335_Probe+0xf0>)
34010fd2:	60ab      	str	r3, [r5, #8]
  imx335_if->DeInit = CMW_IMX335_DeInit;
34010fd4:	4b10      	ldr	r3, [pc, #64]	@ (34011018 <CMW_IMX335_Probe+0xf4>)
34010fd6:	606b      	str	r3, [r5, #4]
  imx335_if->Run = CMW_IMX335_Run;
34010fd8:	4b10      	ldr	r3, [pc, #64]	@ (3401101c <CMW_IMX335_Probe+0xf8>)
34010fda:	60eb      	str	r3, [r5, #12]
  imx335_if->VsyncEventCallback = CMW_IMX335_VsyncEventCallback;
34010fdc:	4b10      	ldr	r3, [pc, #64]	@ (34011020 <CMW_IMX335_Probe+0xfc>)
34010fde:	612b      	str	r3, [r5, #16]
  imx335_if->FrameEventCallback = CMW_IMX335_FrameEventCallback;
34010fe0:	4b10      	ldr	r3, [pc, #64]	@ (34011024 <CMW_IMX335_Probe+0x100>)
34010fe2:	616b      	str	r3, [r5, #20]
  imx335_if->ReadID = CMW_IMX335_ReadID;
34010fe4:	4b10      	ldr	r3, [pc, #64]	@ (34011028 <CMW_IMX335_Probe+0x104>)
34010fe6:	61eb      	str	r3, [r5, #28]
  imx335_if->SetGain = CMW_IMX335_SetGain;
34010fe8:	4b10      	ldr	r3, [pc, #64]	@ (3401102c <CMW_IMX335_Probe+0x108>)
34010fea:	64ab      	str	r3, [r5, #72]	@ 0x48
  imx335_if->SetExposure = CMW_IMX335_SetExposure;
34010fec:	4b10      	ldr	r3, [pc, #64]	@ (34011030 <CMW_IMX335_Probe+0x10c>)
34010fee:	64eb      	str	r3, [r5, #76]	@ 0x4c
  imx335_if->SetWBRefMode = CMW_IMX335_SetWBRefMode;
34010ff0:	4b10      	ldr	r3, [pc, #64]	@ (34011034 <CMW_IMX335_Probe+0x110>)
34010ff2:	656b      	str	r3, [r5, #84]	@ 0x54
  imx335_if->ListWBRefModes = CMW_IMX335_ListWBRefModes;
34010ff4:	4b10      	ldr	r3, [pc, #64]	@ (34011038 <CMW_IMX335_Probe+0x114>)
34010ff6:	65ab      	str	r3, [r5, #88]	@ 0x58
  imx335_if->SetFrequency = CMW_IMX335_SetFrequency;
34010ff8:	4b10      	ldr	r3, [pc, #64]	@ (3401103c <CMW_IMX335_Probe+0x118>)
34010ffa:	642b      	str	r3, [r5, #64]	@ 0x40
  imx335_if->SetFramerate = CMW_IMX335_SetFramerate;
34010ffc:	4b10      	ldr	r3, [pc, #64]	@ (34011040 <CMW_IMX335_Probe+0x11c>)
34010ffe:	646b      	str	r3, [r5, #68]	@ 0x44
  imx335_if->SetMirrorFlip = CMW_IMX335_SetMirrorFlip;
34011000:	4b10      	ldr	r3, [pc, #64]	@ (34011044 <CMW_IMX335_Probe+0x120>)
34011002:	62eb      	str	r3, [r5, #44]	@ 0x2c
  imx335_if->GetSensorInfo = CMW_IMX335_GetSensorInfo;
34011004:	4b10      	ldr	r3, [pc, #64]	@ (34011048 <CMW_IMX335_Probe+0x124>)
34011006:	662b      	str	r3, [r5, #96]	@ 0x60
  imx335_if->SetTestPattern = CMW_IMX335_SetTestPattern;
34011008:	4b10      	ldr	r3, [pc, #64]	@ (3401104c <CMW_IMX335_Probe+0x128>)
3401100a:	666b      	str	r3, [r5, #100]	@ 0x64
  return ret;
3401100c:	e7c7      	b.n	34010f9e <CMW_IMX335_Probe+0x7a>
3401100e:	bf00      	nop
34011010:	34010eb1 	.word	0x34010eb1
34011014:	34010e69 	.word	0x34010e69
34011018:	34010e47 	.word	0x34010e47
3401101c:	34010e33 	.word	0x34010e33
34011020:	34010eed 	.word	0x34010eed
34011024:	34010d55 	.word	0x34010d55
34011028:	34010d7f 	.word	0x34010d7f
3401102c:	34010e2d 	.word	0x34010e2d
34011030:	34010e27 	.word	0x34010e27
34011034:	34010d57 	.word	0x34010d57
34011038:	34010d6b 	.word	0x34010d6b
3401103c:	34010e21 	.word	0x34010e21
34011040:	34010de1 	.word	0x34010de1
34011044:	34010dd5 	.word	0x34010dd5
34011048:	34010d8d 	.word	0x34010d8d
3401104c:	34010d85 	.word	0x34010d85

34011050 <CMW_VD55G1_Read32>:
static int CMW_VD55G1_Read32(CMW_VD55G1_t *pObj, uint16_t addr, uint32_t *value)
{
  uint8_t data[4];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
34011050:	2304      	movs	r3, #4
{
34011052:	b537      	push	{r0, r1, r2, r4, r5, lr}
34011054:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
34011056:	6fc5      	ldr	r5, [r0, #124]	@ 0x7c
34011058:	eb0d 0203 	add.w	r2, sp, r3
3401105c:	8800      	ldrh	r0, [r0, #0]
3401105e:	47a8      	blx	r5
  if (ret)
34011060:	b908      	cbnz	r0, 34011066 <CMW_VD55G1_Read32+0x16>
    return ret;

  *value = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0];
34011062:	9b01      	ldr	r3, [sp, #4]
34011064:	6023      	str	r3, [r4, #0]

  return 0;
}
34011066:	b003      	add	sp, #12
34011068:	bd30      	pop	{r4, r5, pc}

3401106a <VD55G1_ShutdownPin>:

static void VD55G1_ShutdownPin(struct VD55G1_Ctx *ctx, int value)
{
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  p_ctx->ShutdownPin(value);
3401106a:	f8d0 3084 	ldr.w	r3, [r0, #132]	@ 0x84
3401106e:	4608      	mov	r0, r1
34011070:	4718      	bx	r3

34011072 <VD55G1_Read8>:
}

static int VD55G1_Read8(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t *value)
{
34011072:	b410      	push	{r4}
  return pObj->ReadReg(pObj->Address, addr, value, 1);
34011074:	6f84      	ldr	r4, [r0, #120]	@ 0x78
34011076:	2301      	movs	r3, #1
34011078:	46a4      	mov	ip, r4
3401107a:	f830 0c04 	ldrh.w	r0, [r0, #-4]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Read8(p_ctx, addr, value);
}
3401107e:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->ReadReg(pObj->Address, addr, value, 1);
34011082:	4760      	bx	ip

34011084 <VD55G1_Read16>:

static int VD55G1_Read16(struct VD55G1_Ctx *ctx, uint16_t addr, uint16_t *value)
{
34011084:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
34011086:	2302      	movs	r3, #2
{
34011088:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3401108a:	6f85      	ldr	r5, [r0, #120]	@ 0x78
3401108c:	aa01      	add	r2, sp, #4
3401108e:	f830 0c04 	ldrh.w	r0, [r0, #-4]
34011092:	47a8      	blx	r5
  if (ret)
34011094:	b910      	cbnz	r0, 3401109c <VD55G1_Read16+0x18>
  *value = (data[1] << 8) | data[0];
34011096:	f8bd 3004 	ldrh.w	r3, [sp, #4]
3401109a:	8023      	strh	r3, [r4, #0]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Read16(p_ctx, addr, value);
}
3401109c:	b003      	add	sp, #12
3401109e:	bd30      	pop	{r4, r5, pc}

340110a0 <VD55G1_Read32>:

static int VD55G1_Read32(struct VD55G1_Ctx *ctx, uint16_t addr, uint32_t *value)
{
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Read32(p_ctx, addr, value);
340110a0:	3804      	subs	r0, #4
340110a2:	f7ff bfd5 	b.w	34011050 <CMW_VD55G1_Read32>

340110a6 <VD55G1_Write8>:
}

static int VD55G1_Write8(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t value)
{
340110a6:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, &value, 1);
340110a8:	2301      	movs	r3, #1
340110aa:	6f44      	ldr	r4, [r0, #116]	@ 0x74
340110ac:	f88d 2007 	strb.w	r2, [sp, #7]
340110b0:	f830 0c04 	ldrh.w	r0, [r0, #-4]
340110b4:	f10d 0207 	add.w	r2, sp, #7
340110b8:	47a0      	blx	r4
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Write8(p_ctx, addr, value);
}
340110ba:	b002      	add	sp, #8
340110bc:	bd10      	pop	{r4, pc}

340110be <VD55G1_Write16>:

static int VD55G1_Write16(struct VD55G1_Ctx *ctx, uint16_t addr, uint16_t value)
{
340110be:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 2);
340110c0:	2302      	movs	r3, #2
340110c2:	6f44      	ldr	r4, [r0, #116]	@ 0x74
340110c4:	f8ad 2006 	strh.w	r2, [sp, #6]
340110c8:	f830 0c04 	ldrh.w	r0, [r0, #-4]
340110cc:	f10d 0206 	add.w	r2, sp, #6
340110d0:	47a0      	blx	r4
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Write16(p_ctx, addr, value);
}
340110d2:	b002      	add	sp, #8
340110d4:	bd10      	pop	{r4, pc}

340110d6 <VD55G1_Write32>:
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
340110d6:	2304      	movs	r3, #4

static int VD55G1_Write32(struct VD55G1_Ctx *ctx, uint16_t addr, uint32_t value)
{
340110d8:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
340110da:	6f44      	ldr	r4, [r0, #116]	@ 0x74
340110dc:	9201      	str	r2, [sp, #4]
340110de:	f830 0c04 	ldrh.w	r0, [r0, #-4]
340110e2:	eb0d 0203 	add.w	r2, sp, r3
340110e6:	47a0      	blx	r4
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Write32(p_ctx, addr, value);
}
340110e8:	b002      	add	sp, #8
340110ea:	bd10      	pop	{r4, pc}

340110ec <VD55G1_WriteArray>:

static int VD55G1_WriteArray(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t *data, int data_len)
{
340110ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
340110f0:	4680      	mov	r8, r0
340110f2:	460d      	mov	r5, r1
340110f4:	4616      	mov	r6, r2
340110f6:	461c      	mov	r4, r3
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
  const unsigned int chunk_size = 128;
  uint16_t sz;
  int ret;

  while (data_len) {
340110f8:	b914      	cbnz	r4, 34011100 <VD55G1_WriteArray+0x14>
    data_len -= sz;
    addr += sz;
    data += sz;
  }

  return 0;
340110fa:	4620      	mov	r0, r4
}
340110fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    sz = MIN(data_len, chunk_size);
34011100:	2c80      	cmp	r4, #128	@ 0x80
34011102:	46a1      	mov	r9, r4
34011104:	bf28      	it	cs
34011106:	f04f 0980 	movcs.w	r9, #128	@ 0x80
3401110a:	fa1f fa89 	uxth.w	sl, r9
    ret = p_ctx->WriteReg(p_ctx->Address, addr, data, sz);
3401110e:	4653      	mov	r3, sl
34011110:	4632      	mov	r2, r6
34011112:	4629      	mov	r1, r5
34011114:	f8d8 7074 	ldr.w	r7, [r8, #116]	@ 0x74
34011118:	f838 0c04 	ldrh.w	r0, [r8, #-4]
3401111c:	47b8      	blx	r7
    if (ret)
3401111e:	2800      	cmp	r0, #0
34011120:	d1ec      	bne.n	340110fc <VD55G1_WriteArray+0x10>
    addr += sz;
34011122:	44aa      	add	sl, r5
    data_len -= sz;
34011124:	eba4 0409 	sub.w	r4, r4, r9
    addr += sz;
34011128:	fa1f f58a 	uxth.w	r5, sl
    data += sz;
3401112c:	444e      	add	r6, r9
3401112e:	e7e3      	b.n	340110f8 <VD55G1_WriteArray+0xc>

34011130 <VD55G1_Delay>:

static void VD55G1_Delay(struct VD55G1_Ctx *ctx, uint32_t delay_in_ms)
{
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  p_ctx->Delay(delay_in_ms);
34011130:	f8d0 3080 	ldr.w	r3, [r0, #128]	@ 0x80
34011134:	4608      	mov	r0, r1
34011136:	4718      	bx	r3

34011138 <VD55G1_Log>:
  if (lvl > current_lvl)
    return ;

  vprintf(format, ap);
#endif
}
34011138:	4770      	bx	lr

3401113a <CMW_VD55G1_GetSensorInfo>:
  * @param  pInfo pointer to sensor info structure
  * @retval Component status
  */
static int32_t CMW_VD55G1_GetSensorInfo(void *io_ctx, ISP_SensorInfoTypeDef *info)
{
  if ((io_ctx ==  NULL) || (info == NULL))
3401113a:	b140      	cbz	r0, 3401114e <CMW_VD55G1_GetSensorInfo+0x14>
3401113c:	b139      	cbz	r1, 3401114e <CMW_VD55G1_GetSensorInfo+0x14>
    return CMW_ERROR_WRONG_PARAM;
  }

  /* Return the default full resolution */
  info->width = VD55G1_MAX_WIDTH;
  info->height = VD55G1_MAX_HEIGHT;
3401113e:	f44f 7249 	mov.w	r2, #804	@ 0x324
34011142:	f44f 7330 	mov.w	r3, #704	@ 0x2c0

  return CMW_ERROR_NONE;
34011146:	2000      	movs	r0, #0
  info->height = VD55G1_MAX_HEIGHT;
34011148:	e9c1 2309 	strd	r2, r3, [r1, #36]	@ 0x24
  return CMW_ERROR_NONE;
3401114c:	4770      	bx	lr
    return CMW_ERROR_WRONG_PARAM;
3401114e:	f06f 0001 	mvn.w	r0, #1
}
34011152:	4770      	bx	lr

34011154 <CMW_VD55G1_MirrorFlipConfig>:

static int32_t CMW_VD55G1_MirrorFlipConfig(void *io_ctx, uint32_t Config)
{
  int32_t ret = CMW_ERROR_NONE;

  switch (Config) {
34011154:	2903      	cmp	r1, #3
34011156:	d80d      	bhi.n	34011174 <CMW_VD55G1_MirrorFlipConfig+0x20>
34011158:	e8df f001 	tbb	[pc, r1]
3401115c:	0a080602 	.word	0x0a080602
    case CMW_MIRRORFLIP_NONE:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP_NONE);
34011160:	2100      	movs	r1, #0
      break;
    case CMW_MIRRORFLIP_MIRROR:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR);
      break;
    case CMW_MIRRORFLIP_FLIP_MIRROR:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP);
34011162:	3004      	adds	r0, #4
34011164:	f001 bc37 	b.w	340129d6 <VD55G1_SetFlipMirrorMode>
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_FLIP);
34011168:	2101      	movs	r1, #1
3401116a:	e7fa      	b.n	34011162 <CMW_VD55G1_MirrorFlipConfig+0xe>
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR);
3401116c:	2102      	movs	r1, #2
3401116e:	e7f8      	b.n	34011162 <CMW_VD55G1_MirrorFlipConfig+0xe>
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP);
34011170:	2103      	movs	r1, #3
34011172:	e7f6      	b.n	34011162 <CMW_VD55G1_MirrorFlipConfig+0xe>
    default:
      ret = CMW_ERROR_PERIPH_FAILURE;
  }

  return ret;
}
34011174:	f06f 0003 	mvn.w	r0, #3
34011178:	4770      	bx	lr

3401117a <CMW_VD55G1_Stop>:
{
3401117a:	b508      	push	{r3, lr}
  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3401117c:	3004      	adds	r0, #4
3401117e:	f001 fc23 	bl	340129c8 <VD55G1_Stop>
    return CMW_ERROR_PERIPH_FAILURE;
34011182:	2800      	cmp	r0, #0
}
34011184:	bf18      	it	ne
34011186:	f06f 0003 	mvnne.w	r0, #3
3401118a:	bd08      	pop	{r3, pc}

3401118c <CMW_VD55G1_Start>:
{
3401118c:	b510      	push	{r4, lr}
  ret = VD55G1_Start(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3401118e:	1d04      	adds	r4, r0, #4
34011190:	4620      	mov	r0, r4
34011192:	f001 f98d 	bl	340124b0 <VD55G1_Start>
  if (ret) {
34011196:	b120      	cbz	r0, 340111a2 <CMW_VD55G1_Start+0x16>
    VD55G1_DeInit(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
34011198:	4620      	mov	r0, r4
3401119a:	f001 f977 	bl	3401248c <VD55G1_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
3401119e:	f06f 0003 	mvn.w	r0, #3
}
340111a2:	bd10      	pop	{r4, pc}

340111a4 <CMW_VD55G1_DeInit>:
{
340111a4:	b538      	push	{r3, r4, r5, lr}
  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
340111a6:	1d05      	adds	r5, r0, #4
{
340111a8:	4604      	mov	r4, r0
  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
340111aa:	4628      	mov	r0, r5
340111ac:	f001 fc0c 	bl	340129c8 <VD55G1_Stop>
  if (ret)
340111b0:	b110      	cbz	r0, 340111b8 <CMW_VD55G1_DeInit+0x14>
    return CMW_ERROR_PERIPH_FAILURE;
340111b2:	f06f 0003 	mvn.w	r0, #3
}
340111b6:	bd38      	pop	{r3, r4, r5, pc}
  ret = VD55G1_DeInit(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
340111b8:	4628      	mov	r0, r5
340111ba:	f001 f967 	bl	3401248c <VD55G1_DeInit>
  if (ret)
340111be:	2800      	cmp	r0, #0
340111c0:	d1f7      	bne.n	340111b2 <CMW_VD55G1_DeInit+0xe>
  ((CMW_VD55G1_t *)io_ctx)->IsInitialized = 0;
340111c2:	f884 006c 	strb.w	r0, [r4, #108]	@ 0x6c
  return CMW_ERROR_NONE;
340111c6:	e7f6      	b.n	340111b6 <CMW_VD55G1_DeInit+0x12>

340111c8 <CMW_VD55G1_Init>:
{
340111c8:	b570      	push	{r4, r5, r6, lr}
340111ca:	460c      	mov	r4, r1
340111cc:	b092      	sub	sp, #72	@ 0x48
340111ce:	4605      	mov	r5, r0
  VD55G1_Config_t config = { 0 };
340111d0:	2234      	movs	r2, #52	@ 0x34
340111d2:	2100      	movs	r1, #0
340111d4:	a805      	add	r0, sp, #20
340111d6:	f008 ffa5 	bl	3401a124 <memset>
  assert(initSensor != NULL);
340111da:	b92c      	cbnz	r4, 340111e8 <CMW_VD55G1_Init+0x20>
340111dc:	21f8      	movs	r1, #248	@ 0xf8
340111de:	4b2c      	ldr	r3, [pc, #176]	@ (34011290 <CMW_VD55G1_Init+0xc8>)
340111e0:	4a2c      	ldr	r2, [pc, #176]	@ (34011294 <CMW_VD55G1_Init+0xcc>)
340111e2:	482d      	ldr	r0, [pc, #180]	@ (34011298 <CMW_VD55G1_Init+0xd0>)
340111e4:	f007 fe3a 	bl	34018e5c <__assert_func>
  if (((CMW_VD55G1_t *)io_ctx)->IsInitialized)
340111e8:	f895 306c 	ldrb.w	r3, [r5, #108]	@ 0x6c
340111ec:	2b00      	cmp	r3, #0
340111ee:	d138      	bne.n	34011262 <CMW_VD55G1_Init+0x9a>
  config.frame_rate = initSensor->fps;
340111f0:	68a3      	ldr	r3, [r4, #8]
340111f2:	9307      	str	r3, [sp, #28]
  ret = CMW_VD55G1_GetResType(initSensor->width, initSensor->height, &config.resolution);
340111f4:	e9d4 2300 	ldrd	r2, r3, [r4]
  if (width == 320 && height == 240)
340111f8:	f5b2 7fa0 	cmp.w	r2, #320	@ 0x140
340111fc:	d104      	bne.n	34011208 <CMW_VD55G1_Init+0x40>
340111fe:	2bf0      	cmp	r3, #240	@ 0xf0
34011200:	d00b      	beq.n	3401121a <CMW_VD55G1_Init+0x52>
    return CMW_ERROR_WRONG_PARAM;
34011202:	f06f 0001 	mvn.w	r0, #1
34011206:	e02d      	b.n	34011264 <CMW_VD55G1_Init+0x9c>
  else if (width == 640 && height == 480)
34011208:	f5b2 7f20 	cmp.w	r2, #640	@ 0x280
3401120c:	d12c      	bne.n	34011268 <CMW_VD55G1_Init+0xa0>
3401120e:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
34011212:	d1f6      	bne.n	34011202 <CMW_VD55G1_Init+0x3a>
    *res = VD55G1_RES_VGA_640_480;
34011214:	2301      	movs	r3, #1
      *res = VD55G1_RES_FULL_804_704;
34011216:	f88d 3018 	strb.w	r3, [sp, #24]
  vd55g1_config->csiconfig.data_rate_in_mps = VD55G1_DEFAULT_DATARATE;
3401121a:	4a20      	ldr	r2, [pc, #128]	@ (3401129c <CMW_VD55G1_Init+0xd4>)
3401121c:	4b20      	ldr	r3, [pc, #128]	@ (340112a0 <CMW_VD55G1_Init+0xd8>)
  vd55g1_config->csiconfig.clock_lane_swap_enable = 1;
3401121e:	2601      	movs	r6, #1
  vd55g1_config->csiconfig.data_rate_in_mps = VD55G1_DEFAULT_DATARATE;
34011220:	e9cd 2301 	strd	r2, r3, [sp, #4]
  sensor_config = initSensor->sensor_config ? (CMW_VD55G1_config_t*)(initSensor->sensor_config) : &default_sensor_config;
34011224:	6963      	ldr	r3, [r4, #20]
34011226:	aa01      	add	r2, sp, #4
34011228:	2b00      	cmp	r3, #0
3401122a:	bf08      	it	eq
3401122c:	4613      	moveq	r3, r2
  config.ext_clock_freq_in_hz = sensor_config->ext_clock_freq_in_hz;
3401122e:	681a      	ldr	r2, [r3, #0]
  vd55g1_config->csiconfig.data_lane_swap_enable = 1;
34011230:	e9cd 6603 	strd	r6, r6, [sp, #12]
  config.ext_clock_freq_in_hz = sensor_config->ext_clock_freq_in_hz;
34011234:	9205      	str	r2, [sp, #20]
  config.out_itf.data_rate_in_mps = sensor_config->csiconfig.data_rate_in_mps;
34011236:	685a      	ldr	r2, [r3, #4]
  ret = VD55G1_Init(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, &config);
34011238:	a905      	add	r1, sp, #20
  config.out_itf.data_rate_in_mps = sensor_config->csiconfig.data_rate_in_mps;
3401123a:	9209      	str	r2, [sp, #36]	@ 0x24
  config.out_itf.clock_lane_swap_enable =sensor_config->csiconfig.clock_lane_swap_enable;
3401123c:	689a      	ldr	r2, [r3, #8]
  config.out_itf.data_lane_swap_enable = sensor_config->csiconfig.data_lane_swap_enable;
3401123e:	68db      	ldr	r3, [r3, #12]
  ret = VD55G1_Init(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, &config);
34011240:	1d28      	adds	r0, r5, #4
  config.out_itf.data_lane_swap_enable = sensor_config->csiconfig.data_lane_swap_enable;
34011242:	930b      	str	r3, [sp, #44]	@ 0x2c
  config.flip_mirror_mode = CMW_VD55G1_getMirrorFlipConfig(initSensor->mirrorFlip);
34011244:	6923      	ldr	r3, [r4, #16]
  config.out_itf.clock_lane_swap_enable =sensor_config->csiconfig.clock_lane_swap_enable;
34011246:	920a      	str	r2, [sp, #40]	@ 0x28
  config.flip_mirror_mode = CMW_VD55G1_getMirrorFlipConfig(initSensor->mirrorFlip);
34011248:	2b03      	cmp	r3, #3
3401124a:	bf28      	it	cs
3401124c:	2303      	movcs	r3, #3
3401124e:	f88d 3020 	strb.w	r3, [sp, #32]
    config.gpio_ctrl[i] = VD55G1_GPIO_GPIO_IN;
34011252:	f04f 3301 	mov.w	r3, #16843009	@ 0x1010101
34011256:	9311      	str	r3, [sp, #68]	@ 0x44
  ret = VD55G1_Init(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, &config);
34011258:	f001 f814 	bl	34012284 <VD55G1_Init>
  if (ret)
3401125c:	b9a0      	cbnz	r0, 34011288 <CMW_VD55G1_Init+0xc0>
  ((CMW_VD55G1_t *)io_ctx)->IsInitialized = 1;
3401125e:	f885 606c 	strb.w	r6, [r5, #108]	@ 0x6c
    return CMW_ERROR_NONE;
34011262:	2000      	movs	r0, #0
}
34011264:	b012      	add	sp, #72	@ 0x48
34011266:	bd70      	pop	{r4, r5, r6, pc}
  else if (width == 800 && height == 600)
34011268:	f5b2 7f48 	cmp.w	r2, #800	@ 0x320
3401126c:	d104      	bne.n	34011278 <CMW_VD55G1_Init+0xb0>
3401126e:	f5b3 7f16 	cmp.w	r3, #600	@ 0x258
34011272:	d1c6      	bne.n	34011202 <CMW_VD55G1_Init+0x3a>
    *res = VD55G1_RES_SXGA_800_600;
34011274:	2302      	movs	r3, #2
34011276:	e7ce      	b.n	34011216 <CMW_VD55G1_Init+0x4e>
  else if (width == 804 && height == 704)
34011278:	f5b2 7f49 	cmp.w	r2, #804	@ 0x324
3401127c:	d1c1      	bne.n	34011202 <CMW_VD55G1_Init+0x3a>
3401127e:	f5b3 7f30 	cmp.w	r3, #704	@ 0x2c0
34011282:	d1be      	bne.n	34011202 <CMW_VD55G1_Init+0x3a>
      *res = VD55G1_RES_FULL_804_704;
34011284:	2303      	movs	r3, #3
34011286:	e7c6      	b.n	34011216 <CMW_VD55G1_Init+0x4e>
    return CMW_ERROR_PERIPH_FAILURE;
34011288:	f06f 0003 	mvn.w	r0, #3
3401128c:	e7ea      	b.n	34011264 <CMW_VD55G1_Init+0x9c>
3401128e:	bf00      	nop
34011290:	34020761 	.word	0x34020761
34011294:	340a706c 	.word	0x340a706c
34011298:	34020774 	.word	0x34020774
3401129c:	00b71b00 	.word	0x00b71b00
340112a0:	2fec1100 	.word	0x2fec1100

340112a4 <CMW_VD55G1_Probe>:
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
  io_ctx->Delay(20); /* NRST de-asserted during 20ms */
}

int CMW_VD55G1_Probe(CMW_VD55G1_t *io_ctx, CMW_Sensor_if_t *vd55g1_if)
{
340112a4:	b537      	push	{r0, r1, r2, r4, r5, lr}
340112a6:	4604      	mov	r4, r0
  int ret = CMW_ERROR_NONE;
  uint32_t id;

  io_ctx->ctx_driver.shutdown_pin = VD55G1_ShutdownPin;
340112a8:	4b26      	ldr	r3, [pc, #152]	@ (34011344 <CMW_VD55G1_Probe+0xa0>)
{
340112aa:	460d      	mov	r5, r1
  io_ctx->ctx_driver.shutdown_pin = VD55G1_ShutdownPin;
340112ac:	6043      	str	r3, [r0, #4]
  io_ctx->ctx_driver.read8 = VD55G1_Read8;
340112ae:	4b26      	ldr	r3, [pc, #152]	@ (34011348 <CMW_VD55G1_Probe+0xa4>)
340112b0:	6083      	str	r3, [r0, #8]
  io_ctx->ctx_driver.read16 = VD55G1_Read16;
340112b2:	4b26      	ldr	r3, [pc, #152]	@ (3401134c <CMW_VD55G1_Probe+0xa8>)
340112b4:	60c3      	str	r3, [r0, #12]
  io_ctx->ctx_driver.read32 = VD55G1_Read32;
340112b6:	4b26      	ldr	r3, [pc, #152]	@ (34011350 <CMW_VD55G1_Probe+0xac>)
340112b8:	6103      	str	r3, [r0, #16]
  io_ctx->ctx_driver.write8 = VD55G1_Write8;
340112ba:	4b26      	ldr	r3, [pc, #152]	@ (34011354 <CMW_VD55G1_Probe+0xb0>)
340112bc:	6143      	str	r3, [r0, #20]
  io_ctx->ctx_driver.write16 = VD55G1_Write16;
340112be:	4b26      	ldr	r3, [pc, #152]	@ (34011358 <CMW_VD55G1_Probe+0xb4>)
340112c0:	6183      	str	r3, [r0, #24]
  io_ctx->ctx_driver.write32 = VD55G1_Write32;
340112c2:	4b26      	ldr	r3, [pc, #152]	@ (3401135c <CMW_VD55G1_Probe+0xb8>)
340112c4:	61c3      	str	r3, [r0, #28]
  io_ctx->ctx_driver.write_array = VD55G1_WriteArray;
340112c6:	4b26      	ldr	r3, [pc, #152]	@ (34011360 <CMW_VD55G1_Probe+0xbc>)
340112c8:	6203      	str	r3, [r0, #32]
  io_ctx->ctx_driver.delay = VD55G1_Delay;
340112ca:	4b26      	ldr	r3, [pc, #152]	@ (34011364 <CMW_VD55G1_Probe+0xc0>)
340112cc:	6243      	str	r3, [r0, #36]	@ 0x24
  io_ctx->ctx_driver.log = VD55G1_Log;
340112ce:	4b26      	ldr	r3, [pc, #152]	@ (34011368 <CMW_VD55G1_Probe+0xc4>)
340112d0:	6283      	str	r3, [r0, #40]	@ 0x28
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
340112d2:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
340112d6:	2000      	movs	r0, #0
340112d8:	4798      	blx	r3
  io_ctx->Delay(200); /* NRST signals asserted during 200ms */
340112da:	20c8      	movs	r0, #200	@ 0xc8
340112dc:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
340112e0:	4798      	blx	r3
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
340112e2:	2001      	movs	r0, #1
340112e4:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
340112e8:	4798      	blx	r3
  io_ctx->Delay(20); /* NRST de-asserted during 20ms */
340112ea:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
340112ee:	2014      	movs	r0, #20
340112f0:	4798      	blx	r3
  if (!io_ctx->Init)
340112f2:	6f23      	ldr	r3, [r4, #112]	@ 0x70
340112f4:	b923      	cbnz	r3, 34011300 <CMW_VD55G1_Probe+0x5c>
  CMW_VD55G1_PowerOn(io_ctx);

  ret = VD55G1_RegisterBusIO(io_ctx);
  if (ret != CMW_ERROR_NONE)
  {
    return CMW_ERROR_COMPONENT_FAILURE;
340112f6:	f06f 0404 	mvn.w	r4, #4
  vd55g1_if->Start = CMW_VD55G1_Start;
  vd55g1_if->Stop = CMW_VD55G1_Stop;
  vd55g1_if->SetMirrorFlip = CMW_VD55G1_MirrorFlipConfig;
  vd55g1_if->GetSensorInfo = CMW_VD55G1_GetSensorInfo;
  return ret;
}
340112fa:	4620      	mov	r0, r4
340112fc:	b003      	add	sp, #12
340112fe:	bd30      	pop	{r4, r5, pc}
  ret = io_ctx->Init();
34011300:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34011302:	4601      	mov	r1, r0
34011304:	2800      	cmp	r0, #0
34011306:	d1f6      	bne.n	340112f6 <CMW_VD55G1_Probe+0x52>
  ret = CMW_VD55G1_Read32(io_ctx, VD55G1_REG_MODEL_ID, &reg32);
34011308:	4620      	mov	r0, r4
3401130a:	aa01      	add	r2, sp, #4
3401130c:	f7ff fea0 	bl	34011050 <CMW_VD55G1_Read32>
  if (ret)
34011310:	4604      	mov	r4, r0
34011312:	2800      	cmp	r0, #0
34011314:	d1ef      	bne.n	340112f6 <CMW_VD55G1_Probe+0x52>
  if (id != VD55G1_CHIP_ID)
34011316:	9a01      	ldr	r2, [sp, #4]
34011318:	4b14      	ldr	r3, [pc, #80]	@ (3401136c <CMW_VD55G1_Probe+0xc8>)
3401131a:	429a      	cmp	r2, r3
3401131c:	d1eb      	bne.n	340112f6 <CMW_VD55G1_Probe+0x52>
  memset(vd55g1_if, 0, sizeof(*vd55g1_if));
3401131e:	4601      	mov	r1, r0
34011320:	225c      	movs	r2, #92	@ 0x5c
34011322:	f105 000c 	add.w	r0, r5, #12
34011326:	f008 fefd 	bl	3401a124 <memset>
  vd55g1_if->Init = CMW_VD55G1_Init;
3401132a:	4b11      	ldr	r3, [pc, #68]	@ (34011370 <CMW_VD55G1_Probe+0xcc>)
3401132c:	602b      	str	r3, [r5, #0]
  vd55g1_if->DeInit = CMW_VD55G1_DeInit;
3401132e:	4b11      	ldr	r3, [pc, #68]	@ (34011374 <CMW_VD55G1_Probe+0xd0>)
34011330:	606b      	str	r3, [r5, #4]
  vd55g1_if->Start = CMW_VD55G1_Start;
34011332:	4b11      	ldr	r3, [pc, #68]	@ (34011378 <CMW_VD55G1_Probe+0xd4>)
34011334:	60ab      	str	r3, [r5, #8]
  vd55g1_if->Stop = CMW_VD55G1_Stop;
34011336:	4b11      	ldr	r3, [pc, #68]	@ (3401137c <CMW_VD55G1_Probe+0xd8>)
34011338:	61ab      	str	r3, [r5, #24]
  vd55g1_if->SetMirrorFlip = CMW_VD55G1_MirrorFlipConfig;
3401133a:	4b11      	ldr	r3, [pc, #68]	@ (34011380 <CMW_VD55G1_Probe+0xdc>)
3401133c:	62eb      	str	r3, [r5, #44]	@ 0x2c
  vd55g1_if->GetSensorInfo = CMW_VD55G1_GetSensorInfo;
3401133e:	4b11      	ldr	r3, [pc, #68]	@ (34011384 <CMW_VD55G1_Probe+0xe0>)
34011340:	662b      	str	r3, [r5, #96]	@ 0x60
  return ret;
34011342:	e7da      	b.n	340112fa <CMW_VD55G1_Probe+0x56>
34011344:	3401106b 	.word	0x3401106b
34011348:	34011073 	.word	0x34011073
3401134c:	34011085 	.word	0x34011085
34011350:	340110a1 	.word	0x340110a1
34011354:	340110a7 	.word	0x340110a7
34011358:	340110bf 	.word	0x340110bf
3401135c:	340110d7 	.word	0x340110d7
34011360:	340110ed 	.word	0x340110ed
34011364:	34011131 	.word	0x34011131
34011368:	34011139 	.word	0x34011139
3401136c:	53354731 	.word	0x53354731
34011370:	340111c9 	.word	0x340111c9
34011374:	340111a5 	.word	0x340111a5
34011378:	3401118d 	.word	0x3401118d
3401137c:	3401117b 	.word	0x3401117b
34011380:	34011155 	.word	0x34011155
34011384:	3401113b 	.word	0x3401113b

34011388 <CMW_VD66GY_Read16>:
{
  return pObj->ReadReg(pObj->Address, addr, value, 1);
}

static int CMW_VD66GY_Read16(CMW_VD66GY_t *pObj, uint16_t addr, uint16_t *value)
{
34011388:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t data[2];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3401138a:	2302      	movs	r3, #2
{
3401138c:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3401138e:	f8d0 512c 	ldr.w	r5, [r0, #300]	@ 0x12c
34011392:	aa01      	add	r2, sp, #4
34011394:	8800      	ldrh	r0, [r0, #0]
34011396:	47a8      	blx	r5
  if (ret)
34011398:	b910      	cbnz	r0, 340113a0 <CMW_VD66GY_Read16+0x18>
    return ret;

  *value = (data[1] << 8) | data[0];
3401139a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
3401139e:	8023      	strh	r3, [r4, #0]

  return CMW_ERROR_NONE;
}
340113a0:	b003      	add	sp, #12
340113a2:	bd30      	pop	{r4, r5, pc}

340113a4 <VD6G_ShutdownPin>:

static void VD6G_ShutdownPin(struct VD6G_Ctx *ctx, int value)
{
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  p_ctx->ShutdownPin(value);
340113a4:	f8d0 3134 	ldr.w	r3, [r0, #308]	@ 0x134
340113a8:	4608      	mov	r0, r1
340113aa:	4718      	bx	r3

340113ac <VD6G_Read8>:
}

static int VD6G_Read8(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t *value)
{
340113ac:	b410      	push	{r4}
  return pObj->ReadReg(pObj->Address, addr, value, 1);
340113ae:	f8d0 4128 	ldr.w	r4, [r0, #296]	@ 0x128
340113b2:	2301      	movs	r3, #1
340113b4:	46a4      	mov	ip, r4
340113b6:	f830 0c04 	ldrh.w	r0, [r0, #-4]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Read8(p_ctx, addr, value);
}
340113ba:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->ReadReg(pObj->Address, addr, value, 1);
340113be:	4760      	bx	ip

340113c0 <VD6G_Read16>:

static int VD6G_Read16(struct VD6G_Ctx *ctx, uint16_t addr, uint16_t *value)
{
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Read16(p_ctx, addr, value);
340113c0:	3804      	subs	r0, #4
340113c2:	f7ff bfe1 	b.w	34011388 <CMW_VD66GY_Read16>

340113c6 <VD6G_Read32>:
  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
340113c6:	2304      	movs	r3, #4
}

static int VD6G_Read32(struct VD6G_Ctx *ctx, uint16_t addr, uint32_t *value)
{
340113c8:	b537      	push	{r0, r1, r2, r4, r5, lr}
340113ca:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
340113cc:	f8d0 5128 	ldr.w	r5, [r0, #296]	@ 0x128
340113d0:	eb0d 0203 	add.w	r2, sp, r3
340113d4:	f830 0c04 	ldrh.w	r0, [r0, #-4]
340113d8:	47a8      	blx	r5
  if (ret)
340113da:	b908      	cbnz	r0, 340113e0 <VD6G_Read32+0x1a>
  *value = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0];
340113dc:	9b01      	ldr	r3, [sp, #4]
340113de:	6023      	str	r3, [r4, #0]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Read32(p_ctx, addr, value);
}
340113e0:	b003      	add	sp, #12
340113e2:	bd30      	pop	{r4, r5, pc}

340113e4 <VD6G_Write8>:

static int VD6G_Write8(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t value)
{
340113e4:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, &value, 1);
340113e6:	2301      	movs	r3, #1
340113e8:	f8d0 4124 	ldr.w	r4, [r0, #292]	@ 0x124
340113ec:	f88d 2007 	strb.w	r2, [sp, #7]
340113f0:	f830 0c04 	ldrh.w	r0, [r0, #-4]
340113f4:	f10d 0207 	add.w	r2, sp, #7
340113f8:	47a0      	blx	r4
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Write8(p_ctx, addr, value);
}
340113fa:	b002      	add	sp, #8
340113fc:	bd10      	pop	{r4, pc}

340113fe <VD6G_Write16>:

static int VD6G_Write16(struct VD6G_Ctx *ctx, uint16_t addr, uint16_t value)
{
340113fe:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 2);
34011400:	2302      	movs	r3, #2
34011402:	f8d0 4124 	ldr.w	r4, [r0, #292]	@ 0x124
34011406:	f8ad 2006 	strh.w	r2, [sp, #6]
3401140a:	f830 0c04 	ldrh.w	r0, [r0, #-4]
3401140e:	f10d 0206 	add.w	r2, sp, #6
34011412:	47a0      	blx	r4
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Write16(p_ctx, addr, value);
}
34011414:	b002      	add	sp, #8
34011416:	bd10      	pop	{r4, pc}

34011418 <VD6G_Write32>:
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
34011418:	2304      	movs	r3, #4

static int VD6G_Write32(struct VD6G_Ctx *ctx, uint16_t addr, uint32_t value)
{
3401141a:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
3401141c:	f8d0 4124 	ldr.w	r4, [r0, #292]	@ 0x124
34011420:	9201      	str	r2, [sp, #4]
34011422:	f830 0c04 	ldrh.w	r0, [r0, #-4]
34011426:	eb0d 0203 	add.w	r2, sp, r3
3401142a:	47a0      	blx	r4
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Write32(p_ctx, addr, value);
}
3401142c:	b002      	add	sp, #8
3401142e:	bd10      	pop	{r4, pc}

34011430 <VD6G_WriteArray>:

static int VD6G_WriteArray(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t *data, int data_len)
{
34011430:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34011434:	4680      	mov	r8, r0
34011436:	460d      	mov	r5, r1
34011438:	4616      	mov	r6, r2
3401143a:	461c      	mov	r4, r3
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
  const unsigned int chunk_size = 128;
  uint16_t sz;
  int ret;

  while (data_len) {
3401143c:	b914      	cbnz	r4, 34011444 <VD6G_WriteArray+0x14>
    data_len -= sz;
    addr += sz;
    data += sz;
  }

  return 0;
3401143e:	4620      	mov	r0, r4
}
34011440:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    sz = MIN(data_len, chunk_size);
34011444:	2c80      	cmp	r4, #128	@ 0x80
34011446:	46a1      	mov	r9, r4
34011448:	bf28      	it	cs
3401144a:	f04f 0980 	movcs.w	r9, #128	@ 0x80
3401144e:	fa1f fa89 	uxth.w	sl, r9
    ret = p_ctx->WriteReg(p_ctx->Address, addr, data, sz);
34011452:	4653      	mov	r3, sl
34011454:	4632      	mov	r2, r6
34011456:	4629      	mov	r1, r5
34011458:	f8d8 7124 	ldr.w	r7, [r8, #292]	@ 0x124
3401145c:	f838 0c04 	ldrh.w	r0, [r8, #-4]
34011460:	47b8      	blx	r7
    if (ret)
34011462:	2800      	cmp	r0, #0
34011464:	d1ec      	bne.n	34011440 <VD6G_WriteArray+0x10>
    addr += sz;
34011466:	44aa      	add	sl, r5
    data_len -= sz;
34011468:	eba4 0409 	sub.w	r4, r4, r9
    addr += sz;
3401146c:	fa1f f58a 	uxth.w	r5, sl
    data += sz;
34011470:	444e      	add	r6, r9
34011472:	e7e3      	b.n	3401143c <VD6G_WriteArray+0xc>

34011474 <VD6G_Delay>:

static void VD6G_Delay(struct VD6G_Ctx *ctx, uint32_t delay_in_ms)
{
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  p_ctx->Delay(delay_in_ms);
34011474:	f8d0 3130 	ldr.w	r3, [r0, #304]	@ 0x130
34011478:	4608      	mov	r0, r1
3401147a:	4718      	bx	r3

3401147c <VD6G_Log>:
  if (lvl > current_lvl)
    return ;

  vprintf(format, ap);
#endif
}
3401147c:	4770      	bx	lr

3401147e <CMW_VD66GY_FrameEventCallback>:
#endif
}

static void CMW_VD66GY_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
}
3401147e:	4770      	bx	lr

34011480 <CMW_VD66GY_SetGain>:
{
34011480:	b5f0      	push	{r4, r5, r6, r7, lr}
34011482:	ed2d 8b08 	vpush	{d8-d11}
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
34011486:	1d06      	adds	r6, r0, #4
{
34011488:	b085      	sub	sp, #20
3401148a:	460d      	mov	r5, r1
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
3401148c:	4630      	mov	r0, r6
3401148e:	f10d 020b 	add.w	r2, sp, #11
34011492:	f10d 010a 	add.w	r1, sp, #10
34011496:	f002 f8a5 	bl	340135e4 <VD6G_GetAnalogGainRegRange>
  if (ret)
3401149a:	2800      	cmp	r0, #0
3401149c:	f040 80bc 	bne.w	34011618 <CMW_VD66GY_SetGain+0x198>
  ret = VD6G_GetDigitalGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &dgain_regmin, &dgain_regmax);
340114a0:	4630      	mov	r0, r6
340114a2:	f10d 020e 	add.w	r2, sp, #14
340114a6:	a903      	add	r1, sp, #12
340114a8:	f002 f908 	bl	340136bc <VD6G_GetDigitalGainRegRange>
  if (ret)
340114ac:	2800      	cmp	r0, #0
340114ae:	f040 80b3 	bne.w	34011618 <CMW_VD66GY_SetGain+0x198>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
340114b2:	2420      	movs	r4, #32
340114b4:	f89d 300a 	ldrb.w	r3, [sp, #10]
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340114b8:	eeb3 ab04 	vmov.f64	d10, #52	@ 0x41a00000  20.0
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
340114bc:	f1c3 0320 	rsb	r3, r3, #32
340114c0:	fb94 f3f3 	sdiv	r3, r4, r3
340114c4:	ee00 3a10 	vmov	s0, r3
340114c8:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
340114cc:	f00a fed8 	bl	3401c280 <log10>
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340114d0:	f89d 300b 	ldrb.w	r3, [sp, #11]
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
340114d4:	eeb0 8b40 	vmov.f64	d8, d0
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340114d8:	1ae3      	subs	r3, r4, r3
340114da:	fb94 f3f3 	sdiv	r3, r4, r3
340114de:	ee00 3a10 	vmov	s0, r3
340114e2:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
340114e6:	f00a fecb 	bl	3401c280 <log10>
340114ea:	ed9f bb59 	vldr	d11, [pc, #356]	@ 34011650 <CMW_VD66GY_SetGain+0x1d0>
340114ee:	ee20 0b0a 	vmul.f64	d0, d0, d10
340114f2:	ee20 0b0b 	vmul.f64	d0, d0, d11
340114f6:	eefc 7bc0 	vcvt.u32.f64	s15, d0
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340114fa:	f8bd 300c 	ldrh.w	r3, [sp, #12]
340114fe:	f89d 200c 	ldrb.w	r2, [sp, #12]
34011502:	0a1b      	lsrs	r3, r3, #8
34011504:	ee00 3a10 	vmov	s0, r3
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
34011508:	ee17 7a90 	vmov	r7, s15
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
3401150c:	ee07 2a90 	vmov	s15, r2
34011510:	ed9f 9a55 	vldr	s18, [pc, #340]	@ 34011668 <CMW_VD66GY_SetGain+0x1e8>
34011514:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34011518:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
3401151c:	eea7 0a89 	vfma.f32	s0, s15, s18
34011520:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34011524:	f00a feac 	bl	3401c280 <log10>
34011528:	ee20 0b0a 	vmul.f64	d0, d0, d10
3401152c:	ee20 0b0b 	vmul.f64	d0, d0, d11
34011530:	eefc 7bc0 	vcvt.u32.f64	s15, d0
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011534:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34011538:	f89d 200e 	ldrb.w	r2, [sp, #14]
3401153c:	0a1b      	lsrs	r3, r3, #8
3401153e:	ee00 3a10 	vmov	s0, r3
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
34011542:	ee17 4a90 	vmov	r4, s15
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011546:	ee07 2a90 	vmov	s15, r2
3401154a:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
3401154e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34011552:	eea7 0a89 	vfma.f32	s0, s15, s18
34011556:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
3401155a:	f00a fe91 	bl	3401c280 <log10>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3401155e:	ee28 8b0a 	vmul.f64	d8, d8, d10
34011562:	ee28 8b0b 	vmul.f64	d8, d8, d11
34011566:	eebc 8bc8 	vcvt.u32.f64	s16, d8
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
3401156a:	ee20 0b0a 	vmul.f64	d0, d0, d10
  if ((gain < dgain_min_mdB + again_min_mdB)
3401156e:	ee18 3a10 	vmov	r3, s16
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011572:	ee20 0b0b 	vmul.f64	d0, d0, d11
  if ((gain < dgain_min_mdB + again_min_mdB)
34011576:	4423      	add	r3, r4
34011578:	42ab      	cmp	r3, r5
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
3401157a:	eebc 0bc0 	vcvt.u32.f64	s0, d0
  if ((gain < dgain_min_mdB + again_min_mdB)
3401157e:	d861      	bhi.n	34011644 <CMW_VD66GY_SetGain+0x1c4>
      || (gain > dgain_max_mdB + again_max_mdB))
34011580:	ee10 3a10 	vmov	r3, s0
34011584:	443b      	add	r3, r7
34011586:	429d      	cmp	r5, r3
34011588:	d85c      	bhi.n	34011644 <CMW_VD66GY_SetGain+0x1c4>
  if (gain <= again_max_mdB)
3401158a:	42bd      	cmp	r5, r7
3401158c:	d848      	bhi.n	34011620 <CMW_VD66GY_SetGain+0x1a0>
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - dgain_min_mdB));
3401158e:	1b2d      	subs	r5, r5, r4
34011590:	ee07 5a90 	vmov	s15, r5
34011594:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34011598:	ee87 1b0b 	vdiv.f64	d1, d7, d11
3401159c:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
340115a0:	ee81 1b0a 	vdiv.f64	d1, d1, d10
340115a4:	f00a ff74 	bl	3401c490 <pow>
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)dgain_min_mdB);
340115a8:	ee07 4a90 	vmov	s15, r4
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - dgain_min_mdB));
340115ac:	eeb0 9b40 	vmov.f64	d9, d0
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
340115b0:	eeb8 7b67 	vcvt.f64.u32	d7, s15
340115b4:	ee87 1b0b 	vdiv.f64	d1, d7, d11
340115b8:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
340115bc:	ee81 1b0a 	vdiv.f64	d1, d1, d10
340115c0:	f00a ff66 	bl	3401c490 <pow>
  ret = VD6G_SetAnalogGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, (int) (32 - (32 / analog_linear_gain)));
340115c4:	ed9f 7b24 	vldr	d7, [pc, #144]	@ 34011658 <CMW_VD66GY_SetGain+0x1d8>
340115c8:	ee87 6b09 	vdiv.f64	d6, d7, d9
340115cc:	ee37 7b46 	vsub.f64	d7, d7, d6
340115d0:	eefd 7bc7 	vcvt.s32.f64	s15, d7
340115d4:	4630      	mov	r0, r6
340115d6:	ee17 1a90 	vmov	r1, s15
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
340115da:	eeb0 8b40 	vmov.f64	d8, d0
  ret = VD6G_SetAnalogGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, (int) (32 - (32 / analog_linear_gain)));
340115de:	f002 f83d 	bl	3401365c <VD6G_SetAnalogGain>
  if (ret)
340115e2:	b9c8      	cbnz	r0, 34011618 <CMW_VD66GY_SetGain+0x198>
  ret = VD6G_SetDigitalGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, FLOAT_TO_FP58(digital_linear_gain));
340115e4:	eefc 7bc8 	vcvt.u32.f64	s15, d8
340115e8:	ee17 3a90 	vmov	r3, s15
340115ec:	b299      	uxth	r1, r3
340115ee:	ee07 1a90 	vmov	s15, r1
340115f2:	eeb8 7be7 	vcvt.f64.s32	d7, s15
340115f6:	ee38 8b47 	vsub.f64	d8, d8, d7
340115fa:	ed9f 7b19 	vldr	d7, [pc, #100]	@ 34011660 <CMW_VD66GY_SetGain+0x1e0>
340115fe:	ee28 8b07 	vmul.f64	d8, d8, d7
34011602:	eefc 7bc8 	vcvt.u32.f64	s15, d8
34011606:	edcd 7a01 	vstr	s15, [sp, #4]
3401160a:	f89d 3004 	ldrb.w	r3, [sp, #4]
3401160e:	4630      	mov	r0, r6
34011610:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
34011614:	f002 f880 	bl	34013718 <VD6G_SetDigitalGain>
}
34011618:	b005      	add	sp, #20
3401161a:	ecbd 8b08 	vpop	{d8-d11}
3401161e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)again_max_mdB);
34011620:	ee07 7a90 	vmov	s15, r7
34011624:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34011628:	ee87 1b0b 	vdiv.f64	d1, d7, d11
3401162c:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
34011630:	ee81 1b0a 	vdiv.f64	d1, d1, d10
34011634:	f00a ff2c 	bl	3401c490 <pow>
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
34011638:	1bed      	subs	r5, r5, r7
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)again_max_mdB);
3401163a:	eeb0 9b40 	vmov.f64	d9, d0
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
3401163e:	ee07 5a90 	vmov	s15, r5
34011642:	e7b5      	b.n	340115b0 <CMW_VD66GY_SetGain+0x130>
    return -1;
34011644:	f04f 30ff 	mov.w	r0, #4294967295
34011648:	e7e6      	b.n	34011618 <CMW_VD66GY_SetGain+0x198>
3401164a:	bf00      	nop
3401164c:	f3af 8000 	nop.w
34011650:	00000000 	.word	0x00000000
34011654:	408f4000 	.word	0x408f4000
34011658:	00000000 	.word	0x00000000
3401165c:	40400000 	.word	0x40400000
34011660:	00000000 	.word	0x00000000
34011664:	40700000 	.word	0x40700000
34011668:	3b800000 	.word	0x3b800000

3401166c <CMW_VD66GY_SetExposure>:
  return VD6G_SetExposureTime(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, exposure);
3401166c:	3004      	adds	r0, #4
3401166e:	f002 b8f5 	b.w	3401385c <VD6G_SetExposureTime>

34011672 <CMW_VD66GY_SetExposureMode>:
  switch (mode)
34011672:	2901      	cmp	r1, #1
{
34011674:	b508      	push	{r3, lr}
34011676:	f100 0004 	add.w	r0, r0, #4
  switch (mode)
3401167a:	d002      	beq.n	34011682 <CMW_VD66GY_SetExposureMode+0x10>
3401167c:	2902      	cmp	r1, #2
      ret = VD6G_SetExposureMode(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, VD6G_EXPOSURE_AUTO);
3401167e:	bf18      	it	ne
34011680:	2100      	movne	r1, #0
34011682:	f001 ffa5 	bl	340135d0 <VD6G_SetExposureMode>
  return (ret == 0) ? CMW_ERROR_NONE : CMW_ERROR_UNKNOWN_FAILURE;
34011686:	2800      	cmp	r0, #0
}
34011688:	bf18      	it	ne
3401168a:	f06f 0005 	mvnne.w	r0, #5
3401168e:	bd08      	pop	{r3, pc}

34011690 <CMW_VD66GY_SetWBRefMode>:
{
34011690:	b508      	push	{r3, lr}
  ret = ISP_SetWBRefMode(&((CMW_VD66GY_t *)io_ctx)->hIsp, Automatic, RefColorTemp);
34011692:	306c      	adds	r0, #108	@ 0x6c
34011694:	f002 ffc7 	bl	34014626 <ISP_SetWBRefMode>
  return CMW_ERROR_NONE;
34011698:	2800      	cmp	r0, #0
}
3401169a:	bf14      	ite	ne
3401169c:	f06f 0003 	mvnne.w	r0, #3
340116a0:	2000      	moveq	r0, #0
340116a2:	bd08      	pop	{r3, pc}

340116a4 <CMW_VD66GY_ListWBRefModes>:
{
340116a4:	b508      	push	{r3, lr}
  ret = ISP_ListWBRefModes(&((CMW_VD66GY_t *)io_ctx)->hIsp, RefColorTemp);
340116a6:	306c      	adds	r0, #108	@ 0x6c
340116a8:	f002 ffaa 	bl	34014600 <ISP_ListWBRefModes>
  return CMW_ERROR_NONE;
340116ac:	2800      	cmp	r0, #0
}
340116ae:	bf14      	ite	ne
340116b0:	f06f 0003 	mvnne.w	r0, #3
340116b4:	2000      	moveq	r0, #0
340116b6:	bd08      	pop	{r3, pc}

340116b8 <CMW_VD66GY_GetSensorInfo>:
{
340116b8:	b570      	push	{r4, r5, r6, lr}
340116ba:	ed2d 8b08 	vpush	{d8-d11}
340116be:	460c      	mov	r4, r1
  if ((!io_ctx) || (info == NULL))
340116c0:	4605      	mov	r5, r0
{
340116c2:	b082      	sub	sp, #8
  if ((!io_ctx) || (info == NULL))
340116c4:	2800      	cmp	r0, #0
340116c6:	f000 80a0 	beq.w	3401180a <CMW_VD66GY_GetSensorInfo+0x152>
340116ca:	2900      	cmp	r1, #0
340116cc:	f000 809d 	beq.w	3401180a <CMW_VD66GY_GetSensorInfo+0x152>
    strcpy(info->name, VD66GY_NAME);
340116d0:	4951      	ldr	r1, [pc, #324]	@ (34011818 <CMW_VD66GY_GetSensorInfo+0x160>)
340116d2:	4620      	mov	r0, r4
340116d4:	f008 ffa7 	bl	3401a626 <strcpy>
  info->bayer_pattern = ((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer - 1;
340116d8:	f895 302c 	ldrb.w	r3, [r5, #44]	@ 0x2c
  info->height = VD6G_MAX_HEIGHT;
340116dc:	f44f 628c 	mov.w	r2, #1120	@ 0x460
  info->bayer_pattern = ((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer - 1;
340116e0:	3b01      	subs	r3, #1
340116e2:	f884 3020 	strb.w	r3, [r4, #32]
  info->color_depth = VD6G_COLOR_DEPTH_RAW8;
340116e6:	2308      	movs	r3, #8
340116e8:	f884 3021 	strb.w	r3, [r4, #33]	@ 0x21
  info->height = VD6G_MAX_HEIGHT;
340116ec:	f240 5354 	movw	r3, #1364	@ 0x554
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
340116f0:	3504      	adds	r5, #4
  info->height = VD6G_MAX_HEIGHT;
340116f2:	e9c4 2309 	strd	r2, r3, [r4, #36]	@ 0x24
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
340116f6:	4628      	mov	r0, r5
340116f8:	f10d 0203 	add.w	r2, sp, #3
340116fc:	f10d 0102 	add.w	r1, sp, #2
34011700:	f001 ff70 	bl	340135e4 <VD6G_GetAnalogGainRegRange>
  if (ret)
34011704:	2800      	cmp	r0, #0
34011706:	d17c      	bne.n	34011802 <CMW_VD66GY_GetSensorInfo+0x14a>
  ret = VD6G_GetDigitalGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &dgain_regmin, &dgain_regmax);
34011708:	4628      	mov	r0, r5
3401170a:	f10d 0206 	add.w	r2, sp, #6
3401170e:	a901      	add	r1, sp, #4
34011710:	f001 ffd4 	bl	340136bc <VD6G_GetDigitalGainRegRange>
  if (ret)
34011714:	2800      	cmp	r0, #0
34011716:	d174      	bne.n	34011802 <CMW_VD66GY_GetSensorInfo+0x14a>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
34011718:	2620      	movs	r6, #32
3401171a:	f89d 3002 	ldrb.w	r3, [sp, #2]
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
3401171e:	ed9f ba3f 	vldr	s22, [pc, #252]	@ 3401181c <CMW_VD66GY_GetSensorInfo+0x164>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
34011722:	f1c3 0320 	rsb	r3, r3, #32
34011726:	fb96 f3f3 	sdiv	r3, r6, r3
3401172a:	ee00 3a10 	vmov	s0, r3
3401172e:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
34011732:	f00a fda5 	bl	3401c280 <log10>
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
34011736:	f89d 3003 	ldrb.w	r3, [sp, #3]
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3401173a:	eeb0 9b40 	vmov.f64	d9, d0
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3401173e:	1af3      	subs	r3, r6, r3
34011740:	fb96 f3f3 	sdiv	r3, r6, r3
34011744:	ee00 3a10 	vmov	s0, r3
34011748:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
3401174c:	f00a fd98 	bl	3401c280 <log10>
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
34011750:	f8bd 3004 	ldrh.w	r3, [sp, #4]
34011754:	f89d 2004 	ldrb.w	r2, [sp, #4]
34011758:	0a1b      	lsrs	r3, r3, #8
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3401175a:	eeb0 8b40 	vmov.f64	d8, d0
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
3401175e:	ee07 2a90 	vmov	s15, r2
34011762:	ee00 3a10 	vmov	s0, r3
34011766:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3401176a:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
3401176e:	eea7 0a8b 	vfma.f32	s0, s15, s22
34011772:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34011776:	f00a fd83 	bl	3401c280 <log10>
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
3401177a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
3401177e:	f89d 2006 	ldrb.w	r2, [sp, #6]
34011782:	0a1b      	lsrs	r3, r3, #8
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
34011784:	eeb0 ab40 	vmov.f64	d10, d0
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011788:	ee07 2a90 	vmov	s15, r2
3401178c:	ee00 3a10 	vmov	s0, r3
34011790:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34011794:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
34011798:	eea7 0a8b 	vfma.f32	s0, s15, s22
3401179c:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
340117a0:	f00a fd6e 	bl	3401c280 <log10>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
340117a4:	eeb3 7b04 	vmov.f64	d7, #52	@ 0x41a00000  20.0
340117a8:	ed9f 6b19 	vldr	d6, [pc, #100]	@ 34011810 <CMW_VD66GY_GetSensorInfo+0x158>
340117ac:	ee29 9b07 	vmul.f64	d9, d9, d7
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340117b0:	ee2a ab07 	vmul.f64	d10, d10, d7
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
340117b4:	ee29 9b06 	vmul.f64	d9, d9, d6
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340117b8:	ee2a ab06 	vmul.f64	d10, d10, d6
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340117bc:	ee28 8b07 	vmul.f64	d8, d8, d7
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
340117c0:	ee20 0b07 	vmul.f64	d0, d0, d7
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
340117c4:	eebc 9bc9 	vcvt.u32.f64	s18, d9
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340117c8:	eebc abca 	vcvt.u32.f64	s20, d10
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340117cc:	ee28 8b06 	vmul.f64	d8, d8, d6
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
340117d0:	ee20 0b06 	vmul.f64	d0, d0, d6
  info->gain_min = again_min_mdB + dgain_min_mdB;
340117d4:	ee1a 2a10 	vmov	r2, s20
340117d8:	ee19 3a10 	vmov	r3, s18
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340117dc:	eebc 8bc8 	vcvt.u32.f64	s16, d8
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
340117e0:	eebc 0bc0 	vcvt.u32.f64	s0, d0
  info->gain_min = again_min_mdB + dgain_min_mdB;
340117e4:	4413      	add	r3, r2
340117e6:	62e3      	str	r3, [r4, #44]	@ 0x2c
  info->gain_max = again_max_mdB + dgain_max_mdB;
340117e8:	ee10 2a10 	vmov	r2, s0
340117ec:	ee18 3a10 	vmov	r3, s16
340117f0:	4413      	add	r3, r2
  ret = VD6G_GetExposureRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &info->exposure_min, &info->exposure_max);
340117f2:	4628      	mov	r0, r5
  info->gain_max = again_max_mdB + dgain_max_mdB;
340117f4:	6323      	str	r3, [r4, #48]	@ 0x30
  ret = VD6G_GetExposureRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &info->exposure_min, &info->exposure_max);
340117f6:	f104 0238 	add.w	r2, r4, #56	@ 0x38
340117fa:	f104 0134 	add.w	r1, r4, #52	@ 0x34
340117fe:	f001 ffe1 	bl	340137c4 <VD6G_GetExposureRegRange>
}
34011802:	b002      	add	sp, #8
34011804:	ecbd 8b08 	vpop	{d8-d11}
34011808:	bd70      	pop	{r4, r5, r6, pc}
    return CMW_ERROR_WRONG_PARAM;
3401180a:	f06f 0001 	mvn.w	r0, #1
3401180e:	e7f8      	b.n	34011802 <CMW_VD66GY_GetSensorInfo+0x14a>
34011810:	00000000 	.word	0x00000000
34011814:	408f4000 	.word	0x408f4000
34011818:	34020825 	.word	0x34020825
3401181c:	3b800000 	.word	0x3b800000

34011820 <CMW_VD66GY_Stop>:
{
34011820:	b508      	push	{r3, lr}
  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
34011822:	3004      	adds	r0, #4
34011824:	f001 fea2 	bl	3401356c <VD6G_Stop>
    return CMW_ERROR_PERIPH_FAILURE;
34011828:	2800      	cmp	r0, #0
}
3401182a:	bf18      	it	ne
3401182c:	f06f 0003 	mvnne.w	r0, #3
34011830:	bd08      	pop	{r3, pc}
	...

34011834 <CMW_VD66GY_Start>:
{
34011834:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = ISP_Init(&((CMW_VD66GY_t *)io_ctx)->hIsp, ((CMW_VD66GY_t *)io_ctx)->hdcmipp, 0, &((CMW_VD66GY_t *)io_ctx)->appliHelpers, &ISP_IQParamCacheInit_VD66GY);
34011836:	4b10      	ldr	r3, [pc, #64]	@ (34011878 <CMW_VD66GY_Start+0x44>)
34011838:	f100 056c 	add.w	r5, r0, #108	@ 0x6c
3401183c:	9300      	str	r3, [sp, #0]
{
3401183e:	4604      	mov	r4, r0
  ret = ISP_Init(&((CMW_VD66GY_t *)io_ctx)->hIsp, ((CMW_VD66GY_t *)io_ctx)->hdcmipp, 0, &((CMW_VD66GY_t *)io_ctx)->appliHelpers, &ISP_IQParamCacheInit_VD66GY);
34011840:	f8d0 1118 	ldr.w	r1, [r0, #280]	@ 0x118
34011844:	f100 03f4 	add.w	r3, r0, #244	@ 0xf4
34011848:	2200      	movs	r2, #0
3401184a:	4628      	mov	r0, r5
3401184c:	f002 fd9a 	bl	34014384 <ISP_Init>
  if (ret != ISP_OK)
34011850:	b978      	cbnz	r0, 34011872 <CMW_VD66GY_Start+0x3e>
  ret = ISP_Start(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011852:	4628      	mov	r0, r5
34011854:	f002 fe24 	bl	340144a0 <ISP_Start>
  if (ret != ISP_OK)
34011858:	b938      	cbnz	r0, 3401186a <CMW_VD66GY_Start+0x36>
  ret = VD6G_Start(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3401185a:	3404      	adds	r4, #4
3401185c:	4620      	mov	r0, r4
3401185e:	f001 fd41 	bl	340132e4 <VD6G_Start>
  if (ret) {
34011862:	b120      	cbz	r0, 3401186e <CMW_VD66GY_Start+0x3a>
    VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
34011864:	4620      	mov	r0, r4
34011866:	f001 fd2d 	bl	340132c4 <VD6G_DeInit>
      return CMW_ERROR_PERIPH_FAILURE;
3401186a:	f06f 0003 	mvn.w	r0, #3
}
3401186e:	b003      	add	sp, #12
34011870:	bd30      	pop	{r4, r5, pc}
    return CMW_ERROR_COMPONENT_FAILURE;
34011872:	f06f 0004 	mvn.w	r0, #4
34011876:	e7fa      	b.n	3401186e <CMW_VD66GY_Start+0x3a>
34011878:	340a70b0 	.word	0x340a70b0

3401187c <CMW_VD66GY_DeInit>:
{
3401187c:	b538      	push	{r3, r4, r5, lr}
  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3401187e:	1d05      	adds	r5, r0, #4
{
34011880:	4604      	mov	r4, r0
  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
34011882:	4628      	mov	r0, r5
34011884:	f001 fe72 	bl	3401356c <VD6G_Stop>
  if (ret)
34011888:	b110      	cbz	r0, 34011890 <CMW_VD66GY_DeInit+0x14>
    return CMW_ERROR_PERIPH_FAILURE;
3401188a:	f06f 0003 	mvn.w	r0, #3
}
3401188e:	bd38      	pop	{r3, r4, r5, pc}
  ret = VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
34011890:	4628      	mov	r0, r5
34011892:	f001 fd17 	bl	340132c4 <VD6G_DeInit>
  if (ret)
34011896:	2800      	cmp	r0, #0
34011898:	d1f7      	bne.n	3401188a <CMW_VD66GY_DeInit+0xe>
  ((CMW_VD66GY_t *)io_ctx)->IsInitialized = 0;
3401189a:	f884 011c 	strb.w	r0, [r4, #284]	@ 0x11c
  return CMW_ERROR_NONE;
3401189e:	e7f6      	b.n	3401188e <CMW_VD66GY_DeInit+0x12>

340118a0 <CMW_VD66GY_Run>:
{
340118a0:	b508      	push	{r3, lr}
  ret = ISP_BackgroundProcess(&((CMW_VD66GY_t *)io_ctx)->hIsp);
340118a2:	306c      	adds	r0, #108	@ 0x6c
340118a4:	f002 fe9c 	bl	340145e0 <ISP_BackgroundProcess>
  return CMW_ERROR_NONE;
340118a8:	2800      	cmp	r0, #0
}
340118aa:	bf14      	ite	ne
340118ac:	f06f 0003 	mvnne.w	r0, #3
340118b0:	2000      	moveq	r0, #0
340118b2:	bd08      	pop	{r3, pc}

340118b4 <CMW_VD66GY_VsyncEventCallback>:
  switch (pipe)
340118b4:	2901      	cmp	r1, #1
{
340118b6:	b510      	push	{r4, lr}
  switch (pipe)
340118b8:	d007      	beq.n	340118ca <CMW_VD66GY_VsyncEventCallback+0x16>
340118ba:	2902      	cmp	r1, #2
340118bc:	d00f      	beq.n	340118de <CMW_VD66GY_VsyncEventCallback+0x2a>
340118be:	b999      	cbnz	r1, 340118e8 <CMW_VD66GY_VsyncEventCallback+0x34>
}
340118c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncDumpFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
340118c4:	306c      	adds	r0, #108	@ 0x6c
340118c6:	f002 bf08 	b.w	340146da <ISP_IncDumpFrameId>
      ISP_IncMainFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
340118ca:	f100 046c 	add.w	r4, r0, #108	@ 0x6c
340118ce:	4620      	mov	r0, r4
340118d0:	f002 feff 	bl	340146d2 <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_VD66GY_t *)io_ctx)->hIsp);
340118d4:	4620      	mov	r0, r4
}
340118d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_GatherStatistics(&((CMW_VD66GY_t *)io_ctx)->hIsp);
340118da:	f002 bef8 	b.w	340146ce <ISP_GatherStatistics>
      ISP_IncAncillaryFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
340118de:	306c      	adds	r0, #108	@ 0x6c
}
340118e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncAncillaryFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
340118e4:	f002 bef7 	b.w	340146d6 <ISP_IncAncillaryFrameId>
}
340118e8:	bd10      	pop	{r4, pc}
	...

340118ec <CMW_VD66GY_SetDefaultSensorValues>:
{
340118ec:	b508      	push	{r3, lr}
  assert(vd66gy_config != NULL);
340118ee:	b930      	cbnz	r0, 340118fe <CMW_VD66GY_SetDefaultSensorValues+0x12>
340118f0:	f240 1125 	movw	r1, #293	@ 0x125
340118f4:	4b08      	ldr	r3, [pc, #32]	@ (34011918 <CMW_VD66GY_SetDefaultSensorValues+0x2c>)
340118f6:	4a09      	ldr	r2, [pc, #36]	@ (3401191c <CMW_VD66GY_SetDefaultSensorValues+0x30>)
340118f8:	4809      	ldr	r0, [pc, #36]	@ (34011920 <CMW_VD66GY_SetDefaultSensorValues+0x34>)
340118fa:	f007 faaf 	bl	34018e5c <__assert_func>
  vd66gy_config->line_len = 0; // Default line length
340118fe:	2200      	movs	r2, #0
34011900:	4b08      	ldr	r3, [pc, #32]	@ (34011924 <CMW_VD66GY_SetDefaultSensorValues+0x38>)
  vd66gy_config->csiconfig.clock_lane_swap_enable = 1;
34011902:	2102      	movs	r1, #2
  vd66gy_config->line_len = 0; // Default line length
34011904:	e9c0 3200 	strd	r3, r2, [r0]
  vd66gy_config->csiconfig.clock_lane_swap_enable = 1;
34011908:	2301      	movs	r3, #1
  vd66gy_config->csiconfig.data_lanes_mapping_swap_enable = 0;
3401190a:	6182      	str	r2, [r0, #24]
  vd66gy_config->csiconfig.clock_lane_swap_enable = 1;
3401190c:	e9c0 1302 	strd	r1, r3, [r0, #8]
  vd66gy_config->csiconfig.data_lane1_swap_enable = 1;
34011910:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
34011914:	bd08      	pop	{r3, pc}
34011916:	bf00      	nop
34011918:	3402082c 	.word	0x3402082c
3401191c:	340a708c 	.word	0x340a708c
34011920:	34020842 	.word	0x34020842
34011924:	00b71b00 	.word	0x00b71b00

34011928 <CMW_VD66GY_Init>:
{
34011928:	b570      	push	{r4, r5, r6, lr}
3401192a:	460c      	mov	r4, r1
3401192c:	b096      	sub	sp, #88	@ 0x58
3401192e:	4605      	mov	r5, r0
  VD6G_Config_t config = { 0 };
34011930:	2238      	movs	r2, #56	@ 0x38
34011932:	2100      	movs	r1, #0
34011934:	a808      	add	r0, sp, #32
34011936:	f008 fbf5 	bl	3401a124 <memset>
  assert(initSensor != NULL);
3401193a:	b92c      	cbnz	r4, 34011948 <CMW_VD66GY_Init+0x20>
3401193c:	21ee      	movs	r1, #238	@ 0xee
3401193e:	4b34      	ldr	r3, [pc, #208]	@ (34011a10 <CMW_VD66GY_Init+0xe8>)
34011940:	4a34      	ldr	r2, [pc, #208]	@ (34011a14 <CMW_VD66GY_Init+0xec>)
34011942:	4835      	ldr	r0, [pc, #212]	@ (34011a18 <CMW_VD66GY_Init+0xf0>)
34011944:	f007 fa8a 	bl	34018e5c <__assert_func>
  if (((CMW_VD66GY_t *)io_ctx)->IsInitialized)
34011948:	f895 311c 	ldrb.w	r3, [r5, #284]	@ 0x11c
3401194c:	2b00      	cmp	r3, #0
3401194e:	d15d      	bne.n	34011a0c <CMW_VD66GY_Init+0xe4>
  config.frame_rate = initSensor->fps;
34011950:	68a3      	ldr	r3, [r4, #8]
34011952:	930a      	str	r3, [sp, #40]	@ 0x28
  ret = CMW_VD66GY_GetResType(initSensor->width, initSensor->height, &config.resolution);
34011954:	e9d4 2300 	ldrd	r2, r3, [r4]
  if (width == 320 && height == 240)
34011958:	f5b2 7fa0 	cmp.w	r2, #320	@ 0x140
3401195c:	d104      	bne.n	34011968 <CMW_VD66GY_Init+0x40>
3401195e:	2bf0      	cmp	r3, #240	@ 0xf0
34011960:	d00b      	beq.n	3401197a <CMW_VD66GY_Init+0x52>
    return CMW_ERROR_WRONG_PARAM;
34011962:	f06f 0001 	mvn.w	r0, #1
34011966:	e036      	b.n	340119d6 <CMW_VD66GY_Init+0xae>
  else if (width == 640 && height == 480)
34011968:	f5b2 7f20 	cmp.w	r2, #640	@ 0x280
3401196c:	d135      	bne.n	340119da <CMW_VD66GY_Init+0xb2>
3401196e:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
34011972:	d1f6      	bne.n	34011962 <CMW_VD66GY_Init+0x3a>
    *res = VD6G_RES_VGA_640_480;
34011974:	2301      	movs	r3, #1
    *res = VD6G_RES_FULL_1120_1364;
34011976:	f88d 3024 	strb.w	r3, [sp, #36]	@ 0x24
  CMW_VD66GY_SetDefaultSensorValues(&default_sensor_config);
3401197a:	ae01      	add	r6, sp, #4
3401197c:	4630      	mov	r0, r6
3401197e:	f7ff ffb5 	bl	340118ec <CMW_VD66GY_SetDefaultSensorValues>
  sensor_config = initSensor->sensor_config ? (CMW_VD66GY_config_t*)(initSensor->sensor_config) : &default_sensor_config;
34011982:	6963      	ldr	r3, [r4, #20]
  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
34011984:	a908      	add	r1, sp, #32
  sensor_config = initSensor->sensor_config ? (CMW_VD66GY_config_t*)(initSensor->sensor_config) : &default_sensor_config;
34011986:	2b00      	cmp	r3, #0
34011988:	bf08      	it	eq
3401198a:	4633      	moveq	r3, r6
  config.ext_clock_freq_in_hz = sensor_config->ext_clock_freq_in_hz;
3401198c:	681a      	ldr	r2, [r3, #0]
3401198e:	9208      	str	r2, [sp, #32]
  config.line_len = sensor_config->line_len;
34011990:	685a      	ldr	r2, [r3, #4]
34011992:	920c      	str	r2, [sp, #48]	@ 0x30
  config.out_itf.datalane_nb = sensor_config->csiconfig.datalane_nb;
34011994:	689a      	ldr	r2, [r3, #8]
34011996:	920e      	str	r2, [sp, #56]	@ 0x38
  config.out_itf.clock_lane_swap_enable = sensor_config->csiconfig.clock_lane_swap_enable;
34011998:	68da      	ldr	r2, [r3, #12]
3401199a:	920f      	str	r2, [sp, #60]	@ 0x3c
  config.out_itf.data_lane0_swap_enable = sensor_config->csiconfig.data_lane0_swap_enable;
3401199c:	691a      	ldr	r2, [r3, #16]
3401199e:	9210      	str	r2, [sp, #64]	@ 0x40
  config.out_itf.data_lane1_swap_enable = sensor_config->csiconfig.data_lane1_swap_enable;
340119a0:	695a      	ldr	r2, [r3, #20]
  config.out_itf.data_lanes_mapping_swap_enable = sensor_config->csiconfig.data_lanes_mapping_swap_enable;
340119a2:	699b      	ldr	r3, [r3, #24]
  config.out_itf.data_lane1_swap_enable = sensor_config->csiconfig.data_lane1_swap_enable;
340119a4:	9211      	str	r2, [sp, #68]	@ 0x44
  config.out_itf.data_lanes_mapping_swap_enable = sensor_config->csiconfig.data_lanes_mapping_swap_enable;
340119a6:	9312      	str	r3, [sp, #72]	@ 0x48
  config.flip_mirror_mode = CMW_VD66GY_getMirrorFlipConfig(initSensor->mirrorFlip);
340119a8:	6923      	ldr	r3, [r4, #16]
  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
340119aa:	1d2c      	adds	r4, r5, #4
  config.flip_mirror_mode = CMW_VD66GY_getMirrorFlipConfig(initSensor->mirrorFlip);
340119ac:	2b03      	cmp	r3, #3
340119ae:	bf28      	it	cs
340119b0:	2303      	movcs	r3, #3
340119b2:	f88d 302c 	strb.w	r3, [sp, #44]	@ 0x2c
    config.gpio_ctrl[i] = VD6G_GPIO_GPIO_IN;
340119b6:	f04f 3301 	mov.w	r3, #16843009	@ 0x1010101
  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
340119ba:	4620      	mov	r0, r4
    config.gpio_ctrl[i] = VD6G_GPIO_GPIO_IN;
340119bc:	e9cd 3313 	strd	r3, r3, [sp, #76]	@ 0x4c
  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
340119c0:	f001 f970 	bl	34012ca4 <VD6G_Init>
  if (ret)
340119c4:	b928      	cbnz	r0, 340119d2 <CMW_VD66GY_Init+0xaa>
  if (((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer == VD6G_BAYER_NONE)
340119c6:	f895 302c 	ldrb.w	r3, [r5, #44]	@ 0x2c
340119ca:	b9e3      	cbnz	r3, 34011a06 <CMW_VD66GY_Init+0xde>
    VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
340119cc:	4620      	mov	r0, r4
340119ce:	f001 fc79 	bl	340132c4 <VD6G_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
340119d2:	f06f 0003 	mvn.w	r0, #3
}
340119d6:	b016      	add	sp, #88	@ 0x58
340119d8:	bd70      	pop	{r4, r5, r6, pc}
  else if (width == 1024 && height == 768)
340119da:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
340119de:	d104      	bne.n	340119ea <CMW_VD66GY_Init+0xc2>
340119e0:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
340119e4:	d1bd      	bne.n	34011962 <CMW_VD66GY_Init+0x3a>
    *res = VD6G_RES_XGA_1024_768;
340119e6:	2303      	movs	r3, #3
340119e8:	e7c5      	b.n	34011976 <CMW_VD66GY_Init+0x4e>
  else if (width == 1120 && height == 720)
340119ea:	f5b2 6f8c 	cmp.w	r2, #1120	@ 0x460
340119ee:	d1b8      	bne.n	34011962 <CMW_VD66GY_Init+0x3a>
340119f0:	f5b3 7f34 	cmp.w	r3, #720	@ 0x2d0
340119f4:	d101      	bne.n	340119fa <CMW_VD66GY_Init+0xd2>
    *res = VD6G_RES_PORTRAIT_1120_720;
340119f6:	2307      	movs	r3, #7
340119f8:	e7bd      	b.n	34011976 <CMW_VD66GY_Init+0x4e>
  else if (width == 1120 && height == 1364)
340119fa:	f240 5254 	movw	r2, #1364	@ 0x554
340119fe:	4293      	cmp	r3, r2
34011a00:	d1af      	bne.n	34011962 <CMW_VD66GY_Init+0x3a>
    *res = VD6G_RES_FULL_1120_1364;
34011a02:	2308      	movs	r3, #8
34011a04:	e7b7      	b.n	34011976 <CMW_VD66GY_Init+0x4e>
  ((CMW_VD66GY_t *)io_ctx)->IsInitialized = 1;
34011a06:	2301      	movs	r3, #1
34011a08:	f885 311c 	strb.w	r3, [r5, #284]	@ 0x11c
    return CMW_ERROR_NONE;
34011a0c:	2000      	movs	r0, #0
34011a0e:	e7e2      	b.n	340119d6 <CMW_VD66GY_Init+0xae>
34011a10:	34020761 	.word	0x34020761
34011a14:	340a707c 	.word	0x340a707c
34011a18:	34020842 	.word	0x34020842

34011a1c <VD66GY_RegisterBusIO>:

int32_t VD66GY_RegisterBusIO(CMW_VD66GY_t *io_ctx)
{
  int ret;

  if (!io_ctx)
34011a1c:	b118      	cbz	r0, 34011a26 <VD66GY_RegisterBusIO+0xa>
    return CMW_ERROR_COMPONENT_FAILURE;

  if (!io_ctx->Init)
34011a1e:	f8d0 3120 	ldr.w	r3, [r0, #288]	@ 0x120
34011a22:	b103      	cbz	r3, 34011a26 <VD66GY_RegisterBusIO+0xa>
    return CMW_ERROR_COMPONENT_FAILURE;

  ret = io_ctx->Init();
34011a24:	4718      	bx	r3

  return ret;
}
34011a26:	f06f 0004 	mvn.w	r0, #4
34011a2a:	4770      	bx	lr

34011a2c <VD66GY_ReadID>:

int32_t VD66GY_ReadID(CMW_VD66GY_t *io_ctx, uint32_t *Id)
{
34011a2c:	b513      	push	{r0, r1, r4, lr}
34011a2e:	460c      	mov	r4, r1
  uint16_t reg16;
  int32_t ret;

  ret = CMW_VD66GY_Read16(io_ctx, VD66GY_REG_MODEL_ID, &reg16);
34011a30:	f10d 0206 	add.w	r2, sp, #6
34011a34:	2100      	movs	r1, #0
34011a36:	f7ff fca7 	bl	34011388 <CMW_VD66GY_Read16>
  if (ret)
34011a3a:	b910      	cbnz	r0, 34011a42 <VD66GY_ReadID+0x16>
    return ret;

  *Id = reg16;
34011a3c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
34011a40:	6023      	str	r3, [r4, #0]

  return CMW_ERROR_NONE;
}
34011a42:	b002      	add	sp, #8
34011a44:	bd10      	pop	{r4, pc}
	...

34011a48 <CMW_VD66GY_Probe>:
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
  HAL_Delay(20);     /* NRST de-asserted during 20ms */
}

int CMW_VD66GY_Probe(CMW_VD66GY_t *io_ctx, CMW_Sensor_if_t *vd6g_if)
{
34011a48:	b537      	push	{r0, r1, r2, r4, r5, lr}
34011a4a:	4604      	mov	r4, r0
  int ret = CMW_ERROR_NONE;
  uint32_t id;

  io_ctx->ctx_driver.shutdown_pin = VD6G_ShutdownPin;
34011a4c:	4b2e      	ldr	r3, [pc, #184]	@ (34011b08 <CMW_VD66GY_Probe+0xc0>)
{
34011a4e:	460d      	mov	r5, r1
  io_ctx->ctx_driver.shutdown_pin = VD6G_ShutdownPin;
34011a50:	6043      	str	r3, [r0, #4]
  io_ctx->ctx_driver.read8 = VD6G_Read8;
34011a52:	4b2e      	ldr	r3, [pc, #184]	@ (34011b0c <CMW_VD66GY_Probe+0xc4>)
34011a54:	6083      	str	r3, [r0, #8]
  io_ctx->ctx_driver.read16 = VD6G_Read16;
34011a56:	4b2e      	ldr	r3, [pc, #184]	@ (34011b10 <CMW_VD66GY_Probe+0xc8>)
34011a58:	60c3      	str	r3, [r0, #12]
  io_ctx->ctx_driver.read32 = VD6G_Read32;
34011a5a:	4b2e      	ldr	r3, [pc, #184]	@ (34011b14 <CMW_VD66GY_Probe+0xcc>)
34011a5c:	6103      	str	r3, [r0, #16]
  io_ctx->ctx_driver.write8 = VD6G_Write8;
34011a5e:	4b2e      	ldr	r3, [pc, #184]	@ (34011b18 <CMW_VD66GY_Probe+0xd0>)
34011a60:	6143      	str	r3, [r0, #20]
  io_ctx->ctx_driver.write16 = VD6G_Write16;
34011a62:	4b2e      	ldr	r3, [pc, #184]	@ (34011b1c <CMW_VD66GY_Probe+0xd4>)
34011a64:	6183      	str	r3, [r0, #24]
  io_ctx->ctx_driver.write32 = VD6G_Write32;
34011a66:	4b2e      	ldr	r3, [pc, #184]	@ (34011b20 <CMW_VD66GY_Probe+0xd8>)
34011a68:	61c3      	str	r3, [r0, #28]
  io_ctx->ctx_driver.write_array = VD6G_WriteArray;
34011a6a:	4b2e      	ldr	r3, [pc, #184]	@ (34011b24 <CMW_VD66GY_Probe+0xdc>)
34011a6c:	6203      	str	r3, [r0, #32]
  io_ctx->ctx_driver.delay = VD6G_Delay;
34011a6e:	4b2e      	ldr	r3, [pc, #184]	@ (34011b28 <CMW_VD66GY_Probe+0xe0>)
34011a70:	6243      	str	r3, [r0, #36]	@ 0x24
  io_ctx->ctx_driver.log = VD6G_Log;
34011a72:	4b2e      	ldr	r3, [pc, #184]	@ (34011b2c <CMW_VD66GY_Probe+0xe4>)
34011a74:	6283      	str	r3, [r0, #40]	@ 0x28
  io_ctx->EnablePin(1);
34011a76:	f8d0 313c 	ldr.w	r3, [r0, #316]	@ 0x13c
34011a7a:	2001      	movs	r0, #1
34011a7c:	4798      	blx	r3
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
34011a7e:	f8d4 3138 	ldr.w	r3, [r4, #312]	@ 0x138
34011a82:	2000      	movs	r0, #0
34011a84:	4798      	blx	r3
  HAL_Delay(200);   /* NRST signals asserted during 200ms */
34011a86:	20c8      	movs	r0, #200	@ 0xc8
34011a88:	f7f3 f9fe 	bl	34004e88 <HAL_Delay>
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
34011a8c:	2001      	movs	r0, #1
34011a8e:	f8d4 3138 	ldr.w	r3, [r4, #312]	@ 0x138
34011a92:	4798      	blx	r3
  HAL_Delay(20);     /* NRST de-asserted during 20ms */
34011a94:	2014      	movs	r0, #20
34011a96:	f7f3 f9f7 	bl	34004e88 <HAL_Delay>

  CMW_VD66GY_PowerOn(io_ctx);

  ret = VD66GY_RegisterBusIO(io_ctx);
34011a9a:	4620      	mov	r0, r4
34011a9c:	f7ff ffbe 	bl	34011a1c <VD66GY_RegisterBusIO>
  if (ret != CMW_ERROR_NONE)
34011aa0:	b120      	cbz	r0, 34011aac <CMW_VD66GY_Probe+0x64>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
34011aa2:	f06f 0404 	mvn.w	r4, #4
  vd6g_if->SetExposureMode = CMW_VD66GY_SetExposureMode;
  vd6g_if->SetWBRefMode = CMW_VD66GY_SetWBRefMode;
  vd6g_if->ListWBRefModes = CMW_VD66GY_ListWBRefModes;
  vd6g_if->GetSensorInfo = CMW_VD66GY_GetSensorInfo;
  return ret;
}
34011aa6:	4620      	mov	r0, r4
34011aa8:	b003      	add	sp, #12
34011aaa:	bd30      	pop	{r4, r5, pc}
  ret = VD66GY_ReadID(io_ctx, &id);
34011aac:	4620      	mov	r0, r4
34011aae:	a901      	add	r1, sp, #4
34011ab0:	f7ff ffbc 	bl	34011a2c <VD66GY_ReadID>
  if (ret != CMW_ERROR_NONE)
34011ab4:	4604      	mov	r4, r0
34011ab6:	2800      	cmp	r0, #0
34011ab8:	d1f3      	bne.n	34011aa2 <CMW_VD66GY_Probe+0x5a>
  if (id != VD66GY_CHIP_ID)
34011aba:	f245 6303 	movw	r3, #22019	@ 0x5603
34011abe:	9a01      	ldr	r2, [sp, #4]
34011ac0:	429a      	cmp	r2, r3
34011ac2:	d1ee      	bne.n	34011aa2 <CMW_VD66GY_Probe+0x5a>
  memset(vd6g_if, 0, sizeof(*vd6g_if));
34011ac4:	4601      	mov	r1, r0
34011ac6:	224c      	movs	r2, #76	@ 0x4c
34011ac8:	f105 001c 	add.w	r0, r5, #28
34011acc:	f008 fb2a 	bl	3401a124 <memset>
  vd6g_if->Init = CMW_VD66GY_Init;
34011ad0:	4b17      	ldr	r3, [pc, #92]	@ (34011b30 <CMW_VD66GY_Probe+0xe8>)
34011ad2:	602b      	str	r3, [r5, #0]
  vd6g_if->DeInit = CMW_VD66GY_DeInit;
34011ad4:	4b17      	ldr	r3, [pc, #92]	@ (34011b34 <CMW_VD66GY_Probe+0xec>)
34011ad6:	606b      	str	r3, [r5, #4]
  vd6g_if->Run = CMW_VD66GY_Run;
34011ad8:	4b17      	ldr	r3, [pc, #92]	@ (34011b38 <CMW_VD66GY_Probe+0xf0>)
34011ada:	60eb      	str	r3, [r5, #12]
  vd6g_if->VsyncEventCallback = CMW_VD66GY_VsyncEventCallback;
34011adc:	4b17      	ldr	r3, [pc, #92]	@ (34011b3c <CMW_VD66GY_Probe+0xf4>)
34011ade:	612b      	str	r3, [r5, #16]
  vd6g_if->FrameEventCallback = CMW_VD66GY_FrameEventCallback;
34011ae0:	4b17      	ldr	r3, [pc, #92]	@ (34011b40 <CMW_VD66GY_Probe+0xf8>)
34011ae2:	616b      	str	r3, [r5, #20]
  vd6g_if->Start = CMW_VD66GY_Start;
34011ae4:	4b17      	ldr	r3, [pc, #92]	@ (34011b44 <CMW_VD66GY_Probe+0xfc>)
34011ae6:	60ab      	str	r3, [r5, #8]
  vd6g_if->Stop = CMW_VD66GY_Stop;
34011ae8:	4b17      	ldr	r3, [pc, #92]	@ (34011b48 <CMW_VD66GY_Probe+0x100>)
34011aea:	61ab      	str	r3, [r5, #24]
  vd6g_if->SetGain = CMW_VD66GY_SetGain;
34011aec:	4b17      	ldr	r3, [pc, #92]	@ (34011b4c <CMW_VD66GY_Probe+0x104>)
34011aee:	64ab      	str	r3, [r5, #72]	@ 0x48
  vd6g_if->SetExposure = CMW_VD66GY_SetExposure;
34011af0:	4b17      	ldr	r3, [pc, #92]	@ (34011b50 <CMW_VD66GY_Probe+0x108>)
34011af2:	64eb      	str	r3, [r5, #76]	@ 0x4c
  vd6g_if->SetExposureMode = CMW_VD66GY_SetExposureMode;
34011af4:	4b17      	ldr	r3, [pc, #92]	@ (34011b54 <CMW_VD66GY_Probe+0x10c>)
34011af6:	652b      	str	r3, [r5, #80]	@ 0x50
  vd6g_if->SetWBRefMode = CMW_VD66GY_SetWBRefMode;
34011af8:	4b17      	ldr	r3, [pc, #92]	@ (34011b58 <CMW_VD66GY_Probe+0x110>)
34011afa:	656b      	str	r3, [r5, #84]	@ 0x54
  vd6g_if->ListWBRefModes = CMW_VD66GY_ListWBRefModes;
34011afc:	4b17      	ldr	r3, [pc, #92]	@ (34011b5c <CMW_VD66GY_Probe+0x114>)
34011afe:	65ab      	str	r3, [r5, #88]	@ 0x58
  vd6g_if->GetSensorInfo = CMW_VD66GY_GetSensorInfo;
34011b00:	4b17      	ldr	r3, [pc, #92]	@ (34011b60 <CMW_VD66GY_Probe+0x118>)
34011b02:	662b      	str	r3, [r5, #96]	@ 0x60
  return ret;
34011b04:	e7cf      	b.n	34011aa6 <CMW_VD66GY_Probe+0x5e>
34011b06:	bf00      	nop
34011b08:	340113a5 	.word	0x340113a5
34011b0c:	340113ad 	.word	0x340113ad
34011b10:	340113c1 	.word	0x340113c1
34011b14:	340113c7 	.word	0x340113c7
34011b18:	340113e5 	.word	0x340113e5
34011b1c:	340113ff 	.word	0x340113ff
34011b20:	34011419 	.word	0x34011419
34011b24:	34011431 	.word	0x34011431
34011b28:	34011475 	.word	0x34011475
34011b2c:	3401147d 	.word	0x3401147d
34011b30:	34011929 	.word	0x34011929
34011b34:	3401187d 	.word	0x3401187d
34011b38:	340118a1 	.word	0x340118a1
34011b3c:	340118b5 	.word	0x340118b5
34011b40:	3401147f 	.word	0x3401147f
34011b44:	34011835 	.word	0x34011835
34011b48:	34011821 	.word	0x34011821
34011b4c:	34011481 	.word	0x34011481
34011b50:	3401166d 	.word	0x3401166d
34011b54:	34011673 	.word	0x34011673
34011b58:	34011691 	.word	0x34011691
34011b5c:	340116a5 	.word	0x340116a5
34011b60:	340116b9 	.word	0x340116b9

34011b64 <IMX335_ReadRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_ReadRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
34011b64:	b410      	push	{r4}
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
34011b66:	6904      	ldr	r4, [r0, #16]
34011b68:	8900      	ldrh	r0, [r0, #8]
34011b6a:	46a4      	mov	ip, r4
}
34011b6c:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
34011b70:	4760      	bx	ip

34011b72 <IMX335_WriteRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_WriteRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
34011b72:	b410      	push	{r4}
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
34011b74:	68c4      	ldr	r4, [r0, #12]
34011b76:	8900      	ldrh	r0, [r0, #8]
34011b78:	46a4      	mov	ip, r4
}
34011b7a:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
34011b7e:	4760      	bx	ip

34011b80 <IMX335_WriteTable>:
{
34011b80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int32_t ret = IMX335_OK;
34011b82:	2500      	movs	r5, #0
34011b84:	1c8c      	adds	r4, r1, #2
34011b86:	eb04 0682 	add.w	r6, r4, r2, lsl #2
      if(imx335_write_reg(&pObj->Ctx, regs[index].addr, (uint8_t *)&(regs[index].val), 1) != IMX335_OK)
34011b8a:	f100 0718 	add.w	r7, r0, #24
    if(ret != IMX335_ERROR)
34011b8e:	b135      	cbz	r5, 34011b9e <IMX335_WriteTable+0x1e>
  int32_t ret = IMX335_OK;
34011b90:	f04f 35ff 	mov.w	r5, #4294967295
  for(index=0; index<size ; index++)
34011b94:	3404      	adds	r4, #4
34011b96:	42b4      	cmp	r4, r6
34011b98:	d1f9      	bne.n	34011b8e <IMX335_WriteTable+0xe>
}
34011b9a:	4628      	mov	r0, r5
34011b9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(imx335_write_reg(&pObj->Ctx, regs[index].addr, (uint8_t *)&(regs[index].val), 1) != IMX335_OK)
34011b9e:	2301      	movs	r3, #1
34011ba0:	4622      	mov	r2, r4
34011ba2:	4638      	mov	r0, r7
34011ba4:	f834 1c02 	ldrh.w	r1, [r4, #-2]
34011ba8:	f000 f99d 	bl	34011ee6 <imx335_write_reg>
34011bac:	2800      	cmp	r0, #0
34011bae:	d1ef      	bne.n	34011b90 <IMX335_WriteTable+0x10>
34011bb0:	e7f0      	b.n	34011b94 <IMX335_WriteTable+0x14>
	...

34011bb4 <IMX335_RegisterBusIO>:
  */
int32_t IMX335_RegisterBusIO(IMX335_Object_t *pObj, IMX335_IO_t *pIO)
{
  int32_t ret;

  if (pObj == NULL)
34011bb4:	b190      	cbz	r0, 34011bdc <IMX335_RegisterBusIO+0x28>
    ret = IMX335_ERROR;
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
    pObj->IO.DeInit    = pIO->DeInit;
34011bb6:	684a      	ldr	r2, [r1, #4]
    pObj->IO.Init      = pIO->Init;
34011bb8:	680b      	ldr	r3, [r1, #0]
    pObj->IO.DeInit    = pIO->DeInit;
34011bba:	6042      	str	r2, [r0, #4]
    pObj->IO.Address   = pIO->Address;
34011bbc:	890a      	ldrh	r2, [r1, #8]
    pObj->IO.Init      = pIO->Init;
34011bbe:	6003      	str	r3, [r0, #0]
    pObj->IO.Address   = pIO->Address;
34011bc0:	8102      	strh	r2, [r0, #8]
    pObj->IO.WriteReg  = pIO->WriteReg;
34011bc2:	68ca      	ldr	r2, [r1, #12]
34011bc4:	60c2      	str	r2, [r0, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
34011bc6:	690a      	ldr	r2, [r1, #16]
34011bc8:	6102      	str	r2, [r0, #16]
    pObj->IO.GetTick   = pIO->GetTick;
34011bca:	694a      	ldr	r2, [r1, #20]

    pObj->Ctx.ReadReg  = IMX335_ReadRegWrap;
    pObj->Ctx.WriteReg = IMX335_WriteRegWrap;
    pObj->Ctx.handle   = pObj;
34011bcc:	6200      	str	r0, [r0, #32]
    pObj->IO.GetTick   = pIO->GetTick;
34011bce:	6142      	str	r2, [r0, #20]
    pObj->Ctx.ReadReg  = IMX335_ReadRegWrap;
34011bd0:	4a04      	ldr	r2, [pc, #16]	@ (34011be4 <IMX335_RegisterBusIO+0x30>)
34011bd2:	61c2      	str	r2, [r0, #28]
    pObj->Ctx.WriteReg = IMX335_WriteRegWrap;
34011bd4:	4a04      	ldr	r2, [pc, #16]	@ (34011be8 <IMX335_RegisterBusIO+0x34>)
34011bd6:	6182      	str	r2, [r0, #24]

    if(pObj->IO.Init != NULL)
34011bd8:	b103      	cbz	r3, 34011bdc <IMX335_RegisterBusIO+0x28>
    {
      ret = pObj->IO.Init();
34011bda:	4718      	bx	r3
      ret = IMX335_ERROR;
    }
  }

  return ret;
}
34011bdc:	f04f 30ff 	mov.w	r0, #4294967295
34011be0:	4770      	bx	lr
34011be2:	bf00      	nop
34011be4:	34011b65 	.word	0x34011b65
34011be8:	34011b73 	.word	0x34011b73

34011bec <IMX335_Init>:
  * @param  Resolution  Camera resolution
  * @param  PixelFormat pixel format to be configured
  * @retval Component status
  */
int32_t IMX335_Init(IMX335_Object_t *pObj, uint32_t Resolution, uint32_t PixelFormat)
{
34011bec:	b510      	push	{r4, lr}
  int32_t ret = IMX335_OK;

  if(pObj->IsInitialized == 0U)
34011bee:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
{
34011bf2:	4604      	mov	r4, r0
  if(pObj->IsInitialized == 0U)
34011bf4:	b9a3      	cbnz	r3, 34011c20 <IMX335_Init+0x34>
  {
    switch (Resolution)
34011bf6:	2906      	cmp	r1, #6
34011bf8:	d002      	beq.n	34011c00 <IMX335_Init+0x14>
        }
        break;
      /* Add new resolution here */
      default:
        /* Resolution not supported */
        ret = IMX335_ERROR;
34011bfa:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

  return ret;
}
34011bfe:	bd10      	pop	{r4, pc}
        if(IMX335_WriteTable(pObj, res_2592_1944_regs, ARRAY_SIZE(res_2592_1944_regs)) != IMX335_OK)
34011c00:	2254      	movs	r2, #84	@ 0x54
34011c02:	4908      	ldr	r1, [pc, #32]	@ (34011c24 <IMX335_Init+0x38>)
34011c04:	f7ff ffbc 	bl	34011b80 <IMX335_WriteTable>
34011c08:	2800      	cmp	r0, #0
34011c0a:	d1f6      	bne.n	34011bfa <IMX335_Init+0xe>
      if(IMX335_WriteTable(pObj, mode_2l_10b_regs, ARRAY_SIZE(mode_2l_10b_regs)) != IMX335_OK)
34011c0c:	2205      	movs	r2, #5
34011c0e:	4620      	mov	r0, r4
34011c10:	4905      	ldr	r1, [pc, #20]	@ (34011c28 <IMX335_Init+0x3c>)
34011c12:	f7ff ffb5 	bl	34011b80 <IMX335_WriteTable>
34011c16:	2800      	cmp	r0, #0
34011c18:	d1ef      	bne.n	34011bfa <IMX335_Init+0xe>
        pObj->IsInitialized = 1U;
34011c1a:	2301      	movs	r3, #1
34011c1c:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
  int32_t ret = IMX335_OK;
34011c20:	2000      	movs	r0, #0
  return ret;
34011c22:	e7ec      	b.n	34011bfe <IMX335_Init+0x12>
34011c24:	340a74a8 	.word	0x340a74a8
34011c28:	340a7494 	.word	0x340a7494

34011c2c <IMX335_Start>:
int32_t IMX335_Start(IMX335_Object_t *pObj)
{
  uint8_t tmp;
  int32_t ret = IMX335_OK;
  /* Start streaming */
  tmp = IMX335_MODE_STREAMING;
34011c2c:	2300      	movs	r3, #0
{
34011c2e:	b573      	push	{r0, r1, r4, r5, r6, lr}
34011c30:	4605      	mov	r5, r0
  tmp = IMX335_MODE_STREAMING;
34011c32:	f88d 3007 	strb.w	r3, [sp, #7]
  ret = imx335_write_reg(&pObj->Ctx, IMX335_REG_MODE_SELECT, &tmp, 1);
34011c36:	f44f 5140 	mov.w	r1, #12288	@ 0x3000
34011c3a:	2301      	movs	r3, #1
34011c3c:	f10d 0207 	add.w	r2, sp, #7
34011c40:	3018      	adds	r0, #24
34011c42:	f000 f950 	bl	34011ee6 <imx335_write_reg>
  if (ret != IMX335_OK)
34011c46:	4604      	mov	r4, r0
34011c48:	b950      	cbnz	r0, 34011c60 <IMX335_Start+0x34>
  tickstart = pObj->IO.GetTick();
34011c4a:	696b      	ldr	r3, [r5, #20]
34011c4c:	4798      	blx	r3
34011c4e:	4606      	mov	r6, r0
  while((pObj->IO.GetTick() - tickstart) < Delay)
34011c50:	696b      	ldr	r3, [r5, #20]
34011c52:	4798      	blx	r3
34011c54:	1b83      	subs	r3, r0, r6
34011c56:	2b13      	cmp	r3, #19
34011c58:	d9fa      	bls.n	34011c50 <IMX335_Start+0x24>
  {
    return IMX335_ERROR;
  }
  IMX335_Delay(pObj, 20);
  return ret;
}
34011c5a:	4620      	mov	r0, r4
34011c5c:	b002      	add	sp, #8
34011c5e:	bd70      	pop	{r4, r5, r6, pc}
    return IMX335_ERROR;
34011c60:	f04f 34ff 	mov.w	r4, #4294967295
34011c64:	e7f9      	b.n	34011c5a <IMX335_Start+0x2e>

34011c66 <IMX335_DeInit>:
  * @param  pObj  pointer to component object
  * @retval Component status
  */
int32_t IMX335_DeInit(IMX335_Object_t *pObj)
{
  if(pObj->IsInitialized == 1U)
34011c66:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
34011c6a:	2b01      	cmp	r3, #1
  {
    /* De-initialize camera sensor interface */
    pObj->IsInitialized = 0U;
34011c6c:	bf04      	itt	eq
34011c6e:	2300      	moveq	r3, #0
34011c70:	f880 3024 	strbeq.w	r3, [r0, #36]	@ 0x24
  }

  return IMX335_OK;
}
34011c74:	2000      	movs	r0, #0
34011c76:	4770      	bx	lr

34011c78 <IMX335_ReadID>:
  * @param  pObj  pointer to component object
  * @param  Id    pointer to component ID
  * @retval Component status
  */
int32_t IMX335_ReadID(IMX335_Object_t *pObj, uint32_t *Id)
{
34011c78:	b537      	push	{r0, r1, r2, r4, r5, lr}
  int32_t ret;
  uint8_t tmp;

  /* Initialize I2C */
  pObj->IO.Init();
34011c7a:	4604      	mov	r4, r0
34011c7c:	f854 3b18 	ldr.w	r3, [r4], #24
{
34011c80:	460d      	mov	r5, r1
  pObj->IO.Init();
34011c82:	4798      	blx	r3

  if(imx335_read_reg(&pObj->Ctx, IMX335_REG_ID, &tmp, 1)!= IMX335_OK)
34011c84:	2301      	movs	r3, #1
34011c86:	f643 1112 	movw	r1, #14610	@ 0x3912
34011c8a:	4620      	mov	r0, r4
34011c8c:	f10d 0207 	add.w	r2, sp, #7
34011c90:	f000 f922 	bl	34011ed8 <imx335_read_reg>
34011c94:	b920      	cbnz	r0, 34011ca0 <IMX335_ReadID+0x28>
  {
    ret = IMX335_ERROR;
  }
  else
  {
    *Id = tmp;
34011c96:	f89d 3007 	ldrb.w	r3, [sp, #7]
34011c9a:	602b      	str	r3, [r5, #0]
    ret = IMX335_OK;
  }

  /* Component status */
  return ret;
}
34011c9c:	b003      	add	sp, #12
34011c9e:	bd30      	pop	{r4, r5, pc}
    ret = IMX335_ERROR;
34011ca0:	f04f 30ff 	mov.w	r0, #4294967295
  return ret;
34011ca4:	e7fa      	b.n	34011c9c <IMX335_ReadID+0x24>
	...

34011ca8 <IMX335_SetGain>:
  * @param  pObj  pointer to component object
  * @param  Gain Gain in mdB
  * @retval Component status
  */
int32_t IMX335_SetGain(IMX335_Object_t *pObj, int32_t gain)
{
34011ca8:	b530      	push	{r4, r5, lr}
  int32_t ret = IMX335_OK;
  uint8_t hold;

  if ((gain > IMX335_GAIN_MAX) || (gain < IMX335_GAIN_MIN))
34011caa:	4b1a      	ldr	r3, [pc, #104]	@ (34011d14 <IMX335_SetGain+0x6c>)
{
34011cac:	b085      	sub	sp, #20
  if ((gain > IMX335_GAIN_MAX) || (gain < IMX335_GAIN_MIN))
34011cae:	4299      	cmp	r1, r3
34011cb0:	d903      	bls.n	34011cba <IMX335_SetGain+0x12>
  {
    ret = IMX335_ERROR;
34011cb2:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

return ret;
}
34011cb6:	b005      	add	sp, #20
34011cb8:	bd30      	pop	{r4, r5, pc}
    gain /= IMX335_GAIN_UNIT_MDB;
34011cba:	f44f 7396 	mov.w	r3, #300	@ 0x12c
    hold = 1;
34011cbe:	2501      	movs	r5, #1
    gain /= IMX335_GAIN_UNIT_MDB;
34011cc0:	fb91 f1f3 	sdiv	r1, r1, r3
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011cc4:	f100 0418 	add.w	r4, r0, #24
    gain /= IMX335_GAIN_UNIT_MDB;
34011cc8:	9101      	str	r1, [sp, #4]
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011cca:	462b      	mov	r3, r5
34011ccc:	f243 0101 	movw	r1, #12289	@ 0x3001
34011cd0:	4620      	mov	r0, r4
34011cd2:	f10d 020f 	add.w	r2, sp, #15
    hold = 1;
34011cd6:	f88d 500f 	strb.w	r5, [sp, #15]
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011cda:	f000 f904 	bl	34011ee6 <imx335_write_reg>
34011cde:	2800      	cmp	r0, #0
34011ce0:	d1e7      	bne.n	34011cb2 <IMX335_SetGain+0xa>
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_GAIN, (uint8_t *)&gain, 2) != IMX335_OK)
34011ce2:	2302      	movs	r3, #2
34011ce4:	f243 01e8 	movw	r1, #12520	@ 0x30e8
34011ce8:	4620      	mov	r0, r4
34011cea:	aa01      	add	r2, sp, #4
34011cec:	f000 f8fb 	bl	34011ee6 <imx335_write_reg>
34011cf0:	2800      	cmp	r0, #0
34011cf2:	d1de      	bne.n	34011cb2 <IMX335_SetGain+0xa>
        hold = 0;
34011cf4:	f88d 000f 	strb.w	r0, [sp, #15]
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011cf8:	462b      	mov	r3, r5
34011cfa:	f243 0101 	movw	r1, #12289	@ 0x3001
34011cfe:	4620      	mov	r0, r4
34011d00:	f10d 020f 	add.w	r2, sp, #15
34011d04:	f000 f8ef 	bl	34011ee6 <imx335_write_reg>
34011d08:	3800      	subs	r0, #0
34011d0a:	bf18      	it	ne
34011d0c:	2001      	movne	r0, #1
34011d0e:	4240      	negs	r0, r0
return ret;
34011d10:	e7d1      	b.n	34011cb6 <IMX335_SetGain+0xe>
34011d12:	bf00      	nop
34011d14:	00011940 	.word	0x00011940

34011d18 <IMX335_SetExposure>:
  * @param  pObj  pointer to component object
  * @param  Exposure Exposure in micro seconds
  * @retval Component status
  */
int32_t IMX335_SetExposure(IMX335_Object_t *pObj, int32_t exposure)
{
34011d18:	b530      	push	{r4, r5, lr}
34011d1a:	ed2d 8b02 	vpush	{d8}
  int32_t ret = IMX335_OK;
  uint32_t vmax, shutter;
  uint8_t hold;


  if (imx335_read_reg(&pObj->Ctx, IMX335_REG_VMAX, (uint8_t *)&vmax, 4) != IMX335_OK)
34011d1e:	f100 0418 	add.w	r4, r0, #24
{
34011d22:	b085      	sub	sp, #20
34011d24:	ee08 1a10 	vmov	s16, r1
  if (imx335_read_reg(&pObj->Ctx, IMX335_REG_VMAX, (uint8_t *)&vmax, 4) != IMX335_OK)
34011d28:	2304      	movs	r3, #4
34011d2a:	f243 0130 	movw	r1, #12336	@ 0x3030
34011d2e:	4620      	mov	r0, r4
34011d30:	aa02      	add	r2, sp, #8
34011d32:	f000 f8d1 	bl	34011ed8 <imx335_read_reg>
34011d36:	b128      	cbz	r0, 34011d44 <IMX335_SetExposure+0x2c>
  {
    ret = IMX335_ERROR;
34011d38:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

  return ret;
}
34011d3c:	b005      	add	sp, #20
34011d3e:	ecbd 8b02 	vpop	{d8}
34011d42:	bd30      	pop	{r4, r5, pc}
    shutter = (uint32_t) (vmax - (exposure / IMX335_1H_PERIOD_USEC));
34011d44:	eddd 7a02 	vldr	s15, [sp, #8]
34011d48:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
34011d4c:	eddf 6a1a 	vldr	s13, [pc, #104]	@ 34011db8 <IMX335_SetExposure+0xa0>
34011d50:	eef8 7a67 	vcvt.f32.u32	s15, s15
34011d54:	ee88 7a26 	vdiv.f32	s14, s16, s13
34011d58:	ee77 7ac7 	vsub.f32	s15, s15, s14
34011d5c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34011d60:	ee17 3a90 	vmov	r3, s15
    if (shutter < IMX335_SHUTTER_MIN)
34011d64:	2b08      	cmp	r3, #8
    shutter = (uint32_t) (vmax - (exposure / IMX335_1H_PERIOD_USEC));
34011d66:	edcd 7a03 	vstr	s15, [sp, #12]
    if (shutter < IMX335_SHUTTER_MIN)
34011d6a:	d9e5      	bls.n	34011d38 <IMX335_SetExposure+0x20>
      hold = 1;
34011d6c:	2501      	movs	r5, #1
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011d6e:	f243 0101 	movw	r1, #12289	@ 0x3001
34011d72:	462b      	mov	r3, r5
34011d74:	4620      	mov	r0, r4
34011d76:	f10d 0207 	add.w	r2, sp, #7
      hold = 1;
34011d7a:	f88d 5007 	strb.w	r5, [sp, #7]
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011d7e:	f000 f8b2 	bl	34011ee6 <imx335_write_reg>
34011d82:	2800      	cmp	r0, #0
34011d84:	d1d8      	bne.n	34011d38 <IMX335_SetExposure+0x20>
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_SHUTTER, (uint8_t *)&shutter, 3) != IMX335_OK)
34011d86:	2303      	movs	r3, #3
34011d88:	f243 0158 	movw	r1, #12376	@ 0x3058
34011d8c:	4620      	mov	r0, r4
34011d8e:	aa03      	add	r2, sp, #12
34011d90:	f000 f8a9 	bl	34011ee6 <imx335_write_reg>
34011d94:	2800      	cmp	r0, #0
34011d96:	d1cf      	bne.n	34011d38 <IMX335_SetExposure+0x20>
          hold = 0;
34011d98:	f88d 0007 	strb.w	r0, [sp, #7]
          if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011d9c:	462b      	mov	r3, r5
34011d9e:	f243 0101 	movw	r1, #12289	@ 0x3001
34011da2:	4620      	mov	r0, r4
34011da4:	f10d 0207 	add.w	r2, sp, #7
34011da8:	f000 f89d 	bl	34011ee6 <imx335_write_reg>
34011dac:	3800      	subs	r0, #0
34011dae:	bf18      	it	ne
34011db0:	2001      	movne	r0, #1
34011db2:	4240      	negs	r0, r0
  return ret;
34011db4:	e7c2      	b.n	34011d3c <IMX335_SetExposure+0x24>
34011db6:	bf00      	nop
34011db8:	40ed097c 	.word	0x40ed097c

34011dbc <IMX335_SetFrequency>:
  */
int32_t IMX335_SetFrequency(IMX335_Object_t *pObj, int32_t frequency)
{
  uint32_t ret = IMX335_OK;

  switch (frequency)
34011dbc:	3901      	subs	r1, #1
        ret = IMX335_ERROR;
      }
      break;
    default:
      /* IMX335_INCK_6MHZ */
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
34011dbe:	2207      	movs	r2, #7
{
34011dc0:	b508      	push	{r3, lr}
  switch (frequency)
34011dc2:	2903      	cmp	r1, #3
34011dc4:	d811      	bhi.n	34011dea <IMX335_SetFrequency+0x2e>
34011dc6:	e8df f001 	tbb	[pc, r1]
34011dca:	0c0e      	.short	0x0c0e
34011dcc:	020a      	.short	0x020a
      if(IMX335_WriteTable(pObj, inck_74Mhz_regs, ARRAY_SIZE(inck_74Mhz_regs)) != IMX335_OK)
34011dce:	4908      	ldr	r1, [pc, #32]	@ (34011df0 <IMX335_SetFrequency+0x34>)
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
34011dd0:	f7ff fed6 	bl	34011b80 <IMX335_WriteTable>
34011dd4:	3800      	subs	r0, #0
34011dd6:	bf18      	it	ne
34011dd8:	2001      	movne	r0, #1
34011dda:	4240      	negs	r0, r0
      }
      break;
  };

  return ret;
}
34011ddc:	bd08      	pop	{r3, pc}
      if(IMX335_WriteTable(pObj, inck_27Mhz_regs, ARRAY_SIZE(inck_27Mhz_regs)) != IMX335_OK)
34011dde:	4905      	ldr	r1, [pc, #20]	@ (34011df4 <IMX335_SetFrequency+0x38>)
34011de0:	e7f6      	b.n	34011dd0 <IMX335_SetFrequency+0x14>
      if(IMX335_WriteTable(pObj, inck_24Mhz_regs, ARRAY_SIZE(inck_24Mhz_regs)) != IMX335_OK)
34011de2:	4905      	ldr	r1, [pc, #20]	@ (34011df8 <IMX335_SetFrequency+0x3c>)
34011de4:	e7f4      	b.n	34011dd0 <IMX335_SetFrequency+0x14>
      if(IMX335_WriteTable(pObj, inck_18Mhz_regs, ARRAY_SIZE(inck_18Mhz_regs)) != IMX335_OK)
34011de6:	4905      	ldr	r1, [pc, #20]	@ (34011dfc <IMX335_SetFrequency+0x40>)
34011de8:	e7f2      	b.n	34011dd0 <IMX335_SetFrequency+0x14>
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
34011dea:	4905      	ldr	r1, [pc, #20]	@ (34011e00 <IMX335_SetFrequency+0x44>)
34011dec:	e7f0      	b.n	34011dd0 <IMX335_SetFrequency+0x14>
34011dee:	bf00      	nop
34011df0:	340a7478 	.word	0x340a7478
34011df4:	340a745c 	.word	0x340a745c
34011df8:	340a7440 	.word	0x340a7440
34011dfc:	340a7424 	.word	0x340a7424
34011e00:	340a7408 	.word	0x340a7408

34011e04 <IMX335_SetFramerate>:
  * @retval Component status
  */
int32_t IMX335_SetFramerate(IMX335_Object_t *pObj, int32_t framerate)
{
  uint32_t ret = IMX335_OK;
  switch (framerate)
34011e04:	2914      	cmp	r1, #20
{
34011e06:	b508      	push	{r3, lr}
34011e08:	4603      	mov	r3, r0
  switch (framerate)
34011e0a:	d019      	beq.n	34011e40 <IMX335_SetFramerate+0x3c>
34011e0c:	dc07      	bgt.n	34011e1e <IMX335_SetFramerate+0x1a>
34011e0e:	290a      	cmp	r1, #10
34011e10:	d00a      	beq.n	34011e28 <IMX335_SetFramerate+0x24>
34011e12:	290f      	cmp	r1, #15
34011e14:	d011      	beq.n	34011e3a <IMX335_SetFramerate+0x36>
        ret = IMX335_ERROR;
      }
      break;
    default:
      /* 30fps */
      if(IMX335_WriteTable(pObj, framerate_30fps_regs, ARRAY_SIZE(framerate_30fps_regs)) != IMX335_OK)
34011e16:	2202      	movs	r2, #2
34011e18:	4618      	mov	r0, r3
34011e1a:	490b      	ldr	r1, [pc, #44]	@ (34011e48 <IMX335_SetFramerate+0x44>)
34011e1c:	e006      	b.n	34011e2c <IMX335_SetFramerate+0x28>
  switch (framerate)
34011e1e:	2919      	cmp	r1, #25
34011e20:	d1f9      	bne.n	34011e16 <IMX335_SetFramerate+0x12>
      if(IMX335_WriteTable(pObj, framerate_25fps_regs, ARRAY_SIZE(framerate_25fps_regs)) != IMX335_OK)
34011e22:	2202      	movs	r2, #2
34011e24:	4909      	ldr	r1, [pc, #36]	@ (34011e4c <IMX335_SetFramerate+0x48>)
34011e26:	e001      	b.n	34011e2c <IMX335_SetFramerate+0x28>
      if(IMX335_WriteTable(pObj, framerate_10fps_regs, ARRAY_SIZE(framerate_10fps_regs)) != IMX335_OK)
34011e28:	2202      	movs	r2, #2
34011e2a:	4909      	ldr	r1, [pc, #36]	@ (34011e50 <IMX335_SetFramerate+0x4c>)
      if(IMX335_WriteTable(pObj, framerate_30fps_regs, ARRAY_SIZE(framerate_30fps_regs)) != IMX335_OK)
34011e2c:	f7ff fea8 	bl	34011b80 <IMX335_WriteTable>
34011e30:	3800      	subs	r0, #0
34011e32:	bf18      	it	ne
34011e34:	2001      	movne	r0, #1
34011e36:	4240      	negs	r0, r0
      }
      break;
  };

  return ret;
}
34011e38:	bd08      	pop	{r3, pc}
      if(IMX335_WriteTable(pObj, framerate_15fps_regs, ARRAY_SIZE(framerate_15fps_regs)) != IMX335_OK)
34011e3a:	2202      	movs	r2, #2
34011e3c:	4905      	ldr	r1, [pc, #20]	@ (34011e54 <IMX335_SetFramerate+0x50>)
34011e3e:	e7f5      	b.n	34011e2c <IMX335_SetFramerate+0x28>
      if(IMX335_WriteTable(pObj, framerate_20fps_regs, ARRAY_SIZE(framerate_20fps_regs)) != IMX335_OK)
34011e40:	2202      	movs	r2, #2
34011e42:	4905      	ldr	r1, [pc, #20]	@ (34011e58 <IMX335_SetFramerate+0x54>)
34011e44:	e7f2      	b.n	34011e2c <IMX335_SetFramerate+0x28>
34011e46:	bf00      	nop
34011e48:	340a73e0 	.word	0x340a73e0
34011e4c:	340a73e8 	.word	0x340a73e8
34011e50:	340a7400 	.word	0x340a7400
34011e54:	340a73f8 	.word	0x340a73f8
34011e58:	340a73f0 	.word	0x340a73f0

34011e5c <IMX335_MirrorFlipConfig>:
  */
int32_t IMX335_MirrorFlipConfig(IMX335_Object_t *pObj, uint32_t Config)
{
  int32_t ret = IMX335_OK;

  switch (Config)
34011e5c:	2902      	cmp	r1, #2
    case IMX335_MIRROR_FLIP:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[3], ARRAY_SIZE(mirrorflip_mode_regs[3]));
      break;
    case IMX335_MIRROR_FLIP_NONE:
    default:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
34011e5e:	f04f 020a 	mov.w	r2, #10
  switch (Config)
34011e62:	d006      	beq.n	34011e72 <IMX335_MirrorFlipConfig+0x16>
34011e64:	2903      	cmp	r1, #3
34011e66:	d006      	beq.n	34011e76 <IMX335_MirrorFlipConfig+0x1a>
34011e68:	2901      	cmp	r1, #1
34011e6a:	d106      	bne.n	34011e7a <IMX335_MirrorFlipConfig+0x1e>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[1], ARRAY_SIZE(mirrorflip_mode_regs[1]));
34011e6c:	4904      	ldr	r1, [pc, #16]	@ (34011e80 <IMX335_MirrorFlipConfig+0x24>)
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
34011e6e:	f7ff be87 	b.w	34011b80 <IMX335_WriteTable>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[2], ARRAY_SIZE(mirrorflip_mode_regs[2]));
34011e72:	4904      	ldr	r1, [pc, #16]	@ (34011e84 <IMX335_MirrorFlipConfig+0x28>)
34011e74:	e7fb      	b.n	34011e6e <IMX335_MirrorFlipConfig+0x12>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[3], ARRAY_SIZE(mirrorflip_mode_regs[3]));
34011e76:	4904      	ldr	r1, [pc, #16]	@ (34011e88 <IMX335_MirrorFlipConfig+0x2c>)
34011e78:	e7f9      	b.n	34011e6e <IMX335_MirrorFlipConfig+0x12>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
34011e7a:	4904      	ldr	r1, [pc, #16]	@ (34011e8c <IMX335_MirrorFlipConfig+0x30>)
34011e7c:	e7f7      	b.n	34011e6e <IMX335_MirrorFlipConfig+0x12>
34011e7e:	bf00      	nop
34011e80:	340a7368 	.word	0x340a7368
34011e84:	340a7390 	.word	0x340a7390
34011e88:	340a73b8 	.word	0x340a73b8
34011e8c:	340a7340 	.word	0x340a7340

34011e90 <IMX335_SetTestPattern>:
  *               10: Horizontal color bars
  *               11: Vertical color bars
  * @retval Component status
  */
int32_t IMX335_SetTestPattern(IMX335_Object_t *pObj, int32_t mode)
{
34011e90:	b513      	push	{r0, r1, r4, lr}
  int32_t ret = IMX335_OK;
  uint8_t val;

  if (mode >= 0)
34011e92:	2900      	cmp	r1, #0
{
34011e94:	4604      	mov	r4, r0
  if (mode >= 0)
34011e96:	db15      	blt.n	34011ec4 <IMX335_SetTestPattern+0x34>
  {
    /* Enable Test Pattern #mode */
    val = mode;
34011e98:	f88d 1007 	strb.w	r1, [sp, #7]
    if (imx335_write_reg(&pObj->Ctx, IMX335_REG_TPG, &val, 1) != IMX335_OK)
34011e9c:	2301      	movs	r3, #1
34011e9e:	f243 219e 	movw	r1, #12958	@ 0x329e
34011ea2:	f10d 0207 	add.w	r2, sp, #7
34011ea6:	3018      	adds	r0, #24
34011ea8:	f000 f81d 	bl	34011ee6 <imx335_write_reg>
34011eac:	b968      	cbnz	r0, 34011eca <IMX335_SetTestPattern+0x3a>
    {
      return IMX335_ERROR;
    }
    if (IMX335_WriteTable(pObj, test_pattern_enable_regs, ARRAY_SIZE(test_pattern_enable_regs)) != IMX335_OK)
34011eae:	2207      	movs	r2, #7
34011eb0:	4620      	mov	r0, r4
34011eb2:	4907      	ldr	r1, [pc, #28]	@ (34011ed0 <IMX335_SetTestPattern+0x40>)
    }
  }
  else
  {
    /* Disable Test Pattern */
    if (IMX335_WriteTable(pObj, test_pattern_disable_regs, ARRAY_SIZE(test_pattern_disable_regs)) != IMX335_OK)
34011eb4:	f7ff fe64 	bl	34011b80 <IMX335_WriteTable>
34011eb8:	3800      	subs	r0, #0
34011eba:	bf18      	it	ne
34011ebc:	2001      	movne	r0, #1
34011ebe:	4240      	negs	r0, r0
      return IMX335_ERROR;
    }
  }

  return ret;
}
34011ec0:	b002      	add	sp, #8
34011ec2:	bd10      	pop	{r4, pc}
    if (IMX335_WriteTable(pObj, test_pattern_disable_regs, ARRAY_SIZE(test_pattern_disable_regs)) != IMX335_OK)
34011ec4:	2207      	movs	r2, #7
34011ec6:	4903      	ldr	r1, [pc, #12]	@ (34011ed4 <IMX335_SetTestPattern+0x44>)
34011ec8:	e7f4      	b.n	34011eb4 <IMX335_SetTestPattern+0x24>
      return IMX335_ERROR;
34011eca:	f04f 30ff 	mov.w	r0, #4294967295
34011ece:	e7f7      	b.n	34011ec0 <IMX335_SetTestPattern+0x30>
34011ed0:	340a7324 	.word	0x340a7324
34011ed4:	340a7308 	.word	0x340a7308

34011ed8 <imx335_read_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to read
  * @retval Component status
  */
int32_t imx335_read_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *pdata, uint16_t length)
{
34011ed8:	b410      	push	{r4}
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
34011eda:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
34011ede:	46a4      	mov	ip, r4
}
34011ee0:	f85d 4b04 	ldr.w	r4, [sp], #4
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
34011ee4:	4760      	bx	ip

34011ee6 <imx335_write_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to write
  * @retval Component status
  */
int32_t imx335_write_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *data, uint16_t length)
{
34011ee6:	b410      	push	{r4}
  return ctx->WriteReg(ctx->handle, reg, data, length);
34011ee8:	6804      	ldr	r4, [r0, #0]
34011eea:	6880      	ldr	r0, [r0, #8]
34011eec:	46a4      	mov	ip, r4
}
34011eee:	f85d 4b04 	ldr.w	r4, [sp], #4
  return ctx->WriteReg(ctx->handle, reg, data, length);
34011ef2:	4760      	bx	ip

34011ef4 <VD55G1_log_impl>:
    return NULL;
  }
}

static void VD55G1_log_impl(VD55G1_Ctx_t *ctx, int lvl, const char *format, ...)
{
34011ef4:	b40c      	push	{r2, r3}
34011ef6:	b513      	push	{r0, r1, r4, lr}
  va_list ap;

  if (!ctx->log)
34011ef8:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34011efa:	b11c      	cbz	r4, 34011f04 <VD55G1_log_impl+0x10>
    return ;

  va_start(ap, format);
34011efc:	ab05      	add	r3, sp, #20
  ctx->log(ctx, lvl, format, ap);
34011efe:	9a04      	ldr	r2, [sp, #16]
  va_start(ap, format);
34011f00:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, lvl, format, ap);
34011f02:	47a0      	blx	r4
  va_end(ap);
}
34011f04:	b002      	add	sp, #8
34011f06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34011f0a:	b002      	add	sp, #8
34011f0c:	4770      	bx	lr
	...

34011f10 <VD55G1_PollReg8>:

  return 0;
}

static int VD55G1_PollReg8(VD55G1_Ctx_t *ctx, uint16_t addr, uint8_t poll_val)
{
34011f10:	b5f0      	push	{r4, r5, r6, r7, lr}
34011f12:	4604      	mov	r4, r0
34011f14:	460e      	mov	r6, r1
34011f16:	4617      	mov	r7, r2
34011f18:	2531      	movs	r5, #49	@ 0x31
34011f1a:	b085      	sub	sp, #20
  int loop_nb = timeout_ms / loop_delay_ms;
  uint8_t val;
  int ret;

  while (--loop_nb) {
    ret = ctx->read8(ctx, addr, &val);
34011f1c:	4631      	mov	r1, r6
34011f1e:	4620      	mov	r0, r4
34011f20:	6863      	ldr	r3, [r4, #4]
34011f22:	f10d 020f 	add.w	r2, sp, #15
34011f26:	4798      	blx	r3
    if (ret < 0)
34011f28:	2800      	cmp	r0, #0
34011f2a:	db17      	blt.n	34011f5c <VD55G1_PollReg8+0x4c>
      return ret;
    if (val == poll_val)
34011f2c:	f89d 300f 	ldrb.w	r3, [sp, #15]
34011f30:	42bb      	cmp	r3, r7
34011f32:	d015      	beq.n	34011f60 <VD55G1_PollReg8+0x50>
      return 0;
    ctx->delay(ctx, loop_delay_ms);
34011f34:	210a      	movs	r1, #10
34011f36:	4620      	mov	r0, r4
34011f38:	6a23      	ldr	r3, [r4, #32]
34011f3a:	4798      	blx	r3
  while (--loop_nb) {
34011f3c:	3d01      	subs	r5, #1
34011f3e:	d1ed      	bne.n	34011f1c <VD55G1_PollReg8+0xc>
  }

  VD55G1_dbg(ctx, 0, "current state %d\n", val);
34011f40:	f89d 300f 	ldrb.w	r3, [sp, #15]
34011f44:	4620      	mov	r0, r4
34011f46:	9301      	str	r3, [sp, #4]
34011f48:	f240 132b 	movw	r3, #299	@ 0x12b
34011f4c:	2103      	movs	r1, #3
34011f4e:	9300      	str	r3, [sp, #0]
34011f50:	4a04      	ldr	r2, [pc, #16]	@ (34011f64 <VD55G1_PollReg8+0x54>)
34011f52:	462b      	mov	r3, r5
34011f54:	f7ff ffce 	bl	34011ef4 <VD55G1_log_impl>

  return -1;
34011f58:	f04f 30ff 	mov.w	r0, #4294967295
}
34011f5c:	b005      	add	sp, #20
34011f5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      return 0;
34011f60:	2000      	movs	r0, #0
34011f62:	e7fb      	b.n	34011f5c <VD55G1_PollReg8+0x4c>
34011f64:	340208f3 	.word	0x340208f3

34011f68 <VD55G1_WaitState>:

  return state == VD55G1_SYSTEM_FSM_STREAMING;
}

static int VD55G1_WaitState(VD55G1_Ctx_t *ctx, int state)
{
34011f68:	b573      	push	{r0, r1, r4, r5, r6, lr}
  int ret = VD55G1_PollReg8(ctx, VD55G1_REG_SYSTEM_FSM, state);
34011f6a:	b2ca      	uxtb	r2, r1
{
34011f6c:	460d      	mov	r5, r1
  int ret = VD55G1_PollReg8(ctx, VD55G1_REG_SYSTEM_FSM, state);
34011f6e:	211c      	movs	r1, #28
{
34011f70:	4606      	mov	r6, r0
  int ret = VD55G1_PollReg8(ctx, VD55G1_REG_SYSTEM_FSM, state);
34011f72:	f7ff ffcd 	bl	34011f10 <VD55G1_PollReg8>

  if (ret)
34011f76:	4604      	mov	r4, r0
34011f78:	b150      	cbz	r0, 34011f90 <VD55G1_WaitState+0x28>
    VD55G1_warn(ctx, "Unable to reach state %d\n", state);
34011f7a:	f240 1341 	movw	r3, #321	@ 0x141
34011f7e:	2101      	movs	r1, #1
34011f80:	4630      	mov	r0, r6
34011f82:	4a09      	ldr	r2, [pc, #36]	@ (34011fa8 <VD55G1_WaitState+0x40>)
34011f84:	9500      	str	r5, [sp, #0]
34011f86:	f7ff ffb5 	bl	34011ef4 <VD55G1_log_impl>
  else
    VD55G1_dbg(ctx, 0, "reach state %d\n", state);

  return ret;
}
34011f8a:	4620      	mov	r0, r4
34011f8c:	b002      	add	sp, #8
34011f8e:	bd70      	pop	{r4, r5, r6, pc}
    VD55G1_dbg(ctx, 0, "reach state %d\n", state);
34011f90:	f240 1343 	movw	r3, #323	@ 0x143
34011f94:	2103      	movs	r1, #3
34011f96:	9300      	str	r3, [sp, #0]
34011f98:	4a04      	ldr	r2, [pc, #16]	@ (34011fac <VD55G1_WaitState+0x44>)
34011f9a:	4603      	mov	r3, r0
34011f9c:	9501      	str	r5, [sp, #4]
34011f9e:	4630      	mov	r0, r6
34011fa0:	f7ff ffa8 	bl	34011ef4 <VD55G1_log_impl>
  return ret;
34011fa4:	e7f1      	b.n	34011f8a <VD55G1_WaitState+0x22>
34011fa6:	bf00      	nop
34011fa8:	34020916 	.word	0x34020916
34011fac:	34020940 	.word	0x34020940

34011fb0 <display_error>:
{
34011fb0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  ret = ctx->read16(ctx, VD55G1_ERROR_CODE, &reg16);
34011fb2:	2110      	movs	r1, #16
34011fb4:	6883      	ldr	r3, [r0, #8]
34011fb6:	f10d 020e 	add.w	r2, sp, #14
{
34011fba:	4604      	mov	r4, r0
  ret = ctx->read16(ctx, VD55G1_ERROR_CODE, &reg16);
34011fbc:	4798      	blx	r3
  assert(ret == 0);
34011fbe:	4601      	mov	r1, r0
34011fc0:	b128      	cbz	r0, 34011fce <display_error+0x1e>
34011fc2:	21fc      	movs	r1, #252	@ 0xfc
34011fc4:	4b07      	ldr	r3, [pc, #28]	@ (34011fe4 <display_error+0x34>)
34011fc6:	4a08      	ldr	r2, [pc, #32]	@ (34011fe8 <display_error+0x38>)
34011fc8:	4808      	ldr	r0, [pc, #32]	@ (34011fec <display_error+0x3c>)
34011fca:	f006 ff47 	bl	34018e5c <__assert_func>
  VD55G1_error(ctx, "ERROR_CODE : 0x%04x\n", reg16);
34011fce:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34011fd2:	4620      	mov	r0, r4
34011fd4:	9300      	str	r3, [sp, #0]
34011fd6:	4a06      	ldr	r2, [pc, #24]	@ (34011ff0 <display_error+0x40>)
34011fd8:	23fd      	movs	r3, #253	@ 0xfd
34011fda:	f7ff ff8b 	bl	34011ef4 <VD55G1_log_impl>
}
34011fde:	b004      	add	sp, #16
34011fe0:	bd10      	pop	{r4, pc}
34011fe2:	bf00      	nop
34011fe4:	3401d8b3 	.word	0x3401d8b3
34011fe8:	340a7753 	.word	0x340a7753
34011fec:	34020961 	.word	0x34020961
34011ff0:	34020a15 	.word	0x34020a15

34011ff4 <VD55G1_ApplyPatchCommon>:
  return 0;
}

static int VD55G1_ApplyPatchCommon(VD55G1_Ctx_t *ctx, uint8_t *patch_array, int patch_len, uint8_t patch_major,
                                   uint8_t patch_minor)
{
34011ff4:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t reg16;
  int ret;

  ret = ctx->write_array(ctx, VD55G1_REG_FWPATCH_START_ADDR, patch_array, patch_len);
34011ff6:	69c4      	ldr	r4, [r0, #28]
{
34011ff8:	b087      	sub	sp, #28
34011ffa:	461e      	mov	r6, r3
  ret = ctx->write_array(ctx, VD55G1_REG_FWPATCH_START_ADDR, patch_array, patch_len);
34011ffc:	4613      	mov	r3, r2
34011ffe:	460a      	mov	r2, r1
34012000:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
{
34012004:	4605      	mov	r5, r0
34012006:	f89d 7030 	ldrb.w	r7, [sp, #48]	@ 0x30
  ret = ctx->write_array(ctx, VD55G1_REG_FWPATCH_START_ADDR, patch_array, patch_len);
3401200a:	47a0      	blx	r4
  VD55G1_TraceError(ctx, ret);
3401200c:	4604      	mov	r4, r0
3401200e:	b958      	cbnz	r0, 34012028 <VD55G1_ApplyPatchCommon+0x34>

  ret = ctx->write8(ctx, VD55G1_REG_BOOT, VD55G1_BOOT_PATCH_AND_BOOT);
34012010:	2202      	movs	r2, #2
34012012:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012016:	4628      	mov	r0, r5
34012018:	692b      	ldr	r3, [r5, #16]
3401201a:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401201c:	4604      	mov	r4, r0
3401201e:	b190      	cbz	r0, 34012046 <VD55G1_ApplyPatchCommon+0x52>
34012020:	f240 1377 	movw	r3, #375	@ 0x177
34012024:	9002      	str	r0, [sp, #8]
34012026:	e002      	b.n	3401202e <VD55G1_ApplyPatchCommon+0x3a>
  VD55G1_TraceError(ctx, ret);
34012028:	f44f 73ba 	mov.w	r3, #372	@ 0x174
3401202c:	9002      	str	r0, [sp, #8]
    return -1;
  }
  VD55G1_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
  VD55G1_TraceError(ctx, ret);
3401202e:	4a32      	ldr	r2, [pc, #200]	@ (340120f8 <VD55G1_ApplyPatchCommon+0x104>)
34012030:	4628      	mov	r0, r5
34012032:	9200      	str	r2, [sp, #0]
34012034:	2100      	movs	r1, #0
34012036:	4a31      	ldr	r2, [pc, #196]	@ (340120fc <VD55G1_ApplyPatchCommon+0x108>)
34012038:	9301      	str	r3, [sp, #4]
3401203a:	f7ff ff5b 	bl	34011ef4 <VD55G1_log_impl>
3401203e:	4628      	mov	r0, r5
34012040:	f7ff ffb6 	bl	34011fb0 <display_error>
34012044:	e039      	b.n	340120ba <VD55G1_ApplyPatchCommon+0xc6>
  ret = VD55G1_PollReg8(ctx, VD55G1_REG_BOOT, VD55G1_CMD_ACK);
34012046:	4602      	mov	r2, r0
34012048:	f44f 7100 	mov.w	r1, #512	@ 0x200
3401204c:	4628      	mov	r0, r5
3401204e:	f7ff ff5f 	bl	34011f10 <VD55G1_PollReg8>
  VD55G1_TraceError(ctx, ret);
34012052:	4604      	mov	r4, r0
34012054:	b118      	cbz	r0, 3401205e <VD55G1_ApplyPatchCommon+0x6a>
34012056:	f44f 73bd 	mov.w	r3, #378	@ 0x17a
3401205a:	9002      	str	r0, [sp, #8]
3401205c:	e7e7      	b.n	3401202e <VD55G1_ApplyPatchCommon+0x3a>
  ret = ctx->read16(ctx, VD55G1_REG_FWPATCH_REVISION, &reg16);
3401205e:	2112      	movs	r1, #18
34012060:	4628      	mov	r0, r5
34012062:	68ab      	ldr	r3, [r5, #8]
34012064:	f10d 0216 	add.w	r2, sp, #22
34012068:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401206a:	4604      	mov	r4, r0
3401206c:	b118      	cbz	r0, 34012076 <VD55G1_ApplyPatchCommon+0x82>
3401206e:	f240 137d 	movw	r3, #381	@ 0x17d
34012072:	9002      	str	r0, [sp, #8]
34012074:	e7db      	b.n	3401202e <VD55G1_ApplyPatchCommon+0x3a>
  VD55G1_dbg(ctx, 0, "patch = 0x%04x\n", reg16);
34012076:	f8bd 3016 	ldrh.w	r3, [sp, #22]
3401207a:	4a21      	ldr	r2, [pc, #132]	@ (34012100 <VD55G1_ApplyPatchCommon+0x10c>)
3401207c:	9301      	str	r3, [sp, #4]
3401207e:	f44f 73bf 	mov.w	r3, #382	@ 0x17e
34012082:	2103      	movs	r1, #3
34012084:	9300      	str	r3, [sp, #0]
34012086:	4603      	mov	r3, r0
34012088:	4628      	mov	r0, r5
3401208a:	f7ff ff33 	bl	34011ef4 <VD55G1_log_impl>
  if (reg16 != (patch_major << 8) + patch_minor) {
3401208e:	f8bd 2016 	ldrh.w	r2, [sp, #22]
34012092:	eb07 2306 	add.w	r3, r7, r6, lsl #8
34012096:	429a      	cmp	r2, r3
34012098:	b2d3      	uxtb	r3, r2
3401209a:	ea4f 2212 	mov.w	r2, r2, lsr #8
3401209e:	d00f      	beq.n	340120c0 <VD55G1_ApplyPatchCommon+0xcc>
    VD55G1_error(ctx, "bad patch version expected %d.%d got %d.%d\n", patch_major, patch_minor, reg16 >> 8, reg16 & 0xff);
340120a0:	e9cd 2302 	strd	r2, r3, [sp, #8]
340120a4:	4621      	mov	r1, r4
340120a6:	f240 1381 	movw	r3, #385	@ 0x181
340120aa:	4628      	mov	r0, r5
340120ac:	e9cd 6700 	strd	r6, r7, [sp]
340120b0:	4a14      	ldr	r2, [pc, #80]	@ (34012104 <VD55G1_ApplyPatchCommon+0x110>)
340120b2:	f7ff ff1f 	bl	34011ef4 <VD55G1_log_impl>
    return -1;
340120b6:	f04f 34ff 	mov.w	r4, #4294967295

  VD55G1_notice(ctx, "sensor boot successfully\n");

  return 0;
}
340120ba:	4620      	mov	r0, r4
340120bc:	b007      	add	sp, #28
340120be:	bdf0      	pop	{r4, r5, r6, r7, pc}
  VD55G1_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);
340120c0:	e9cd 2300 	strd	r2, r3, [sp]
340120c4:	2102      	movs	r1, #2
340120c6:	f44f 73c2 	mov.w	r3, #388	@ 0x184
340120ca:	4628      	mov	r0, r5
340120cc:	4a0e      	ldr	r2, [pc, #56]	@ (34012108 <VD55G1_ApplyPatchCommon+0x114>)
340120ce:	f7ff ff11 	bl	34011ef4 <VD55G1_log_impl>
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
340120d2:	2102      	movs	r1, #2
340120d4:	4628      	mov	r0, r5
340120d6:	f7ff ff47 	bl	34011f68 <VD55G1_WaitState>
  VD55G1_TraceError(ctx, ret);
340120da:	4604      	mov	r4, r0
340120dc:	b938      	cbnz	r0, 340120ee <VD55G1_ApplyPatchCommon+0xfa>
  VD55G1_notice(ctx, "sensor boot successfully\n");
340120de:	f240 1389 	movw	r3, #393	@ 0x189
340120e2:	2102      	movs	r1, #2
340120e4:	4628      	mov	r0, r5
340120e6:	4a09      	ldr	r2, [pc, #36]	@ (3401210c <VD55G1_ApplyPatchCommon+0x118>)
340120e8:	f7ff ff04 	bl	34011ef4 <VD55G1_log_impl>
  return 0;
340120ec:	e7e5      	b.n	340120ba <VD55G1_ApplyPatchCommon+0xc6>
  VD55G1_TraceError(ctx, ret);
340120ee:	f240 1387 	movw	r3, #391	@ 0x187
340120f2:	9002      	str	r0, [sp, #8]
340120f4:	e79b      	b.n	3401202e <VD55G1_ApplyPatchCommon+0x3a>
340120f6:	bf00      	nop
340120f8:	340a7729 	.word	0x340a7729
340120fc:	34020a3a 	.word	0x34020a3a
34012100:	34020a5f 	.word	0x34020a5f
34012104:	34020a80 	.word	0x34020a80
34012108:	34020abc 	.word	0x34020abc
3401210c:	34020ae1 	.word	0x34020ae1

34012110 <VD55G1_ComputeFrameLength>:

  return 0;
}

static int VD55G1_ComputeFrameLength(VD55G1_Ctx_t *ctx, int fps, uint16_t *frame_length)
{
34012110:	b5f0      	push	{r4, r5, r6, r7, lr}
34012112:	b089      	sub	sp, #36	@ 0x24
34012114:	460e      	mov	r6, r1
34012116:	4617      	mov	r7, r2
  int req_frame_length;
  uint16_t line_length;
  uint16_t height;
  int ret;

  ret = ctx->read16(ctx, VD55G1_REG_LINE_LENGTH, &line_length);
34012118:	f44f 7140 	mov.w	r1, #768	@ 0x300
3401211c:	6883      	ldr	r3, [r0, #8]
3401211e:	aa07      	add	r2, sp, #28
{
34012120:	4604      	mov	r4, r0
  ret = ctx->read16(ctx, VD55G1_REG_LINE_LENGTH, &line_length);
3401####MQTT_PASS####:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012124:	4605      	mov	r5, r0
34012126:	b960      	cbnz	r0, 34012142 <VD55G1_ComputeFrameLength+0x32>

  ret = ctx->read16(ctx, VD55G1_REG_Y_HEIGHT, &height);
34012128:	f240 5112 	movw	r1, #1298	@ 0x512
3401212c:	4620      	mov	r0, r4
3401212e:	68a3      	ldr	r3, [r4, #8]
34012130:	f10d 021e 	add.w	r2, sp, #30
34012134:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012136:	4605      	mov	r5, r0
34012138:	b190      	cbz	r0, 34012160 <VD55G1_ComputeFrameLength+0x50>
3401213a:	f44f 7316 	mov.w	r3, #600	@ 0x258
3401213e:	9002      	str	r0, [sp, #8]
34012140:	e002      	b.n	34012148 <VD55G1_ComputeFrameLength+0x38>
  VD55G1_TraceError(ctx, ret);
34012142:	f240 2355 	movw	r3, #597	@ 0x255
34012146:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
34012148:	4a17      	ldr	r2, [pc, #92]	@ (340121a8 <VD55G1_ComputeFrameLength+0x98>)
3401214a:	4620      	mov	r0, r4
3401214c:	9200      	str	r2, [sp, #0]
3401214e:	2100      	movs	r1, #0
34012150:	4a16      	ldr	r2, [pc, #88]	@ (340121ac <VD55G1_ComputeFrameLength+0x9c>)
34012152:	9301      	str	r3, [sp, #4]
34012154:	f7ff fece 	bl	34011ef4 <VD55G1_log_impl>
34012158:	4620      	mov	r0, r4
3401215a:	f7ff ff29 	bl	34011fb0 <display_error>
3401215e:	e01f      	b.n	340121a0 <VD55G1_ComputeFrameLength+0x90>

  min_frame_length = height + VD55G1_MIN_VBLANK;
  req_frame_length = drv_ctx->pclk / (line_length * fps);
34012160:	f8bd 201c 	ldrh.w	r2, [sp, #28]
34012164:	6b20      	ldr	r0, [r4, #48]	@ 0x30
34012166:	4372      	muls	r2, r6
34012168:	fbb0 f0f2 	udiv	r0, r0, r2
  min_frame_length = height + VD55G1_MIN_VBLANK;
3401216c:	f8bd 301e 	ldrh.w	r3, [sp, #30]
  *frame_length = MIN(MAX(min_frame_length, req_frame_length), 65535);
34012170:	f64f 71ff 	movw	r1, #65535	@ 0xffff
  min_frame_length = height + VD55G1_MIN_VBLANK;
34012174:	3356      	adds	r3, #86	@ 0x56
  *frame_length = MIN(MAX(min_frame_length, req_frame_length), 65535);
34012176:	4283      	cmp	r3, r0
34012178:	461a      	mov	r2, r3
3401217a:	bfb8      	it	lt
3401217c:	4602      	movlt	r2, r0
3401217e:	428a      	cmp	r2, r1
34012180:	bfa8      	it	ge
34012182:	460a      	movge	r2, r1
34012184:	803a      	strh	r2, [r7, #0]

  VD55G1_dbg(ctx, 1, "frame_length to MAX(%d, %d) = %d to reach %d fps\n", min_frame_length, req_frame_length,
34012186:	e9cd 3001 	strd	r3, r0, [sp, #4]
3401218a:	f240 235e 	movw	r3, #606	@ 0x25e
3401218e:	e9cd 2603 	strd	r2, r6, [sp, #12]
34012192:	9300      	str	r3, [sp, #0]
34012194:	2104      	movs	r1, #4
34012196:	2301      	movs	r3, #1
34012198:	4620      	mov	r0, r4
3401219a:	4a05      	ldr	r2, [pc, #20]	@ (340121b0 <VD55G1_ComputeFrameLength+0xa0>)
3401219c:	f7ff feaa 	bl	34011ef4 <VD55G1_log_impl>
             *frame_length, fps);

  return 0;
}
340121a0:	4628      	mov	r0, r5
340121a2:	b009      	add	sp, #36	@ 0x24
340121a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
340121a6:	bf00      	nop
340121a8:	340a7694 	.word	0x340a7694
340121ac:	34020a3a 	.word	0x34020a3a
340121b0:	34020b0b 	.word	0x34020b0b

340121b4 <VD55G1_SetFlicker>:

  return 0;
}

static int VD55G1_SetFlicker(VD55G1_Ctx_t *ctx, VD55G1_Flicker_t flicker)
{
340121b4:	b530      	push	{r4, r5, lr}
340121b6:	2902      	cmp	r1, #2
340121b8:	4605      	mov	r5, r0
340121ba:	b085      	sub	sp, #20
340121bc:	d818      	bhi.n	340121f0 <VD55G1_SetFlicker+0x3c>
    break;
  default:
    return -1;
  }

  ret = ctx->write16(ctx, VD55G1_REG_EXPOSURE_COMPILER_CONTROL_A, mode);
340121be:	4a0e      	ldr	r2, [pc, #56]	@ (340121f8 <VD55G1_SetFlicker+0x44>)
340121c0:	6943      	ldr	r3, [r0, #20]
340121c2:	5c52      	ldrb	r2, [r2, r1]
340121c4:	f240 4182 	movw	r1, #1154	@ 0x482
340121c8:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340121ca:	4604      	mov	r4, r0
340121cc:	b168      	cbz	r0, 340121ea <VD55G1_SetFlicker+0x36>
340121ce:	f240 23ed 	movw	r3, #749	@ 0x2ed
340121d2:	4a0a      	ldr	r2, [pc, #40]	@ (340121fc <VD55G1_SetFlicker+0x48>)
340121d4:	9002      	str	r0, [sp, #8]
340121d6:	9200      	str	r2, [sp, #0]
340121d8:	4628      	mov	r0, r5
340121da:	2100      	movs	r1, #0
340121dc:	4a08      	ldr	r2, [pc, #32]	@ (34012200 <VD55G1_SetFlicker+0x4c>)
340121de:	9301      	str	r3, [sp, #4]
340121e0:	f7ff fe88 	bl	34011ef4 <VD55G1_log_impl>
340121e4:	4628      	mov	r0, r5
340121e6:	f7ff fee3 	bl	34011fb0 <display_error>

  return 0;
}
340121ea:	4620      	mov	r0, r4
340121ec:	b005      	add	sp, #20
340121ee:	bd30      	pop	{r4, r5, pc}
    return -1;
340121f0:	f04f 34ff 	mov.w	r4, #4294967295
340121f4:	e7f9      	b.n	340121ea <VD55G1_SetFlicker+0x36>
340121f6:	bf00      	nop
340121f8:	340a75f8 	.word	0x340a75f8
340121fc:	340a7643 	.word	0x340a7643
34012200:	34020a3a 	.word	0x34020a3a

34012204 <VD55G1_StopStreaming>:

  return 0;
}

static int VD55G1_StopStreaming(VD55G1_Ctx_t *ctx)
{
34012204:	b530      	push	{r4, r5, lr}
  int ret;

  ret = ctx->write8(ctx, VD55G1_REG_STREAMING, VD55G1_STREAMING_STOP_STREAM);
34012206:	2201      	movs	r2, #1
34012208:	f240 2102 	movw	r1, #514	@ 0x202
3401220c:	6903      	ldr	r3, [r0, #16]
{
3401220e:	b085      	sub	sp, #20
34012210:	4605      	mov	r5, r0
  ret = ctx->write8(ctx, VD55G1_REG_STREAMING, VD55G1_STREAMING_STOP_STREAM);
34012212:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012214:	4604      	mov	r4, r0
34012216:	b958      	cbnz	r0, 34012230 <VD55G1_StopStreaming+0x2c>

  ret = VD55G1_PollReg8(ctx, VD55G1_REG_STREAMING, VD55G1_CMD_ACK);
34012218:	4602      	mov	r2, r0
3401221a:	f240 2102 	movw	r1, #514	@ 0x202
3401221e:	4628      	mov	r0, r5
34012220:	f7ff fe76 	bl	34011f10 <VD55G1_PollReg8>
  VD55G1_TraceError(ctx, ret);
34012224:	4604      	mov	r4, r0
34012226:	b190      	cbz	r0, 3401224e <VD55G1_StopStreaming+0x4a>
34012228:	f240 3332 	movw	r3, #818	@ 0x332
3401222c:	9002      	str	r0, [sp, #8]
3401222e:	e002      	b.n	34012236 <VD55G1_StopStreaming+0x32>
  VD55G1_TraceError(ctx, ret);
34012230:	f240 332f 	movw	r3, #815	@ 0x32f
34012234:	9002      	str	r0, [sp, #8]

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
  VD55G1_TraceError(ctx, ret);
34012236:	4a10      	ldr	r2, [pc, #64]	@ (34012278 <VD55G1_StopStreaming+0x74>)
34012238:	4628      	mov	r0, r5
3401223a:	9200      	str	r2, [sp, #0]
3401223c:	2100      	movs	r1, #0
3401223e:	4a0f      	ldr	r2, [pc, #60]	@ (3401227c <VD55G1_StopStreaming+0x78>)
34012240:	9301      	str	r3, [sp, #4]
34012242:	f7ff fe57 	bl	34011ef4 <VD55G1_log_impl>
34012246:	4628      	mov	r0, r5
34012248:	f7ff feb2 	bl	34011fb0 <display_error>
3401224c:	e010      	b.n	34012270 <VD55G1_StopStreaming+0x6c>
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
3401224e:	2102      	movs	r1, #2
34012250:	4628      	mov	r0, r5
34012252:	f7ff fe89 	bl	34011f68 <VD55G1_WaitState>
  VD55G1_TraceError(ctx, ret);
34012256:	4604      	mov	r4, r0
34012258:	b118      	cbz	r0, 34012262 <VD55G1_StopStreaming+0x5e>
3401225a:	f240 3335 	movw	r3, #821	@ 0x335
3401225e:	9002      	str	r0, [sp, #8]
34012260:	e7e9      	b.n	34012236 <VD55G1_StopStreaming+0x32>

  VD55G1_notice(ctx, "Streaming is off\n");
34012262:	f240 3337 	movw	r3, #823	@ 0x337
34012266:	2102      	movs	r1, #2
34012268:	4628      	mov	r0, r5
3401226a:	4a05      	ldr	r2, [pc, #20]	@ (34012280 <VD55G1_StopStreaming+0x7c>)
3401226c:	f7ff fe42 	bl	34011ef4 <VD55G1_log_impl>

  return 0;
}
34012270:	4620      	mov	r0, r4
34012272:	b005      	add	sp, #20
34012274:	bd30      	pop	{r4, r5, pc}
34012276:	bf00      	nop
34012278:	340a7618 	.word	0x340a7618
3401227c:	34020a3a 	.word	0x34020a3a
34012280:	34020b4e 	.word	0x34020b4e

34012284 <VD55G1_Init>:

  return VD55G1_StartAWU(ctx);
}

int VD55G1_Init(VD55G1_Ctx_t *ctx, VD55G1_Config_t *config)
{
34012284:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  VD55G1_AWUConfig_t *awu = &config->awu;
  struct drv_ctx *drv_ctx = &ctx->ctx;
  int ret;

  if (config->frame_rate < VD55G1_MIN_FPS)
34012288:	688b      	ldr	r3, [r1, #8]
{
3401228a:	4605      	mov	r5, r0
  if (config->frame_rate < VD55G1_MIN_FPS)
3401228c:	3b02      	subs	r3, #2
3401228e:	2ba6      	cmp	r3, #166	@ 0xa6
{
34012290:	460c      	mov	r4, r1
34012292:	b086      	sub	sp, #24
  if (config->frame_rate < VD55G1_MIN_FPS)
34012294:	d802      	bhi.n	3401229c <VD55G1_Init+0x18>
    return -1;
  if (config->frame_rate > VD55G1_MAX_FPS)
    return -1;

  if ((config->resolution != VD55G1_RES_QVGA_320_240) &&
34012296:	790b      	ldrb	r3, [r1, #4]
34012298:	2b03      	cmp	r3, #3
3401229a:	d905      	bls.n	340122a8 <VD55G1_Init+0x24>
    return -1;
3401229c:	f04f 34ff 	mov.w	r4, #4294967295
    return ret;

  drv_ctx->state = VD55G1_ST_IDLE;

  return 0;
}
340122a0:	4620      	mov	r0, r4
340122a2:	b006      	add	sp, #24
340122a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (awu->is_enable && awu->threshold != VD55G1_AWU_THRESHOLD_DEFAULT) {
340122a8:	69cb      	ldr	r3, [r1, #28]
340122aa:	b123      	cbz	r3, 340122b6 <VD55G1_Init+0x32>
340122ac:	6acb      	ldr	r3, [r1, #44]	@ 0x2c
340122ae:	b113      	cbz	r3, 340122b6 <VD55G1_Init+0x32>
    if (awu->threshold < VD55G1_AWU_THRESHOLD_MIN)
340122b0:	3b02      	subs	r3, #2
340122b2:	2b7e      	cmp	r3, #126	@ 0x7e
340122b4:	d8f2      	bhi.n	3401229c <VD55G1_Init+0x18>
  drv_ctx->config_save = *config;
340122b6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
340122b8:	f105 0634 	add.w	r6, r5, #52	@ 0x34
340122bc:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340122be:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
340122c0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340122c2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
340122c4:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340122c6:	6823      	ldr	r3, [r4, #0]
  ctx->shutdown_pin(ctx, 0);
340122c8:	2100      	movs	r1, #0
340122ca:	4628      	mov	r0, r5
  drv_ctx->config_save = *config;
340122cc:	6033      	str	r3, [r6, #0]
  ctx->shutdown_pin(ctx, 0);
340122ce:	682b      	ldr	r3, [r5, #0]
340122d0:	4798      	blx	r3
  ctx->delay(ctx, 10);
340122d2:	210a      	movs	r1, #10
340122d4:	4628      	mov	r0, r5
340122d6:	6a2b      	ldr	r3, [r5, #32]
340122d8:	4798      	blx	r3
  ctx->shutdown_pin(ctx, 1);
340122da:	2101      	movs	r1, #1
340122dc:	4628      	mov	r0, r5
340122de:	682b      	ldr	r3, [r5, #0]
340122e0:	4798      	blx	r3
  ctx->delay(ctx, 10);
340122e2:	210a      	movs	r1, #10
340122e4:	4628      	mov	r0, r5
340122e6:	6a2b      	ldr	r3, [r5, #32]
340122e8:	4798      	blx	r3
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_READY_TO_BOOT);
340122ea:	2101      	movs	r1, #1
340122ec:	4628      	mov	r0, r5
340122ee:	f7ff fe3b 	bl	34011f68 <VD55G1_WaitState>
  if (ret)
340122f2:	4604      	mov	r4, r0
340122f4:	2800      	cmp	r0, #0
340122f6:	d1d3      	bne.n	340122a0 <VD55G1_Init+0x1c>
  ret = ctx->read32(ctx, VD55G1_REG_MODEL_ID, &reg32);
340122f8:	4601      	mov	r1, r0
340122fa:	68eb      	ldr	r3, [r5, #12]
340122fc:	4628      	mov	r0, r5
340122fe:	aa05      	add	r2, sp, #20
34012300:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012302:	4604      	mov	r4, r0
34012304:	b9c0      	cbnz	r0, 34012338 <VD55G1_Init+0xb4>
  VD55G1_dbg(ctx, 0, "model_id = 0x%04x\n", reg32);
34012306:	9b05      	ldr	r3, [sp, #20]
34012308:	4a52      	ldr	r2, [pc, #328]	@ (34012454 <VD55G1_Init+0x1d0>)
3401230a:	9301      	str	r3, [sp, #4]
3401230c:	f240 1351 	movw	r3, #337	@ 0x151
34012310:	2103      	movs	r1, #3
34012312:	9300      	str	r3, [sp, #0]
34012314:	4603      	mov	r3, r0
34012316:	4628      	mov	r0, r5
34012318:	f7ff fdec 	bl	34011ef4 <VD55G1_log_impl>
  if (reg32 != VD55G1_MODEL_ID) {
3401231c:	9a05      	ldr	r2, [sp, #20]
3401231e:	4b4e      	ldr	r3, [pc, #312]	@ (34012458 <VD55G1_Init+0x1d4>)
34012320:	429a      	cmp	r2, r3
34012322:	d018      	beq.n	34012356 <VD55G1_Init+0xd2>
    VD55G1_error(ctx, "Bad model id expected 0x%04x / got 0x%04x\n", VD55G1_MODEL_ID, reg32);
34012324:	e9cd 3200 	strd	r3, r2, [sp]
34012328:	4621      	mov	r1, r4
3401232a:	f240 1353 	movw	r3, #339	@ 0x153
3401232e:	4628      	mov	r0, r5
34012330:	4a4a      	ldr	r2, [pc, #296]	@ (3401245c <VD55G1_Init+0x1d8>)
34012332:	f7ff fddf 	bl	34011ef4 <VD55G1_log_impl>
  if (ret)
34012336:	e7b1      	b.n	3401229c <VD55G1_Init+0x18>
  VD55G1_TraceError(ctx, ret);
34012338:	f44f 73a8 	mov.w	r3, #336	@ 0x150
3401233c:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
3401233e:	4a48      	ldr	r2, [pc, #288]	@ (34012460 <VD55G1_Init+0x1dc>)
34012340:	9301      	str	r3, [sp, #4]
    VD55G1_TraceError(ctx, ret);
34012342:	4628      	mov	r0, r5
34012344:	9200      	str	r2, [sp, #0]
34012346:	2100      	movs	r1, #0
34012348:	4a46      	ldr	r2, [pc, #280]	@ (34012464 <VD55G1_Init+0x1e0>)
3401234a:	f7ff fdd3 	bl	34011ef4 <VD55G1_log_impl>
3401234e:	4628      	mov	r0, r5
34012350:	f7ff fe2e 	bl	34011fb0 <display_error>
  if (ret)
34012354:	e7a4      	b.n	340122a0 <VD55G1_Init+0x1c>
  ret = ctx->read16(ctx, VD55G1_REG_REVISION, &reg16);
34012356:	2104      	movs	r1, #4
34012358:	4628      	mov	r0, r5
3401235a:	68ab      	ldr	r3, [r5, #8]
3401235c:	f10d 0212 	add.w	r2, sp, #18
34012360:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012362:	4604      	mov	r4, r0
34012364:	b9f0      	cbnz	r0, 340123a4 <VD55G1_Init+0x120>
  VD55G1_dbg(ctx, 0, "revision = 0x%04x\n", reg16);
34012366:	f8bd 3012 	ldrh.w	r3, [sp, #18]
3401236a:	4a3f      	ldr	r2, [pc, #252]	@ (34012468 <VD55G1_Init+0x1e4>)
3401236c:	9301      	str	r3, [sp, #4]
3401236e:	f240 1359 	movw	r3, #345	@ 0x159
34012372:	2103      	movs	r1, #3
34012374:	9300      	str	r3, [sp, #0]
34012376:	4603      	mov	r3, r0
34012378:	4628      	mov	r0, r5
3401237a:	f7ff fdbb 	bl	34011ef4 <VD55G1_log_impl>
  switch (reg16) {
3401237e:	f241 0210 	movw	r2, #4112	@ 0x1010
34012382:	f8bd 3012 	ldrh.w	r3, [sp, #18]
34012386:	4293      	cmp	r3, r2
34012388:	d010      	beq.n	340123ac <VD55G1_Init+0x128>
3401238a:	f242 0220 	movw	r2, #8224	@ 0x2020
3401238e:	4293      	cmp	r3, r2
34012390:	d00c      	beq.n	340123ac <VD55G1_Init+0x128>
    VD55G1_error(ctx, "Unsupported revision0x%04x\n", reg16);
34012392:	9300      	str	r3, [sp, #0]
34012394:	4621      	mov	r1, r4
34012396:	f44f 73b1 	mov.w	r3, #354	@ 0x162
3401239a:	4628      	mov	r0, r5
3401239c:	4a33      	ldr	r2, [pc, #204]	@ (3401246c <VD55G1_Init+0x1e8>)
3401239e:	f7ff fda9 	bl	34011ef4 <VD55G1_log_impl>
  if (ret)
340123a2:	e77b      	b.n	3401229c <VD55G1_Init+0x18>
  VD55G1_TraceError(ctx, ret);
340123a4:	f44f 73ac 	mov.w	r3, #344	@ 0x158
340123a8:	9002      	str	r0, [sp, #8]
340123aa:	e7c8      	b.n	3401233e <VD55G1_Init+0xba>
    drv_ctx->cut_version = VD55G1_REVISION_CUT_1;
340123ac:	62eb      	str	r3, [r5, #44]	@ 0x2c
  ret = ctx->read32(ctx, VD55G1_REG_ROM_REVISION, &reg32);
340123ae:	2108      	movs	r1, #8
340123b0:	4628      	mov	r0, r5
340123b2:	68eb      	ldr	r3, [r5, #12]
340123b4:	aa05      	add	r2, sp, #20
340123b6:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340123b8:	4604      	mov	r4, r0
340123ba:	b9d0      	cbnz	r0, 340123f2 <VD55G1_Init+0x16e>
  VD55G1_dbg(ctx, 0, "rom = 0x%04x\n", reg32);
340123bc:	9b05      	ldr	r3, [sp, #20]
340123be:	4a2c      	ldr	r2, [pc, #176]	@ (34012470 <VD55G1_Init+0x1ec>)
340123c0:	9301      	str	r3, [sp, #4]
340123c2:	f44f 73b4 	mov.w	r3, #360	@ 0x168
340123c6:	2103      	movs	r1, #3
340123c8:	9300      	str	r3, [sp, #0]
340123ca:	4603      	mov	r3, r0
340123cc:	4628      	mov	r0, r5
340123ce:	f7ff fd91 	bl	34011ef4 <VD55G1_log_impl>
  switch (drv_ctx->cut_version) {
340123d2:	f241 0210 	movw	r2, #4112	@ 0x1010
340123d6:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
340123d8:	4293      	cmp	r3, r2
340123da:	d00e      	beq.n	340123fa <VD55G1_Init+0x176>
340123dc:	f242 0220 	movw	r2, #8224	@ 0x2020
340123e0:	4293      	cmp	r3, r2
340123e2:	d02b      	beq.n	3401243c <VD55G1_Init+0x1b8>
    assert(0);
340123e4:	f44f 71cd 	mov.w	r1, #410	@ 0x19a
340123e8:	4b22      	ldr	r3, [pc, #136]	@ (34012474 <VD55G1_Init+0x1f0>)
340123ea:	4a23      	ldr	r2, [pc, #140]	@ (34012478 <VD55G1_Init+0x1f4>)
340123ec:	4823      	ldr	r0, [pc, #140]	@ (3401247c <VD55G1_Init+0x1f8>)
340123ee:	f006 fd35 	bl	34018e5c <__assert_func>
  VD55G1_TraceError(ctx, ret);
340123f2:	f240 1367 	movw	r3, #359	@ 0x167
340123f6:	9002      	str	r0, [sp, #8]
340123f8:	e7a1      	b.n	3401233e <VD55G1_Init+0xba>
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_1, sizeof(patch_array_cut_1),
340123fa:	2316      	movs	r3, #22
340123fc:	f241 22e4 	movw	r2, #4836	@ 0x12e4
34012400:	9300      	str	r3, [sp, #0]
34012402:	2301      	movs	r3, #1
34012404:	491e      	ldr	r1, [pc, #120]	@ (34012480 <VD55G1_Init+0x1fc>)
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_2, sizeof(patch_array_cut_2),
34012406:	4628      	mov	r0, r5
34012408:	f7ff fdf4 	bl	34011ff4 <VD55G1_ApplyPatchCommon>
3401240c:	4604      	mov	r4, r0
  if (ret)
3401240e:	2800      	cmp	r0, #0
34012410:	f47f af46 	bne.w	340122a0 <VD55G1_Init+0x1c>
34012414:	f240 561d 	movw	r6, #1309	@ 0x51d
  for (i = 0 ; i < VD55G1_GPIO_NB; i++)
34012418:	f240 5821 	movw	r8, #1313	@ 0x521
3401241c:	f105 0763 	add.w	r7, r5, #99	@ 0x63
    ret = ctx->write8(ctx, VD55G1_REG_GPIO_x(i), drv_ctx->config_save.gpio_ctrl[i]);
34012420:	4631      	mov	r1, r6
34012422:	4628      	mov	r0, r5
34012424:	692b      	ldr	r3, [r5, #16]
34012426:	f817 2f01 	ldrb.w	r2, [r7, #1]!
3401242a:	4798      	blx	r3
    VD55G1_TraceError(ctx, ret);
3401242c:	4604      	mov	r4, r0
3401242e:	b158      	cbz	r0, 34012448 <VD55G1_Init+0x1c4>
34012430:	f240 13a9 	movw	r3, #425	@ 0x1a9
34012434:	4a13      	ldr	r2, [pc, #76]	@ (34012484 <VD55G1_Init+0x200>)
34012436:	9002      	str	r0, [sp, #8]
34012438:	9301      	str	r3, [sp, #4]
3401243a:	e782      	b.n	34012342 <VD55G1_Init+0xbe>
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_2, sizeof(patch_array_cut_2),
3401243c:	2302      	movs	r3, #2
3401243e:	f44f 7272 	mov.w	r2, #968	@ 0x3c8
34012442:	4911      	ldr	r1, [pc, #68]	@ (34012488 <VD55G1_Init+0x204>)
34012444:	9300      	str	r3, [sp, #0]
34012446:	e7de      	b.n	34012406 <VD55G1_Init+0x182>
  for (i = 0 ; i < VD55G1_GPIO_NB; i++)
34012448:	3601      	adds	r6, #1
3401244a:	b2b6      	uxth	r6, r6
3401244c:	4546      	cmp	r6, r8
3401244e:	d1e7      	bne.n	34012420 <VD55G1_Init+0x19c>
  drv_ctx->state = VD55G1_ST_IDLE;
34012450:	62a8      	str	r0, [r5, #40]	@ 0x28
  return 0;
34012452:	e725      	b.n	340122a0 <VD55G1_Init+0x1c>
34012454:	34020b70 	.word	0x34020b70
34012458:	53354731 	.word	0x53354731
3401245c:	34020b94 	.word	0x34020b94
34012460:	340a7761 	.word	0x340a7761
34012464:	34020a3a 	.word	0x34020a3a
34012468:	34020bcf 	.word	0x34020bcf
3401246c:	34020bf3 	.word	0x34020bf3
34012470:	34020c1f 	.word	0x34020c1f
34012474:	340217f8 	.word	0x340217f8
34012478:	340a7741 	.word	0x340a7741
3401247c:	34020961 	.word	0x34020961
34012480:	340a7bb0 	.word	0x340a7bb0
34012484:	340a771c 	.word	0x340a771c
34012488:	340a77e8 	.word	0x340a77e8

3401248c <VD55G1_DeInit>:

int VD55G1_DeInit(VD55G1_Ctx_t *ctx)
{
  struct drv_ctx *drv_ctx = &ctx->ctx;

  if (drv_ctx->state == VD55G1_ST_STREAMING)
3401248c:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
3401248e:	b510      	push	{r4, lr}
  if (drv_ctx->state == VD55G1_ST_STREAMING)
34012490:	2b01      	cmp	r3, #1
{
34012492:	4604      	mov	r4, r0
  if (drv_ctx->state == VD55G1_ST_STREAMING)
34012494:	d008      	beq.n	340124a8 <VD55G1_DeInit+0x1c>
    return -1;

  ctx->shutdown_pin(ctx, 0);
34012496:	6803      	ldr	r3, [r0, #0]
34012498:	2100      	movs	r1, #0
3401249a:	4798      	blx	r3
  ctx->delay(ctx, 10);
3401249c:	4620      	mov	r0, r4
3401249e:	210a      	movs	r1, #10
340124a0:	6a23      	ldr	r3, [r4, #32]
340124a2:	4798      	blx	r3

  return 0;
340124a4:	2000      	movs	r0, #0
}
340124a6:	bd10      	pop	{r4, pc}
    return -1;
340124a8:	f04f 30ff 	mov.w	r0, #4294967295
340124ac:	e7fb      	b.n	340124a6 <VD55G1_DeInit+0x1a>
	...

340124b0 <VD55G1_Start>:

int VD55G1_Start(VD55G1_Ctx_t *ctx)
{
340124b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (drv_ctx->config_save.out_itf.data_rate_in_mps < VD55G1_MIN_DATARATE ||
340124b2:	6c43      	ldr	r3, [r0, #68]	@ 0x44
340124b4:	4e8a      	ldr	r6, [pc, #552]	@ (340126e0 <VD55G1_Start+0x230>)
340124b6:	4a8b      	ldr	r2, [pc, #556]	@ (340126e4 <VD55G1_Start+0x234>)
340124b8:	4433      	add	r3, r6
340124ba:	4293      	cmp	r3, r2
{
340124bc:	4605      	mov	r5, r0
340124be:	b087      	sub	sp, #28
  if (drv_ctx->config_save.out_itf.data_rate_in_mps < VD55G1_MIN_DATARATE ||
340124c0:	d87e      	bhi.n	340125c0 <VD55G1_Start+0x110>
  ret = ctx->write32(ctx, VD55G1_REG_EXT_CLOCK, drv_ctx->config_save.ext_clock_freq_in_hz);
340124c2:	f44f 7108 	mov.w	r1, #544	@ 0x220
340124c6:	6983      	ldr	r3, [r0, #24]
340124c8:	6b42      	ldr	r2, [r0, #52]	@ 0x34
340124ca:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340124cc:	4604      	mov	r4, r0
340124ce:	b958      	cbnz	r0, 340124e8 <VD55G1_Start+0x38>
  ret = ctx->write32(ctx, VD55G1_REG_MIPI_DATA_RATE, drv_ctx->config_save.out_itf.data_rate_in_mps);
340124d0:	f44f 7109 	mov.w	r1, #548	@ 0x224
340124d4:	4628      	mov	r0, r5
340124d6:	69ab      	ldr	r3, [r5, #24]
340124d8:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
340124da:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340124dc:	4604      	mov	r4, r0
340124de:	b300      	cbz	r0, 34012522 <VD55G1_Start+0x72>
340124e0:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
340124e4:	9002      	str	r0, [sp, #8]
340124e6:	e002      	b.n	340124ee <VD55G1_Start+0x3e>
  VD55G1_TraceError(ctx, ret);
340124e8:	f240 13f5 	movw	r3, #501	@ 0x1f5
340124ec:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
340124ee:	4a7e      	ldr	r2, [pc, #504]	@ (340126e8 <VD55G1_Start+0x238>)
340124f0:	4628      	mov	r0, r5
340124f2:	9200      	str	r2, [sp, #0]
340124f4:	2100      	movs	r1, #0
340124f6:	4a7d      	ldr	r2, [pc, #500]	@ (340126ec <VD55G1_Start+0x23c>)
340124f8:	9301      	str	r3, [sp, #4]
340124fa:	f7ff fcfb 	bl	34011ef4 <VD55G1_log_impl>
340124fe:	4628      	mov	r0, r5
34012500:	f7ff fd56 	bl	34011fb0 <display_error>
  VD55G1_TraceError(ctx, ret);
34012504:	f240 23fe 	movw	r3, #766	@ 0x2fe
34012508:	9402      	str	r4, [sp, #8]
  VD55G1_TraceError(ctx, ret);
3401250a:	4a79      	ldr	r2, [pc, #484]	@ (340126f0 <VD55G1_Start+0x240>)
3401250c:	9301      	str	r3, [sp, #4]
  VD55G1_TraceError(ctx, ret);
3401250e:	4628      	mov	r0, r5
34012510:	9200      	str	r2, [sp, #0]
34012512:	2100      	movs	r1, #0
34012514:	4a75      	ldr	r2, [pc, #468]	@ (340126ec <VD55G1_Start+0x23c>)
34012516:	f7ff fced 	bl	34011ef4 <VD55G1_log_impl>
3401251a:	4628      	mov	r0, r5
3401251c:	f7ff fd48 	bl	34011fb0 <display_error>
  ret = VD55G1_Setup(ctx);
  if (ret)
    return ret;

  ret = VD55G1_StartStreaming(ctx);
  if (ret)
34012520:	e233      	b.n	3401298a <VD55G1_Start+0x4da>
  ret = ctx->read32(ctx, VD55G1_REG_MIPI_DATA_RATE, &mipi_data_rate);
34012522:	f44f 7109 	mov.w	r1, #548	@ 0x224
34012526:	4628      	mov	r0, r5
34012528:	68eb      	ldr	r3, [r5, #12]
3401252a:	aa05      	add	r2, sp, #20
3401252c:	4798      	blx	r3
  if (ret)
3401252e:	2800      	cmp	r0, #0
34012530:	d144      	bne.n	340125bc <VD55G1_Start+0x10c>
  if (mipi_data_rate <= 1200000000 && mipi_data_rate > 600000000)
34012532:	9b05      	ldr	r3, [sp, #20]
34012534:	4a6f      	ldr	r2, [pc, #444]	@ (340126f4 <VD55G1_Start+0x244>)
34012536:	4970      	ldr	r1, [pc, #448]	@ (340126f8 <VD55G1_Start+0x248>)
34012538:	441a      	add	r2, r3
3401253a:	428a      	cmp	r2, r1
3401253c:	496f      	ldr	r1, [pc, #444]	@ (340126fc <VD55G1_Start+0x24c>)
3401253e:	d904      	bls.n	3401254a <VD55G1_Start+0x9a>
  else if (mipi_data_rate <= 600000000 && mipi_data_rate > 300000000)
34012540:	4a6f      	ldr	r2, [pc, #444]	@ (34012700 <VD55G1_Start+0x250>)
34012542:	441a      	add	r2, r3
34012544:	428a      	cmp	r2, r1
34012546:	d80e      	bhi.n	34012566 <VD55G1_Start+0xb6>
    return mipi_data_rate * 2;
34012548:	005b      	lsls	r3, r3, #1
  if (system_clk <= 1200000000 && system_clk > 900000000)
3401254a:	4a6e      	ldr	r2, [pc, #440]	@ (34012704 <VD55G1_Start+0x254>)
3401254c:	441a      	add	r2, r3
3401254e:	428a      	cmp	r2, r1
34012550:	d90e      	bls.n	34012570 <VD55G1_Start+0xc0>
  else if (system_clk <= 900000000 && system_clk > 780000000)
34012552:	4a6d      	ldr	r2, [pc, #436]	@ (34012708 <VD55G1_Start+0x258>)
34012554:	496d      	ldr	r1, [pc, #436]	@ (3401270c <VD55G1_Start+0x25c>)
34012556:	441a      	add	r2, r3
34012558:	428a      	cmp	r2, r1
    return system_clk / 6;
3401255a:	bf94      	ite	ls
3401255c:	2206      	movls	r2, #6
    return system_clk / 5;
3401255e:	2205      	movhi	r2, #5
34012560:	fbb3 f3f2 	udiv	r3, r3, r2
  if (!drv_ctx->pclk)
34012564:	e005      	b.n	34012572 <VD55G1_Start+0xc2>
  else if (mipi_data_rate <= 300000000 && mipi_data_rate >= 250000000)
34012566:	4a6a      	ldr	r2, [pc, #424]	@ (34012710 <VD55G1_Start+0x260>)
34012568:	441e      	add	r6, r3
3401256a:	4296      	cmp	r6, r2
3401256c:	d826      	bhi.n	340125bc <VD55G1_Start+0x10c>
    return mipi_data_rate * 4;
3401256e:	009b      	lsls	r3, r3, #2
    return system_clk / 8;
34012570:	08db      	lsrs	r3, r3, #3
  drv_ctx->pclk = VD55G1_GetPixelClock(ctx);
34012572:	632b      	str	r3, [r5, #48]	@ 0x30
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
34012574:	6cab      	ldr	r3, [r5, #72]	@ 0x48
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
34012576:	2208      	movs	r2, #8
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
34012578:	3b00      	subs	r3, #0
3401257a:	bf18      	it	ne
3401257c:	2301      	movne	r3, #1
3401257e:	64ab      	str	r3, [r5, #72]	@ 0x48
  out_itf->data_lane_swap_enable = !!out_itf->data_lane_swap_enable;
34012580:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
34012582:	f240 310a 	movw	r1, #778	@ 0x30a
  out_itf->data_lane_swap_enable = !!out_itf->data_lane_swap_enable;
34012586:	3b00      	subs	r3, #0
34012588:	bf18      	it	ne
3401258a:	2301      	movne	r3, #1
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
3401258c:	4628      	mov	r0, r5
  out_itf->data_lane_swap_enable = !!out_itf->data_lane_swap_enable;
3401258e:	64eb      	str	r3, [r5, #76]	@ 0x4c
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
34012590:	692b      	ldr	r3, [r5, #16]
34012592:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012594:	4604      	mov	r4, r0
34012596:	b1b0      	cbz	r0, 340125c6 <VD55G1_Start+0x116>
34012598:	f240 230d 	movw	r3, #525	@ 0x20d
3401259c:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
3401259e:	4a5d      	ldr	r2, [pc, #372]	@ (34012714 <VD55G1_Start+0x264>)
340125a0:	9301      	str	r3, [sp, #4]
340125a2:	2100      	movs	r1, #0
340125a4:	4628      	mov	r0, r5
340125a6:	9200      	str	r2, [sp, #0]
340125a8:	4a50      	ldr	r2, [pc, #320]	@ (340126ec <VD55G1_Start+0x23c>)
340125aa:	f7ff fca3 	bl	34011ef4 <VD55G1_log_impl>
340125ae:	4628      	mov	r0, r5
340125b0:	f7ff fcfe 	bl	34011fb0 <display_error>
  VD55G1_TraceError(ctx, ret);
340125b4:	f240 3301 	movw	r3, #769	@ 0x301
340125b8:	9402      	str	r4, [sp, #8]
340125ba:	e7a6      	b.n	3401250a <VD55G1_Start+0x5a>
  drv_ctx->pclk = VD55G1_GetPixelClock(ctx);
340125bc:	2300      	movs	r3, #0
340125be:	632b      	str	r3, [r5, #48]	@ 0x30
    return -1;
340125c0:	f04f 34ff 	mov.w	r4, #4294967295
340125c4:	e79e      	b.n	34012504 <VD55G1_Start+0x54>
  oif_ctrl = out_itf->data_lane_swap_enable << 6 |
340125c6:	e9d5 2312 	ldrd	r2, r3, [r5, #72]	@ 0x48
340125ca:	00d2      	lsls	r2, r2, #3
340125cc:	ea42 1283 	orr.w	r2, r2, r3, lsl #6
  ret = ctx->write16(ctx, VD55G1_REG_OIF_CTRL, oif_ctrl);
340125d0:	f44f 7143 	mov.w	r1, #780	@ 0x30c
340125d4:	4628      	mov	r0, r5
340125d6:	696b      	ldr	r3, [r5, #20]
340125d8:	b292      	uxth	r2, r2
340125da:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340125dc:	4604      	mov	r4, r0
340125de:	b958      	cbnz	r0, 340125f8 <VD55G1_Start+0x148>
  ret = ctx->write8(ctx, VD55G1_REG_OIF_IMG_CTRL, 0x2a);
340125e0:	222a      	movs	r2, #42	@ 0x2a
340125e2:	f240 310f 	movw	r1, #783	@ 0x30f
340125e6:	4628      	mov	r0, r5
340125e8:	692b      	ldr	r3, [r5, #16]
340125ea:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340125ec:	4604      	mov	r4, r0
340125ee:	b138      	cbz	r0, 34012600 <VD55G1_Start+0x150>
340125f0:	f240 2317 	movw	r3, #535	@ 0x217
340125f4:	9002      	str	r0, [sp, #8]
340125f6:	e7d2      	b.n	3401259e <VD55G1_Start+0xee>
  VD55G1_TraceError(ctx, ret);
340125f8:	f240 2313 	movw	r3, #531	@ 0x213
340125fc:	9002      	str	r0, [sp, #8]
340125fe:	e7ce      	b.n	3401259e <VD55G1_Start+0xee>
  mode = VD55G1_Resolution2Mode(drv_ctx->config_save.resolution);
34012600:	f895 3038 	ldrb.w	r3, [r5, #56]	@ 0x38
  switch (resolution) {
34012604:	2b03      	cmp	r3, #3
34012606:	f200 8102 	bhi.w	3401280e <VD55G1_Start+0x35e>
3401260a:	4a43      	ldr	r2, [pc, #268]	@ (34012718 <VD55G1_Start+0x268>)
3401260c:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
  if (!mode)
34012610:	2e00      	cmp	r6, #0
34012612:	f000 80fc 	beq.w	3401280e <VD55G1_Start+0x35e>
  ret = ctx->write8(ctx, VD55G1_REG_READOUT_CTRL, mode->bin_mode);
34012616:	f240 512e 	movw	r1, #1326	@ 0x52e
3401261a:	4628      	mov	r0, r5
3401261c:	692b      	ldr	r3, [r5, #16]
3401261e:	7a32      	ldrb	r2, [r6, #8]
34012620:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012622:	4604      	mov	r4, r0
34012624:	b188      	cbz	r0, 3401264a <VD55G1_Start+0x19a>
34012626:	f240 2327 	movw	r3, #551	@ 0x227
3401262a:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
3401262c:	4a3b      	ldr	r2, [pc, #236]	@ (3401271c <VD55G1_Start+0x26c>)
3401262e:	4628      	mov	r0, r5
34012630:	9200      	str	r2, [sp, #0]
34012632:	2100      	movs	r1, #0
34012634:	4a2d      	ldr	r2, [pc, #180]	@ (340126ec <VD55G1_Start+0x23c>)
34012636:	9301      	str	r3, [sp, #4]
34012638:	f7ff fc5c 	bl	34011ef4 <VD55G1_log_impl>
3401263c:	4628      	mov	r0, r5
3401263e:	f7ff fcb7 	bl	34011fb0 <display_error>
  VD55G1_TraceError(ctx, ret);
34012642:	f44f 7341 	mov.w	r3, #772	@ 0x304
34012646:	9402      	str	r4, [sp, #8]
34012648:	e75f      	b.n	3401250a <VD55G1_Start+0x5a>
  ret = ctx->write16(ctx, VD55G1_REG_X_START, mode->crop.left);
3401264a:	f240 5114 	movw	r1, #1300	@ 0x514
3401264e:	4628      	mov	r0, r5
34012650:	696b      	ldr	r3, [r5, #20]
34012652:	89b2      	ldrh	r2, [r6, #12]
34012654:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012656:	4604      	mov	r4, r0
34012658:	b958      	cbnz	r0, 34012672 <VD55G1_Start+0x1c2>
  ret = ctx->write16(ctx, VD55G1_REG_X_WIDTH, mode->crop.width);
3401265a:	f240 5116 	movw	r1, #1302	@ 0x516
3401265e:	4628      	mov	r0, r5
34012660:	696b      	ldr	r3, [r5, #20]
34012662:	8ab2      	ldrh	r2, [r6, #20]
34012664:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012666:	4604      	mov	r4, r0
34012668:	b138      	cbz	r0, 3401267a <VD55G1_Start+0x1ca>
3401266a:	f44f 730b 	mov.w	r3, #556	@ 0x22c
3401266e:	9002      	str	r0, [sp, #8]
34012670:	e7dc      	b.n	3401262c <VD55G1_Start+0x17c>
  VD55G1_TraceError(ctx, ret);
34012672:	f240 232a 	movw	r3, #554	@ 0x22a
34012676:	9002      	str	r0, [sp, #8]
34012678:	e7d8      	b.n	3401262c <VD55G1_Start+0x17c>
  ret = ctx->write16(ctx, VD55G1_REG_Y_START, mode->crop.top);
3401267a:	f44f 61a2 	mov.w	r1, #1296	@ 0x510
3401267e:	4628      	mov	r0, r5
34012680:	696b      	ldr	r3, [r5, #20]
34012682:	8a32      	ldrh	r2, [r6, #16]
34012684:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012686:	4604      	mov	r4, r0
34012688:	b118      	cbz	r0, 34012692 <VD55G1_Start+0x1e2>
3401268a:	f240 232e 	movw	r3, #558	@ 0x22e
3401268e:	9002      	str	r0, [sp, #8]
34012690:	e7cc      	b.n	3401262c <VD55G1_Start+0x17c>
  ret = ctx->write16(ctx, VD55G1_REG_Y_HEIGHT, mode->crop.height);
34012692:	f240 5112 	movw	r1, #1298	@ 0x512
34012696:	4628      	mov	r0, r5
34012698:	696b      	ldr	r3, [r5, #20]
3401269a:	8b32      	ldrh	r2, [r6, #24]
3401269c:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401269e:	4604      	mov	r4, r0
340126a0:	b118      	cbz	r0, 340126aa <VD55G1_Start+0x1fa>
340126a2:	f44f 730c 	mov.w	r3, #560	@ 0x230
340126a6:	9002      	str	r0, [sp, #8]
340126a8:	e7c0      	b.n	3401262c <VD55G1_Start+0x17c>
  ret = ctx->read16(ctx, VD55G1_REG_X_WIDTH, &width);
340126aa:	f240 5116 	movw	r1, #1302	@ 0x516
340126ae:	4628      	mov	r0, r5
340126b0:	68ab      	ldr	r3, [r5, #8]
340126b2:	aa05      	add	r2, sp, #20
340126b4:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340126b6:	4604      	mov	r4, r0
340126b8:	b3a0      	cbz	r0, 34012724 <VD55G1_Start+0x274>
340126ba:	f240 233e 	movw	r3, #574	@ 0x23e
340126be:	9002      	str	r0, [sp, #8]
340126c0:	4a17      	ldr	r2, [pc, #92]	@ (34012720 <VD55G1_Start+0x270>)
340126c2:	9301      	str	r3, [sp, #4]
340126c4:	4628      	mov	r0, r5
340126c6:	9200      	str	r2, [sp, #0]
340126c8:	2100      	movs	r1, #0
340126ca:	4a08      	ldr	r2, [pc, #32]	@ (340126ec <VD55G1_Start+0x23c>)
340126cc:	f7ff fc12 	bl	34011ef4 <VD55G1_log_impl>
340126d0:	4628      	mov	r0, r5
340126d2:	f7ff fc6d 	bl	34011fb0 <display_error>
  VD55G1_TraceError(ctx, ret);
340126d6:	f240 3307 	movw	r3, #775	@ 0x307
340126da:	9402      	str	r4, [sp, #8]
340126dc:	e715      	b.n	3401250a <VD55G1_Start+0x5a>
340126de:	bf00      	nop
340126e0:	f1194d80 	.word	0xf1194d80
340126e4:	389fd980 	.word	0x389fd980
340126e8:	340a76fc 	.word	0x340a76fc
340126ec:	34020a3a 	.word	0x34020a3a
340126f0:	340a770f 	.word	0x340a770f
340126f4:	dc3cb9ff 	.word	0xdc3cb9ff
340126f8:	23c345ff 	.word	0x23c345ff
340126fc:	11e1a2ff 	.word	0x11e1a2ff
34012700:	ee1e5cff 	.word	0xee1e5cff
34012704:	ca5b16ff 	.word	0xca5b16ff
34012708:	d18224ff 	.word	0xd18224ff
3401270c:	07270dff 	.word	0x07270dff
34012710:	02faf080 	.word	0x02faf080
34012714:	340a76e9 	.word	0x340a76e9
34012718:	340a7608 	.word	0x340a7608
3401271c:	340a76d8 	.word	0x340a76d8
34012720:	340a76ae 	.word	0x340a76ae
  min_line_len_mipi = ((width * VD55G1_MIPI_BPP + VD55G1_MIPI_MARGIN) * (uint64_t)drv_ctx->pclk)
34012724:	f8bd 1014 	ldrh.w	r1, [sp, #20]
34012728:	6b28      	ldr	r0, [r5, #48]	@ 0x30
3401272a:	00c9      	lsls	r1, r1, #3
3401272c:	f501 7161 	add.w	r1, r1, #900	@ 0x384
                      / VD55G1_MIPI_DATA_RATE_HZ;
34012730:	a3a3      	add	r3, pc, #652	@ (adr r3, 340129c0 <VD55G1_Start+0x510>)
34012732:	e9d3 2300 	ldrd	r2, r3, [r3]
34012736:	fba1 0100 	umull	r0, r1, r1, r0
3401273a:	f7ef f857 	bl	340017ec <__aeabi_uldivmod>
  line_len = MAX(VD55G1_MIN_LINE_LEN_ADC_10, min_line_len_mipi);
3401273e:	f5b0 6f8d 	cmp.w	r0, #1128	@ 0x468
34012742:	bfb8      	it	lt
34012744:	f44f 608d 	movlt.w	r0, #1128	@ 0x468
  ret = ctx->write16(ctx, VD55G1_REG_LINE_LENGTH, line_len);
34012748:	f44f 7140 	mov.w	r1, #768	@ 0x300
3401274c:	b282      	uxth	r2, r0
  line_len = MAX(VD55G1_MIN_LINE_LEN_ADC_10, min_line_len_mipi);
3401274e:	4606      	mov	r6, r0
  ret = ctx->write16(ctx, VD55G1_REG_LINE_LENGTH, line_len);
34012750:	696b      	ldr	r3, [r5, #20]
34012752:	4628      	mov	r0, r5
34012754:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012756:	4604      	mov	r4, r0
34012758:	2800      	cmp	r0, #0
3401275a:	d14e      	bne.n	340127fa <VD55G1_Start+0x34a>
  VD55G1_dbg(ctx, 1, "line_length = %d\n", line_len);
3401275c:	f240 2346 	movw	r3, #582	@ 0x246
34012760:	b2b6      	uxth	r6, r6
34012762:	2104      	movs	r1, #4
34012764:	4628      	mov	r0, r5
34012766:	4a8a      	ldr	r2, [pc, #552]	@ (34012990 <VD55G1_Start+0x4e0>)
34012768:	9300      	str	r3, [sp, #0]
3401276a:	9601      	str	r6, [sp, #4]
3401276c:	2301      	movs	r3, #1
3401276e:	f7ff fbc1 	bl	34011ef4 <VD55G1_log_impl>
  ret = VD55G1_ComputeFrameLength(ctx, drv_ctx->config_save.frame_rate, &frame_length);
34012772:	4628      	mov	r0, r5
34012774:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
34012776:	aa05      	add	r2, sp, #20
34012778:	f7ff fcca 	bl	34012110 <VD55G1_ComputeFrameLength>
  if (ret)
3401277c:	4604      	mov	r4, r0
3401277e:	2800      	cmp	r0, #0
34012780:	d1a9      	bne.n	340126d6 <VD55G1_Start+0x226>
  VD55G1_dbg(ctx, 1, "Set frame_length to %d to reach %d fps\n", frame_length, drv_ctx->config_save.frame_rate);
34012782:	f8bd 4014 	ldrh.w	r4, [sp, #20]
34012786:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
34012788:	2104      	movs	r1, #4
3401278a:	e9cd 4301 	strd	r4, r3, [sp, #4]
3401278e:	f240 2372 	movw	r3, #626	@ 0x272
34012792:	4628      	mov	r0, r5
34012794:	4a7f      	ldr	r2, [pc, #508]	@ (34012994 <VD55G1_Start+0x4e4>)
34012796:	9300      	str	r3, [sp, #0]
34012798:	2301      	movs	r3, #1
3401279a:	f7ff fbab 	bl	34011ef4 <VD55G1_log_impl>
  ret = ctx->write16(ctx, VD55G1_REG_FRAME_LENGTH, frame_length);
3401279e:	4622      	mov	r2, r4
340127a0:	f240 510c 	movw	r1, #1292	@ 0x50c
340127a4:	4628      	mov	r0, r5
340127a6:	696b      	ldr	r3, [r5, #20]
340127a8:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340127aa:	4604      	mov	r4, r0
340127ac:	bb48      	cbnz	r0, 34012802 <VD55G1_Start+0x352>
  if (awu->is_enable)
340127ae:	6d2b      	ldr	r3, [r5, #80]	@ 0x50
  max_fps = drv_ctx->config_save.frame_rate;
340127b0:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
  if (awu->is_enable)
340127b2:	bb7b      	cbnz	r3, 34012814 <VD55G1_Start+0x364>
  ret = VD55G1_ComputeFrameLength(ctx, max_fps, &frame_length);
340127b4:	4628      	mov	r0, r5
340127b6:	aa05      	add	r2, sp, #20
340127b8:	f7ff fcaa 	bl	34012110 <VD55G1_ComputeFrameLength>
  if (ret)
340127bc:	4604      	mov	r4, r0
340127be:	b9c0      	cbnz	r0, 340127f2 <VD55G1_Start+0x342>
  ret = ctx->write16(ctx, VD55G1_REG_MAX_COARSE_INTEGRATION_LINES, frame_length - 10);
340127c0:	f8bd 6014 	ldrh.w	r6, [sp, #20]
340127c4:	f240 3172 	movw	r1, #882	@ 0x372
340127c8:	3e0a      	subs	r6, #10
340127ca:	4628      	mov	r0, r5
340127cc:	696b      	ldr	r3, [r5, #20]
340127ce:	b2b2      	uxth	r2, r6
340127d0:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340127d2:	4604      	mov	r4, r0
340127d4:	b338      	cbz	r0, 34012826 <VD55G1_Start+0x376>
340127d6:	f240 238f 	movw	r3, #655	@ 0x28f
340127da:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
340127dc:	4a6e      	ldr	r2, [pc, #440]	@ (34012998 <VD55G1_Start+0x4e8>)
340127de:	4628      	mov	r0, r5
340127e0:	9200      	str	r2, [sp, #0]
340127e2:	2100      	movs	r1, #0
340127e4:	4a6d      	ldr	r2, [pc, #436]	@ (3401299c <VD55G1_Start+0x4ec>)
340127e6:	9301      	str	r3, [sp, #4]
340127e8:	f7ff fb84 	bl	34011ef4 <VD55G1_log_impl>
340127ec:	4628      	mov	r0, r5
340127ee:	f7ff fbdf 	bl	34011fb0 <display_error>
  VD55G1_TraceError(ctx, ret);
340127f2:	f240 330a 	movw	r3, #778	@ 0x30a
340127f6:	9402      	str	r4, [sp, #8]
340127f8:	e687      	b.n	3401250a <VD55G1_Start+0x5a>
  VD55G1_TraceError(ctx, ret);
340127fa:	f240 2345 	movw	r3, #581	@ 0x245
340127fe:	9002      	str	r0, [sp, #8]
34012800:	e75e      	b.n	340126c0 <VD55G1_Start+0x210>
  VD55G1_TraceError(ctx, ret);
34012802:	f44f 731d 	mov.w	r3, #628	@ 0x274
34012806:	4a66      	ldr	r2, [pc, #408]	@ (340129a0 <VD55G1_Start+0x4f0>)
34012808:	9002      	str	r0, [sp, #8]
3401280a:	9301      	str	r3, [sp, #4]
3401280c:	e75a      	b.n	340126c4 <VD55G1_Start+0x214>
3401280e:	f04f 34ff 	mov.w	r4, #4294967295
34012812:	e716      	b.n	34012642 <VD55G1_Start+0x192>
    max_fps = MAX(max_fps, awu->convergence_frame_rate);
34012814:	6d6b      	ldr	r3, [r5, #84]	@ 0x54
34012816:	4299      	cmp	r1, r3
34012818:	bfb8      	it	lt
3401281a:	4619      	movlt	r1, r3
    max_fps = MAX(max_fps, awu->awu_frame_rate);
3401281c:	6dab      	ldr	r3, [r5, #88]	@ 0x58
3401281e:	4299      	cmp	r1, r3
34012820:	bfb8      	it	lt
34012822:	4619      	movlt	r1, r3
34012824:	e7c6      	b.n	340127b4 <VD55G1_Start+0x304>
  VD55G1_dbg(ctx, 1, "Max coarse lines = %d\n", frame_length - 10);
34012826:	f44f 7324 	mov.w	r3, #656	@ 0x290
3401282a:	2104      	movs	r1, #4
3401282c:	4628      	mov	r0, r5
3401282e:	4a5d      	ldr	r2, [pc, #372]	@ (340129a4 <VD55G1_Start+0x4f4>)
34012830:	9300      	str	r3, [sp, #0]
34012832:	9601      	str	r6, [sp, #4]
34012834:	2301      	movs	r3, #1
34012836:	f7ff fb5d 	bl	34011ef4 <VD55G1_log_impl>
  reg = drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE ? VD55G1_EXP_MODE_MANUAL : VD55G1_EXP_MODE_AUTO;
3401283a:	f895 2041 	ldrb.w	r2, [r5, #65]	@ 0x41
  ret = ctx->write8(ctx, VD55G1_REG_EXP_MODE, reg);
3401283e:	f44f 61a0 	mov.w	r1, #1280	@ 0x500
  reg = drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE ? VD55G1_EXP_MODE_MANUAL : VD55G1_EXP_MODE_AUTO;
34012842:	3a00      	subs	r2, #0
34012844:	bf18      	it	ne
34012846:	2201      	movne	r2, #1
  ret = ctx->write8(ctx, VD55G1_REG_EXP_MODE, reg);
34012848:	4628      	mov	r0, r5
3401284a:	692b      	ldr	r3, [r5, #16]
3401284c:	0052      	lsls	r2, r2, #1
3401284e:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012850:	4604      	mov	r4, r0
34012852:	b118      	cbz	r0, 3401285c <VD55G1_Start+0x3ac>
34012854:	f240 2395 	movw	r3, #661	@ 0x295
34012858:	9002      	str	r0, [sp, #8]
3401285a:	e7bf      	b.n	340127dc <VD55G1_Start+0x32c>
  switch (drv_ctx->config_save.flip_mirror_mode) {
3401285c:	f895 3040 	ldrb.w	r3, [r5, #64]	@ 0x40
34012860:	2b03      	cmp	r3, #3
34012862:	d905      	bls.n	34012870 <VD55G1_Start+0x3c0>
    return -1;
34012864:	f04f 34ff 	mov.w	r4, #4294967295
  VD55G1_TraceError(ctx, ret);
34012868:	f240 330d 	movw	r3, #781	@ 0x30d
3401286c:	9402      	str	r4, [sp, #8]
3401286e:	e64c      	b.n	3401250a <VD55G1_Start+0x5a>
  ret = ctx->write8(ctx, VD55G1_REG_ORIENTATION, mode);
34012870:	4a4d      	ldr	r2, [pc, #308]	@ (340129a8 <VD55G1_Start+0x4f8>)
34012872:	692c      	ldr	r4, [r5, #16]
34012874:	f240 3102 	movw	r1, #770	@ 0x302
34012878:	4628      	mov	r0, r5
3401287a:	5cd2      	ldrb	r2, [r2, r3]
3401287c:	47a0      	blx	r4
  VD55G1_TraceError(ctx, ret);
3401287e:	4604      	mov	r4, r0
34012880:	b948      	cbnz	r0, 34012896 <VD55G1_Start+0x3e6>
  switch (drv_ctx->config_save.patgen) {
34012882:	f895 3041 	ldrb.w	r3, [r5, #65]	@ 0x41
34012886:	2b02      	cmp	r3, #2
34012888:	d914      	bls.n	340128b4 <VD55G1_Start+0x404>
    return -1;
3401288a:	f04f 34ff 	mov.w	r4, #4294967295
  VD55G1_TraceError(ctx, ret);
3401288e:	f44f 7344 	mov.w	r3, #784	@ 0x310
34012892:	9402      	str	r4, [sp, #8]
34012894:	e639      	b.n	3401250a <VD55G1_Start+0x5a>
  VD55G1_TraceError(ctx, ret);
34012896:	f240 23b2 	movw	r3, #690	@ 0x2b2
3401289a:	4a44      	ldr	r2, [pc, #272]	@ (340129ac <VD55G1_Start+0x4fc>)
3401289c:	9002      	str	r0, [sp, #8]
3401289e:	9200      	str	r2, [sp, #0]
340128a0:	4628      	mov	r0, r5
340128a2:	2100      	movs	r1, #0
340128a4:	4a3d      	ldr	r2, [pc, #244]	@ (3401299c <VD55G1_Start+0x4ec>)
340128a6:	9301      	str	r3, [sp, #4]
340128a8:	f7ff fb24 	bl	34011ef4 <VD55G1_log_impl>
340128ac:	4628      	mov	r0, r5
340128ae:	f7ff fb7f 	bl	34011fb0 <display_error>
  VD55G1_TraceError(ctx, ret);
340128b2:	e7d9      	b.n	34012868 <VD55G1_Start+0x3b8>
340128b4:	4a3e      	ldr	r2, [pc, #248]	@ (340129b0 <VD55G1_Start+0x500>)
340128b6:	f832 6013 	ldrh.w	r6, [r2, r3, lsl #1]
  if (drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE)
340128ba:	b313      	cbz	r3, 34012902 <VD55G1_Start+0x452>
    ret = ctx->write8(ctx, VD55G1_REG_DUSTER_CTRL, VD55G1_DUSTER_DISABLE);
340128bc:	4602      	mov	r2, r0
340128be:	f240 31ae 	movw	r1, #942	@ 0x3ae
340128c2:	4628      	mov	r0, r5
340128c4:	692b      	ldr	r3, [r5, #16]
340128c6:	4798      	blx	r3
    VD55G1_TraceError(ctx, ret);
340128c8:	4604      	mov	r4, r0
340128ca:	b170      	cbz	r0, 340128ea <VD55G1_Start+0x43a>
340128cc:	f240 23ce 	movw	r3, #718	@ 0x2ce
340128d0:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
340128d2:	4a38      	ldr	r2, [pc, #224]	@ (340129b4 <VD55G1_Start+0x504>)
340128d4:	4628      	mov	r0, r5
340128d6:	9200      	str	r2, [sp, #0]
340128d8:	2100      	movs	r1, #0
340128da:	4a30      	ldr	r2, [pc, #192]	@ (3401299c <VD55G1_Start+0x4ec>)
340128dc:	9301      	str	r3, [sp, #4]
340128de:	f7ff fb09 	bl	34011ef4 <VD55G1_log_impl>
340128e2:	4628      	mov	r0, r5
340128e4:	f7ff fb64 	bl	34011fb0 <display_error>
  VD55G1_TraceError(ctx, ret);
340128e8:	e7d1      	b.n	3401288e <VD55G1_Start+0x3de>
    ret = ctx->write8(ctx, VD55G1_REG_DARKCAL_CTRL, VD55G1_DARKCAL_BYPASS_DARKAVG);
340128ea:	2202      	movs	r2, #2
340128ec:	f240 312a 	movw	r1, #810	@ 0x32a
340128f0:	4628      	mov	r0, r5
340128f2:	692b      	ldr	r3, [r5, #16]
340128f4:	4798      	blx	r3
    VD55G1_TraceError(ctx, ret);
340128f6:	4604      	mov	r4, r0
340128f8:	b118      	cbz	r0, 34012902 <VD55G1_Start+0x452>
340128fa:	f44f 7334 	mov.w	r3, #720	@ 0x2d0
340128fe:	9002      	str	r0, [sp, #8]
34012900:	e7e7      	b.n	340128d2 <VD55G1_Start+0x422>
  ret = ctx->write16(ctx, VD55G1_REG_PATGEN_CTRL, value);
34012902:	4632      	mov	r2, r6
34012904:	f44f 7141 	mov.w	r1, #772	@ 0x304
34012908:	4628      	mov	r0, r5
3401290a:	696b      	ldr	r3, [r5, #20]
3401290c:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401290e:	4604      	mov	r4, r0
34012910:	b118      	cbz	r0, 3401291a <VD55G1_Start+0x46a>
34012912:	f44f 7335 	mov.w	r3, #724	@ 0x2d4
34012916:	9002      	str	r0, [sp, #8]
34012918:	e7db      	b.n	340128d2 <VD55G1_Start+0x422>
  return VD55G1_SetFlicker(ctx, drv_ctx->config_save.flicker);
3401291a:	4628      	mov	r0, r5
3401291c:	f895 1042 	ldrb.w	r1, [r5, #66]	@ 0x42
34012920:	f7ff fc48 	bl	340121b4 <VD55G1_SetFlicker>
  VD55G1_TraceError(ctx, ret);
34012924:	4604      	mov	r4, r0
34012926:	b118      	cbz	r0, 34012930 <VD55G1_Start+0x480>
34012928:	f240 3313 	movw	r3, #787	@ 0x313
3401292c:	9002      	str	r0, [sp, #8]
3401292e:	e5ec      	b.n	3401250a <VD55G1_Start+0x5a>
  ret = ctx->write8(ctx, VD55G1_REG_STBY, VD55G1_STBY_START_STREAM);
34012930:	2201      	movs	r2, #1
34012932:	f240 2101 	movw	r1, #513	@ 0x201
34012936:	4628      	mov	r0, r5
34012938:	692b      	ldr	r3, [r5, #16]
3401293a:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401293c:	4604      	mov	r4, r0
3401293e:	b128      	cbz	r0, 3401294c <VD55G1_Start+0x49c>
34012940:	f240 331d 	movw	r3, #797	@ 0x31d
34012944:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
34012946:	4a1c      	ldr	r2, [pc, #112]	@ (340129b8 <VD55G1_Start+0x508>)
34012948:	9301      	str	r3, [sp, #4]
3401294a:	e5e0      	b.n	3401250e <VD55G1_Start+0x5e>
  ret = VD55G1_PollReg8(ctx, VD55G1_REG_STBY, VD55G1_CMD_ACK);
3401294c:	4602      	mov	r2, r0
3401294e:	f240 2101 	movw	r1, #513	@ 0x201
34012952:	4628      	mov	r0, r5
34012954:	f7ff fadc 	bl	34011f10 <VD55G1_PollReg8>
  VD55G1_TraceError(ctx, ret);
34012958:	4604      	mov	r4, r0
3401295a:	b948      	cbnz	r0, 34012970 <VD55G1_Start+0x4c0>
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_STREAMING);
3401295c:	2103      	movs	r1, #3
3401295e:	4628      	mov	r0, r5
34012960:	f7ff fb02 	bl	34011f68 <VD55G1_WaitState>
  VD55G1_TraceError(ctx, ret);
34012964:	4604      	mov	r4, r0
34012966:	b138      	cbz	r0, 34012978 <VD55G1_Start+0x4c8>
34012968:	f240 3323 	movw	r3, #803	@ 0x323
3401296c:	9002      	str	r0, [sp, #8]
3401296e:	e7ea      	b.n	34012946 <VD55G1_Start+0x496>
  VD55G1_TraceError(ctx, ret);
34012970:	f44f 7348 	mov.w	r3, #800	@ 0x320
34012974:	9002      	str	r0, [sp, #8]
34012976:	e7e6      	b.n	34012946 <VD55G1_Start+0x496>
  VD55G1_notice(ctx, "Streaming is on\n");
34012978:	f240 3325 	movw	r3, #805	@ 0x325
3401297c:	2102      	movs	r1, #2
3401297e:	4628      	mov	r0, r5
34012980:	4a0e      	ldr	r2, [pc, #56]	@ (340129bc <VD55G1_Start+0x50c>)
34012982:	f7ff fab7 	bl	34011ef4 <VD55G1_log_impl>
    return ret;
  drv_ctx->state = VD55G1_ST_STREAMING;
34012986:	2301      	movs	r3, #1
34012988:	62ab      	str	r3, [r5, #40]	@ 0x28

  return 0;
}
3401298a:	4620      	mov	r0, r4
3401298c:	b007      	add	sp, #28
3401298e:	bdf0      	pop	{r4, r5, r6, r7, pc}
34012990:	34020c3e 	.word	0x34020c3e
34012994:	34020c61 	.word	0x34020c61
34012998:	340a767f 	.word	0x340a767f
3401299c:	34020a3a 	.word	0x34020a3a
340129a0:	340a76c2 	.word	0x340a76c2
340129a4:	34020c9a 	.word	0x34020c9a
340129a8:	340a7602 	.word	0x340a7602
340129ac:	340a7668 	.word	0x340a7668
340129b0:	340a75fc 	.word	0x340a75fc
340129b4:	340a7655 	.word	0x340a7655
340129b8:	340a762d 	.word	0x340a762d
340129bc:	34020cc2 	.word	0x34020cc2
340129c0:	2fec1100 	.word	0x2fec1100
340129c4:	00000000 	.word	0x00000000

340129c8 <VD55G1_Stop>:

int VD55G1_Stop(VD55G1_Ctx_t *ctx)
{
340129c8:	b510      	push	{r4, lr}
340129ca:	4604      	mov	r4, r0
  struct drv_ctx *drv_ctx = &ctx->ctx;
  int ret;

  ret = VD55G1_StopStreaming(ctx);
340129cc:	f7ff fc1a 	bl	34012204 <VD55G1_StopStreaming>
  if (ret)
340129d0:	b900      	cbnz	r0, 340129d4 <VD55G1_Stop+0xc>
    return ret;
  drv_ctx->state = VD55G1_ST_IDLE;
340129d2:	62a0      	str	r0, [r4, #40]	@ 0x28

  return 0;
}
340129d4:	bd10      	pop	{r4, pc}

340129d6 <VD55G1_SetFlipMirrorMode>:

  return 0;
}

int VD55G1_SetFlipMirrorMode(VD55G1_Ctx_t *ctx, VD55G1_MirrorFlip_t mode)
{
340129d6:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = ctx->read8(ctx, VD55G1_REG_SYSTEM_FSM, &state);
340129d8:	6843      	ldr	r3, [r0, #4]
{
340129da:	460d      	mov	r5, r1
  ret = ctx->read8(ctx, VD55G1_REG_SYSTEM_FSM, &state);
340129dc:	f10d 0207 	add.w	r2, sp, #7
340129e0:	211c      	movs	r1, #28
{
340129e2:	4604      	mov	r4, r0
  ret = ctx->read8(ctx, VD55G1_REG_SYSTEM_FSM, &state);
340129e4:	4798      	blx	r3
  if (ret)
340129e6:	2800      	cmp	r0, #0
340129e8:	d10f      	bne.n	34012a0a <VD55G1_SetFlipMirrorMode+0x34>
  return state == VD55G1_SYSTEM_FSM_STREAMING;
340129ea:	f89d 3007 	ldrb.w	r3, [sp, #7]

  is_streaming = VD55G1_IsStreaming(ctx);
  if (is_streaming < 0)
    return is_streaming;

  if (is_streaming) {
340129ee:	2b03      	cmp	r3, #3
340129f0:	d10e      	bne.n	34012a10 <VD55G1_SetFlipMirrorMode+0x3a>
    ret = VD55G1_Stop(ctx);
340129f2:	4620      	mov	r0, r4
340129f4:	f7ff ffe8 	bl	340129c8 <VD55G1_Stop>
    if (ret)
340129f8:	b940      	cbnz	r0, 34012a0c <VD55G1_SetFlipMirrorMode+0x36>
  }

  drv_ctx->config_save.flip_mirror_mode = mode;

  if (is_streaming) {
    ret = VD55G1_Start(ctx);
340129fa:	4620      	mov	r0, r4
  drv_ctx->config_save.flip_mirror_mode = mode;
340129fc:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    if (ret)
      return ret;
  }

  return 0;
}
34012a00:	b003      	add	sp, #12
34012a02:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    ret = VD55G1_Start(ctx);
34012a06:	f7ff bd53 	b.w	340124b0 <VD55G1_Start>
  if (is_streaming < 0)
34012a0a:	daf2      	bge.n	340129f2 <VD55G1_SetFlipMirrorMode+0x1c>
}
34012a0c:	b003      	add	sp, #12
34012a0e:	bd30      	pop	{r4, r5, pc}
  drv_ctx->config_save.flip_mirror_mode = mode;
34012a10:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
  if (is_streaming) {
34012a14:	e7fa      	b.n	34012a0c <VD55G1_SetFlipMirrorMode+0x36>

34012a16 <VD6G_error>:
  ctx->log(ctx, VD6G_LVL_WARNING, format, ap);
  va_end(ap);
}

static void VD6G_error(VD6G_Ctx_t *ctx, const char *format, ...)
{
34012a16:	b40e      	push	{r1, r2, r3}
34012a18:	b517      	push	{r0, r1, r2, r4, lr}
  va_list ap;

  if (!ctx->log)
34012a1a:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012a1c:	b124      	cbz	r4, 34012a28 <VD6G_error+0x12>
    return ;

  va_start(ap, format);
34012a1e:	ab06      	add	r3, sp, #24
  ctx->log(ctx, VD6G_LVL_ERROR, format, ap);
34012a20:	2100      	movs	r1, #0
34012a22:	9a05      	ldr	r2, [sp, #20]
  va_start(ap, format);
34012a24:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_ERROR, format, ap);
34012a26:	47a0      	blx	r4
  va_end(ap);
}
34012a28:	b003      	add	sp, #12
34012a2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012a2e:	b003      	add	sp, #12
34012a30:	4770      	bx	lr

34012a32 <VD6G_notice>:
{
34012a32:	b40e      	push	{r1, r2, r3}
34012a34:	b517      	push	{r0, r1, r2, r4, lr}
  if (!ctx->log)
34012a36:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012a38:	b124      	cbz	r4, 34012a44 <VD6G_notice+0x12>
  va_start(ap, format);
34012a3a:	ab06      	add	r3, sp, #24
  ctx->log(ctx, VD6G_LVL_NOTICE, format, ap);
34012a3c:	2102      	movs	r1, #2
34012a3e:	9a05      	ldr	r2, [sp, #20]
  va_start(ap, format);
34012a40:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_NOTICE, format, ap);
34012a42:	47a0      	blx	r4
}
34012a44:	b003      	add	sp, #12
34012a46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012a4a:	b003      	add	sp, #12
34012a4c:	4770      	bx	lr
	...

34012a50 <display_error>:

static void display_error(VD6G_Ctx_t *ctx)
{
34012a50:	b513      	push	{r0, r1, r4, lr}
  uint16_t reg16;
  int ret;

  ret = ctx->read16(ctx, VD6G_ERROR_CODE, &reg16);
34012a52:	6883      	ldr	r3, [r0, #8]
34012a54:	211c      	movs	r1, #28
34012a56:	f10d 0206 	add.w	r2, sp, #6
{
34012a5a:	4604      	mov	r4, r0
  ret = ctx->read16(ctx, VD6G_ERROR_CODE, &reg16);
34012a5c:	4798      	blx	r3
  assert(ret == 0);
34012a5e:	b130      	cbz	r0, 34012a6e <display_error+0x1e>
34012a60:	f240 1131 	movw	r1, #305	@ 0x131
34012a64:	4b06      	ldr	r3, [pc, #24]	@ (34012a80 <display_error+0x30>)
34012a66:	4a07      	ldr	r2, [pc, #28]	@ (34012a84 <display_error+0x34>)
34012a68:	4807      	ldr	r0, [pc, #28]	@ (34012a88 <display_error+0x38>)
34012a6a:	f006 f9f7 	bl	34018e5c <__assert_func>
  VD6G_error(ctx, "ERROR_CODE : 0x%04x\n", reg16);
34012a6e:	4620      	mov	r0, r4
34012a70:	f8bd 2006 	ldrh.w	r2, [sp, #6]
34012a74:	4905      	ldr	r1, [pc, #20]	@ (34012a8c <display_error+0x3c>)
34012a76:	f7ff ffce 	bl	34012a16 <VD6G_error>
}
34012a7a:	b002      	add	sp, #8
34012a7c:	bd10      	pop	{r4, pc}
34012a7e:	bf00      	nop
34012a80:	3401d8b3 	.word	0x3401d8b3
34012a84:	340a90cf 	.word	0x340a90cf
34012a88:	34020ce3 	.word	0x34020ce3
34012a8c:	34020a25 	.word	0x34020a25

34012a90 <VD6G_PollReg8>:

static int VD6G_PollReg8(VD6G_Ctx_t *ctx, uint16_t addr, uint8_t poll_val)
{
34012a90:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
34012a94:	4604      	mov	r4, r0
34012a96:	460f      	mov	r7, r1
34012a98:	4690      	mov	r8, r2
34012a9a:	2631      	movs	r6, #49	@ 0x31
  int loop_nb = timeout_ms / loop_delay_ms;
  uint8_t val;
  int ret;

  while (--loop_nb) {
    ret = ctx->read8(ctx, addr, &val);
34012a9c:	4639      	mov	r1, r7
34012a9e:	4620      	mov	r0, r4
34012aa0:	6863      	ldr	r3, [r4, #4]
34012aa2:	f10d 020f 	add.w	r2, sp, #15
34012aa6:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
34012aa8:	4605      	mov	r5, r0
34012aaa:	b938      	cbnz	r0, 34012abc <VD6G_PollReg8+0x2c>
    if (val == poll_val)
34012aac:	f89d 300f 	ldrb.w	r3, [sp, #15]
34012ab0:	4543      	cmp	r3, r8
34012ab2:	d10f      	bne.n	34012ad4 <VD6G_PollReg8+0x44>
      return 0;
    ctx->delay(ctx, loop_delay_ms);
  }

  return -1;
}
34012ab4:	4628      	mov	r0, r5
34012ab6:	b004      	add	sp, #16
34012ab8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    VD6G_TraceError(ctx, ret);
34012abc:	9000      	str	r0, [sp, #0]
34012abe:	f240 133f 	movw	r3, #319	@ 0x13f
34012ac2:	4620      	mov	r0, r4
34012ac4:	4a08      	ldr	r2, [pc, #32]	@ (34012ae8 <VD6G_PollReg8+0x58>)
34012ac6:	4909      	ldr	r1, [pc, #36]	@ (34012aec <VD6G_PollReg8+0x5c>)
34012ac8:	f7ff ffa5 	bl	34012a16 <VD6G_error>
34012acc:	4620      	mov	r0, r4
34012ace:	f7ff ffbf 	bl	34012a50 <display_error>
34012ad2:	e7ef      	b.n	34012ab4 <VD6G_PollReg8+0x24>
    ctx->delay(ctx, loop_delay_ms);
34012ad4:	210a      	movs	r1, #10
34012ad6:	4620      	mov	r0, r4
34012ad8:	6a23      	ldr	r3, [r4, #32]
34012ada:	4798      	blx	r3
  while (--loop_nb) {
34012adc:	3e01      	subs	r6, #1
34012ade:	d1dd      	bne.n	34012a9c <VD6G_PollReg8+0xc>
  return -1;
34012ae0:	f04f 35ff 	mov.w	r5, #4294967295
34012ae4:	e7e6      	b.n	34012ab4 <VD6G_PollReg8+0x24>
34012ae6:	bf00      	nop
34012ae8:	340a90dd 	.word	0x340a90dd
34012aec:	34020a4a 	.word	0x34020a4a

34012af0 <VD6G_SetExposureModeInternal>:

static int VD6G_SetExposureModeInternal(VD6G_Ctx_t *ctx, VD6G_ExposureMode_t mode)
{
  int ret;

  if ((mode != VD6G_EXPOSURE_AUTO) &&
34012af0:	2902      	cmp	r1, #2
{
34012af2:	b537      	push	{r0, r1, r2, r4, r5, lr}
34012af4:	4605      	mov	r5, r0
34012af6:	460a      	mov	r2, r1
  if ((mode != VD6G_EXPOSURE_AUTO) &&
34012af8:	d813      	bhi.n	34012b22 <VD6G_SetExposureModeInternal+0x32>
      (mode != VD6G_EXPOSURE_FREEZE_AEALGO) &&
      (mode != VD6G_EXPOSURE_MANUAL)) {
    return -1;
  }

  ret = ctx->write8(ctx, VD6G_REG_EXP_MODE, mode);
34012afa:	f240 414c 	movw	r1, #1100	@ 0x44c
34012afe:	6903      	ldr	r3, [r0, #16]
34012b00:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012b02:	4604      	mov	r4, r0
34012b04:	b150      	cbz	r0, 34012b1c <VD6G_SetExposureModeInternal+0x2c>
34012b06:	9000      	str	r0, [sp, #0]
34012b08:	f240 2367 	movw	r3, #615	@ 0x267
34012b0c:	4628      	mov	r0, r5
34012b0e:	4a06      	ldr	r2, [pc, #24]	@ (34012b28 <VD6G_SetExposureModeInternal+0x38>)
34012b10:	4906      	ldr	r1, [pc, #24]	@ (34012b2c <VD6G_SetExposureModeInternal+0x3c>)
34012b12:	f7ff ff80 	bl	34012a16 <VD6G_error>
34012b16:	4628      	mov	r0, r5
34012b18:	f7ff ff9a 	bl	34012a50 <display_error>

  return 0;
}
34012b1c:	4620      	mov	r0, r4
34012b1e:	b003      	add	sp, #12
34012b20:	bd30      	pop	{r4, r5, pc}
    return -1;
34012b22:	f04f 34ff 	mov.w	r4, #4294967295
34012b26:	e7f9      	b.n	34012b1c <VD6G_SetExposureModeInternal+0x2c>
34012b28:	340a8fce 	.word	0x340a8fce
34012b2c:	34020a4a 	.word	0x34020a4a

34012b30 <VD6G_SetFlicker>:
static int VD6G_SetFlicker(VD6G_Ctx_t *ctx, VD6G_Flicker_t flicker)
{
  uint16_t mode;
  int ret;

  switch (flicker) {
34012b30:	2902      	cmp	r1, #2
{
34012b32:	b537      	push	{r0, r1, r2, r4, r5, lr}
34012b34:	4605      	mov	r5, r0
34012b36:	d815      	bhi.n	34012b64 <VD6G_SetFlicker+0x34>
    break;
  default:
    return -1;
  }

  ret = ctx->write16(ctx, VD6G_REG_AE_COMPILER_CONTROL, mode);
34012b38:	4a0c      	ldr	r2, [pc, #48]	@ (34012b6c <VD6G_SetFlicker+0x3c>)
34012b3a:	6943      	ldr	r3, [r0, #20]
34012b3c:	5c52      	ldrb	r2, [r2, r1]
34012b3e:	f44f 6186 	mov.w	r1, #1072	@ 0x430
34012b42:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012b44:	4604      	mov	r4, r0
34012b46:	b150      	cbz	r0, 34012b5e <VD6G_SetFlicker+0x2e>
34012b48:	9000      	str	r0, [sp, #0]
34012b4a:	f240 33b1 	movw	r3, #945	@ 0x3b1
34012b4e:	4628      	mov	r0, r5
34012b50:	4a07      	ldr	r2, [pc, #28]	@ (34012b70 <VD6G_SetFlicker+0x40>)
34012b52:	4908      	ldr	r1, [pc, #32]	@ (34012b74 <VD6G_SetFlicker+0x44>)
34012b54:	f7ff ff5f 	bl	34012a16 <VD6G_error>
34012b58:	4628      	mov	r0, r5
34012b5a:	f7ff ff79 	bl	34012a50 <display_error>

  return 0;
}
34012b5e:	4620      	mov	r0, r4
34012b60:	b003      	add	sp, #12
34012b62:	bd30      	pop	{r4, r5, pc}
    return -1;
34012b64:	f04f 34ff 	mov.w	r4, #4294967295
34012b68:	e7f9      	b.n	34012b5e <VD6G_SetFlicker+0x2e>
34012b6a:	bf00      	nop
34012b6c:	340a8e94 	.word	0x340a8e94
34012b70:	340a8f98 	.word	0x340a8f98
34012b74:	34020a4a 	.word	0x34020a4a

34012b78 <VD6G_GetLineTimeInUs>:
{
34012b78:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34012b7a:	460e      	mov	r6, r1
  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_len);
34012b7c:	6883      	ldr	r3, [r0, #8]
34012b7e:	f44f 7140 	mov.w	r1, #768	@ 0x300
34012b82:	f10d 020e 	add.w	r2, sp, #14
{
34012b86:	4605      	mov	r5, r0
  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_len);
34012b88:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012b8a:	4604      	mov	r4, r0
34012b8c:	b968      	cbnz	r0, 34012baa <VD6G_GetLineTimeInUs+0x32>
  *line_time_in_us = ((uint64_t)line_len * 1000000) / VD6G_PIXEL_CLOCK;
34012b8e:	a311      	add	r3, pc, #68	@ (adr r3, 34012bd4 <VD6G_GetLineTimeInUs+0x5c>)
34012b90:	e9d3 2300 	ldrd	r2, r3, [r3]
34012b94:	f8bd 000e 	ldrh.w	r0, [sp, #14]
34012b98:	490b      	ldr	r1, [pc, #44]	@ (34012bc8 <VD6G_GetLineTimeInUs+0x50>)
34012b9a:	fba0 0101 	umull	r0, r1, r0, r1
34012b9e:	f7ee fe25 	bl	340017ec <__aeabi_uldivmod>
34012ba2:	6030      	str	r0, [r6, #0]
}
34012ba4:	4620      	mov	r0, r4
34012ba6:	b004      	add	sp, #16
34012ba8:	bd70      	pop	{r4, r5, r6, pc}
  VD6G_TraceError(ctx, ret);
34012baa:	9000      	str	r0, [sp, #0]
34012bac:	f44f 73a7 	mov.w	r3, #334	@ 0x14e
34012bb0:	4628      	mov	r0, r5
34012bb2:	4a06      	ldr	r2, [pc, #24]	@ (34012bcc <VD6G_GetLineTimeInUs+0x54>)
34012bb4:	4906      	ldr	r1, [pc, #24]	@ (34012bd0 <VD6G_GetLineTimeInUs+0x58>)
34012bb6:	f7ff ff2e 	bl	34012a16 <VD6G_error>
34012bba:	4628      	mov	r0, r5
34012bbc:	f7ff ff48 	bl	34012a50 <display_error>
34012bc0:	e7f0      	b.n	34012ba4 <VD6G_GetLineTimeInUs+0x2c>
34012bc2:	bf00      	nop
34012bc4:	f3af 8000 	nop.w
34012bc8:	000f4240 	.word	0x000f4240
34012bcc:	340a8ee5 	.word	0x340a8ee5
34012bd0:	34020a4a 	.word	0x34020a4a
34012bd4:	09959d00 	.word	0x09959d00
34012bd8:	00000000 	.word	0x00000000

34012bdc <VD6G_warn.constprop.0>:
static void VD6G_warn(VD6G_Ctx_t *ctx, const char *format, ...)
34012bdc:	b40e      	push	{r1, r2, r3}
34012bde:	b517      	push	{r0, r1, r2, r4, lr}
  if (!ctx->log)
34012be0:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012be2:	b124      	cbz	r4, 34012bee <VD6G_warn.constprop.0+0x12>
  va_start(ap, format);
34012be4:	ab06      	add	r3, sp, #24
  ctx->log(ctx, VD6G_LVL_WARNING, format, ap);
34012be6:	2101      	movs	r1, #1
34012be8:	4a03      	ldr	r2, [pc, #12]	@ (34012bf8 <VD6G_warn.constprop.0+0x1c>)
  va_start(ap, format);
34012bea:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_WARNING, format, ap);
34012bec:	47a0      	blx	r4
}
34012bee:	b003      	add	sp, #12
34012bf0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012bf4:	b003      	add	sp, #12
34012bf6:	4770      	bx	lr
34012bf8:	34020926 	.word	0x34020926

34012bfc <VD6G_dbg.constprop.0>:
static void VD6G_dbg(VD6G_Ctx_t *ctx, int lvl, const char *format, ...)
34012bfc:	b40c      	push	{r2, r3}
34012bfe:	b513      	push	{r0, r1, r4, lr}
  if (!ctx->log)
34012c00:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012c02:	b124      	cbz	r4, 34012c0e <VD6G_dbg.constprop.0+0x12>
  va_start(ap, format);
34012c04:	ab05      	add	r3, sp, #20
  ctx->log(ctx, VD6G_LVL_DBG(lvl), format, ap);
34012c06:	2103      	movs	r1, #3
34012c08:	9a04      	ldr	r2, [sp, #16]
  va_start(ap, format);
34012c0a:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_DBG(lvl), format, ap);
34012c0c:	47a0      	blx	r4
}
34012c0e:	b002      	add	sp, #8
34012c10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012c14:	b002      	add	sp, #8
34012c16:	4770      	bx	lr

34012c18 <VD6G_GetTopDie>:
{
34012c18:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34012c1a:	460e      	mov	r6, r1
  ret = ctx->read16(ctx, VD6G_REG_REVISION, &reg16);
34012c1c:	6883      	ldr	r3, [r0, #8]
34012c1e:	2102      	movs	r1, #2
34012c20:	f10d 020e 	add.w	r2, sp, #14
{
34012c24:	4605      	mov	r5, r0
  ret = ctx->read16(ctx, VD6G_REG_REVISION, &reg16);
34012c26:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012c28:	4604      	mov	r4, r0
34012c2a:	b968      	cbnz	r0, 34012c48 <VD6G_GetTopDie+0x30>
  VD6G_dbg(ctx, 0, "revision = 0x%04x\n", reg16);
34012c2c:	4601      	mov	r1, r0
34012c2e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34012c32:	4628      	mov	r0, r5
34012c34:	4a0a      	ldr	r2, [pc, #40]	@ (34012c60 <VD6G_GetTopDie+0x48>)
34012c36:	f7ff ffe1 	bl	34012bfc <VD6G_dbg.constprop.0>
  *top_die = reg16 >> 8;
34012c3a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34012c3e:	0a1b      	lsrs	r3, r3, #8
34012c40:	7033      	strb	r3, [r6, #0]
}
34012c42:	4620      	mov	r0, r4
34012c44:	b004      	add	sp, #16
34012c46:	bd70      	pop	{r4, r5, r6, pc}
  VD6G_TraceError(ctx, ret);
34012c48:	9000      	str	r0, [sp, #0]
34012c4a:	f240 1373 	movw	r3, #371	@ 0x173
34012c4e:	4628      	mov	r0, r5
34012c50:	4a04      	ldr	r2, [pc, #16]	@ (34012c64 <VD6G_GetTopDie+0x4c>)
34012c52:	4905      	ldr	r1, [pc, #20]	@ (34012c68 <VD6G_GetTopDie+0x50>)
34012c54:	f7ff fedf 	bl	34012a16 <VD6G_error>
34012c58:	4628      	mov	r0, r5
34012c5a:	f7ff fef9 	bl	34012a50 <display_error>
34012c5e:	e7f0      	b.n	34012c42 <VD6G_GetTopDie+0x2a>
34012c60:	34020be0 	.word	0x34020be0
34012c64:	340a90ae 	.word	0x340a90ae
34012c68:	34020a4a 	.word	0x34020a4a

34012c6c <VD6G_WaitState>:
{
34012c6c:	b570      	push	{r4, r5, r6, lr}
  int ret = VD6G_PollReg8(ctx, VD6G_REG_SYSTEM_FSM, state);
34012c6e:	b2ca      	uxtb	r2, r1
{
34012c70:	460d      	mov	r5, r1
  int ret = VD6G_PollReg8(ctx, VD6G_REG_SYSTEM_FSM, state);
34012c72:	2128      	movs	r1, #40	@ 0x28
{
34012c74:	4606      	mov	r6, r0
  int ret = VD6G_PollReg8(ctx, VD6G_REG_SYSTEM_FSM, state);
34012c76:	f7ff ff0b 	bl	34012a90 <VD6G_PollReg8>
  if (ret)
34012c7a:	4604      	mov	r4, r0
34012c7c:	b130      	cbz	r0, 34012c8c <VD6G_WaitState+0x20>
    VD6G_warn(ctx, "Unable to reach state %d\n", state);
34012c7e:	462a      	mov	r2, r5
34012c80:	4630      	mov	r0, r6
34012c82:	4906      	ldr	r1, [pc, #24]	@ (34012c9c <VD6G_WaitState+0x30>)
34012c84:	f7ff ffaa 	bl	34012bdc <VD6G_warn.constprop.0>
}
34012c88:	4620      	mov	r0, r4
34012c8a:	bd70      	pop	{r4, r5, r6, pc}
    VD6G_dbg(ctx, 0, "reach state %d\n", state);
34012c8c:	4601      	mov	r1, r0
34012c8e:	462b      	mov	r3, r5
34012c90:	4630      	mov	r0, r6
34012c92:	4a03      	ldr	r2, [pc, #12]	@ (34012ca0 <VD6G_WaitState+0x34>)
34012c94:	f7ff ffb2 	bl	34012bfc <VD6G_dbg.constprop.0>
  return ret;
34012c98:	e7f6      	b.n	34012c88 <VD6G_WaitState+0x1c>
34012c9a:	bf00      	nop
34012c9c:	34020926 	.word	0x34020926
34012ca0:	34020951 	.word	0x34020951

34012ca4 <VD6G_Init>:

  return 0;
}

int VD6G_Init(VD6G_Ctx_t *ctx, VD6G_Config_t *config)
{
34012ca4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
  int ret;

  if (config->frame_rate < VD6G_MIN_FPS)
34012ca8:	688b      	ldr	r3, [r1, #8]
{
34012caa:	4605      	mov	r5, r0
  if (config->frame_rate < VD6G_MIN_FPS)
34012cac:	3b01      	subs	r3, #1
34012cae:	2b57      	cmp	r3, #87	@ 0x57
{
34012cb0:	460c      	mov	r4, r1
34012cb2:	b087      	sub	sp, #28
  if (config->frame_rate < VD6G_MIN_FPS)
34012cb4:	d802      	bhi.n	34012cbc <VD6G_Init+0x18>
    return -1;
  if (config->frame_rate > VD6G_MAX_FPS)
    return -1;

  if ((config->resolution != VD6G_RES_QVGA_320_240) &&
34012cb6:	790b      	ldrb	r3, [r1, #4]
34012cb8:	2b08      	cmp	r3, #8
34012cba:	d905      	bls.n	34012cc8 <VD6G_Init+0x24>
    return -1;
34012cbc:	f04f 34ff 	mov.w	r4, #4294967295
  ret = VD6G_SetupEarly(ctx);
  if (ret)
    return ret;

  return 0;
}
34012cc0:	4620      	mov	r0, r4
34012cc2:	b007      	add	sp, #28
34012cc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((config->flip_mirror_mode != VD6G_MIRROR_FLIP_NONE) &&
34012cc8:	7b0b      	ldrb	r3, [r1, #12]
34012cca:	2b03      	cmp	r3, #3
34012ccc:	d8f6      	bhi.n	34012cbc <VD6G_Init+0x18>
  ctx->shutdown_pin(ctx, 0);
34012cce:	6803      	ldr	r3, [r0, #0]
34012cd0:	2100      	movs	r1, #0
34012cd2:	4798      	blx	r3
  ctx->delay(ctx, 10);
34012cd4:	210a      	movs	r1, #10
34012cd6:	4628      	mov	r0, r5
34012cd8:	6a2b      	ldr	r3, [r5, #32]
34012cda:	4798      	blx	r3
  ctx->shutdown_pin(ctx, 1);
34012cdc:	2101      	movs	r1, #1
34012cde:	4628      	mov	r0, r5
34012ce0:	682b      	ldr	r3, [r5, #0]
34012ce2:	4798      	blx	r3
  drv_ctx->config_save = *config;
34012ce4:	f105 0630 	add.w	r6, r5, #48	@ 0x30
  ctx->delay(ctx, 10);
34012ce8:	210a      	movs	r1, #10
34012cea:	4628      	mov	r0, r5
34012cec:	6a2b      	ldr	r3, [r5, #32]
34012cee:	4798      	blx	r3
  drv_ctx->config_save = *config;
34012cf0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34012cf2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
34012cf4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34012cf6:	c60f      	stmia	r6!, {r0, r1, r2, r3}
34012cf8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34012cfa:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  drv_ctx->is_streaming = 0;
34012cfc:	2300      	movs	r3, #0
  drv_ctx->config_save = *config;
34012cfe:	e894 0003 	ldmia.w	r4, {r0, r1}
34012d02:	e886 0003 	stmia.w	r6, {r0, r1}
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_READY_TO_BOOT);
34012d06:	2101      	movs	r1, #1
34012d08:	4628      	mov	r0, r5
  drv_ctx->is_streaming = 0;
34012d0a:	62eb      	str	r3, [r5, #44]	@ 0x2c
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_READY_TO_BOOT);
34012d0c:	f7ff ffae 	bl	34012c6c <VD6G_WaitState>
  if (ret)
34012d10:	4604      	mov	r4, r0
34012d12:	2800      	cmp	r0, #0
34012d14:	d1d4      	bne.n	34012cc0 <VD6G_Init+0x1c>
  ret = ctx->read16(ctx, VD6G_REG_MODEL_ID, &reg16);
34012d16:	ae03      	add	r6, sp, #12
34012d18:	4601      	mov	r1, r0
34012d1a:	4632      	mov	r2, r6
34012d1c:	4628      	mov	r0, r5
34012d1e:	68ab      	ldr	r3, [r5, #8]
34012d20:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012d22:	4604      	mov	r4, r0
34012d24:	b988      	cbnz	r0, 34012d4a <VD6G_Init+0xa6>
  VD6G_dbg(ctx, 0, "model_id = 0x%04x\n", reg16);
34012d26:	4601      	mov	r1, r0
34012d28:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012d2c:	4aaf      	ldr	r2, [pc, #700]	@ (34012fec <VD6G_Init+0x348>)
34012d2e:	4628      	mov	r0, r5
34012d30:	f7ff ff64 	bl	34012bfc <VD6G_dbg.constprop.0>
  if (reg16 != VD6G_MODEL_ID) {
34012d34:	f245 6203 	movw	r2, #22019	@ 0x5603
34012d38:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012d3c:	4293      	cmp	r3, r2
34012d3e:	d010      	beq.n	34012d62 <VD6G_Init+0xbe>
    VD6G_error(ctx, "Bad model id expected 0x%04x / got 0x%04x\n", VD6G_MODEL_ID, reg16);
34012d40:	4628      	mov	r0, r5
34012d42:	49ab      	ldr	r1, [pc, #684]	@ (34012ff0 <VD6G_Init+0x34c>)
34012d44:	f7ff fe67 	bl	34012a16 <VD6G_error>
  if (ret)
34012d48:	e7b8      	b.n	34012cbc <VD6G_Init+0x18>
  VD6G_TraceError(ctx, ret);
34012d4a:	f240 1381 	movw	r3, #385	@ 0x181
34012d4e:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34012d50:	4aa8      	ldr	r2, [pc, #672]	@ (34012ff4 <VD6G_Init+0x350>)
  VD6G_TraceError(ctx, ret);
34012d52:	4628      	mov	r0, r5
34012d54:	49a8      	ldr	r1, [pc, #672]	@ (34012ff8 <VD6G_Init+0x354>)
34012d56:	f7ff fe5e 	bl	34012a16 <VD6G_error>
34012d5a:	4628      	mov	r0, r5
34012d5c:	f7ff fe78 	bl	34012a50 <display_error>
34012d60:	e7ae      	b.n	34012cc0 <VD6G_Init+0x1c>
  ret = VD6G_GetTopDie(ctx, &top_die);
34012d62:	4628      	mov	r0, r5
34012d64:	f10d 010b 	add.w	r1, sp, #11
34012d68:	f7ff ff56 	bl	34012c18 <VD6G_GetTopDie>
  if (ret)
34012d6c:	4604      	mov	r4, r0
34012d6e:	2800      	cmp	r0, #0
34012d70:	d1a6      	bne.n	34012cc0 <VD6G_Init+0x1c>
  if (top_die != VD6G_TOP_DIE_SLOW_BOOT && top_die != VD6G_TOP_DIE_FAST_BOOT) {
34012d72:	f89d 300b 	ldrb.w	r3, [sp, #11]
34012d76:	2b20      	cmp	r3, #32
34012d78:	d006      	beq.n	34012d88 <VD6G_Init+0xe4>
34012d7a:	2b31      	cmp	r3, #49	@ 0x31
34012d7c:	d004      	beq.n	34012d88 <VD6G_Init+0xe4>
    VD6G_error(ctx, "Unsupported revision\n");
34012d7e:	499f      	ldr	r1, [pc, #636]	@ (34012ffc <VD6G_Init+0x358>)
    VD6G_error(ctx, "External clock out of rangen\n");
34012d80:	4628      	mov	r0, r5
34012d82:	f7ff fe48 	bl	34012a16 <VD6G_error>
  if (ret)
34012d86:	e799      	b.n	34012cbc <VD6G_Init+0x18>
  ret = ctx->read16(ctx, VD6G_REG_ROM_REVISION, &reg16);
34012d88:	4632      	mov	r2, r6
34012d8a:	2114      	movs	r1, #20
34012d8c:	4628      	mov	r0, r5
34012d8e:	68ab      	ldr	r3, [r5, #8]
34012d90:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012d92:	4604      	mov	r4, r0
34012d94:	b9d8      	cbnz	r0, 34012dce <VD6G_Init+0x12a>
  VD6G_dbg(ctx, 0, "rom = 0x%04x\n", reg16);
34012d96:	4601      	mov	r1, r0
34012d98:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012d9c:	4628      	mov	r0, r5
34012d9e:	4a98      	ldr	r2, [pc, #608]	@ (34013000 <VD6G_Init+0x35c>)
34012da0:	f7ff ff2c 	bl	34012bfc <VD6G_dbg.constprop.0>
  ret = VD6G_GetTopDie(ctx, &top_die);
34012da4:	4628      	mov	r0, r5
34012da6:	f10d 010b 	add.w	r1, sp, #11
34012daa:	f7ff ff35 	bl	34012c18 <VD6G_GetTopDie>
  if (ret)
34012dae:	4604      	mov	r4, r0
34012db0:	2800      	cmp	r0, #0
34012db2:	d185      	bne.n	34012cc0 <VD6G_Init+0x1c>
  switch (top_die) {
34012db4:	f89d 300b 	ldrb.w	r3, [sp, #11]
34012db8:	2b20      	cmp	r3, #32
34012dba:	d00c      	beq.n	34012dd6 <VD6G_Init+0x132>
34012dbc:	2b31      	cmp	r3, #49	@ 0x31
34012dbe:	d057      	beq.n	34012e70 <VD6G_Init+0x1cc>
    assert(0);
34012dc0:	f44f 71e5 	mov.w	r1, #458	@ 0x1ca
34012dc4:	4b8f      	ldr	r3, [pc, #572]	@ (34013004 <VD6G_Init+0x360>)
34012dc6:	4a90      	ldr	r2, [pc, #576]	@ (34013008 <VD6G_Init+0x364>)
    assert(0);
34012dc8:	4890      	ldr	r0, [pc, #576]	@ (3401300c <VD6G_Init+0x368>)
34012dca:	f006 f847 	bl	34018e5c <__assert_func>
  VD6G_TraceError(ctx, ret);
34012dce:	f240 1391 	movw	r3, #401	@ 0x191
34012dd2:	9000      	str	r0, [sp, #0]
34012dd4:	e7bc      	b.n	34012d50 <VD6G_Init+0xac>
  ret = ctx->write_array(ctx, 0x2000, (uint8_t *) patch_cut2, sizeof(patch_cut2));
34012dd6:	69ec      	ldr	r4, [r5, #28]
34012dd8:	f642 23f8 	movw	r3, #11000	@ 0x2af8
34012ddc:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34012de0:	4628      	mov	r0, r5
34012de2:	4a8b      	ldr	r2, [pc, #556]	@ (34013010 <VD6G_Init+0x36c>)
34012de4:	47a0      	blx	r4
  VD6G_TraceError(ctx, ret);
34012de6:	4604      	mov	r4, r0
34012de8:	b120      	cbz	r0, 34012df4 <VD6G_Init+0x150>
34012dea:	f44f 73d1 	mov.w	r3, #418	@ 0x1a2
34012dee:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34012df0:	4a88      	ldr	r2, [pc, #544]	@ (34013014 <VD6G_Init+0x370>)
34012df2:	e7ae      	b.n	34012d52 <VD6G_Init+0xae>
  ret = ctx->write8(ctx, VD6G_REG_BOOT, VD6G_CMD_PATCH_SETUP);
34012df4:	2202      	movs	r2, #2
34012df6:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012dfa:	4628      	mov	r0, r5
34012dfc:	692b      	ldr	r3, [r5, #16]
34012dfe:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012e00:	4604      	mov	r4, r0
34012e02:	bb38      	cbnz	r0, 34012e54 <VD6G_Init+0x1b0>
  ret = VD6G_PollReg8(ctx, VD6G_REG_BOOT, VD6G_CMD_ACK);
34012e04:	4602      	mov	r2, r0
34012e06:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012e0a:	4628      	mov	r0, r5
34012e0c:	f7ff fe40 	bl	34012a90 <VD6G_PollReg8>
  if (ret)
34012e10:	4604      	mov	r4, r0
34012e12:	2800      	cmp	r0, #0
34012e14:	f47f af54 	bne.w	34012cc0 <VD6G_Init+0x1c>
  ret = ctx->read16(ctx, VD6G_REG_FWPATCH_REVISION, &reg16);
34012e18:	4632      	mov	r2, r6
34012e1a:	211e      	movs	r1, #30
34012e1c:	4628      	mov	r0, r5
34012e1e:	68ab      	ldr	r3, [r5, #8]
34012e20:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012e22:	4604      	mov	r4, r0
34012e24:	b9d0      	cbnz	r0, 34012e5c <VD6G_Init+0x1b8>
  VD6G_dbg(ctx, 0, "patch = 0x%04x\n", reg16);
34012e26:	4601      	mov	r1, r0
34012e28:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012e2c:	4628      	mov	r0, r5
34012e2e:	4a7a      	ldr	r2, [pc, #488]	@ (34013018 <VD6G_Init+0x374>)
34012e30:	f7ff fee4 	bl	34012bfc <VD6G_dbg.constprop.0>
  if (reg16 != (patch_major << 8) + patch_minor) {
34012e34:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012e38:	f5b3 7f07 	cmp.w	r3, #540	@ 0x21c
34012e3c:	d012      	beq.n	34012e64 <VD6G_Init+0x1c0>
    VD6G_error(ctx, "bad patch version expected %d.%d got %d.%d\n", patch_major, patch_minor,
34012e3e:	b2da      	uxtb	r2, r3
34012e40:	0a1b      	lsrs	r3, r3, #8
34012e42:	9201      	str	r2, [sp, #4]
34012e44:	9300      	str	r3, [sp, #0]
34012e46:	2202      	movs	r2, #2
34012e48:	231c      	movs	r3, #28
34012e4a:	4974      	ldr	r1, [pc, #464]	@ (3401301c <VD6G_Init+0x378>)
    VD6G_error(ctx, "bad vtpatch version, expected %d got rd:%d, gr:%d gt:%d\n", VT_REVISION, cur_vtpatch_rd_rev,
34012e4c:	4628      	mov	r0, r5
34012e4e:	f7ff fde2 	bl	34012a16 <VD6G_error>
  if (ret)
34012e52:	e733      	b.n	34012cbc <VD6G_Init+0x18>
  VD6G_TraceError(ctx, ret);
34012e54:	f240 13a5 	movw	r3, #421	@ 0x1a5
34012e58:	9000      	str	r0, [sp, #0]
34012e5a:	e7c9      	b.n	34012df0 <VD6G_Init+0x14c>
  VD6G_TraceError(ctx, ret);
34012e5c:	f44f 73d6 	mov.w	r3, #428	@ 0x1ac
34012e60:	9000      	str	r0, [sp, #0]
34012e62:	e7c5      	b.n	34012df0 <VD6G_Init+0x14c>
  VD6G_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);
34012e64:	231c      	movs	r3, #28
34012e66:	2202      	movs	r2, #2
34012e68:	4628      	mov	r0, r5
34012e6a:	496d      	ldr	r1, [pc, #436]	@ (34013020 <VD6G_Init+0x37c>)
34012e6c:	f7ff fde1 	bl	34012a32 <VD6G_notice>
  ret = ctx->write8(ctx, VD6G_REG_BOOT, VD6G_CMD_BOOT);
34012e70:	2201      	movs	r2, #1
34012e72:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012e76:	4628      	mov	r0, r5
34012e78:	692b      	ldr	r3, [r5, #16]
34012e7a:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012e7c:	4604      	mov	r4, r0
34012e7e:	b120      	cbz	r0, 34012e8a <VD6G_Init+0x1e6>
34012e80:	f240 13d5 	movw	r3, #469	@ 0x1d5
34012e84:	4a67      	ldr	r2, [pc, #412]	@ (34013024 <VD6G_Init+0x380>)
34012e86:	9000      	str	r0, [sp, #0]
34012e88:	e763      	b.n	34012d52 <VD6G_Init+0xae>
  ret = VD6G_PollReg8(ctx, VD6G_REG_BOOT, VD6G_CMD_ACK);
34012e8a:	4602      	mov	r2, r0
34012e8c:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012e90:	4628      	mov	r0, r5
34012e92:	f7ff fdfd 	bl	34012a90 <VD6G_PollReg8>
  if (ret)
34012e96:	4604      	mov	r4, r0
34012e98:	2800      	cmp	r0, #0
34012e9a:	f47f af11 	bne.w	34012cc0 <VD6G_Init+0x1c>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
34012e9e:	2102      	movs	r1, #2
34012ea0:	4628      	mov	r0, r5
34012ea2:	f7ff fee3 	bl	34012c6c <VD6G_WaitState>
  if (ret)
34012ea6:	4604      	mov	r4, r0
34012ea8:	2800      	cmp	r0, #0
34012eaa:	f47f af09 	bne.w	34012cc0 <VD6G_Init+0x1c>
  VD6G_notice(ctx, "sensor boot successfully\n");
34012eae:	4628      	mov	r0, r5
34012eb0:	495d      	ldr	r1, [pc, #372]	@ (34013028 <VD6G_Init+0x384>)
34012eb2:	f7ff fdbe 	bl	34012a32 <VD6G_notice>
  ret = VD6G_GetTopDie(ctx, &top_die);
34012eb6:	4628      	mov	r0, r5
34012eb8:	f10d 0109 	add.w	r1, sp, #9
34012ebc:	f7ff feac 	bl	34012c18 <VD6G_GetTopDie>
  if (ret)
34012ec0:	4604      	mov	r4, r0
34012ec2:	2800      	cmp	r0, #0
34012ec4:	f47f aefc 	bne.w	34012cc0 <VD6G_Init+0x1c>
  switch (top_die) {
34012ec8:	f89d 3009 	ldrb.w	r3, [sp, #9]
34012ecc:	2b20      	cmp	r3, #32
34012ece:	d007      	beq.n	34012ee0 <VD6G_Init+0x23c>
34012ed0:	2b31      	cmp	r3, #49	@ 0x31
34012ed2:	f000 80ff 	beq.w	340130d4 <VD6G_Init+0x430>
    assert(0);
34012ed6:	f44f 710d 	mov.w	r1, #564	@ 0x234
34012eda:	4b4a      	ldr	r3, [pc, #296]	@ (34013004 <VD6G_Init+0x360>)
34012edc:	4a53      	ldr	r2, [pc, #332]	@ (3401302c <VD6G_Init+0x388>)
34012ede:	e773      	b.n	34012dc8 <VD6G_Init+0x124>
  ret = ctx->write8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_START_VTRAM_UPDATE);
34012ee0:	2201      	movs	r2, #1
34012ee2:	f240 2103 	movw	r1, #515	@ 0x203
34012ee6:	4628      	mov	r0, r5
34012ee8:	692b      	ldr	r3, [r5, #16]
34012eea:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012eec:	4604      	mov	r4, r0
34012eee:	b120      	cbz	r0, 34012efa <VD6G_Init+0x256>
34012ef0:	f44f 73f6 	mov.w	r3, #492	@ 0x1ec
34012ef4:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34012ef6:	4a4e      	ldr	r2, [pc, #312]	@ (34013030 <VD6G_Init+0x38c>)
34012ef8:	e72b      	b.n	34012d52 <VD6G_Init+0xae>
  ret = VD6G_PollReg8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_ACK);
34012efa:	4602      	mov	r2, r0
34012efc:	f240 2103 	movw	r1, #515	@ 0x203
34012f00:	4628      	mov	r0, r5
34012f02:	f7ff fdc5 	bl	34012a90 <VD6G_PollReg8>
  if (ret)
34012f06:	4604      	mov	r4, r0
34012f08:	2800      	cmp	r0, #0
34012f0a:	f47f aed9 	bne.w	34012cc0 <VD6G_Init+0x1c>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
34012f0e:	2102      	movs	r1, #2
34012f10:	4628      	mov	r0, r5
34012f12:	f7ff feab 	bl	34012c6c <VD6G_WaitState>
  if (ret)
34012f16:	4604      	mov	r4, r0
34012f18:	2800      	cmp	r0, #0
34012f1a:	f47f aed1 	bne.w	34012cc0 <VD6G_Init+0x1c>
  for (i = 0; i < vtpatch_area_nb; i++) {
34012f1e:	4681      	mov	r9, r0
34012f20:	f8df 8110 	ldr.w	r8, [pc, #272]	@ 34013034 <VD6G_Init+0x390>
34012f24:	f8df a110 	ldr.w	sl, [pc, #272]	@ 34013038 <VD6G_Init+0x394>
    ret = ctx->write_array(ctx, vtpatch_desc[i].offset, (uint8_t *) (vtpatch + vtpatch_offset),
34012f28:	f8df b110 	ldr.w	fp, [pc, #272]	@ 3401303c <VD6G_Init+0x398>
  for (i = 0; i < vtpatch_area_nb; i++) {
34012f2c:	f8da 3000 	ldr.w	r3, [sl]
34012f30:	4599      	cmp	r9, r3
34012f32:	db13      	blt.n	34012f5c <VD6G_Init+0x2b8>
  ret = ctx->write8(ctx, 0xd9f8, VT_REVISION);
34012f34:	2211      	movs	r2, #17
34012f36:	f64d 11f8 	movw	r1, #55800	@ 0xd9f8
34012f3a:	4628      	mov	r0, r5
34012f3c:	692b      	ldr	r3, [r5, #16]
34012f3e:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012f40:	4604      	mov	r4, r0
34012f42:	bb58      	cbnz	r0, 34012f9c <VD6G_Init+0x2f8>
  ret = ctx->write8(ctx, 0xaffc, VT_REVISION);
34012f44:	2211      	movs	r2, #17
34012f46:	f64a 71fc 	movw	r1, #45052	@ 0xaffc
34012f4a:	4628      	mov	r0, r5
34012f4c:	692b      	ldr	r3, [r5, #16]
34012f4e:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012f50:	4604      	mov	r4, r0
34012f52:	b338      	cbz	r0, 34012fa4 <VD6G_Init+0x300>
34012f54:	f240 13ff 	movw	r3, #511	@ 0x1ff
34012f58:	9000      	str	r0, [sp, #0]
34012f5a:	e7cc      	b.n	34012ef6 <VD6G_Init+0x252>
    ret = ctx->write_array(ctx, vtpatch_desc[i].offset, (uint8_t *) (vtpatch + vtpatch_offset),
34012f5c:	69ef      	ldr	r7, [r5, #28]
34012f5e:	f8d8 3004 	ldr.w	r3, [r8, #4]
34012f62:	f8b8 1000 	ldrh.w	r1, [r8]
34012f66:	4628      	mov	r0, r5
34012f68:	eb0b 0204 	add.w	r2, fp, r4
34012f6c:	47b8      	blx	r7
    VD6G_TraceError(ctx, ret);
34012f6e:	f108 0808 	add.w	r8, r8, #8
34012f72:	4607      	mov	r7, r0
34012f74:	b928      	cbnz	r0, 34012f82 <VD6G_Init+0x2de>
    vtpatch_offset += vtpatch_desc[i].size;
34012f76:	f858 3c04 	ldr.w	r3, [r8, #-4]
  for (i = 0; i < vtpatch_area_nb; i++) {
34012f7a:	f109 0901 	add.w	r9, r9, #1
    vtpatch_offset += vtpatch_desc[i].size;
34012f7e:	441c      	add	r4, r3
  for (i = 0; i < vtpatch_area_nb; i++) {
34012f80:	e7d4      	b.n	34012f2c <VD6G_Init+0x288>
    VD6G_TraceError(ctx, ret);
34012f82:	f240 13f9 	movw	r3, #505	@ 0x1f9
34012f86:	4a2a      	ldr	r2, [pc, #168]	@ (34013030 <VD6G_Init+0x38c>)
34012f88:	491b      	ldr	r1, [pc, #108]	@ (34012ff8 <VD6G_Init+0x354>)
34012f8a:	9000      	str	r0, [sp, #0]
34012f8c:	4628      	mov	r0, r5
34012f8e:	f7ff fd42 	bl	34012a16 <VD6G_error>
34012f92:	4628      	mov	r0, r5
34012f94:	f7ff fd5c 	bl	34012a50 <display_error>
    return ret;
34012f98:	463c      	mov	r4, r7
34012f9a:	e691      	b.n	34012cc0 <VD6G_Init+0x1c>
  VD6G_TraceError(ctx, ret);
34012f9c:	f240 13fd 	movw	r3, #509	@ 0x1fd
34012fa0:	9000      	str	r0, [sp, #0]
34012fa2:	e7a8      	b.n	34012ef6 <VD6G_Init+0x252>
  ret = ctx->write8(ctx, 0xbbb4, VT_REVISION);
34012fa4:	2211      	movs	r2, #17
34012fa6:	f64b 31b4 	movw	r1, #48052	@ 0xbbb4
34012faa:	4628      	mov	r0, r5
34012fac:	692b      	ldr	r3, [r5, #16]
34012fae:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012fb0:	4604      	mov	r4, r0
34012fb2:	b118      	cbz	r0, 34012fbc <VD6G_Init+0x318>
34012fb4:	f240 2301 	movw	r3, #513	@ 0x201
34012fb8:	9000      	str	r0, [sp, #0]
34012fba:	e79c      	b.n	34012ef6 <VD6G_Init+0x252>
  ret = ctx->write8(ctx, 0xb898, VT_REVISION);
34012fbc:	2211      	movs	r2, #17
34012fbe:	f64b 0198 	movw	r1, #47256	@ 0xb898
34012fc2:	4628      	mov	r0, r5
34012fc4:	692b      	ldr	r3, [r5, #16]
34012fc6:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012fc8:	4604      	mov	r4, r0
34012fca:	b118      	cbz	r0, 34012fd4 <VD6G_Init+0x330>
34012fcc:	f240 2303 	movw	r3, #515	@ 0x203
34012fd0:	9000      	str	r0, [sp, #0]
34012fd2:	e790      	b.n	34012ef6 <VD6G_Init+0x252>
  ret = ctx->write8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_END_VTRAM_UPDATE);
34012fd4:	2202      	movs	r2, #2
34012fd6:	f240 2103 	movw	r1, #515	@ 0x203
34012fda:	4628      	mov	r0, r5
34012fdc:	692b      	ldr	r3, [r5, #16]
34012fde:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012fe0:	4604      	mov	r4, r0
34012fe2:	b368      	cbz	r0, 34013040 <VD6G_Init+0x39c>
34012fe4:	f240 2306 	movw	r3, #518	@ 0x206
34012fe8:	9000      	str	r0, [sp, #0]
34012fea:	e784      	b.n	34012ef6 <VD6G_Init+0x252>
34012fec:	34020b81 	.word	0x34020b81
34012ff0:	34020ba4 	.word	0x34020ba4
34012ff4:	340a90bd 	.word	0x340a90bd
34012ff8:	34020a4a 	.word	0x34020a4a
34012ffc:	34020d93 	.word	0x34020d93
34013000:	34020c30 	.word	0x34020c30
34013004:	340217f8 	.word	0x340217f8
34013008:	340a909e 	.word	0x340a909e
3401300c:	34020ce3 	.word	0x34020ce3
34013010:	340aa9b0 	.word	0x340aa9b0
34013014:	340a9086 	.word	0x340a9086
34013018:	34020a70 	.word	0x34020a70
3401301c:	34020a90 	.word	0x34020a90
34013020:	34020acc 	.word	0x34020acc
34013024:	340a9079 	.word	0x340a9079
34013028:	34020af1 	.word	0x34020af1
3401302c:	340a9067 	.word	0x340a9067
34013030:	340a904d 	.word	0x340a904d
34013034:	340b0f3c 	.word	0x340b0f3c
34013038:	340b0f38 	.word	0x340b0f38
3401303c:	340a91e8 	.word	0x340a91e8
  ret = VD6G_PollReg8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_ACK);
34013040:	4602      	mov	r2, r0
34013042:	f240 2103 	movw	r1, #515	@ 0x203
34013046:	4628      	mov	r0, r5
34013048:	f7ff fd22 	bl	34012a90 <VD6G_PollReg8>
  if (ret)
3401304c:	4604      	mov	r4, r0
3401304e:	2800      	cmp	r0, #0
34013050:	f47f ae36 	bne.w	34012cc0 <VD6G_Init+0x1c>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
34013054:	2102      	movs	r1, #2
34013056:	4628      	mov	r0, r5
34013058:	f7ff fe08 	bl	34012c6c <VD6G_WaitState>
  if (ret)
3401305c:	4604      	mov	r4, r0
3401305e:	2800      	cmp	r0, #0
34013060:	f47f ae2e 	bne.w	34012cc0 <VD6G_Init+0x1c>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_RD_REVISION, &cur_vtpatch_rd_rev);
34013064:	2120      	movs	r1, #32
34013066:	4628      	mov	r0, r5
34013068:	686b      	ldr	r3, [r5, #4]
3401306a:	f10d 020a 	add.w	r2, sp, #10
3401306e:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013070:	4604      	mov	r4, r0
34013072:	b958      	cbnz	r0, 3401308c <VD6G_Init+0x3e8>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_GR_REVISION, &cur_vtpatch_gr_rev);
34013074:	2124      	movs	r1, #36	@ 0x24
34013076:	4628      	mov	r0, r5
34013078:	686b      	ldr	r3, [r5, #4]
3401307a:	f10d 020b 	add.w	r2, sp, #11
3401307e:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013080:	4604      	mov	r4, r0
34013082:	b138      	cbz	r0, 34013094 <VD6G_Init+0x3f0>
34013084:	f240 2313 	movw	r3, #531	@ 0x213
34013088:	9000      	str	r0, [sp, #0]
3401308a:	e734      	b.n	34012ef6 <VD6G_Init+0x252>
  VD6G_TraceError(ctx, ret);
3401308c:	f240 2311 	movw	r3, #529	@ 0x211
34013090:	9000      	str	r0, [sp, #0]
34013092:	e730      	b.n	34012ef6 <VD6G_Init+0x252>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_GT_REVISION, &cur_vtpatch_gt_rev);
34013094:	4632      	mov	r2, r6
34013096:	2126      	movs	r1, #38	@ 0x26
34013098:	4628      	mov	r0, r5
3401309a:	686b      	ldr	r3, [r5, #4]
3401309c:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401309e:	4604      	mov	r4, r0
340130a0:	b118      	cbz	r0, 340130aa <VD6G_Init+0x406>
340130a2:	f240 2315 	movw	r3, #533	@ 0x215
340130a6:	9000      	str	r0, [sp, #0]
340130a8:	e725      	b.n	34012ef6 <VD6G_Init+0x252>
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340130aa:	f89d 300a 	ldrb.w	r3, [sp, #10]
      cur_vtpatch_gr_rev != VT_REVISION ||
340130ae:	f89d 100b 	ldrb.w	r1, [sp, #11]
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340130b2:	2b11      	cmp	r3, #17
      cur_vtpatch_gt_rev != VT_REVISION) {
340130b4:	f89d 200c 	ldrb.w	r2, [sp, #12]
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340130b8:	d004      	beq.n	340130c4 <VD6G_Init+0x420>
    VD6G_error(ctx, "bad vtpatch version, expected %d got rd:%d, gr:%d gt:%d\n", VT_REVISION, cur_vtpatch_rd_rev,
340130ba:	e9cd 1200 	strd	r1, r2, [sp]
340130be:	2211      	movs	r2, #17
340130c0:	496e      	ldr	r1, [pc, #440]	@ (3401327c <VD6G_Init+0x5d8>)
340130c2:	e6c3      	b.n	34012e4c <VD6G_Init+0x1a8>
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340130c4:	2911      	cmp	r1, #17
340130c6:	d1f8      	bne.n	340130ba <VD6G_Init+0x416>
      cur_vtpatch_gr_rev != VT_REVISION ||
340130c8:	2a11      	cmp	r2, #17
340130ca:	d1f6      	bne.n	340130ba <VD6G_Init+0x416>
  VD6G_notice(ctx, "VT patch %d applied\n", VT_REVISION);
340130cc:	4628      	mov	r0, r5
340130ce:	496c      	ldr	r1, [pc, #432]	@ (34013280 <VD6G_Init+0x5dc>)
340130d0:	f7ff fcaf 	bl	34012a32 <VD6G_notice>
  ret = ctx->read8(ctx, VD6G_REG_OPTICAL_REVISION, &reg8);
340130d4:	4632      	mov	r2, r6
340130d6:	211a      	movs	r1, #26
340130d8:	4628      	mov	r0, r5
340130da:	686b      	ldr	r3, [r5, #4]
340130dc:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340130de:	4604      	mov	r4, r0
340130e0:	b120      	cbz	r0, 340130ec <VD6G_Init+0x448>
340130e2:	f240 2341 	movw	r3, #577	@ 0x241
340130e6:	4a67      	ldr	r2, [pc, #412]	@ (34013284 <VD6G_Init+0x5e0>)
340130e8:	9000      	str	r0, [sp, #0]
340130ea:	e632      	b.n	34012d52 <VD6G_Init+0xae>
  if (!(reg8 & 1)) {
340130ec:	f89d 300c 	ldrb.w	r3, [sp, #12]
340130f0:	f013 0301 	ands.w	r3, r3, #1
340130f4:	d008      	beq.n	34013108 <VD6G_Init+0x464>
  switch (drv_ctx->config_save.flip_mirror_mode) {
340130f6:	f895 203c 	ldrb.w	r2, [r5, #60]	@ 0x3c
340130fa:	2a03      	cmp	r2, #3
340130fc:	d81b      	bhi.n	34013136 <VD6G_Init+0x492>
340130fe:	e8df f002 	tbb	[pc, r2]
34013102:	021f      	.short	0x021f
34013104:	1803      	.short	0x1803
34013106:	2304      	movs	r3, #4
34013108:	f240 4767 	movw	r7, #1127	@ 0x467
  for (i = 0; i < VD6G_GPIO_NB; i++) {
3401310c:	f240 496f 	movw	r9, #1135	@ 0x46f
    ctx->bayer = VD6G_BAYER_RGGB;
34013110:	f885 3028 	strb.w	r3, [r5, #40]	@ 0x28
34013114:	f105 085b 	add.w	r8, r5, #91	@ 0x5b
    ret = ctx->write8(ctx, VD6G_REG_GPIO_x_CTRL(i), drv_ctx->config_save.gpio_ctrl[i]);
34013118:	4639      	mov	r1, r7
3401311a:	4628      	mov	r0, r5
3401311c:	692b      	ldr	r3, [r5, #16]
3401311e:	f818 2f01 	ldrb.w	r2, [r8, #1]!
34013122:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
34013124:	4604      	mov	r4, r0
34013126:	b168      	cbz	r0, 34013144 <VD6G_Init+0x4a0>
34013128:	f44f 731d 	mov.w	r3, #628	@ 0x274
3401312c:	4a56      	ldr	r2, [pc, #344]	@ (34013288 <VD6G_Init+0x5e4>)
3401312e:	9000      	str	r0, [sp, #0]
34013130:	e60f      	b.n	34012d52 <VD6G_Init+0xae>
  case VD6G_MIRROR_FLIP:
34013132:	4613      	mov	r3, r2
34013134:	e7e8      	b.n	34013108 <VD6G_Init+0x464>
    assert(0);
34013136:	f240 2156 	movw	r1, #598	@ 0x256
3401313a:	4b54      	ldr	r3, [pc, #336]	@ (3401328c <VD6G_Init+0x5e8>)
3401313c:	4a51      	ldr	r2, [pc, #324]	@ (34013284 <VD6G_Init+0x5e0>)
3401313e:	e643      	b.n	34012dc8 <VD6G_Init+0x124>
  switch (drv_ctx->config_save.flip_mirror_mode) {
34013140:	2302      	movs	r3, #2
34013142:	e7e1      	b.n	34013108 <VD6G_Init+0x464>
  for (i = 0; i < VD6G_GPIO_NB; i++) {
34013144:	3701      	adds	r7, #1
34013146:	b2bf      	uxth	r7, r7
34013148:	454f      	cmp	r7, r9
3401314a:	d1e5      	bne.n	34013118 <VD6G_Init+0x474>
  ret = VD6G_ComputeClocks(ctx, drv_ctx->config_save.ext_clock_freq_in_hz, &pll_prediv, &pll_mult);
3401314c:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
  const unsigned int predivs[] = { 1, 2, 4 };
3401314e:	4a50      	ldr	r2, [pc, #320]	@ (34013290 <VD6G_Init+0x5ec>)
34013150:	ca07      	ldmia	r2, {r0, r1, r2}
34013152:	e886 0007 	stmia.w	r6, {r0, r1, r2}
  if (ext_clock < 6 * M_HZ ||
34013156:	484f      	ldr	r0, [pc, #316]	@ (34013294 <VD6G_Init+0x5f0>)
34013158:	f5a3 02b7 	sub.w	r2, r3, #5996544	@ 0x5b8000
3401315c:	f5a2 6258 	sub.w	r2, r2, #3456	@ 0xd80
34013160:	4282      	cmp	r2, r0
34013162:	4631      	mov	r1, r6
34013164:	d830      	bhi.n	340131c8 <VD6G_Init+0x524>
    if (ext_clock / *pll_prediv < 12 * M_HZ)
34013166:	4a4c      	ldr	r2, [pc, #304]	@ (34013298 <VD6G_Init+0x5f4>)
    *pll_prediv = predivs[i];
34013168:	f851 0b04 	ldr.w	r0, [r1], #4
    if (ext_clock / *pll_prediv < 12 * M_HZ)
3401316c:	fa5f f880 	uxtb.w	r8, r0
34013170:	fbb3 f0f8 	udiv	r0, r3, r8
34013174:	4290      	cmp	r0, r2
34013176:	d302      	bcc.n	3401317e <VD6G_Init+0x4da>
  for (i = 0; i < ARRAY_SIZE(predivs); i++) {
34013178:	3401      	adds	r4, #1
3401317a:	2c03      	cmp	r4, #3
3401317c:	d1f4      	bne.n	34013168 <VD6G_Init+0x4c4>
  *pll_mult = (VD6G_TARGET_PLL * *pll_prediv + ext_clock / 2) / ext_clock;
3401317e:	4a47      	ldr	r2, [pc, #284]	@ (3401329c <VD6G_Init+0x5f8>)
34013180:	085f      	lsrs	r7, r3, #1
34013182:	fb02 7708 	mla	r7, r2, r8, r7
34013186:	fbb7 f7f3 	udiv	r7, r7, r3
  VD6G_dbg(ctx, 0, "Ext Clock = %d Hz\n", ext_clock);
3401318a:	2100      	movs	r1, #0
3401318c:	4628      	mov	r0, r5
3401318e:	4a44      	ldr	r2, [pc, #272]	@ (340132a0 <VD6G_Init+0x5fc>)
34013190:	f7ff fd34 	bl	34012bfc <VD6G_dbg.constprop.0>
  VD6G_dbg(ctx, 0, "PLL mult = %d\n", *pll_mult);
34013194:	b2ff      	uxtb	r7, r7
  VD6G_dbg(ctx, 0, "PLL prediv = %d\n", *pll_prediv);
34013196:	4643      	mov	r3, r8
34013198:	2100      	movs	r1, #0
3401319a:	4628      	mov	r0, r5
3401319c:	4a41      	ldr	r2, [pc, #260]	@ (340132a4 <VD6G_Init+0x600>)
3401319e:	f7ff fd2d 	bl	34012bfc <VD6G_dbg.constprop.0>
  VD6G_dbg(ctx, 0, "PLL mult = %d\n", *pll_mult);
340131a2:	463b      	mov	r3, r7
340131a4:	2100      	movs	r1, #0
340131a6:	4628      	mov	r0, r5
340131a8:	4a3f      	ldr	r2, [pc, #252]	@ (340132a8 <VD6G_Init+0x604>)
340131aa:	f7ff fd27 	bl	34012bfc <VD6G_dbg.constprop.0>
  ret = ctx->write32(ctx, VD6G_REG_EXT_CLOCK, drv_ctx->config_save.ext_clock_freq_in_hz);
340131ae:	f44f 7108 	mov.w	r1, #544	@ 0x220
340131b2:	4628      	mov	r0, r5
340131b4:	69ab      	ldr	r3, [r5, #24]
340131b6:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
340131b8:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340131ba:	4604      	mov	r4, r0
340131bc:	b130      	cbz	r0, 340131cc <VD6G_Init+0x528>
340131be:	f44f 7331 	mov.w	r3, #708	@ 0x2c4
340131c2:	9000      	str	r0, [sp, #0]
    VD6G_TraceError(ctx, ret);
340131c4:	4a39      	ldr	r2, [pc, #228]	@ (340132ac <VD6G_Init+0x608>)
340131c6:	e5c4      	b.n	34012d52 <VD6G_Init+0xae>
    VD6G_error(ctx, "External clock out of rangen\n");
340131c8:	4939      	ldr	r1, [pc, #228]	@ (340132b0 <VD6G_Init+0x60c>)
340131ca:	e5d9      	b.n	34012d80 <VD6G_Init+0xdc>
  ret = ctx->write8(ctx, VD6G_REG_CLK_PLL_PREDIV, pll_prediv);
340131cc:	4642      	mov	r2, r8
340131ce:	f44f 7109 	mov.w	r1, #548	@ 0x224
340131d2:	4628      	mov	r0, r5
340131d4:	692b      	ldr	r3, [r5, #16]
340131d6:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340131d8:	4604      	mov	r4, r0
340131da:	b958      	cbnz	r0, 340131f4 <VD6G_Init+0x550>
  ret = ctx->write8(ctx, VD6G_REG_CLK_SYS_PLL_MULT, pll_mult);
340131dc:	463a      	mov	r2, r7
340131de:	f240 2126 	movw	r1, #550	@ 0x226
340131e2:	4628      	mov	r0, r5
340131e4:	692b      	ldr	r3, [r5, #16]
340131e6:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340131e8:	4604      	mov	r4, r0
340131ea:	b138      	cbz	r0, 340131fc <VD6G_Init+0x558>
340131ec:	f240 23ca 	movw	r3, #714	@ 0x2ca
340131f0:	9000      	str	r0, [sp, #0]
340131f2:	e7e7      	b.n	340131c4 <VD6G_Init+0x520>
  VD6G_TraceError(ctx, ret);
340131f4:	f240 23c7 	movw	r3, #711	@ 0x2c7
340131f8:	9000      	str	r0, [sp, #0]
340131fa:	e7e3      	b.n	340131c4 <VD6G_Init+0x520>
  if (drv_ctx->config_save.line_len) {
340131fc:	6c2a      	ldr	r2, [r5, #64]	@ 0x40
340131fe:	b962      	cbnz	r2, 3401321a <VD6G_Init+0x576>
  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_length);
34013200:	4632      	mov	r2, r6
34013202:	f44f 7140 	mov.w	r1, #768	@ 0x300
34013206:	4628      	mov	r0, r5
34013208:	68ab      	ldr	r3, [r5, #8]
3401320a:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401320c:	4604      	mov	r4, r0
3401320e:	b188      	cbz	r0, 34013234 <VD6G_Init+0x590>
34013210:	f44f 7350 	mov.w	r3, #832	@ 0x340
34013214:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34013216:	4a27      	ldr	r2, [pc, #156]	@ (340132b4 <VD6G_Init+0x610>)
34013218:	e59b      	b.n	34012d52 <VD6G_Init+0xae>
    ret = ctx->write16(ctx, VD6G_LINE_LENGTH, drv_ctx->config_save.line_len);
3401321a:	f44f 7140 	mov.w	r1, #768	@ 0x300
3401321e:	4628      	mov	r0, r5
34013220:	696b      	ldr	r3, [r5, #20]
34013222:	b292      	uxth	r2, r2
34013224:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
34013226:	4604      	mov	r4, r0
34013228:	2800      	cmp	r0, #0
3401322a:	d0e9      	beq.n	34013200 <VD6G_Init+0x55c>
3401322c:	f240 23ce 	movw	r3, #718	@ 0x2ce
34013230:	9000      	str	r0, [sp, #0]
34013232:	e7c7      	b.n	340131c4 <VD6G_Init+0x520>
  VD6G_dbg(ctx, 0, "Line len = %d\n", line_length);
34013234:	4601      	mov	r1, r0
34013236:	f8bd 300c 	ldrh.w	r3, [sp, #12]
3401323a:	4628      	mov	r0, r5
3401323c:	4a1e      	ldr	r2, [pc, #120]	@ (340132b8 <VD6G_Init+0x614>)
3401323e:	f7ff fcdd 	bl	34012bfc <VD6G_dbg.constprop.0>
  frame_length = VD6G_PIXEL_CLOCK / (line_length * drv_ctx->config_save.frame_rate);
34013242:	6baa      	ldr	r2, [r5, #56]	@ 0x38
34013244:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34013248:	4e1c      	ldr	r6, [pc, #112]	@ (340132bc <VD6G_Init+0x618>)
3401324a:	4353      	muls	r3, r2
3401324c:	fb96 f6f3 	sdiv	r6, r6, r3
  VD6G_dbg(ctx, 0, "Set frame_length to %d to reach %d fps\n", frame_length, drv_ctx->config_save.frame_rate);
34013250:	4621      	mov	r1, r4
34013252:	4628      	mov	r0, r5
34013254:	9200      	str	r2, [sp, #0]
34013256:	b2b3      	uxth	r3, r6
34013258:	4a19      	ldr	r2, [pc, #100]	@ (340132c0 <VD6G_Init+0x61c>)
3401325a:	f7ff fccf 	bl	34012bfc <VD6G_dbg.constprop.0>
  ret = ctx->write16(ctx, VD6G_FRAME_LENGTH, frame_length);
3401325e:	f44f 618b 	mov.w	r1, #1112	@ 0x458
34013262:	4628      	mov	r0, r5
34013264:	696b      	ldr	r3, [r5, #20]
34013266:	b2b2      	uxth	r2, r6
34013268:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401326a:	4604      	mov	r4, r0
3401326c:	2800      	cmp	r0, #0
3401326e:	f43f ad27 	beq.w	34012cc0 <VD6G_Init+0x1c>
34013272:	f240 3346 	movw	r3, #838	@ 0x346
34013276:	9000      	str	r0, [sp, #0]
34013278:	e7cd      	b.n	34013216 <VD6G_Init+0x572>
3401327a:	bf00      	nop
3401327c:	34020da9 	.word	0x34020da9
34013280:	34020de2 	.word	0x34020de2
34013284:	340a903b 	.word	0x340a903b
34013288:	340a9030 	.word	0x340a9030
3401328c:	340217f8 	.word	0x340217f8
34013290:	3401d3ac 	.word	0x3401d3ac
34013294:	01406f40 	.word	0x01406f40
34013298:	00b71b00 	.word	0x00b71b00
3401329c:	2fec1100 	.word	0x2fec1100
340132a0:	34020e15 	.word	0x34020e15
340132a4:	34020e28 	.word	0x34020e28
340132a8:	34020e39 	.word	0x34020e39
340132ac:	340a901f 	.word	0x340a901f
340132b0:	34020df7 	.word	0x34020df7
340132b4:	340a900b 	.word	0x340a900b
340132b8:	34020e48 	.word	0x34020e48
340132bc:	09959d00 	.word	0x09959d00
340132c0:	34020c72 	.word	0x34020c72

340132c4 <VD6G_DeInit>:

int VD6G_DeInit(VD6G_Ctx_t *ctx)
{
340132c4:	b538      	push	{r3, r4, r5, lr}
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;

  if (drv_ctx->is_streaming)
340132c6:	6ac5      	ldr	r5, [r0, #44]	@ 0x2c
{
340132c8:	4604      	mov	r4, r0
  if (drv_ctx->is_streaming)
340132ca:	b945      	cbnz	r5, 340132de <VD6G_DeInit+0x1a>
    return -1;

  ctx->shutdown_pin(ctx, 0);
340132cc:	6803      	ldr	r3, [r0, #0]
340132ce:	4629      	mov	r1, r5
340132d0:	4798      	blx	r3
  ctx->delay(ctx, 10);
340132d2:	210a      	movs	r1, #10
340132d4:	4620      	mov	r0, r4
340132d6:	6a23      	ldr	r3, [r4, #32]
340132d8:	4798      	blx	r3

  return 0;
}
340132da:	4628      	mov	r0, r5
340132dc:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
340132de:	f04f 35ff 	mov.w	r5, #4294967295
340132e2:	e7fa      	b.n	340132da <VD6G_DeInit+0x16>

340132e4 <VD6G_Start>:
  if (out_itf->datalane_nb != 1 && out_itf->datalane_nb != 2)
340132e4:	6c83      	ldr	r3, [r0, #72]	@ 0x48

int VD6G_Start(VD6G_Ctx_t *ctx)
{
340132e6:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (out_itf->datalane_nb != 1 && out_itf->datalane_nb != 2)
340132e8:	3b01      	subs	r3, #1
340132ea:	2b01      	cmp	r3, #1
{
340132ec:	4605      	mov	r5, r0
  if (out_itf->datalane_nb != 1 && out_itf->datalane_nb != 2)
340132ee:	d904      	bls.n	340132fa <VD6G_Start+0x16>
    return ret;
340132f0:	f04f 34ff 	mov.w	r4, #4294967295
  if (ret)
    return ret;
  drv_ctx->is_streaming = 1;

  return 0;
}
340132f4:	4620      	mov	r0, r4
340132f6:	b002      	add	sp, #8
340132f8:	bd70      	pop	{r4, r5, r6, pc}
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
340132fa:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
  ret = ctx->write8(ctx, VD6G_REG_FORMAT_CTRL, VD6G_COLOR_DEPTH_RAW8);
340132fc:	2208      	movs	r2, #8
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
340132fe:	3b00      	subs	r3, #0
34013300:	bf18      	it	ne
34013302:	2301      	movne	r3, #1
34013304:	64c3      	str	r3, [r0, #76]	@ 0x4c
  out_itf->data_lane0_swap_enable = !!out_itf->data_lane0_swap_enable;
34013306:	6d03      	ldr	r3, [r0, #80]	@ 0x50
  ret = ctx->write8(ctx, VD6G_REG_FORMAT_CTRL, VD6G_COLOR_DEPTH_RAW8);
34013308:	f240 310a 	movw	r1, #778	@ 0x30a
  out_itf->data_lane0_swap_enable = !!out_itf->data_lane0_swap_enable;
3401330c:	3b00      	subs	r3, #0
3401330e:	bf18      	it	ne
34013310:	2301      	movne	r3, #1
34013312:	6503      	str	r3, [r0, #80]	@ 0x50
  out_itf->data_lane1_swap_enable = !!out_itf->data_lane1_swap_enable;
34013314:	6d43      	ldr	r3, [r0, #84]	@ 0x54
34013316:	3b00      	subs	r3, #0
34013318:	bf18      	it	ne
3401331a:	2301      	movne	r3, #1
3401331c:	6543      	str	r3, [r0, #84]	@ 0x54
  out_itf->data_lanes_mapping_swap_enable = !!out_itf->data_lanes_mapping_swap_enable;
3401331e:	6d83      	ldr	r3, [r0, #88]	@ 0x58
34013320:	3b00      	subs	r3, #0
34013322:	bf18      	it	ne
34013324:	2301      	movne	r3, #1
34013326:	6583      	str	r3, [r0, #88]	@ 0x58
  ret = ctx->write8(ctx, VD6G_REG_FORMAT_CTRL, VD6G_COLOR_DEPTH_RAW8);
34013328:	6903      	ldr	r3, [r0, #16]
3401332a:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401332c:	4604      	mov	r4, r0
3401332e:	b9e8      	cbnz	r0, 3401336c <VD6G_Start+0x88>
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
34013330:	e9d5 0315 	ldrd	r0, r3, [r5, #84]	@ 0x54
             !out_itf->data_lanes_mapping_swap_enable << 7 |
34013334:	6d2a      	ldr	r2, [r5, #80]	@ 0x50
             out_itf->clock_lane_swap_enable << 3 |
34013336:	6ca9      	ldr	r1, [r5, #72]	@ 0x48
             !out_itf->data_lanes_mapping_swap_enable << 7 |
34013338:	0192      	lsls	r2, r2, #6
             out_itf->clock_lane_swap_enable << 3 |
3401333a:	ea42 2240 	orr.w	r2, r2, r0, lsl #9
3401333e:	430a      	orrs	r2, r1
34013340:	ea42 1203 	orr.w	r2, r2, r3, lsl #4
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
34013344:	fab3 f383 	clz	r3, r3
             out_itf->data_lanes_mapping_swap_enable << 4 |
34013348:	6ce9      	ldr	r1, [r5, #76]	@ 0x4c
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
3401334a:	095b      	lsrs	r3, r3, #5
             out_itf->clock_lane_swap_enable << 3 |
3401334c:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
34013350:	ea42 12c3 	orr.w	r2, r2, r3, lsl #7
  ret = ctx->write16(ctx, VD6G_REG_OIF_CTRL, oif_ctrl);
34013354:	f44f 7143 	mov.w	r1, #780	@ 0x30c
34013358:	4628      	mov	r0, r5
3401335a:	696b      	ldr	r3, [r5, #20]
3401335c:	b292      	uxth	r2, r2
3401335e:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013360:	4604      	mov	r4, r0
34013362:	b178      	cbz	r0, 34013384 <VD6G_Start+0xa0>
34013364:	f240 23ee 	movw	r3, #750	@ 0x2ee
34013368:	9000      	str	r0, [sp, #0]
3401336a:	e002      	b.n	34013372 <VD6G_Start+0x8e>
  VD6G_TraceError(ctx, ret);
3401336c:	f44f 7339 	mov.w	r3, #740	@ 0x2e4
34013370:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34013372:	4a74      	ldr	r2, [pc, #464]	@ (34013544 <VD6G_Start+0x260>)
34013374:	4628      	mov	r0, r5
34013376:	4974      	ldr	r1, [pc, #464]	@ (34013548 <VD6G_Start+0x264>)
34013378:	f7ff fb4d 	bl	34012a16 <VD6G_error>
3401337c:	4628      	mov	r0, r5
3401337e:	f7ff fb67 	bl	34012a50 <display_error>
  if (ret)
34013382:	e7b7      	b.n	340132f4 <VD6G_Start+0x10>
  ret = ctx->write16(ctx, VD6G_REG_OIF_CSI_BITRATE, 804);
34013384:	f44f 7249 	mov.w	r2, #804	@ 0x324
34013388:	f240 3112 	movw	r1, #786	@ 0x312
3401338c:	4628      	mov	r0, r5
3401338e:	696b      	ldr	r3, [r5, #20]
34013390:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013392:	4604      	mov	r4, r0
34013394:	b118      	cbz	r0, 3401339e <VD6G_Start+0xba>
34013396:	f240 23f2 	movw	r3, #754	@ 0x2f2
3401339a:	9000      	str	r0, [sp, #0]
3401339c:	e7e9      	b.n	34013372 <VD6G_Start+0x8e>
  ret = ctx->write8(ctx, VD6G_REG_OIF_IMG_CTRL, 0x2a);
3401339e:	222a      	movs	r2, #42	@ 0x2a
340133a0:	f240 310f 	movw	r1, #783	@ 0x30f
340133a4:	4628      	mov	r0, r5
340133a6:	692b      	ldr	r3, [r5, #16]
340133a8:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340133aa:	4604      	mov	r4, r0
340133ac:	b118      	cbz	r0, 340133b6 <VD6G_Start+0xd2>
340133ae:	f240 23f6 	movw	r3, #758	@ 0x2f6
340133b2:	9000      	str	r0, [sp, #0]
340133b4:	e7dd      	b.n	34013372 <VD6G_Start+0x8e>
  mode = VD6G_Resolution2Mode(drv_ctx->config_save.resolution);
340133b6:	f895 3034 	ldrb.w	r3, [r5, #52]	@ 0x34
  switch (resolution) {
340133ba:	2b08      	cmp	r3, #8
340133bc:	d898      	bhi.n	340132f0 <VD6G_Start+0xc>
340133be:	4a63      	ldr	r2, [pc, #396]	@ (3401354c <VD6G_Start+0x268>)
340133c0:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
  if (!mode)
340133c4:	2e00      	cmp	r6, #0
340133c6:	d093      	beq.n	340132f0 <VD6G_Start+0xc>
  ret = ctx->write8(ctx, VD6G_REG_READOUT_CTRL, mode->bin_mode);
340133c8:	f240 417e 	movw	r1, #1150	@ 0x47e
340133cc:	4628      	mov	r0, r5
340133ce:	692b      	ldr	r3, [r5, #16]
340133d0:	7a32      	ldrb	r2, [r6, #8]
340133d2:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340133d4:	4604      	mov	r4, r0
340133d6:	b120      	cbz	r0, 340133e2 <VD6G_Start+0xfe>
340133d8:	f240 3329 	movw	r3, #809	@ 0x329
340133dc:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
340133de:	4a5c      	ldr	r2, [pc, #368]	@ (34013550 <VD6G_Start+0x26c>)
340133e0:	e7c8      	b.n	34013374 <VD6G_Start+0x90>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_X_START, mode->crop.left);
340133e2:	f240 415e 	movw	r1, #1118	@ 0x45e
340133e6:	4628      	mov	r0, r5
340133e8:	696b      	ldr	r3, [r5, #20]
340133ea:	89b2      	ldrh	r2, [r6, #12]
340133ec:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340133ee:	4604      	mov	r4, r0
340133f0:	b978      	cbnz	r0, 34013412 <VD6G_Start+0x12e>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_X_END, mode->crop.left + mode->crop.width - 1);
340133f2:	6973      	ldr	r3, [r6, #20]
340133f4:	68f2      	ldr	r2, [r6, #12]
340133f6:	f44f 618c 	mov.w	r1, #1120	@ 0x460
340133fa:	441a      	add	r2, r3
340133fc:	3a01      	subs	r2, #1
340133fe:	4628      	mov	r0, r5
34013400:	696b      	ldr	r3, [r5, #20]
34013402:	b292      	uxth	r2, r2
34013404:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013406:	4604      	mov	r4, r0
34013408:	b138      	cbz	r0, 3401341a <VD6G_Start+0x136>
3401340a:	f240 332e 	movw	r3, #814	@ 0x32e
3401340e:	9000      	str	r0, [sp, #0]
34013410:	e7e5      	b.n	340133de <VD6G_Start+0xfa>
  VD6G_TraceError(ctx, ret);
34013412:	f44f 734b 	mov.w	r3, #812	@ 0x32c
34013416:	9000      	str	r0, [sp, #0]
34013418:	e7e1      	b.n	340133de <VD6G_Start+0xfa>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_Y_START, mode->crop.top);
3401341a:	f240 4162 	movw	r1, #1122	@ 0x462
3401341e:	4628      	mov	r0, r5
34013420:	696b      	ldr	r3, [r5, #20]
34013422:	8a32      	ldrh	r2, [r6, #16]
34013424:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013426:	4604      	mov	r4, r0
34013428:	b118      	cbz	r0, 34013432 <VD6G_Start+0x14e>
3401342a:	f240 3331 	movw	r3, #817	@ 0x331
3401342e:	9000      	str	r0, [sp, #0]
34013430:	e7d5      	b.n	340133de <VD6G_Start+0xfa>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_Y_END, mode->crop.top + mode->crop.height - 1);
34013432:	69b3      	ldr	r3, [r6, #24]
34013434:	6932      	ldr	r2, [r6, #16]
34013436:	f240 4164 	movw	r1, #1124	@ 0x464
3401343a:	441a      	add	r2, r3
3401343c:	3a01      	subs	r2, #1
3401343e:	4628      	mov	r0, r5
34013440:	696b      	ldr	r3, [r5, #20]
34013442:	b292      	uxth	r2, r2
34013444:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013446:	4604      	mov	r4, r0
34013448:	b118      	cbz	r0, 34013452 <VD6G_Start+0x16e>
3401344a:	f240 3333 	movw	r3, #819	@ 0x333
3401344e:	9000      	str	r0, [sp, #0]
34013450:	e7c5      	b.n	340133de <VD6G_Start+0xfa>
  return VD6G_SetExposureModeInternal(ctx, drv_ctx->config_save.exposure_mode);
34013452:	4628      	mov	r0, r5
34013454:	f895 1064 	ldrb.w	r1, [r5, #100]	@ 0x64
34013458:	f7ff fb4a 	bl	34012af0 <VD6G_SetExposureModeInternal>
  if (ret)
3401345c:	4604      	mov	r4, r0
3401345e:	2800      	cmp	r0, #0
34013460:	f47f af48 	bne.w	340132f4 <VD6G_Start+0x10>
  switch (drv_ctx->config_save.flip_mirror_mode) {
34013464:	f895 303c 	ldrb.w	r3, [r5, #60]	@ 0x3c
34013468:	2b03      	cmp	r3, #3
3401346a:	f63f af41 	bhi.w	340132f0 <VD6G_Start+0xc>
  ret = ctx->write8(ctx, VD6G_REG_ORIENTATION, mode);
3401346e:	4a39      	ldr	r2, [pc, #228]	@ (34013554 <VD6G_Start+0x270>)
34013470:	692c      	ldr	r4, [r5, #16]
34013472:	f240 3102 	movw	r1, #770	@ 0x302
34013476:	4628      	mov	r0, r5
34013478:	5cd2      	ldrb	r2, [r2, r3]
3401347a:	47a0      	blx	r4
  VD6G_TraceError(ctx, ret);
3401347c:	4604      	mov	r4, r0
3401347e:	b9a8      	cbnz	r0, 340134ac <VD6G_Start+0x1c8>
  switch (drv_ctx->config_save.patgen) {
34013480:	f895 3044 	ldrb.w	r3, [r5, #68]	@ 0x44
34013484:	2b06      	cmp	r3, #6
34013486:	f63f af33 	bhi.w	340132f0 <VD6G_Start+0xc>
3401348a:	4a33      	ldr	r2, [pc, #204]	@ (34013558 <VD6G_Start+0x274>)
3401348c:	f832 6013 	ldrh.w	r6, [r2, r3, lsl #1]
  if (drv_ctx->config_save.patgen != VD6G_PATGEN_DISABLE)
34013490:	b1eb      	cbz	r3, 340134ce <VD6G_Start+0x1ea>
    ret = ctx->write8(ctx, VD6G_REG_DUSTER_CTRL, VD6G_DUSTER_CTRL_DISABLE);
34013492:	4602      	mov	r2, r0
34013494:	f44f 7146 	mov.w	r1, #792	@ 0x318
34013498:	4628      	mov	r0, r5
3401349a:	692b      	ldr	r3, [r5, #16]
3401349c:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
3401349e:	4604      	mov	r4, r0
340134a0:	b148      	cbz	r0, 340134b6 <VD6G_Start+0x1d2>
340134a2:	f240 3392 	movw	r3, #914	@ 0x392
340134a6:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
340134a8:	4a2c      	ldr	r2, [pc, #176]	@ (3401355c <VD6G_Start+0x278>)
340134aa:	e763      	b.n	34013374 <VD6G_Start+0x90>
  VD6G_TraceError(ctx, ret);
340134ac:	f240 336a 	movw	r3, #874	@ 0x36a
340134b0:	4a2b      	ldr	r2, [pc, #172]	@ (34013560 <VD6G_Start+0x27c>)
340134b2:	9000      	str	r0, [sp, #0]
340134b4:	e75e      	b.n	34013374 <VD6G_Start+0x90>
    ret = ctx->write8(ctx, VD6G_REG_DARKCAL_CTRL, VD6G_DARKCAL_CTRL_DISABLE_DARKAVG);
340134b6:	2202      	movs	r2, #2
340134b8:	f44f 7150 	mov.w	r1, #832	@ 0x340
340134bc:	4628      	mov	r0, r5
340134be:	692b      	ldr	r3, [r5, #16]
340134c0:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
340134c2:	4604      	mov	r4, r0
340134c4:	b118      	cbz	r0, 340134ce <VD6G_Start+0x1ea>
340134c6:	f44f 7365 	mov.w	r3, #916	@ 0x394
340134ca:	9000      	str	r0, [sp, #0]
340134cc:	e7ec      	b.n	340134a8 <VD6G_Start+0x1c4>
  ret = ctx->write16(ctx, VD6G_REG_PATGEN_CTRL, value);
340134ce:	4632      	mov	r2, r6
340134d0:	f44f 6180 	mov.w	r1, #1024	@ 0x400
340134d4:	4628      	mov	r0, r5
340134d6:	696b      	ldr	r3, [r5, #20]
340134d8:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340134da:	4604      	mov	r4, r0
340134dc:	b118      	cbz	r0, 340134e6 <VD6G_Start+0x202>
340134de:	f44f 7366 	mov.w	r3, #920	@ 0x398
340134e2:	9000      	str	r0, [sp, #0]
340134e4:	e7e0      	b.n	340134a8 <VD6G_Start+0x1c4>
  return VD6G_SetFlicker(ctx, drv_ctx->config_save.flicker);
340134e6:	4628      	mov	r0, r5
340134e8:	f895 1045 	ldrb.w	r1, [r5, #69]	@ 0x45
340134ec:	f7ff fb20 	bl	34012b30 <VD6G_SetFlicker>
  if (ret)
340134f0:	4604      	mov	r4, r0
340134f2:	2800      	cmp	r0, #0
340134f4:	f47f aefe 	bne.w	340132f4 <VD6G_Start+0x10>
  ret = ctx->write8(ctx, VD6G_REG_STBY, VD6G_CMD_START_STREAM);
340134f8:	2201      	movs	r2, #1
340134fa:	f240 2101 	movw	r1, #513	@ 0x201
340134fe:	4628      	mov	r0, r5
34013500:	692b      	ldr	r3, [r5, #16]
34013502:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013504:	4604      	mov	r4, r0
34013506:	b120      	cbz	r0, 34013512 <VD6G_Start+0x22e>
34013508:	f44f 737c 	mov.w	r3, #1008	@ 0x3f0
3401350c:	4a15      	ldr	r2, [pc, #84]	@ (34013564 <VD6G_Start+0x280>)
3401350e:	9000      	str	r0, [sp, #0]
34013510:	e730      	b.n	34013374 <VD6G_Start+0x90>
  ret = VD6G_PollReg8(ctx, VD6G_REG_STBY, VD6G_CMD_ACK);
34013512:	4602      	mov	r2, r0
34013514:	f240 2101 	movw	r1, #513	@ 0x201
34013518:	4628      	mov	r0, r5
3401351a:	f7ff fab9 	bl	34012a90 <VD6G_PollReg8>
  if (ret)
3401351e:	4604      	mov	r4, r0
34013520:	2800      	cmp	r0, #0
34013522:	f47f aee7 	bne.w	340132f4 <VD6G_Start+0x10>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_STREAMING);
34013526:	2103      	movs	r1, #3
34013528:	4628      	mov	r0, r5
3401352a:	f7ff fb9f 	bl	34012c6c <VD6G_WaitState>
  if (ret)
3401352e:	4604      	mov	r4, r0
34013530:	2800      	cmp	r0, #0
34013532:	f47f aedf 	bne.w	340132f4 <VD6G_Start+0x10>
  VD6G_notice(ctx, "Streaming is on\n");
34013536:	4628      	mov	r0, r5
34013538:	490b      	ldr	r1, [pc, #44]	@ (34013568 <VD6G_Start+0x284>)
3401353a:	f7ff fa7a 	bl	34012a32 <VD6G_notice>
  drv_ctx->is_streaming = 1;
3401353e:	2301      	movs	r3, #1
34013540:	62eb      	str	r3, [r5, #44]	@ 0x2c
  return 0;
34013542:	e6d7      	b.n	340132f4 <VD6G_Start+0x10>
34013544:	340a8ffa 	.word	0x340a8ffa
34013548:	34020a4a 	.word	0x34020a4a
3401354c:	340a8eac 	.word	0x340a8eac
34013550:	340a8feb 	.word	0x340a8feb
34013554:	340a8ea6 	.word	0x340a8ea6
34013558:	340a8e98 	.word	0x340a8e98
3401355c:	340a8fa8 	.word	0x340a8fa8
34013560:	340a8fb9 	.word	0x340a8fb9
34013564:	340a8f84 	.word	0x340a8f84
34013568:	34020cd2 	.word	0x34020cd2

3401356c <VD6G_Stop>:

int VD6G_Stop(VD6G_Ctx_t *ctx)
{
3401356c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = ctx->write8(ctx, VD6G_REG_STREAMING, VD6G_CMD_STOP_STREAM);
3401356e:	6903      	ldr	r3, [r0, #16]
34013570:	2201      	movs	r2, #1
34013572:	f240 2102 	movw	r1, #514	@ 0x202
{
34013576:	4605      	mov	r5, r0
  ret = ctx->write8(ctx, VD6G_REG_STREAMING, VD6G_CMD_STOP_STREAM);
34013578:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401357a:	4604      	mov	r4, r0
3401357c:	b998      	cbnz	r0, 340135a6 <VD6G_Stop+0x3a>
  ret = VD6G_PollReg8(ctx, VD6G_REG_STREAMING, VD6G_CMD_ACK);
3401357e:	4602      	mov	r2, r0
34013580:	f240 2102 	movw	r1, #514	@ 0x202
34013584:	4628      	mov	r0, r5
34013586:	f7ff fa83 	bl	34012a90 <VD6G_PollReg8>
  if (ret)
3401358a:	4604      	mov	r4, r0
3401358c:	b9b0      	cbnz	r0, 340135bc <VD6G_Stop+0x50>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
3401358e:	2102      	movs	r1, #2
34013590:	4628      	mov	r0, r5
34013592:	f7ff fb6b 	bl	34012c6c <VD6G_WaitState>
  if (ret)
34013596:	4604      	mov	r4, r0
34013598:	b980      	cbnz	r0, 340135bc <VD6G_Stop+0x50>
  VD6G_notice(ctx, "Streaming is off\n");
3401359a:	4628      	mov	r0, r5
3401359c:	4909      	ldr	r1, [pc, #36]	@ (340135c4 <VD6G_Stop+0x58>)
3401359e:	f7ff fa48 	bl	34012a32 <VD6G_notice>
  int ret;

  ret = VD6G_StopStreaming(ctx);
  if (ret)
    return ret;
  drv_ctx->is_streaming = 0;
340135a2:	62ec      	str	r4, [r5, #44]	@ 0x2c

  return 0;
340135a4:	e00a      	b.n	340135bc <VD6G_Stop+0x50>
  VD6G_TraceError(ctx, ret);
340135a6:	9000      	str	r0, [sp, #0]
340135a8:	f240 4304 	movw	r3, #1028	@ 0x404
340135ac:	4628      	mov	r0, r5
340135ae:	4a06      	ldr	r2, [pc, #24]	@ (340135c8 <VD6G_Stop+0x5c>)
340135b0:	4906      	ldr	r1, [pc, #24]	@ (340135cc <VD6G_Stop+0x60>)
340135b2:	f7ff fa30 	bl	34012a16 <VD6G_error>
340135b6:	4628      	mov	r0, r5
340135b8:	f7ff fa4a 	bl	34012a50 <display_error>
}
340135bc:	4620      	mov	r0, r4
340135be:	b003      	add	sp, #12
340135c0:	bd30      	pop	{r4, r5, pc}
340135c2:	bf00      	nop
340135c4:	34020b5e 	.word	0x34020b5e
340135c8:	340a8f71 	.word	0x340a8f71
340135cc:	34020a4a 	.word	0x34020a4a

340135d0 <VD6G_SetExposureMode>:

  return 0;
}

int VD6G_SetExposureMode(VD6G_Ctx_t *ctx, VD6G_ExposureMode_t mode)
{
340135d0:	b538      	push	{r3, r4, r5, lr}
340135d2:	4604      	mov	r4, r0
340135d4:	460d      	mov	r5, r1
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
  int ret;

  ret = VD6G_SetExposureModeInternal(ctx, mode);
340135d6:	f7ff fa8b 	bl	34012af0 <VD6G_SetExposureModeInternal>
  if (ret)
340135da:	b908      	cbnz	r0, 340135e0 <VD6G_SetExposureMode+0x10>
    return ret;

  drv_ctx->config_save.exposure_mode = mode;
340135dc:	f884 5064 	strb.w	r5, [r4, #100]	@ 0x64

  return 0;
}
340135e0:	bd38      	pop	{r3, r4, r5, pc}
	...

340135e4 <VD6G_GetAnalogGainRegRange>:

int VD6G_GetAnalogGainRegRange(VD6G_Ctx_t *ctx, uint8_t *AGmin, uint8_t *AGmax)
{
340135e4:	b5f0      	push	{r4, r5, r6, r7, lr}
340135e6:	4605      	mov	r5, r0
340135e8:	4616      	mov	r6, r2
  int ret;
  uint8_t value;

  if ((AGmin == NULL) || (AGmax == NULL))
340135ea:	460f      	mov	r7, r1
{
340135ec:	b085      	sub	sp, #20
  if ((AGmin == NULL) || (AGmax == NULL))
340135ee:	b371      	cbz	r1, 3401364e <VD6G_GetAnalogGainRegRange+0x6a>
340135f0:	b36a      	cbz	r2, 3401364e <VD6G_GetAnalogGainRegRange+0x6a>
    return -1;

  ret = ctx->read8(ctx, VD6G_REG_MIN_AG_CODED, &value);
340135f2:	f640 117e 	movw	r1, #2430	@ 0x97e
340135f6:	6843      	ldr	r3, [r0, #4]
340135f8:	f10d 020f 	add.w	r2, sp, #15
340135fc:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340135fe:	4604      	mov	r4, r0
34013600:	b988      	cbnz	r0, 34013626 <VD6G_GetAnalogGainRegRange+0x42>
  *AGmin = value & VD6G_REG_MIN_AG_CODED_MASK;
34013602:	f89d 300f 	ldrb.w	r3, [sp, #15]

  ret = ctx->read8(ctx, VD6G_REG_MAX_AG_CODED, &value);
34013606:	f44f 6116 	mov.w	r1, #2400	@ 0x960
  *AGmin = value & VD6G_REG_MIN_AG_CODED_MASK;
3401360a:	f003 031f 	and.w	r3, r3, #31
3401360e:	703b      	strb	r3, [r7, #0]
  ret = ctx->read8(ctx, VD6G_REG_MAX_AG_CODED, &value);
34013610:	4628      	mov	r0, r5
34013612:	686b      	ldr	r3, [r5, #4]
34013614:	f10d 020f 	add.w	r2, sp, #15
34013618:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401361a:	4604      	mov	r4, r0
3401361c:	b178      	cbz	r0, 3401363e <VD6G_GetAnalogGainRegRange+0x5a>
3401361e:	f240 43cc 	movw	r3, #1228	@ 0x4cc
34013622:	9000      	str	r0, [sp, #0]
34013624:	e002      	b.n	3401362c <VD6G_GetAnalogGainRegRange+0x48>
  VD6G_TraceError(ctx, ret);
34013626:	f44f 6399 	mov.w	r3, #1224	@ 0x4c8
3401362a:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
3401362c:	4628      	mov	r0, r5
3401362e:	4a09      	ldr	r2, [pc, #36]	@ (34013654 <VD6G_GetAnalogGainRegRange+0x70>)
34013630:	4909      	ldr	r1, [pc, #36]	@ (34013658 <VD6G_GetAnalogGainRegRange+0x74>)
34013632:	f7ff f9f0 	bl	34012a16 <VD6G_error>
34013636:	4628      	mov	r0, r5
34013638:	f7ff fa0a 	bl	34012a50 <display_error>
3401363c:	e004      	b.n	34013648 <VD6G_GetAnalogGainRegRange+0x64>
  *AGmax = value & VD6G_REG_MAX_AG_CODED_MASK;
3401363e:	f89d 300f 	ldrb.w	r3, [sp, #15]
34013642:	f003 031f 	and.w	r3, r3, #31
34013646:	7033      	strb	r3, [r6, #0]

  return 0;
}
34013648:	4620      	mov	r0, r4
3401364a:	b005      	add	sp, #20
3401364c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return -1;
3401364e:	f04f 34ff 	mov.w	r4, #4294967295
34013652:	e7f9      	b.n	34013648 <VD6G_GetAnalogGainRegRange+0x64>
34013654:	340a8f56 	.word	0x340a8f56
34013658:	34020a4a 	.word	0x34020a4a

3401365c <VD6G_SetAnalogGain>:

int VD6G_SetAnalogGain(VD6G_Ctx_t *ctx, int gain)
{
3401365c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
3401365e:	460e      	mov	r6, r1
  int ret;
  uint8_t again_regmin, again_regmax;

  ret = VD6G_GetAnalogGainRegRange(ctx, &again_regmin, &again_regmax);
34013660:	f10d 020f 	add.w	r2, sp, #15
34013664:	f10d 010e 	add.w	r1, sp, #14
{
34013668:	4605      	mov	r5, r0
  ret = VD6G_GetAnalogGainRegRange(ctx, &again_regmin, &again_regmax);
3401366a:	f7ff ffbb 	bl	340135e4 <VD6G_GetAnalogGainRegRange>
  if (ret)
3401366e:	4604      	mov	r4, r0
34013670:	b9d0      	cbnz	r0, 340136a8 <VD6G_SetAnalogGain+0x4c>
    return ret;

  ret = CHECK_RANGE(gain, again_regmin, again_regmax);
34013672:	f89d 300e 	ldrb.w	r3, [sp, #14]
34013676:	42b3      	cmp	r3, r6
34013678:	dc19      	bgt.n	340136ae <VD6G_SetAnalogGain+0x52>
3401367a:	f89d 300f 	ldrb.w	r3, [sp, #15]
3401367e:	42b3      	cmp	r3, r6
34013680:	db15      	blt.n	340136ae <VD6G_SetAnalogGain+0x52>
  if (ret)
    return ret;

  ret = ctx->write8(ctx, VD6G_REG_MANUAL_ANALOG_GAIN, gain);
34013682:	f240 414d 	movw	r1, #1101	@ 0x44d
34013686:	4628      	mov	r0, r5
34013688:	692b      	ldr	r3, [r5, #16]
3401368a:	b2f2      	uxtb	r2, r6
3401368c:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401368e:	4604      	mov	r4, r0
34013690:	b150      	cbz	r0, 340136a8 <VD6G_SetAnalogGain+0x4c>
34013692:	9000      	str	r0, [sp, #0]
34013694:	f44f 639c 	mov.w	r3, #1248	@ 0x4e0
34013698:	4628      	mov	r0, r5
3401369a:	4a06      	ldr	r2, [pc, #24]	@ (340136b4 <VD6G_SetAnalogGain+0x58>)
3401369c:	4906      	ldr	r1, [pc, #24]	@ (340136b8 <VD6G_SetAnalogGain+0x5c>)
3401369e:	f7ff f9ba 	bl	34012a16 <VD6G_error>
340136a2:	4628      	mov	r0, r5
340136a4:	f7ff f9d4 	bl	34012a50 <display_error>

  return 0;
}
340136a8:	4620      	mov	r0, r4
340136aa:	b004      	add	sp, #16
340136ac:	bd70      	pop	{r4, r5, r6, pc}
    return ret;
340136ae:	f04f 34ff 	mov.w	r4, #4294967295
340136b2:	e7f9      	b.n	340136a8 <VD6G_SetAnalogGain+0x4c>
340136b4:	340a8f43 	.word	0x340a8f43
340136b8:	34020a4a 	.word	0x34020a4a

340136bc <VD6G_GetDigitalGainRegRange>:

int VD6G_GetDigitalGainRegRange(VD6G_Ctx_t *ctx, uint16_t *DGmin, uint16_t *DGmax)
{
340136bc:	b573      	push	{r0, r1, r4, r5, r6, lr}
340136be:	4616      	mov	r6, r2
340136c0:	4605      	mov	r5, r0
  int ret;

  if ((DGmin == NULL) && (DGmax == NULL))
340136c2:	460a      	mov	r2, r1
340136c4:	b901      	cbnz	r1, 340136c8 <VD6G_GetDigitalGainRegRange+0xc>
340136c6:	b306      	cbz	r6, 3401370a <VD6G_GetDigitalGainRegRange+0x4e>
    return -1;

  ret = ctx->read16(ctx, VD6G_REG_MIN_DG, DGmin);
340136c8:	f640 117c 	movw	r1, #2428	@ 0x97c
340136cc:	4628      	mov	r0, r5
340136ce:	68ab      	ldr	r3, [r5, #8]
340136d0:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340136d2:	4604      	mov	r4, r0
340136d4:	b958      	cbnz	r0, 340136ee <VD6G_GetDigitalGainRegRange+0x32>

  ret = ctx->read16(ctx, VD6G_REG_MAX_DG, DGmax);
340136d6:	4632      	mov	r2, r6
340136d8:	f640 115e 	movw	r1, #2398	@ 0x95e
340136dc:	4628      	mov	r0, r5
340136de:	68ab      	ldr	r3, [r5, #8]
340136e0:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340136e2:	4604      	mov	r4, r0
340136e4:	b170      	cbz	r0, 34013704 <VD6G_GetDigitalGainRegRange+0x48>
340136e6:	f44f 639e 	mov.w	r3, #1264	@ 0x4f0
340136ea:	9000      	str	r0, [sp, #0]
340136ec:	e002      	b.n	340136f4 <VD6G_GetDigitalGainRegRange+0x38>
  VD6G_TraceError(ctx, ret);
340136ee:	f240 43ed 	movw	r3, #1261	@ 0x4ed
340136f2:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
340136f4:	4628      	mov	r0, r5
340136f6:	4a06      	ldr	r2, [pc, #24]	@ (34013710 <VD6G_GetDigitalGainRegRange+0x54>)
340136f8:	4906      	ldr	r1, [pc, #24]	@ (34013714 <VD6G_GetDigitalGainRegRange+0x58>)
340136fa:	f7ff f98c 	bl	34012a16 <VD6G_error>
340136fe:	4628      	mov	r0, r5
34013700:	f7ff f9a6 	bl	34012a50 <display_error>

  return 0;
}
34013704:	4620      	mov	r0, r4
34013706:	b002      	add	sp, #8
34013708:	bd70      	pop	{r4, r5, r6, pc}
    return -1;
3401370a:	f04f 34ff 	mov.w	r4, #4294967295
3401370e:	e7f9      	b.n	34013704 <VD6G_GetDigitalGainRegRange+0x48>
34013710:	340a8f27 	.word	0x340a8f27
34013714:	34020a4a 	.word	0x34020a4a

34013718 <VD6G_SetDigitalGain>:

int VD6G_SetDigitalGain(VD6G_Ctx_t *ctx, int gain)
{
34013718:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
3401371a:	460e      	mov	r6, r1
  int ret;
  uint16_t dgain_regmin, dgain_regmax;

  ret = VD6G_GetDigitalGainRegRange(ctx, &dgain_regmin, &dgain_regmax);
3401371c:	f10d 020e 	add.w	r2, sp, #14
34013720:	a903      	add	r1, sp, #12
{
34013722:	4605      	mov	r5, r0
  ret = VD6G_GetDigitalGainRegRange(ctx, &dgain_regmin, &dgain_regmax);
34013724:	f7ff ffca 	bl	340136bc <VD6G_GetDigitalGainRegRange>
  if (ret)
34013728:	4604      	mov	r4, r0
3401372a:	bb38      	cbnz	r0, 3401377c <VD6G_SetDigitalGain+0x64>
    return ret;

  ret = CHECK_RANGE(gain, dgain_regmin, dgain_regmax);
3401372c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34013730:	42b3      	cmp	r3, r6
34013732:	dc3f      	bgt.n	340137b4 <VD6G_SetDigitalGain+0x9c>
34013734:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34013738:	42b3      	cmp	r3, r6
3401373a:	db3b      	blt.n	340137b4 <VD6G_SetDigitalGain+0x9c>
  if (ret)
    return ret;

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH0_DIGITAL_GAIN, gain);
3401373c:	b2b6      	uxth	r6, r6
3401373e:	4632      	mov	r2, r6
34013740:	f44f 618a 	mov.w	r1, #1104	@ 0x450
34013744:	4628      	mov	r0, r5
34013746:	696b      	ldr	r3, [r5, #20]
34013748:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401374a:	4604      	mov	r4, r0
3401374c:	b958      	cbnz	r0, 34013766 <VD6G_SetDigitalGain+0x4e>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH1_DIGITAL_GAIN, gain);
3401374e:	4632      	mov	r2, r6
34013750:	f240 4152 	movw	r1, #1106	@ 0x452
34013754:	4628      	mov	r0, r5
34013756:	696b      	ldr	r3, [r5, #20]
34013758:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401375a:	4604      	mov	r4, r0
3401375c:	b188      	cbz	r0, 34013782 <VD6G_SetDigitalGain+0x6a>
3401375e:	f240 5306 	movw	r3, #1286	@ 0x506
34013762:	9000      	str	r0, [sp, #0]
34013764:	e002      	b.n	3401376c <VD6G_SetDigitalGain+0x54>
  VD6G_TraceError(ctx, ret);
34013766:	f240 5303 	movw	r3, #1283	@ 0x503
3401376a:	9000      	str	r0, [sp, #0]

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH2_DIGITAL_GAIN, gain);
  VD6G_TraceError(ctx, ret);

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH3_DIGITAL_GAIN, gain);
  VD6G_TraceError(ctx, ret);
3401376c:	4628      	mov	r0, r5
3401376e:	4a13      	ldr	r2, [pc, #76]	@ (340137bc <VD6G_SetDigitalGain+0xa4>)
34013770:	4913      	ldr	r1, [pc, #76]	@ (340137c0 <VD6G_SetDigitalGain+0xa8>)
34013772:	f7ff f950 	bl	34012a16 <VD6G_error>
34013776:	4628      	mov	r0, r5
34013778:	f7ff f96a 	bl	34012a50 <display_error>

  return 0;
}
3401377c:	4620      	mov	r0, r4
3401377e:	b004      	add	sp, #16
34013780:	bd70      	pop	{r4, r5, r6, pc}
  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH2_DIGITAL_GAIN, gain);
34013782:	4632      	mov	r2, r6
34013784:	f240 4154 	movw	r1, #1108	@ 0x454
34013788:	4628      	mov	r0, r5
3401378a:	696b      	ldr	r3, [r5, #20]
3401378c:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401378e:	4604      	mov	r4, r0
34013790:	b118      	cbz	r0, 3401379a <VD6G_SetDigitalGain+0x82>
34013792:	f240 5309 	movw	r3, #1289	@ 0x509
34013796:	9000      	str	r0, [sp, #0]
34013798:	e7e8      	b.n	3401376c <VD6G_SetDigitalGain+0x54>
  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH3_DIGITAL_GAIN, gain);
3401379a:	4632      	mov	r2, r6
3401379c:	f240 4156 	movw	r1, #1110	@ 0x456
340137a0:	4628      	mov	r0, r5
340137a2:	696b      	ldr	r3, [r5, #20]
340137a4:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340137a6:	4604      	mov	r4, r0
340137a8:	2800      	cmp	r0, #0
340137aa:	d0e7      	beq.n	3401377c <VD6G_SetDigitalGain+0x64>
340137ac:	f240 530c 	movw	r3, #1292	@ 0x50c
340137b0:	9000      	str	r0, [sp, #0]
340137b2:	e7db      	b.n	3401376c <VD6G_SetDigitalGain+0x54>
    return ret;
340137b4:	f04f 34ff 	mov.w	r4, #4294967295
340137b8:	e7e0      	b.n	3401377c <VD6G_SetDigitalGain+0x64>
340137ba:	bf00      	nop
340137bc:	340a8f13 	.word	0x340a8f13
340137c0:	34020a4a 	.word	0x34020a4a

340137c4 <VD6G_GetExposureRegRange>:

int VD6G_GetExposureRegRange(VD6G_Ctx_t *ctx, uint32_t *min_us, uint32_t *max_us)
{
340137c4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
340137c8:	4605      	mov	r5, r0
340137ca:	4616      	mov	r6, r2
  uint16_t exp_coarse_intg_margin;
  uint32_t line_time_in_us;
  uint16_t frame_length;
  int ret;

  if ((min_us == NULL) || (max_us == NULL))
340137cc:	460f      	mov	r7, r1
340137ce:	b929      	cbnz	r1, 340137dc <VD6G_GetExposureRegRange+0x18>
    return -1;
340137d0:	f04f 34ff 	mov.w	r4, #4294967295
    *max_us = (frame_length - exp_coarse_intg_margin - VD6G_MAX_MANUAL_EXP_COARSE_OFFSET) * line_time_in_us;
  else
    return -1;

  return 0;
}
340137d4:	4620      	mov	r0, r4
340137d6:	b004      	add	sp, #16
340137d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((min_us == NULL) || (max_us == NULL))
340137dc:	2a00      	cmp	r2, #0
340137de:	d0f7      	beq.n	340137d0 <VD6G_GetExposureRegRange+0xc>
  ret = VD6G_GetLineTimeInUs(ctx, &line_time_in_us);
340137e0:	a903      	add	r1, sp, #12
340137e2:	f7ff f9c9 	bl	34012b78 <VD6G_GetLineTimeInUs>
  if (ret)
340137e6:	4604      	mov	r4, r0
340137e8:	2800      	cmp	r0, #0
340137ea:	d1f3      	bne.n	340137d4 <VD6G_GetExposureRegRange+0x10>
  *min_us = VD6G_MIN_MANUAL_EXP_COARSE * line_time_in_us;
340137ec:	2315      	movs	r3, #21
340137ee:	f8dd 800c 	ldr.w	r8, [sp, #12]
  ret = ctx->read16(ctx, VD6G_FRAME_LENGTH, &frame_length);
340137f2:	f44f 618b 	mov.w	r1, #1112	@ 0x458
  *min_us = VD6G_MIN_MANUAL_EXP_COARSE * line_time_in_us;
340137f6:	fb03 f308 	mul.w	r3, r3, r8
  ret = ctx->read16(ctx, VD6G_FRAME_LENGTH, &frame_length);
340137fa:	4628      	mov	r0, r5
  *min_us = VD6G_MIN_MANUAL_EXP_COARSE * line_time_in_us;
340137fc:	603b      	str	r3, [r7, #0]
  ret = ctx->read16(ctx, VD6G_FRAME_LENGTH, &frame_length);
340137fe:	f10d 020a 	add.w	r2, sp, #10
34013802:	68ab      	ldr	r3, [r5, #8]
34013804:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013806:	4604      	mov	r4, r0
34013808:	b958      	cbnz	r0, 34013822 <VD6G_GetExposureRegRange+0x5e>
  ret = ctx->read16(ctx, VD6G_REG_EXP_COARSE_INTG_MARGIN, &exp_coarse_intg_margin);
3401380a:	f640 1146 	movw	r1, #2374	@ 0x946
3401380e:	4628      	mov	r0, r5
34013810:	68ab      	ldr	r3, [r5, #8]
34013812:	aa02      	add	r2, sp, #8
34013814:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013816:	4604      	mov	r4, r0
34013818:	b178      	cbz	r0, 3401383a <VD6G_GetExposureRegRange+0x76>
3401381a:	f240 5325 	movw	r3, #1317	@ 0x525
3401381e:	9000      	str	r0, [sp, #0]
34013820:	e002      	b.n	34013828 <VD6G_GetExposureRegRange+0x64>
  VD6G_TraceError(ctx, ret);
34013822:	f240 5322 	movw	r3, #1314	@ 0x522
34013826:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34013828:	4628      	mov	r0, r5
3401382a:	4a0a      	ldr	r2, [pc, #40]	@ (34013854 <VD6G_GetExposureRegRange+0x90>)
3401382c:	490a      	ldr	r1, [pc, #40]	@ (34013858 <VD6G_GetExposureRegRange+0x94>)
3401382e:	f7ff f8f2 	bl	34012a16 <VD6G_error>
34013832:	4628      	mov	r0, r5
34013834:	f7ff f90c 	bl	34012a50 <display_error>
34013838:	e7cc      	b.n	340137d4 <VD6G_GetExposureRegRange+0x10>
  if (exp_coarse_intg_margin >= VD6G_MIN_EXP_COARSE_INTG_MARGIN)
3401383a:	f8bd 2008 	ldrh.w	r2, [sp, #8]
3401383e:	2a43      	cmp	r2, #67	@ 0x43
34013840:	d9c6      	bls.n	340137d0 <VD6G_GetExposureRegRange+0xc>
    *max_us = (frame_length - exp_coarse_intg_margin - VD6G_MAX_MANUAL_EXP_COARSE_OFFSET) * line_time_in_us;
34013842:	f8bd 300a 	ldrh.w	r3, [sp, #10]
34013846:	1a9b      	subs	r3, r3, r2
34013848:	3b07      	subs	r3, #7
3401384a:	fb08 f303 	mul.w	r3, r8, r3
3401384e:	6033      	str	r3, [r6, #0]
  return 0;
34013850:	e7c0      	b.n	340137d4 <VD6G_GetExposureRegRange+0x10>
34013852:	bf00      	nop
34013854:	340a8efa 	.word	0x340a8efa
34013858:	34020a4a 	.word	0x34020a4a

3401385c <VD6G_SetExposureTime>:

int VD6G_SetExposureTime(VD6G_Ctx_t *ctx, int exposure_us)
{
3401385c:	b570      	push	{r4, r5, r6, lr}
3401385e:	b086      	sub	sp, #24
34013860:	460e      	mov	r6, r1
  int32_t ret;
  uint32_t exp_min, exp_max;
  uint32_t line_time_in_us;

  ret = VD6G_GetExposureRegRange(ctx, &exp_min, &exp_max);
34013862:	aa04      	add	r2, sp, #16
34013864:	a903      	add	r1, sp, #12
{
34013866:	4605      	mov	r5, r0
  ret = VD6G_GetExposureRegRange(ctx, &exp_min, &exp_max);
34013868:	f7ff ffac 	bl	340137c4 <VD6G_GetExposureRegRange>
  if (ret)
3401386c:	4604      	mov	r4, r0
3401386e:	bb08      	cbnz	r0, 340138b4 <VD6G_SetExposureTime+0x58>
    return ret;

  ret = CHECK_RANGE(exposure_us, exp_min, exp_max);
34013870:	9b03      	ldr	r3, [sp, #12]
34013872:	429e      	cmp	r6, r3
34013874:	d321      	bcc.n	340138ba <VD6G_SetExposureTime+0x5e>
34013876:	9b04      	ldr	r3, [sp, #16]
34013878:	429e      	cmp	r6, r3
3401387a:	d81e      	bhi.n	340138ba <VD6G_SetExposureTime+0x5e>
  if (ret)
    return ret;

  ret = VD6G_GetLineTimeInUs(ctx, &line_time_in_us);
3401387c:	4628      	mov	r0, r5
3401387e:	a905      	add	r1, sp, #20
34013880:	f7ff f97a 	bl	34012b78 <VD6G_GetLineTimeInUs>
  if (ret)
34013884:	4604      	mov	r4, r0
34013886:	b9a8      	cbnz	r0, 340138b4 <VD6G_SetExposureTime+0x58>
    return ret;

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_COARSE_EXP, CEIL(exposure_us / line_time_in_us));
34013888:	9b05      	ldr	r3, [sp, #20]
3401388a:	f240 414e 	movw	r1, #1102	@ 0x44e
3401388e:	fbb6 f2f3 	udiv	r2, r6, r3
34013892:	4628      	mov	r0, r5
34013894:	696b      	ldr	r3, [r5, #20]
34013896:	b292      	uxth	r2, r2
34013898:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401389a:	4604      	mov	r4, r0
3401389c:	b150      	cbz	r0, 340138b4 <VD6G_SetExposureTime+0x58>
3401389e:	9000      	str	r0, [sp, #0]
340138a0:	f240 5342 	movw	r3, #1346	@ 0x542
340138a4:	4628      	mov	r0, r5
340138a6:	4a06      	ldr	r2, [pc, #24]	@ (340138c0 <VD6G_SetExposureTime+0x64>)
340138a8:	4906      	ldr	r1, [pc, #24]	@ (340138c4 <VD6G_SetExposureTime+0x68>)
340138aa:	f7ff f8b4 	bl	34012a16 <VD6G_error>
340138ae:	4628      	mov	r0, r5
340138b0:	f7ff f8ce 	bl	34012a50 <display_error>

  return 0;
}
340138b4:	4620      	mov	r0, r4
340138b6:	b006      	add	sp, #24
340138b8:	bd70      	pop	{r4, r5, r6, pc}
    return ret;
340138ba:	f04f 34ff 	mov.w	r4, #4294967295
340138be:	e7f9      	b.n	340138b4 <VD6G_SetExposureTime+0x58>
340138c0:	340a8ed0 	.word	0x340a8ed0
340138c4:	34020a4a 	.word	0x34020a4a

340138c8 <ISP_Algo_BadPixel_Init>:
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_Init(void *hIsp, void *pAlgo)
{
  (void)hIsp; /* unused */

  ((ISP_AlgoTypeDef *)pAlgo)->state = ISP_ALGO_STATE_INIT;
340138c8:	2000      	movs	r0, #0
340138ca:	7048      	strb	r0, [r1, #1]

  return ISP_OK;
}
340138cc:	4770      	bx	lr

340138ce <ISP_Algo_BadPixel_DeInit>:
{
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  return ISP_OK;
}
340138ce:	2000      	movs	r0, #0
340138d0:	4770      	bx	lr

340138d2 <ISP_Algo_AEC_StatCb>:
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_StatCb(ISP_AlgoTypeDef *pAlgo)
{
  /* Update State */
  pAlgo->state = ISP_ALGO_STATE_STAT_READY;
340138d2:	2303      	movs	r3, #3
340138d4:	7043      	strb	r3, [r0, #1]

  return ISP_OK;
}
340138d6:	2000      	movs	r0, #0
340138d8:	4770      	bx	lr

340138da <ISP_Algo_AWB_StatCb>:
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_StatCb(ISP_AlgoTypeDef *pAlgo)
{
  /* Update State */
  if (pAlgo->state != ISP_ALGO_STATE_INIT)
340138da:	7843      	ldrb	r3, [r0, #1]
340138dc:	b10b      	cbz	r3, 340138e2 <ISP_Algo_AWB_StatCb+0x8>
  {
    pAlgo->state = ISP_ALGO_STATE_STAT_READY;
340138de:	2303      	movs	r3, #3
340138e0:	7043      	strb	r3, [r0, #1]
  }

  return ISP_OK;
}
340138e2:	2000      	movs	r0, #0
340138e4:	4770      	bx	lr
	...

340138e8 <ISP_Algo_BadPixel_Process>:
{
340138e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
340138ea:	4604      	mov	r4, r0
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
340138ec:	f001 fba2 	bl	34015034 <ISP_SVC_IQParam_Get>
  if (IQParamConfig->badPixelAlgo.enable == false)
340138f0:	f890 3054 	ldrb.w	r3, [r0, #84]	@ 0x54
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
340138f4:	4607      	mov	r7, r0
  if (IQParamConfig->badPixelAlgo.enable == false)
340138f6:	b913      	cbnz	r3, 340138fe <ISP_Algo_BadPixel_Process+0x16>
    return ISP_OK;
340138f8:	2000      	movs	r0, #0
}
340138fa:	b003      	add	sp, #12
340138fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  CurrentFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp);
340138fe:	4620      	mov	r0, r4
34013900:	f001 fb4c 	bl	34014f9c <ISP_SVC_Misc_GetMainFrameId>
  if (CurrentFrameId == LastFrameId)
34013904:	4b1e      	ldr	r3, [pc, #120]	@ (34013980 <ISP_Algo_BadPixel_Process+0x98>)
34013906:	681a      	ldr	r2, [r3, #0]
34013908:	4282      	cmp	r2, r0
3401390a:	d0f5      	beq.n	340138f8 <ISP_Algo_BadPixel_Process+0x10>
  if (Step++ >= 0)
3401390c:	4d1d      	ldr	r5, [pc, #116]	@ (34013984 <ISP_Algo_BadPixel_Process+0x9c>)
  LastFrameId = CurrentFrameId;
3401390e:	6018      	str	r0, [r3, #0]
  if (Step++ >= 0)
34013910:	f995 3000 	ldrsb.w	r3, [r5]
34013914:	1c5a      	adds	r2, r3, #1
34013916:	2b00      	cmp	r3, #0
34013918:	702a      	strb	r2, [r5, #0]
3401391a:	db0a      	blt.n	34013932 <ISP_Algo_BadPixel_Process+0x4a>
    ret  = ISP_SVC_ISP_GetBadPixel(hIsp, &BadPixelConfig);
3401391c:	4669      	mov	r1, sp
3401391e:	4620      	mov	r0, r4
34013920:	f001 f8c7 	bl	34014ab2 <ISP_SVC_ISP_GetBadPixel>
    if (ret != ISP_OK)
34013924:	2800      	cmp	r0, #0
34013926:	d1e8      	bne.n	340138fa <ISP_Algo_BadPixel_Process+0x12>
    BadPixelCount += BadPixelConfig.count;
34013928:	4a17      	ldr	r2, [pc, #92]	@ (34013988 <ISP_Algo_BadPixel_Process+0xa0>)
3401392a:	9b01      	ldr	r3, [sp, #4]
3401392c:	6811      	ldr	r1, [r2, #0]
3401392e:	440b      	add	r3, r1
34013930:	6013      	str	r3, [r2, #0]
  if (Step == 10)
34013932:	f995 2000 	ldrsb.w	r2, [r5]
34013936:	2a0a      	cmp	r2, #10
34013938:	d1de      	bne.n	340138f8 <ISP_Algo_BadPixel_Process+0x10>
    BadPixelCount /= 10;
3401393a:	4e13      	ldr	r6, [pc, #76]	@ (34013988 <ISP_Algo_BadPixel_Process+0xa0>)
3401393c:	6833      	ldr	r3, [r6, #0]
3401393e:	fbb3 f3f2 	udiv	r3, r3, r2
    if ((BadPixelCount > IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength > 0))
34013942:	6dba      	ldr	r2, [r7, #88]	@ 0x58
    BadPixelCount /= 10;
34013944:	6033      	str	r3, [r6, #0]
    if ((BadPixelCount > IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength > 0))
34013946:	4293      	cmp	r3, r2
34013948:	d912      	bls.n	34013970 <ISP_Algo_BadPixel_Process+0x88>
3401394a:	f89d 3001 	ldrb.w	r3, [sp, #1]
3401394e:	b113      	cbz	r3, 34013956 <ISP_Algo_BadPixel_Process+0x6e>
      BadPixelConfig.strength--;
34013950:	3b01      	subs	r3, #1
      BadPixelConfig.strength++;
34013952:	f88d 3001 	strb.w	r3, [sp, #1]
    BadPixelConfig.enable = 1;
34013956:	2301      	movs	r3, #1
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &BadPixelConfig);
34013958:	4669      	mov	r1, sp
3401395a:	4620      	mov	r0, r4
    BadPixelConfig.enable = 1;
3401395c:	f88d 3000 	strb.w	r3, [sp]
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &BadPixelConfig);
34013960:	f001 f88c 	bl	34014a7c <ISP_SVC_ISP_SetBadPixel>
    if (ret != ISP_OK)
34013964:	2800      	cmp	r0, #0
34013966:	d1c8      	bne.n	340138fa <ISP_Algo_BadPixel_Process+0x12>
    Step = -1;
34013968:	23ff      	movs	r3, #255	@ 0xff
    BadPixelCount = 0;
3401396a:	6030      	str	r0, [r6, #0]
    Step = -1;
3401396c:	702b      	strb	r3, [r5, #0]
    BadPixelCount = 0;
3401396e:	e7c4      	b.n	340138fa <ISP_Algo_BadPixel_Process+0x12>
    else if ((BadPixelCount < IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength < ISP_BADPIXEL_STRENGTH_MAX - 1))
34013970:	d2f1      	bcs.n	34013956 <ISP_Algo_BadPixel_Process+0x6e>
34013972:	f89d 3001 	ldrb.w	r3, [sp, #1]
34013976:	2b05      	cmp	r3, #5
34013978:	d8ed      	bhi.n	34013956 <ISP_Algo_BadPixel_Process+0x6e>
      BadPixelConfig.strength++;
3401397a:	3301      	adds	r3, #1
3401397c:	e7e9      	b.n	34013952 <ISP_Algo_BadPixel_Process+0x6a>
3401397e:	bf00      	nop
34013980:	340ce434 	.word	0x340ce434
34013984:	340ce430 	.word	0x340ce430
34013988:	340ce42c 	.word	0x340ce42c

3401398c <ISP_Algo_AEC_DeInit>:
{
3401398c:	b508      	push	{r3, lr}
  if (pIspAEprocess != NULL)
3401398e:	4b03      	ldr	r3, [pc, #12]	@ (3401399c <ISP_Algo_AEC_DeInit+0x10>)
34013990:	6818      	ldr	r0, [r3, #0]
34013992:	b108      	cbz	r0, 34013998 <ISP_Algo_AEC_DeInit+0xc>
    evision_api_st_ae_delete(pIspAEprocess);
34013994:	f7ed fd3a 	bl	3400140c <evision_api_st_ae_delete>
}
34013998:	2000      	movs	r0, #0
3401399a:	bd08      	pop	{r3, pc}
3401399c:	340ce454 	.word	0x340ce454

340139a0 <ISP_Algo_AEC_Init>:
{
340139a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
340139a2:	4604      	mov	r4, r0
340139a4:	460e      	mov	r6, r1
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
340139a6:	f001 fb45 	bl	34015034 <ISP_SVC_IQParam_Get>
  if (IQParamConfig->sensorDelay.delay == 0)
340139aa:	f890 3255 	ldrb.w	r3, [r0, #597]	@ 0x255
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
340139ae:	4605      	mov	r5, r0
  if (IQParamConfig->sensorDelay.delay == 0)
340139b0:	b913      	cbnz	r3, 340139b8 <ISP_Algo_AEC_Init+0x18>
    IQParamConfig->sensorDelay.delay = 1;
340139b2:	2301      	movs	r3, #1
340139b4:	f880 3255 	strb.w	r3, [r0, #597]	@ 0x255
  pIspAEprocess = evision_api_st_ae_new(log_cb);
340139b8:	482d      	ldr	r0, [pc, #180]	@ (34013a70 <ISP_Algo_AEC_Init+0xd0>)
340139ba:	f7ed fd0d 	bl	340013d8 <evision_api_st_ae_new>
340139be:	4f2d      	ldr	r7, [pc, #180]	@ (34013a74 <ISP_Algo_AEC_Init+0xd4>)
340139c0:	6038      	str	r0, [r7, #0]
  if (pIspAEprocess == NULL)
340139c2:	b130      	cbz	r0, 340139d2 <ISP_Algo_AEC_Init+0x32>
  e_ret = evision_api_st_ae_init(pIspAEprocess);
340139c4:	f7ed fd5c 	bl	34001480 <evision_api_st_ae_init>
  if (e_ret != EVISION_RET_SUCCESS)
340139c8:	2801      	cmp	r0, #1
340139ca:	d004      	beq.n	340139d6 <ISP_Algo_AEC_Init+0x36>
    evision_api_st_ae_delete(pIspAEprocess);
340139cc:	6838      	ldr	r0, [r7, #0]
340139ce:	f7ed fd1d 	bl	3400140c <evision_api_st_ae_delete>
    return ISP_ERR_ALGO;
340139d2:	20be      	movs	r0, #190	@ 0xbe
340139d4:	e033      	b.n	34013a3e <ISP_Algo_AEC_Init+0x9e>
  pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
340139d6:	683b      	ldr	r3, [r7, #0]
340139d8:	6eea      	ldr	r2, [r5, #108]	@ 0x6c
  pIspAEprocess->hyper_params.gain_max = pIsp_handle->sensorInfo.gain_max;
340139da:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
  pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
340139dc:	611a      	str	r2, [r3, #16]
  pIspAEprocess->hyper_params.compat_freq = IQParamConfig->AECAlgo.antiFlickerFreq;
340139de:	f895 2070 	ldrb.w	r2, [r5, #112]	@ 0x70
  pIspAEprocess->hyper_params.exposure_min = pIsp_handle->sensorInfo.exposure_min;
340139e2:	f8d4 7080 	ldr.w	r7, [r4, #128]	@ 0x80
  pIspAEprocess->hyper_params.compat_freq = IQParamConfig->AECAlgo.antiFlickerFreq;
340139e6:	655a      	str	r2, [r3, #84]	@ 0x54
  pIspAEprocess->hyper_params.exposure_max = pIsp_handle->sensorInfo.exposure_max;
340139e8:	f8d4 2084 	ldr.w	r2, [r4, #132]	@ 0x84
  pIspAEprocess->hyper_params.gain_increment_coeff = HYPERPARAM_AEC_GAIN_INCREMENT_COEFF;
340139ec:	200a      	movs	r0, #10
  pIspAEprocess->hyper_params.exposure_max = pIsp_handle->sensorInfo.exposure_max;
340139ee:	645a      	str	r2, [r3, #68]	@ 0x44
  pIspAEprocess->hyper_params.gain_min = pIsp_handle->sensorInfo.gain_min;
340139f0:	6fa2      	ldr	r2, [r4, #120]	@ 0x78
  pIspAEprocess->hyper_params.gain_max = pIsp_handle->sensorInfo.gain_max;
340139f2:	64d9      	str	r1, [r3, #76]	@ 0x4c
  pIspAEprocess->hyper_params.gain_increment_coeff = HYPERPARAM_AEC_GAIN_INCREMENT_COEFF;
340139f4:	2164      	movs	r1, #100	@ 0x64
  pIspAEprocess->hyper_params.gain_high_delta = HYPERPARAM_AEC_GAIN_HIGH_DELTA;
340139f6:	f04f 0c2d 	mov.w	ip, #45	@ 0x2d
  pIspAEprocess->hyper_params.gain_increment_coeff = HYPERPARAM_AEC_GAIN_INCREMENT_COEFF;
340139fa:	e9c3 0105 	strd	r0, r1, [r3, #20]
  pIspAEprocess->hyper_params.gain_high_delta = HYPERPARAM_AEC_GAIN_HIGH_DELTA;
340139fe:	2178      	movs	r1, #120	@ 0x78
  pIspAEprocess->hyper_params.gain_medium_increment_max = HYPERPARAM_AEC_GAIN_MEDIUM_INC_MAX;
34013a00:	f240 50dc 	movw	r0, #1500	@ 0x5dc
  pIspAEprocess->hyper_params.gain_high_delta = HYPERPARAM_AEC_GAIN_HIGH_DELTA;
34013a04:	e9c3 c107 	strd	ip, r1, [r3, #28]
  pIspAEprocess->hyper_params.gain_medium_increment_max = HYPERPARAM_AEC_GAIN_MEDIUM_INC_MAX;
34013a08:	f241 7170 	movw	r1, #6000	@ 0x1770
34013a0c:	e9c3 0109 	strd	r0, r1, [r3, #36]	@ 0x24
  pIspAEprocess->hyper_params.gain_high_increment_max = HYPERPARAM_AEC_GAIN_HIGH_INC_MAX;
34013a10:	f642 61e0 	movw	r1, #12000	@ 0x2ee0
34013a14:	62d9      	str	r1, [r3, #44]	@ 0x2c
  pIspAEprocess->hyper_params.exposure_up_ratio = HYPERPARAM_AEC_EXPOSURE_UP_RATIO;
34013a16:	a112      	add	r1, pc, #72	@ (adr r1, 34013a60 <ISP_Algo_AEC_Init+0xc0>)
34013a18:	e9d1 0100 	ldrd	r0, r1, [r1]
34013a1c:	e9c3 010c 	strd	r0, r1, [r3, #48]	@ 0x30
  pIspAEprocess->hyper_params.exposure_down_ratio = HYPERPARAM_AEC_EXPOSURE_DOWN_RATIO;
34013a20:	a111      	add	r1, pc, #68	@ (adr r1, 34013a68 <ISP_Algo_AEC_Init+0xc8>)
34013a22:	e9d1 0100 	ldrd	r0, r1, [r1]
34013a26:	e9c3 010e 	strd	r0, r1, [r3, #56]	@ 0x38
  pIspAEprocess->hyper_params.dark_zone_lum_limit = HYPERPARAM_AEC_DARKZONE_LUM_LIMIT;
34013a2a:	2105      	movs	r1, #5
  pIspAEprocess->hyper_params.exposure_min = pIsp_handle->sensorInfo.exposure_min;
34013a2c:	641f      	str	r7, [r3, #64]	@ 0x40
  pIspAEprocess->hyper_params.gain_min = pIsp_handle->sensorInfo.gain_min;
34013a2e:	649a      	str	r2, [r3, #72]	@ 0x48
  pIspAEprocess->hyper_params.dark_zone_lum_limit = HYPERPARAM_AEC_DARKZONE_LUM_LIMIT;
34013a30:	6519      	str	r1, [r3, #80]	@ 0x50
  if (IQParamConfig->AECAlgo.enable == true)
34013a32:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
34013a36:	2b01      	cmp	r3, #1
34013a38:	d003      	beq.n	34013a42 <ISP_Algo_AEC_Init+0xa2>
  algo->state = ISP_ALGO_STATE_INIT;
34013a3a:	2000      	movs	r0, #0
34013a3c:	7070      	strb	r0, [r6, #1]
}
34013a3e:	b003      	add	sp, #12
34013a40:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig) != ISP_OK) || (ISP_SVC_Sensor_SetGain(hIsp, &gainConfig)!= ISP_OK))
34013a42:	4669      	mov	r1, sp
34013a44:	4620      	mov	r0, r4
    gainConfig.gain = pIsp_handle->sensorInfo.gain_min;
34013a46:	e9cd 7200 	strd	r7, r2, [sp]
    if ((ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig) != ISP_OK) || (ISP_SVC_Sensor_SetGain(hIsp, &gainConfig)!= ISP_OK))
34013a4a:	f001 fa73 	bl	34014f34 <ISP_SVC_Sensor_SetExposure>
34013a4e:	2800      	cmp	r0, #0
34013a50:	d1bf      	bne.n	340139d2 <ISP_Algo_AEC_Init+0x32>
34013a52:	4620      	mov	r0, r4
34013a54:	a901      	add	r1, sp, #4
34013a56:	f001 fa49 	bl	34014eec <ISP_SVC_Sensor_SetGain>
34013a5a:	2800      	cmp	r0, #0
34013a5c:	d0ed      	beq.n	34013a3a <ISP_Algo_AEC_Init+0x9a>
34013a5e:	e7b8      	b.n	340139d2 <ISP_Algo_AEC_Init+0x32>
34013a60:	40000000 	.word	0x40000000
34013a64:	3f947ae1 	.word	0x3f947ae1
34013a68:	e0000000 	.word	0xe0000000
34013a6c:	3f70624d 	.word	0x3f70624d
34013a70:	34013a79 	.word	0x34013a79
34013a74:	340ce454 	.word	0x340ce454

34013a78 <log_cb>:
{
34013a78:	b508      	push	{r3, lr}
34013a7a:	4601      	mov	r1, r0
  printf("%s", msg);
34013a7c:	4803      	ldr	r0, [pc, #12]	@ (34013a8c <log_cb+0x14>)
34013a7e:	f006 f97d 	bl	34019d7c <iprintf>
}
34013a82:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("\r\n");
34013a86:	4802      	ldr	r0, [pc, #8]	@ (34013a90 <log_cb+0x18>)
34013a88:	f006 b9e0 	b.w	34019e4c <puts>
34013a8c:	34021f92 	.word	0x34021f92
34013a90:	3401d8b1 	.word	0x3401d8b1

34013a94 <ISP_Algo_AEC_Process>:
{
34013a94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34013a98:	b086      	sub	sp, #24
34013a9a:	4605      	mov	r5, r0
34013a9c:	460c      	mov	r4, r1
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013a9e:	f001 fac9 	bl	34015034 <ISP_SVC_IQParam_Get>
  if (IQParamConfig->AECAlgo.enable == false)
34013aa2:	f890 3068 	ldrb.w	r3, [r0, #104]	@ 0x68
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013aa6:	4606      	mov	r6, r0
  if (IQParamConfig->AECAlgo.enable == false)
34013aa8:	b113      	cbz	r3, 34013ab0 <ISP_Algo_AEC_Process+0x1c>
  switch(algo->state)
34013aaa:	7863      	ldrb	r3, [r4, #1]
34013aac:	2b02      	cmp	r3, #2
34013aae:	d103      	bne.n	34013ab8 <ISP_Algo_AEC_Process+0x24>
{
34013ab0:	2000      	movs	r0, #0
}
34013ab2:	b006      	add	sp, #24
34013ab4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  switch(algo->state)
34013ab8:	d907      	bls.n	34013aca <ISP_Algo_AEC_Process+0x36>
34013aba:	2b03      	cmp	r3, #3
34013abc:	d016      	beq.n	34013aec <ISP_Algo_AEC_Process+0x58>
    printf("WARNING: Unknown AE algo state\r\n");
34013abe:	4831      	ldr	r0, [pc, #196]	@ (34013b84 <ISP_Algo_AEC_Process+0xf0>)
34013ac0:	f006 f9c4 	bl	34019e4c <puts>
    algo->state = ISP_ALGO_STATE_INIT;
34013ac4:	2300      	movs	r3, #0
34013ac6:	7063      	strb	r3, [r4, #1]
    break;
34013ac8:	e7f2      	b.n	34013ab0 <ISP_Algo_AEC_Process+0x1c>
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34013aca:	f890 3255 	ldrb.w	r3, [r0, #597]	@ 0x255
34013ace:	2602      	movs	r6, #2
34013ad0:	9302      	str	r3, [sp, #8]
34013ad2:	2301      	movs	r3, #1
34013ad4:	4622      	mov	r2, r4
34013ad6:	e9cd 6300 	strd	r6, r3, [sp]
34013ada:	4628      	mov	r0, r5
34013adc:	4b2a      	ldr	r3, [pc, #168]	@ (34013b88 <ISP_Algo_AEC_Process+0xf4>)
34013ade:	492b      	ldr	r1, [pc, #172]	@ (34013b8c <ISP_Algo_AEC_Process+0xf8>)
34013ae0:	f001 fcee 	bl	340154c0 <ISP_SVC_Stats_GetNext>
    if (ret != ISP_OK)
34013ae4:	2800      	cmp	r0, #0
34013ae6:	d1e4      	bne.n	34013ab2 <ISP_Algo_AEC_Process+0x1e>
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34013ae8:	7066      	strb	r6, [r4, #1]
    break;
34013aea:	e7e2      	b.n	34013ab2 <ISP_Algo_AEC_Process+0x1e>
    pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
34013aec:	4f28      	ldr	r7, [pc, #160]	@ (34013b90 <ISP_Algo_AEC_Process+0xfc>)
34013aee:	6ec2      	ldr	r2, [r0, #108]	@ 0x6c
34013af0:	683b      	ldr	r3, [r7, #0]
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
34013af2:	a904      	add	r1, sp, #16
    pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
34013af4:	611a      	str	r2, [r3, #16]
    pIspAEprocess->hyper_params.compat_freq = IQParamConfig->AECAlgo.antiFlickerFreq;
34013af6:	f890 2070 	ldrb.w	r2, [r0, #112]	@ 0x70
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
34013afa:	4628      	mov	r0, r5
    pIspAEprocess->hyper_params.compat_freq = IQParamConfig->AECAlgo.antiFlickerFreq;
34013afc:	655a      	str	r2, [r3, #84]	@ 0x54
    avgL = stats.down.averageL;
34013afe:	4b22      	ldr	r3, [pc, #136]	@ (34013b88 <ISP_Algo_AEC_Process+0xf4>)
34013b00:	f893 8037 	ldrb.w	r8, [r3, #55]	@ 0x37
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
34013b04:	f001 fa08 	bl	34014f18 <ISP_SVC_Sensor_GetGain>
    if (ret != ISP_OK)
34013b08:	2800      	cmp	r0, #0
34013b0a:	d1d2      	bne.n	34013ab2 <ISP_Algo_AEC_Process+0x1e>
    ret = ISP_SVC_Sensor_GetExposure(hIsp, &exposureConfig);
34013b0c:	4628      	mov	r0, r5
34013b0e:	a905      	add	r1, sp, #20
34013b10:	f001 fa26 	bl	34014f60 <ISP_SVC_Sensor_GetExposure>
    if (ret != ISP_OK)
34013b14:	2800      	cmp	r0, #0
34013b16:	d1cc      	bne.n	34013ab2 <ISP_Algo_AEC_Process+0x1e>
    Meta.averageL = (uint8_t)avgL;
34013b18:	4b1e      	ldr	r3, [pc, #120]	@ (34013b94 <ISP_Algo_AEC_Process+0x100>)
    Meta.exposureTarget = IQParamConfig->AECAlgo.exposureTarget;
34013b1a:	6ef2      	ldr	r2, [r6, #108]	@ 0x6c
    Meta.averageL = (uint8_t)avgL;
34013b1c:	f883 8001 	strb.w	r8, [r3, #1]
    Meta.exposureTarget = IQParamConfig->AECAlgo.exposureTarget;
34013b20:	605a      	str	r2, [r3, #4]
    e_ret = evision_api_st_ae_process(pIspAEprocess, gainConfig.gain, exposureConfig.exposure, (uint8_t)avgL);
34013b22:	6838      	ldr	r0, [r7, #0]
34013b24:	4643      	mov	r3, r8
34013b26:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
34013b2a:	f7ed fcb4 	bl	34001496 <evision_api_st_ae_process>
    if (e_ret == EVISION_RET_SUCCESS)
34013b2e:	2801      	cmp	r0, #1
34013b30:	d00d      	beq.n	34013b4e <ISP_Algo_AEC_Process+0xba>
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34013b32:	f896 3255 	ldrb.w	r3, [r6, #597]	@ 0x255
34013b36:	2602      	movs	r6, #2
34013b38:	9302      	str	r3, [sp, #8]
34013b3a:	2301      	movs	r3, #1
34013b3c:	4622      	mov	r2, r4
34013b3e:	e9cd 6300 	strd	r6, r3, [sp]
34013b42:	4628      	mov	r0, r5
34013b44:	4b10      	ldr	r3, [pc, #64]	@ (34013b88 <ISP_Algo_AEC_Process+0xf4>)
34013b46:	4911      	ldr	r1, [pc, #68]	@ (34013b8c <ISP_Algo_AEC_Process+0xf8>)
34013b48:	f001 fcba 	bl	340154c0 <ISP_SVC_Stats_GetNext>
34013b4c:	e7cc      	b.n	34013ae8 <ISP_Algo_AEC_Process+0x54>
      if (gainConfig.gain != pIspAEprocess->new_gain)
34013b4e:	683b      	ldr	r3, [r7, #0]
34013b50:	9a04      	ldr	r2, [sp, #16]
34013b52:	689b      	ldr	r3, [r3, #8]
34013b54:	429a      	cmp	r2, r3
34013b56:	d10c      	bne.n	34013b72 <ISP_Algo_AEC_Process+0xde>
      if (exposureConfig.exposure != pIspAEprocess->new_exposure)
34013b58:	683b      	ldr	r3, [r7, #0]
34013b5a:	9a05      	ldr	r2, [sp, #20]
34013b5c:	685b      	ldr	r3, [r3, #4]
34013b5e:	429a      	cmp	r2, r3
34013b60:	d0e7      	beq.n	34013b32 <ISP_Algo_AEC_Process+0x9e>
        ret = ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig);
34013b62:	4628      	mov	r0, r5
34013b64:	a905      	add	r1, sp, #20
        exposureConfig.exposure = pIspAEprocess->new_exposure;
34013b66:	9305      	str	r3, [sp, #20]
        ret = ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig);
34013b68:	f001 f9e4 	bl	34014f34 <ISP_SVC_Sensor_SetExposure>
        if (ret != ISP_OK)
34013b6c:	2800      	cmp	r0, #0
34013b6e:	d0e0      	beq.n	34013b32 <ISP_Algo_AEC_Process+0x9e>
34013b70:	e79f      	b.n	34013ab2 <ISP_Algo_AEC_Process+0x1e>
        ret = ISP_SVC_Sensor_SetGain(hIsp, &gainConfig);
34013b72:	4628      	mov	r0, r5
34013b74:	a904      	add	r1, sp, #16
        gainConfig.gain = pIspAEprocess->new_gain;
34013b76:	9304      	str	r3, [sp, #16]
        ret = ISP_SVC_Sensor_SetGain(hIsp, &gainConfig);
34013b78:	f001 f9b8 	bl	34014eec <ISP_SVC_Sensor_SetGain>
        if (ret != ISP_OK)
34013b7c:	2800      	cmp	r0, #0
34013b7e:	d0eb      	beq.n	34013b58 <ISP_Algo_AEC_Process+0xc4>
34013b80:	e797      	b.n	34013ab2 <ISP_Algo_AEC_Process+0x1e>
34013b82:	bf00      	nop
34013b84:	34020e57 	.word	0x34020e57
34013b88:	340ce3b4 	.word	0x340ce3b4
34013b8c:	340138d3 	.word	0x340138d3
34013b90:	340ce454 	.word	0x340ce454
34013b94:	340ce438 	.word	0x340ce438

34013b98 <ISP_Algo_AWB_Init>:
{
34013b98:	b510      	push	{r4, lr}
  pIspAWBestimator = evision_api_awb_new(log_cb);
34013b9a:	4806      	ldr	r0, [pc, #24]	@ (34013bb4 <ISP_Algo_AWB_Init+0x1c>)
{
34013b9c:	460c      	mov	r4, r1
  pIspAWBestimator = evision_api_awb_new(log_cb);
34013b9e:	f7ed f86a 	bl	34000c76 <evision_api_awb_new>
34013ba2:	4b05      	ldr	r3, [pc, #20]	@ (34013bb8 <ISP_Algo_AWB_Init+0x20>)
34013ba4:	6018      	str	r0, [r3, #0]
  if (pIspAWBestimator == NULL)
34013ba6:	b110      	cbz	r0, 34013bae <ISP_Algo_AWB_Init+0x16>
  algo->state = ISP_ALGO_STATE_INIT;
34013ba8:	2000      	movs	r0, #0
34013baa:	7060      	strb	r0, [r4, #1]
}
34013bac:	bd10      	pop	{r4, pc}
    return ISP_ERR_ALGO;
34013bae:	20be      	movs	r0, #190	@ 0xbe
34013bb0:	e7fc      	b.n	34013bac <ISP_Algo_AWB_Init+0x14>
34013bb2:	bf00      	nop
34013bb4:	34013a79 	.word	0x34013a79
34013bb8:	340ce450 	.word	0x340ce450

34013bbc <ISP_Algo_AWB_DeInit>:
{
34013bbc:	b508      	push	{r3, lr}
  if (pIspAWBestimator != NULL)
34013bbe:	4b03      	ldr	r3, [pc, #12]	@ (34013bcc <ISP_Algo_AWB_DeInit+0x10>)
34013bc0:	6818      	ldr	r0, [r3, #0]
34013bc2:	b108      	cbz	r0, 34013bc8 <ISP_Algo_AWB_DeInit+0xc>
    evision_api_awb_delete(pIspAWBestimator);
34013bc4:	f7ed f872 	bl	34000cac <evision_api_awb_delete>
}
34013bc8:	2000      	movs	r0, #0
34013bca:	bd08      	pop	{r3, pc}
34013bcc:	340ce450 	.word	0x340ce450

34013bd0 <ISP_Algo_ApplyGammaInverse>:
{
34013bd0:	b508      	push	{r3, lr}
34013bd2:	ed2d 8b02 	vpush	{d8}
34013bd6:	ee08 1a10 	vmov	s16, r1
  if (ISP_SVC_Misc_IsGammaEnabled(hIsp, 1 /*main pipe*/) != 0) {
34013bda:	2101      	movs	r1, #1
34013bdc:	f001 f9ee 	bl	34014fbc <ISP_SVC_Misc_IsGammaEnabled>
34013be0:	b190      	cbz	r0, 34013c08 <ISP_Algo_ApplyGammaInverse+0x38>
    out = 255 * pow((float)comp / 255, 1.0 / 2.2);
34013be2:	eddf 7a0f 	vldr	s15, [pc, #60]	@ 34013c20 <ISP_Algo_ApplyGammaInverse+0x50>
34013be6:	eeb8 8a48 	vcvt.f32.u32	s16, s16
34013bea:	ee88 0a27 	vdiv.f32	s0, s16, s15
34013bee:	ed9f 1b08 	vldr	d1, [pc, #32]	@ 34013c10 <ISP_Algo_ApplyGammaInverse+0x40>
34013bf2:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34013bf6:	f008 fc4b 	bl	3401c490 <pow>
34013bfa:	ed9f 7b07 	vldr	d7, [pc, #28]	@ 34013c18 <ISP_Algo_ApplyGammaInverse+0x48>
34013bfe:	ee20 0b07 	vmul.f64	d0, d0, d7
}
34013c02:	ecbd 8b02 	vpop	{d8}
34013c06:	bd08      	pop	{r3, pc}
    out = (double) comp;
34013c08:	eeb8 0b48 	vcvt.f64.u32	d0, s16
  return out;
34013c0c:	e7f9      	b.n	34013c02 <ISP_Algo_ApplyGammaInverse+0x32>
34013c0e:	bf00      	nop
34013c10:	d1745d17 	.word	0xd1745d17
34013c14:	3fdd1745 	.word	0x3fdd1745
34013c18:	00000000 	.word	0x00000000
34013c1c:	406fe000 	.word	0x406fe000
34013c20:	437f0000 	.word	0x437f0000

34013c24 <ISP_Algo_GetUpStat>:
{
34013c24:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
34013c28:	b087      	sub	sp, #28
34013c2a:	460c      	mov	r4, r1
  if ((ISP_SVC_ISP_GetGain(hIsp, &ISPGain) == ISP_OK) && (ISPGain.enable == 1))
34013c2c:	a902      	add	r1, sp, #8
{
34013c2e:	4680      	mov	r8, r0
  if ((ISP_SVC_ISP_GetGain(hIsp, &ISPGain) == ISP_OK) && (ISPGain.enable == 1))
34013c30:	f001 f834 	bl	34014c9c <ISP_SVC_ISP_GetGain>
34013c34:	f894 7036 	ldrb.w	r7, [r4, #54]	@ 0x36
34013c38:	4606      	mov	r6, r0
34013c3a:	2800      	cmp	r0, #0
34013c3c:	d13b      	bne.n	34013cb6 <ISP_Algo_GetUpStat+0x92>
34013c3e:	f89d 3008 	ldrb.w	r3, [sp, #8]
34013c42:	2b01      	cmp	r3, #1
34013c44:	d137      	bne.n	34013cb6 <ISP_Algo_GetUpStat+0x92>
    upG = (int64_t) pStats->down.averageG * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainG;
34013c46:	4d1e      	ldr	r5, [pc, #120]	@ (34013cc0 <ISP_Algo_GetUpStat+0x9c>)
34013c48:	f894 1035 	ldrb.w	r1, [r4, #53]	@ 0x35
34013c4c:	4603      	mov	r3, r0
34013c4e:	9a04      	ldr	r2, [sp, #16]
34013c50:	fba1 0105 	umull	r0, r1, r1, r5
34013c54:	f7ed fd7a 	bl	3400174c <__aeabi_ldivmod>
    upB = (int64_t) pStats->down.averageB * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainB;
34013c58:	4633      	mov	r3, r6
    upG = (int64_t) pStats->down.averageG * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainG;
34013c5a:	4681      	mov	r9, r0
    upB = (int64_t) pStats->down.averageB * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainB;
34013c5c:	9a05      	ldr	r2, [sp, #20]
34013c5e:	fba7 0105 	umull	r0, r1, r7, r5
34013c62:	f7ed fd73 	bl	3400174c <__aeabi_ldivmod>
    upR = (int64_t) pStats->down.averageR * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainR;
34013c66:	f894 1034 	ldrb.w	r1, [r4, #52]	@ 0x34
    upB = (int64_t) pStats->down.averageB * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainB;
34013c6a:	4607      	mov	r7, r0
    upR = (int64_t) pStats->down.averageR * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainR;
34013c6c:	4633      	mov	r3, r6
34013c6e:	fba1 0105 	umull	r0, r1, r1, r5
34013c72:	9a03      	ldr	r2, [sp, #12]
34013c74:	f7ed fd6a 	bl	3400174c <__aeabi_ldivmod>
    pStats->up.averageG = (uint8_t) upG;
34013c78:	f884 9001 	strb.w	r9, [r4, #1]
    pStats->up.averageR = (uint8_t) upR;
34013c7c:	7020      	strb	r0, [r4, #0]
    pStats->up.averageB = (uint8_t) upB;
34013c7e:	70a7      	strb	r7, [r4, #2]
    if ((ISP_SVC_ISP_GetBlackLevel(hIsp, &BlackLevel) == ISP_OK) && (BlackLevel.enable == 1))
34013c80:	4640      	mov	r0, r8
34013c82:	a901      	add	r1, sp, #4
34013c84:	f000 ff53 	bl	34014b2e <ISP_SVC_ISP_GetBlackLevel>
34013c88:	b990      	cbnz	r0, 34013cb0 <ISP_Algo_GetUpStat+0x8c>
34013c8a:	f89d 3004 	ldrb.w	r3, [sp, #4]
34013c8e:	2b01      	cmp	r3, #1
34013c90:	d10e      	bne.n	34013cb0 <ISP_Algo_GetUpStat+0x8c>
    pStats->up.averageR += BlackLevel.BLCR;
34013c92:	7823      	ldrb	r3, [r4, #0]
34013c94:	f89d 2005 	ldrb.w	r2, [sp, #5]
34013c98:	4413      	add	r3, r2
34013c9a:	7023      	strb	r3, [r4, #0]
    pStats->up.averageG += BlackLevel.BLCG;
34013c9c:	f89d 2006 	ldrb.w	r2, [sp, #6]
34013ca0:	7863      	ldrb	r3, [r4, #1]
34013ca2:	4413      	add	r3, r2
34013ca4:	7063      	strb	r3, [r4, #1]
    pStats->up.averageB += BlackLevel.BLCB;
34013ca6:	f89d 2007 	ldrb.w	r2, [sp, #7]
34013caa:	78a3      	ldrb	r3, [r4, #2]
34013cac:	4413      	add	r3, r2
34013cae:	70a3      	strb	r3, [r4, #2]
}
34013cb0:	b007      	add	sp, #28
34013cb2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    pStats->up.averageR = pStats->down.averageR;
34013cb6:	8ea3      	ldrh	r3, [r4, #52]	@ 0x34
    pStats->up.averageB = pStats->down.averageB;
34013cb8:	70a7      	strb	r7, [r4, #2]
    pStats->up.averageR = pStats->down.averageR;
34013cba:	8023      	strh	r3, [r4, #0]
}
34013cbc:	e7f8      	b.n	34013cb0 <ISP_Algo_GetUpStat+0x8c>
34013cbe:	bf00      	nop
34013cc0:	05f5e100 	.word	0x05f5e100
34013cc4:	00000000 	.word	0x00000000

34013cc8 <ISP_Algo_ApplyCConv>:
{
34013cc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
34013ccc:	b08b      	sub	sp, #44	@ 0x2c
34013cce:	460e      	mov	r6, r1
  if ((ISP_SVC_ISP_GetColorConv(hIsp, &colorConv) == ISP_OK) && (colorConv.enable == 1))
34013cd0:	4669      	mov	r1, sp
{
34013cd2:	4615      	mov	r5, r2
34013cd4:	461c      	mov	r4, r3
  if ((ISP_SVC_ISP_GetColorConv(hIsp, &colorConv) == ISP_OK) && (colorConv.enable == 1))
34013cd6:	f001 f8b3 	bl	34014e40 <ISP_SVC_ISP_GetColorConv>
34013cda:	4602      	mov	r2, r0
34013cdc:	2800      	cmp	r0, #0
34013cde:	f040 8096 	bne.w	34013e0e <ISP_Algo_ApplyCConv+0x146>
34013ce2:	f89d 3000 	ldrb.w	r3, [sp]
34013ce6:	2b01      	cmp	r3, #1
34013ce8:	f040 8091 	bne.w	34013e0e <ISP_Algo_ApplyCConv+0x146>
    ccR = (int64_t) inR * colorConv.coeff[0][0] + (int64_t) inG * colorConv.coeff[0][1] + (int64_t) inB * colorConv.coeff[0][2];
34013cec:	9b01      	ldr	r3, [sp, #4]
34013cee:	17d9      	asrs	r1, r3, #31
34013cf0:	fba3 3706 	umull	r3, r7, r3, r6
34013cf4:	fb06 7701 	mla	r7, r6, r1, r7
34013cf8:	9902      	ldr	r1, [sp, #8]
34013cfa:	ea4f 7ce1 	mov.w	ip, r1, asr #31
34013cfe:	fba1 1005 	umull	r1, r0, r1, r5
34013d02:	fb05 000c 	mla	r0, r5, ip, r0
34013d06:	185b      	adds	r3, r3, r1
34013d08:	eb47 0700 	adc.w	r7, r7, r0
34013d0c:	9803      	ldr	r0, [sp, #12]
34013d0e:	ea4f 7ce0 	mov.w	ip, r0, asr #31
34013d12:	fba0 0104 	umull	r0, r1, r0, r4
34013d16:	fb04 110c 	mla	r1, r4, ip, r1
34013d1a:	1818      	adds	r0, r3, r0
    ccG = (int64_t) inR * colorConv.coeff[1][0] + (int64_t) inG * colorConv.coeff[1][1] + (int64_t) inB * colorConv.coeff[1][2];
34013d1c:	9b04      	ldr	r3, [sp, #16]
    ccR = (int64_t) inR * colorConv.coeff[0][0] + (int64_t) inG * colorConv.coeff[0][1] + (int64_t) inB * colorConv.coeff[0][2];
34013d1e:	eb41 0107 	adc.w	r1, r1, r7
    ccG = (int64_t) inR * colorConv.coeff[1][0] + (int64_t) inG * colorConv.coeff[1][1] + (int64_t) inB * colorConv.coeff[1][2];
34013d22:	17df      	asrs	r7, r3, #31
34013d24:	fba3 8306 	umull	r8, r3, r3, r6
34013d28:	fb06 3307 	mla	r3, r6, r7, r3
34013d2c:	9f05      	ldr	r7, [sp, #20]
34013d2e:	fba7 ce05 	umull	ip, lr, r7, r5
34013d32:	ea4f 79e7 	mov.w	r9, r7, asr #31
34013d36:	fb05 ee09 	mla	lr, r5, r9, lr
34013d3a:	eb18 070c 	adds.w	r7, r8, ip
34013d3e:	f8dd c018 	ldr.w	ip, [sp, #24]
34013d42:	eb43 030e 	adc.w	r3, r3, lr
34013d46:	ea4f 7eec 	mov.w	lr, ip, asr #31
34013d4a:	fbac c804 	umull	ip, r8, ip, r4
34013d4e:	fb04 880e 	mla	r8, r4, lr, r8
34013d52:	eb17 070c 	adds.w	r7, r7, ip
34013d56:	eb48 0803 	adc.w	r8, r8, r3
    ccB = (int64_t) inR * colorConv.coeff[2][0] + (int64_t) inG * colorConv.coeff[2][1] + (int64_t) inB * colorConv.coeff[2][2];
34013d5a:	9b07      	ldr	r3, [sp, #28]
34013d5c:	ea4f 7ce3 	mov.w	ip, r3, asr #31
34013d60:	fba3 e306 	umull	lr, r3, r3, r6
34013d64:	fb06 3c0c 	mla	ip, r6, ip, r3
34013d68:	9b08      	ldr	r3, [sp, #32]
34013d6a:	ea4f 79e3 	mov.w	r9, r3, asr #31
34013d6e:	fba3 3605 	umull	r3, r6, r3, r5
34013d72:	fb05 6509 	mla	r5, r5, r9, r6
34013d76:	eb1e 0303 	adds.w	r3, lr, r3
34013d7a:	eb4c 0c05 	adc.w	ip, ip, r5
34013d7e:	9d09      	ldr	r5, [sp, #36]	@ 0x24
34013d80:	ea4f 7ee5 	mov.w	lr, r5, asr #31
34013d84:	fba5 5604 	umull	r5, r6, r5, r4
34013d88:	fb04 660e 	mla	r6, r4, lr, r6
34013d8c:	195c      	adds	r4, r3, r5
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013d8e:	f04f 33ff 	mov.w	r3, #4294967295
34013d92:	4d29      	ldr	r5, [pc, #164]	@ (34013e38 <ISP_Algo_ApplyCConv+0x170>)
    ccB = (int64_t) inR * colorConv.coeff[2][0] + (int64_t) inG * colorConv.coeff[2][1] + (int64_t) inB * colorConv.coeff[2][2];
34013d94:	eb46 060c 	adc.w	r6, r6, ip
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013d98:	42a8      	cmp	r0, r5
34013d9a:	eb71 0303 	sbcs.w	r3, r1, r3
34013d9e:	db3f      	blt.n	34013e20 <ISP_Algo_ApplyCConv+0x158>
    ccR /= ISP_CCM_PRECISION_FACTOR;
34013da0:	a323      	add	r3, pc, #140	@ (adr r3, 34013e30 <ISP_Algo_ApplyCConv+0x168>)
34013da2:	e9d3 2300 	ldrd	r2, r3, [r3]
34013da6:	f7ed fcd1 	bl	3400174c <__aeabi_ldivmod>
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013daa:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
34013dae:	f171 0100 	sbcs.w	r1, r1, #0
34013db2:	4681      	mov	r9, r0
34013db4:	db01      	blt.n	34013dba <ISP_Algo_ApplyCConv+0xf2>
34013db6:	f04f 09ff 	mov.w	r9, #255	@ 0xff
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
34013dba:	f04f 33ff 	mov.w	r3, #4294967295
34013dbe:	42af      	cmp	r7, r5
34013dc0:	eb78 0303 	sbcs.w	r3, r8, r3
34013dc4:	db2e      	blt.n	34013e24 <ISP_Algo_ApplyCConv+0x15c>
    ccG /= ISP_CCM_PRECISION_FACTOR;
34013dc6:	a31a      	add	r3, pc, #104	@ (adr r3, 34013e30 <ISP_Algo_ApplyCConv+0x168>)
34013dc8:	e9d3 2300 	ldrd	r2, r3, [r3]
34013dcc:	4638      	mov	r0, r7
34013dce:	4641      	mov	r1, r8
34013dd0:	f7ed fcbc 	bl	3400174c <__aeabi_ldivmod>
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
34013dd4:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
34013dd8:	f171 0100 	sbcs.w	r1, r1, #0
34013ddc:	4607      	mov	r7, r0
34013dde:	db00      	blt.n	34013de2 <ISP_Algo_ApplyCConv+0x11a>
34013de0:	27ff      	movs	r7, #255	@ 0xff
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
34013de2:	f04f 33ff 	mov.w	r3, #4294967295
34013de6:	42ac      	cmp	r4, r5
34013de8:	eb76 0303 	sbcs.w	r3, r6, r3
34013dec:	db1c      	blt.n	34013e28 <ISP_Algo_ApplyCConv+0x160>
    ccB /= ISP_CCM_PRECISION_FACTOR;
34013dee:	a310      	add	r3, pc, #64	@ (adr r3, 34013e30 <ISP_Algo_ApplyCConv+0x168>)
34013df0:	e9d3 2300 	ldrd	r2, r3, [r3]
34013df4:	4620      	mov	r0, r4
34013df6:	4631      	mov	r1, r6
34013df8:	f7ed fca8 	bl	3400174c <__aeabi_ldivmod>
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
34013dfc:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
34013e00:	f171 0100 	sbcs.w	r1, r1, #0
34013e04:	4604      	mov	r4, r0
34013e06:	db00      	blt.n	34013e0a <ISP_Algo_ApplyCConv+0x142>
34013e08:	24ff      	movs	r4, #255	@ 0xff
    *outR = (uint32_t) ccR;
34013e0a:	464e      	mov	r6, r9
    *outG = (uint32_t) ccG;
34013e0c:	463d      	mov	r5, r7
    *outR = (uint32_t) ccR;
34013e0e:	9b12      	ldr	r3, [sp, #72]	@ 0x48
34013e10:	601e      	str	r6, [r3, #0]
    *outG = (uint32_t) ccG;
34013e12:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
34013e14:	601d      	str	r5, [r3, #0]
    *outB = (uint32_t) ccB;
34013e16:	9b14      	ldr	r3, [sp, #80]	@ 0x50
34013e18:	601c      	str	r4, [r3, #0]
}
34013e1a:	b00b      	add	sp, #44	@ 0x2c
34013e1c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013e20:	4691      	mov	r9, r2
34013e22:	e7ca      	b.n	34013dba <ISP_Algo_ApplyCConv+0xf2>
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
34013e24:	2700      	movs	r7, #0
34013e26:	e7dc      	b.n	34013de2 <ISP_Algo_ApplyCConv+0x11a>
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
34013e28:	2400      	movs	r4, #0
34013e2a:	e7ee      	b.n	34013e0a <ISP_Algo_ApplyCConv+0x142>
34013e2c:	f3af 8000 	nop.w
34013e30:	05f5e100 	.word	0x05f5e100
34013e34:	00000000 	.word	0x00000000
34013e38:	fa0a1f01 	.word	0xfa0a1f01
34013e3c:	00000000 	.word	0x00000000

34013e40 <ISP_Algo_AWB_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_Process(void *hIsp, void *pAlgo)
{
34013e40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34013e44:	ed2d 8b02 	vpush	{d8}
  ISP_ISPGainTypeDef ISPGainConfig;
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
  ISP_StatusTypeDef ret_stat, ret = ISP_OK;
  evision_return_t e_ret;
  uint32_t ccAvgR, ccAvgG, ccAvgB, colorTemp, i, j, profId, profNb;
  float cfaGains[4], ccmCoeffs[3][3], ccmOffsets[3] = { 0 };
34013e48:	2300      	movs	r3, #0
{
34013e4a:	b0a1      	sub	sp, #132	@ 0x84
  float cfaGains[4], ccmCoeffs[3][3], ccmOffsets[3] = { 0 };
34013e4c:	e9cd 3309 	strd	r3, r3, [sp, #36]	@ 0x24
34013e50:	930b      	str	r3, [sp, #44]	@ 0x2c
{
34013e52:	4606      	mov	r6, r0
34013e54:	4688      	mov	r8, r1
  static uint32_t statsHistory[3][3] = { 0 };
  static uint32_t colorTempHistory[2] = { 0 };
  static uint8_t skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_INIT;
  uint8_t stat_has_changed = false;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013e56:	f001 f8ed 	bl	34015034 <ISP_SVC_IQParam_Get>

  if (IQParamConfig->AWBAlgo.enable == false)
34013e5a:	f890 2074 	ldrb.w	r2, [r0, #116]	@ 0x74
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013e5e:	4605      	mov	r5, r0
  if (IQParamConfig->AWBAlgo.enable == false)
34013e60:	4b75      	ldr	r3, [pc, #468]	@ (34014038 <ISP_Algo_AWB_Process+0x1f8>)
34013e62:	b932      	cbnz	r2, 34013e72 <ISP_Algo_AWB_Process+0x32>
  {
    enableCurrent = false;
34013e64:	701a      	strb	r2, [r3, #0]
    return ISP_OK;
34013e66:	2000      	movs	r0, #0
    algo->state = ISP_ALGO_STATE_INIT;
    break;
  }

  return ret;
}
34013e68:	b021      	add	sp, #132	@ 0x84
34013e6a:	ecbd 8b02 	vpop	{d8}
34013e6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else if ((enableCurrent == false) || (IQParamConfig->AWBAlgo.enable == ISP_AWB_ENABLE_RECONFIGURE))
34013e72:	7819      	ldrb	r1, [r3, #0]
34013e74:	b111      	cbz	r1, 34013e7c <ISP_Algo_AWB_Process+0x3c>
34013e76:	2aff      	cmp	r2, #255	@ 0xff
34013e78:	f040 80b9 	bne.w	34013fee <ISP_Algo_AWB_Process+0x1ae>
    algo->state = ISP_ALGO_STATE_INIT;
34013e7c:	2200      	movs	r2, #0
34013e7e:	f888 2001 	strb.w	r2, [r8, #1]
    IQParamConfig->AWBAlgo.enable = true;
34013e82:	2201      	movs	r2, #1
    reconfigureRequest = true;
34013e84:	496d      	ldr	r1, [pc, #436]	@ (3401403c <ISP_Algo_AWB_Process+0x1fc>)
    enableCurrent = true;
34013e86:	701a      	strb	r2, [r3, #0]
    IQParamConfig->AWBAlgo.enable = true;
34013e88:	f885 2074 	strb.w	r2, [r5, #116]	@ 0x74
    reconfigureRequest = true;
34013e8c:	700a      	strb	r2, [r1, #0]
    skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION;
34013e8e:	2206      	movs	r2, #6
34013e90:	4b6b      	ldr	r3, [pc, #428]	@ (34014040 <ISP_Algo_AWB_Process+0x200>)
34013e92:	701a      	strb	r2, [r3, #0]
      colorTempHistory[i] = 0;
34013e94:	2400      	movs	r4, #0
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
34013e96:	ed9f 8a6b 	vldr	s16, [pc, #428]	@ 34014044 <ISP_Algo_AWB_Process+0x204>
      colorTempHistory[i] = 0;
34013e9a:	4b6b      	ldr	r3, [pc, #428]	@ (34014048 <ISP_Algo_AWB_Process+0x208>)
34013e9c:	f8df 91b4 	ldr.w	r9, [pc, #436]	@ 34014054 <ISP_Algo_AWB_Process+0x214>
34013ea0:	e9c3 4400 	strd	r4, r4, [r3]
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
34013ea4:	f8df a1a8 	ldr.w	sl, [pc, #424]	@ 34014050 <ISP_Algo_AWB_Process+0x210>
34013ea8:	f505 778a 	add.w	r7, r5, #276	@ 0x114
      colorTemp = IQParamConfig->AWBAlgo.referenceColorTemp[profId];
34013eac:	6878      	ldr	r0, [r7, #4]
      if (colorTemp == 0)
34013eae:	2800      	cmp	r0, #0
34013eb0:	f000 80ae 	beq.w	34014010 <ISP_Algo_AWB_Process+0x1d0>
      if (profNb > 0)
34013eb4:	b154      	cbz	r4, 34013ecc <ISP_Algo_AWB_Process+0x8c>
        colorTempThresholds[profNb - 1] = (float) ((colorTemp + 3 * IQParamConfig->AWBAlgo.referenceColorTemp[profId - 1]) /4 );
34013eb6:	683b      	ldr	r3, [r7, #0]
34013eb8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
34013ebc:	4403      	add	r3, r0
34013ebe:	089b      	lsrs	r3, r3, #2
34013ec0:	ee07 3a90 	vmov	s15, r3
34013ec4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013ec8:	ed49 7a01 	vstr	s15, [r9, #-4]
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
34013ecc:	edd7 7a06 	vldr	s15, [r7, #24]
34013ed0:	eef8 7a67 	vcvt.f32.u32	s15, s15
34013ed4:	ee87 7a88 	vdiv.f32	s14, s15, s16
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
34013ed8:	edd7 7a0b 	vldr	s15, [r7, #44]	@ 0x2c
34013edc:	eef8 7a67 	vcvt.f32.u32	s15, s15
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
34013ee0:	ed8d 7a10 	vstr	s14, [sp, #64]	@ 0x40
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
34013ee4:	ee87 7a88 	vdiv.f32	s14, s15, s16
      cfaGains[3] = (float) IQParamConfig->AWBAlgo.ispGainB[profId] / ISP_GAIN_PRECISION_FACTOR;
34013ee8:	edd7 7a10 	vldr	s15, [r7, #64]	@ 0x40
34013eec:	eef8 7a67 	vcvt.f32.u32	s15, s15
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
34013ef0:	ed8d 7a11 	vstr	s14, [sp, #68]	@ 0x44
      cfaGains[2] = cfaGains[1];
34013ef4:	ed8d 7a12 	vstr	s14, [sp, #72]	@ 0x48
      cfaGains[3] = (float) IQParamConfig->AWBAlgo.ispGainB[profId] / ISP_GAIN_PRECISION_FACTOR;
34013ef8:	ee87 7a88 	vdiv.f32	s14, s15, s16
34013efc:	2324      	movs	r3, #36	@ 0x24
34013efe:	a916      	add	r1, sp, #88	@ 0x58
34013f00:	ed8d 7a13 	vstr	s14, [sp, #76]	@ 0x4c
      for (i = 0; i < 3; i++)
34013f04:	f04f 0c00 	mov.w	ip, #0
34013f08:	460a      	mov	r2, r1
34013f0a:	fb03 5304 	mla	r3, r3, r4, r5
          ccmCoeffs[i][j] = (float) IQParamConfig->AWBAlgo.coeff[profId][i][j] / ISP_CCM_PRECISION_FACTOR;
34013f0e:	edd3 7a5a 	vldr	s15, [r3, #360]	@ 0x168
34013f12:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013f16:	ee87 7a88 	vdiv.f32	s14, s15, s16
34013f1a:	edd3 7a5b 	vldr	s15, [r3, #364]	@ 0x16c
34013f1e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013f22:	ed81 7a00 	vstr	s14, [r1]
34013f26:	ee87 7a88 	vdiv.f32	s14, s15, s16
34013f2a:	edd3 7a5c 	vldr	s15, [r3, #368]	@ 0x170
34013f2e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013f32:	ed81 7a01 	vstr	s14, [r1, #4]
34013f36:	ee87 7a88 	vdiv.f32	s14, s15, s16
      for (i = 0; i < 3; i++)
34013f3a:	f10c 0c01 	add.w	ip, ip, #1
34013f3e:	f1bc 0f03 	cmp.w	ip, #3
          ccmCoeffs[i][j] = (float) IQParamConfig->AWBAlgo.coeff[profId][i][j] / ISP_CCM_PRECISION_FACTOR;
34013f42:	ed81 7a02 	vstr	s14, [r1, #8]
      for (i = 0; i < 3; i++)
34013f46:	f103 030c 	add.w	r3, r3, #12
34013f4a:	f101 010c 	add.w	r1, r1, #12
34013f4e:	d1de      	bne.n	34013f0e <ISP_Algo_AWB_Process+0xce>
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
34013f50:	ee07 0a90 	vmov	s15, r0
34013f54:	2044      	movs	r0, #68	@ 0x44
34013f56:	eeb8 0a67 	vcvt.f32.u32	s0, s15
34013f5a:	fb00 a004 	mla	r0, r0, r4, sl
34013f5e:	ab09      	add	r3, sp, #36	@ 0x24
34013f60:	a910      	add	r1, sp, #64	@ 0x40
      profNb++;
34013f62:	3401      	adds	r4, #1
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
34013f64:	f7ec fea8 	bl	34000cb8 <evision_api_awb_set_profile>
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34013f68:	2c05      	cmp	r4, #5
34013f6a:	f107 0704 	add.w	r7, r7, #4
34013f6e:	f109 0904 	add.w	r9, r9, #4
34013f72:	d19b      	bne.n	34013eac <ISP_Algo_AWB_Process+0x6c>
                                          (double) IQParamConfig->AWBAlgo.referenceColorTemp[profNb - 1], (uint16_t)profNb,
34013f74:	eb05 0384 	add.w	r3, r5, r4, lsl #2
    e_ret = evision_api_awb_init_profiles(pIspAWBestimator, (double) IQParamConfig->AWBAlgo.referenceColorTemp[0],
34013f78:	ed93 1a45 	vldr	s2, [r3, #276]	@ 0x114
34013f7c:	ed95 0a46 	vldr	s0, [r5, #280]	@ 0x118
34013f80:	4d32      	ldr	r5, [pc, #200]	@ (3401404c <ISP_Algo_AWB_Process+0x20c>)
34013f82:	eeb8 1b41 	vcvt.f64.u32	d1, s2
34013f86:	eeb8 0b40 	vcvt.f64.u32	d0, s0
34013f8a:	4b31      	ldr	r3, [pc, #196]	@ (34014050 <ISP_Algo_AWB_Process+0x210>)
34013f8c:	4a31      	ldr	r2, [pc, #196]	@ (34014054 <ISP_Algo_AWB_Process+0x214>)
34013f8e:	6828      	ldr	r0, [r5, #0]
34013f90:	b2a1      	uxth	r1, r4
34013f92:	f7ec feb1 	bl	34000cf8 <evision_api_awb_init_profiles>
    if (e_ret != EVISION_RET_SUCCESS)
34013f96:	2801      	cmp	r0, #1
34013f98:	f040 8157 	bne.w	3401424a <ISP_Algo_AWB_Process+0x40a>
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
34013f9c:	f20f 0b88 	addw	fp, pc, #136	@ 0x88
34013fa0:	e9db ab00 	ldrd	sl, fp, [fp]
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
34013fa4:	eeb0 7b00 	vmov.f64	d7, #0	@ 0x40000000  2.0
34013fa8:	ed9f 6b21 	vldr	d6, [pc, #132]	@ 34014030 <ISP_Algo_AWB_Process+0x1f0>
    pIspAWBestimator->hyper_params.gm_tolerance = 1;
34013fac:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
34013fb0:	2c03      	cmp	r4, #3
34013fb2:	bf98      	it	ls
34013fb4:	eeb0 7b46 	vmovls.f64	d7, d6
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
34013fb8:	682b      	ldr	r3, [r5, #0]
    pIspAWBestimator->hyper_params.gm_tolerance = 1;
34013fba:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
    pIspAWBestimator->hyper_params.conv_criterion = 3;
34013fbe:	4a26      	ldr	r2, [pc, #152]	@ (34014058 <ISP_Algo_AWB_Process+0x218>)
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
34013fc0:	ed83 7ba8 	vstr	d7, [r3, #672]	@ 0x2a0
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
34013fc4:	e9c3 aba6 	strd	sl, fp, [r3, #664]	@ 0x298
    pIspAWBestimator->hyper_params.conv_criterion = 3;
34013fc8:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34013fcc:	2305      	movs	r3, #5
34013fce:	e9cd 0301 	strd	r0, r3, [sp, #4]
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34013fd2:	2402      	movs	r4, #2
34013fd4:	4642      	mov	r2, r8
34013fd6:	4630      	mov	r0, r6
34013fd8:	4b20      	ldr	r3, [pc, #128]	@ (3401405c <ISP_Algo_AWB_Process+0x21c>)
34013fda:	4921      	ldr	r1, [pc, #132]	@ (34014060 <ISP_Algo_AWB_Process+0x220>)
34013fdc:	9400      	str	r4, [sp, #0]
34013fde:	f001 fa6f 	bl	340154c0 <ISP_SVC_Stats_GetNext>
    if (ret != ISP_OK)
34013fe2:	2800      	cmp	r0, #0
34013fe4:	f47f af40 	bne.w	34013e68 <ISP_Algo_AWB_Process+0x28>
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34013fe8:	f888 4001 	strb.w	r4, [r8, #1]
    break;
34013fec:	e73c      	b.n	34013e68 <ISP_Algo_AWB_Process+0x28>
  switch(algo->state)
34013fee:	f898 3001 	ldrb.w	r3, [r8, #1]
34013ff2:	2b03      	cmp	r3, #3
34013ff4:	f200 8122 	bhi.w	3401423c <ISP_Algo_AWB_Process+0x3fc>
34013ff8:	a201      	add	r2, pc, #4	@ (adr r2, 34014000 <ISP_Algo_AWB_Process+0x1c0>)
34013ffa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34013ffe:	bf00      	nop
34014000:	34013e95 	.word	0x34013e95
34014004:	3401401b 	.word	0x3401401b
34014008:	34013e67 	.word	0x34013e67
3401400c:	34014065 	.word	0x34014065
      return ISP_ERR_WB_COLORTEMP;
34014010:	2096      	movs	r0, #150	@ 0x96
    if (profNb == 0)
34014012:	2c00      	cmp	r4, #0
34014014:	f43f af28 	beq.w	34013e68 <ISP_Algo_AWB_Process+0x28>
34014018:	e7ac      	b.n	34013f74 <ISP_Algo_AWB_Process+0x134>
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3401401a:	2301      	movs	r3, #1
3401401c:	2105      	movs	r1, #5
3401401e:	e9cd 3101 	strd	r3, r1, [sp, #4]
34014022:	e7d6      	b.n	34013fd2 <ISP_Algo_AWB_Process+0x192>
34014024:	f3af 8000 	nop.w
34014028:	9999999a 	.word	0x9999999a
3401402c:	3ff59999 	.word	0x3ff59999
34014030:	cccccccd 	.word	0xcccccccd
34014034:	3ffccccc 	.word	0x3ffccccc
34014038:	340ce3b1 	.word	0x340ce3b1
3401403c:	340ce3b0 	.word	0x340ce3b0
34014040:	340b0f74 	.word	0x340b0f74
34014044:	4cbebc20 	.word	0x4cbebc20
34014048:	340ce3a8 	.word	0x340ce3a8
3401404c:	340ce450 	.word	0x340ce450
34014050:	340ce244 	.word	0x340ce244
34014054:	340ce398 	.word	0x340ce398
34014058:	40400000 	.word	0x40400000
3401405c:	340ce1cc 	.word	0x340ce1cc
34014060:	340138db 	.word	0x340138db
  uint8_t stat_has_changed = false;
34014064:	2400      	movs	r4, #0
    ISP_Algo_GetUpStat(hIsp, &stats);
34014066:	f8df 9284 	ldr.w	r9, [pc, #644]	@ 340142ec <ISP_Algo_AWB_Process+0x4ac>
3401406a:	4630      	mov	r0, r6
3401406c:	4649      	mov	r1, r9
3401406e:	f7ff fdd9 	bl	34013c24 <ISP_Algo_GetUpStat>
    for (i = 0; i < 3; i++)
34014072:	f8df c288 	ldr.w	ip, [pc, #648]	@ 340142fc <ISP_Algo_AWB_Process+0x4bc>
34014076:	46a6      	mov	lr, r4
34014078:	4667      	mov	r7, ip
      if ((abs(stats.up.averageR - (int32_t)statsHistory[i][0]) > 2)
3401407a:	f899 0000 	ldrb.w	r0, [r9]
          || (abs(stats.up.averageG - (int32_t)statsHistory[i][1]) > 2)
3401407e:	f899 1001 	ldrb.w	r1, [r9, #1]
          || (abs(stats.up.averageB - (int32_t)statsHistory[i][2]) > 2))
34014082:	f899 2002 	ldrb.w	r2, [r9, #2]
      if ((abs(stats.up.averageR - (int32_t)statsHistory[i][0]) > 2)
34014086:	f8dc 3000 	ldr.w	r3, [ip]
3401408a:	1ac3      	subs	r3, r0, r3
3401408c:	2b00      	cmp	r3, #0
3401408e:	bfb8      	it	lt
34014090:	425b      	neglt	r3, r3
34014092:	2b02      	cmp	r3, #2
34014094:	f300 80ac 	bgt.w	340141f0 <ISP_Algo_AWB_Process+0x3b0>
          || (abs(stats.up.averageG - (int32_t)statsHistory[i][1]) > 2)
34014098:	f8dc 3004 	ldr.w	r3, [ip, #4]
3401409c:	1acb      	subs	r3, r1, r3
3401409e:	2b00      	cmp	r3, #0
340140a0:	bfb8      	it	lt
340140a2:	425b      	neglt	r3, r3
340140a4:	2b02      	cmp	r3, #2
340140a6:	f300 80a3 	bgt.w	340141f0 <ISP_Algo_AWB_Process+0x3b0>
          || (abs(stats.up.averageB - (int32_t)statsHistory[i][2]) > 2))
340140aa:	f8dc 3008 	ldr.w	r3, [ip, #8]
340140ae:	1ad3      	subs	r3, r2, r3
340140b0:	2b00      	cmp	r3, #0
340140b2:	bfb8      	it	lt
340140b4:	425b      	neglt	r3, r3
        stat_has_changed = true;
340140b6:	2b03      	cmp	r3, #3
340140b8:	bfa8      	it	ge
340140ba:	2401      	movge	r4, #1
    for (i = 0; i < 3; i++)
340140bc:	f10e 0e01 	add.w	lr, lr, #1
340140c0:	f1be 0f03 	cmp.w	lr, #3
340140c4:	f10c 0c0c 	add.w	ip, ip, #12
340140c8:	d1dd      	bne.n	34014086 <ISP_Algo_AWB_Process+0x246>
    if (skip_stat_check_count || stat_has_changed || reconfigureRequest)
340140ca:	4b84      	ldr	r3, [pc, #528]	@ (340142dc <ISP_Algo_AWB_Process+0x49c>)
340140cc:	f8df a230 	ldr.w	sl, [pc, #560]	@ 34014300 <ISP_Algo_AWB_Process+0x4c0>
340140d0:	f893 c000 	ldrb.w	ip, [r3]
340140d4:	f89a e000 	ldrb.w	lr, [sl]
340140d8:	f8df b228 	ldr.w	fp, [pc, #552]	@ 34014304 <ISP_Algo_AWB_Process+0x4c4>
340140dc:	ea4e 030c 	orr.w	r3, lr, ip
340140e0:	431c      	orrs	r4, r3
340140e2:	b2e4      	uxtb	r4, r4
340140e4:	2c00      	cmp	r4, #0
340140e6:	d050      	beq.n	3401418a <ISP_Algo_AWB_Process+0x34a>
        ISP_Algo_ApplyCConv(hIsp, stats.down.averageR, stats.down.averageG, stats.down.averageB, &ccAvgR, &ccAvgG, &ccAvgB);
340140e8:	ab08      	add	r3, sp, #32
        statsHistory[2][1] = stats.up.averageG;
340140ea:	e9c7 0106 	strd	r0, r1, [r7, #24]
        statsHistory[2][2] = stats.up.averageB;
340140ee:	623a      	str	r2, [r7, #32]
        ISP_Algo_ApplyCConv(hIsp, stats.down.averageR, stats.down.averageG, stats.down.averageB, &ccAvgR, &ccAvgG, &ccAvgB);
340140f0:	9302      	str	r3, [sp, #8]
340140f2:	ab07      	add	r3, sp, #28
340140f4:	9301      	str	r3, [sp, #4]
340140f6:	ab06      	add	r3, sp, #24
340140f8:	9300      	str	r3, [sp, #0]
340140fa:	f899 3036 	ldrb.w	r3, [r9, #54]	@ 0x36
340140fe:	f899 2035 	ldrb.w	r2, [r9, #53]	@ 0x35
34014102:	4630      	mov	r0, r6
34014104:	f899 1034 	ldrb.w	r1, [r9, #52]	@ 0x34
34014108:	f7ff fdde 	bl	34013cc8 <ISP_Algo_ApplyCConv>
        meas[0] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgR);
3401410c:	4630      	mov	r0, r6
3401410e:	9906      	ldr	r1, [sp, #24]
34014110:	f7ff fd5e 	bl	34013bd0 <ISP_Algo_ApplyGammaInverse>
        meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
34014114:	4630      	mov	r0, r6
34014116:	9907      	ldr	r1, [sp, #28]
        meas[0] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgR);
34014118:	ed8d 0b10 	vstr	d0, [sp, #64]	@ 0x40
        meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
3401411c:	f7ff fd58 	bl	34013bd0 <ISP_Algo_ApplyGammaInverse>
        meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
34014120:	4630      	mov	r0, r6
34014122:	9908      	ldr	r1, [sp, #32]
        meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
34014124:	ed8d 0b12 	vstr	d0, [sp, #72]	@ 0x48
        meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
34014128:	f7ff fd52 	bl	34013bd0 <ISP_Algo_ApplyGammaInverse>
        e_ret = evision_api_awb_run_average(pIspAWBestimator, NULL, 1, meas);
3401412c:	486c      	ldr	r0, [pc, #432]	@ (340142e0 <ISP_Algo_AWB_Process+0x4a0>)
3401412e:	2201      	movs	r2, #1
34014130:	2100      	movs	r1, #0
34014132:	6800      	ldr	r0, [r0, #0]
34014134:	ab10      	add	r3, sp, #64	@ 0x40
        meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
34014136:	ed8d 0b14 	vstr	d0, [sp, #80]	@ 0x50
        e_ret = evision_api_awb_run_average(pIspAWBestimator, NULL, 1, meas);
3401413a:	f7ec ffa7 	bl	3400108c <evision_api_awb_run_average>
        if (e_ret == EVISION_RET_SUCCESS)
3401413e:	2801      	cmp	r0, #1
34014140:	d17a      	bne.n	34014238 <ISP_Algo_AWB_Process+0x3f8>
          if (pIspAWBestimator->out_temp != currentColorTemp || reconfigureRequest == true)
34014142:	4b67      	ldr	r3, [pc, #412]	@ (340142e0 <ISP_Algo_AWB_Process+0x4a0>)
34014144:	681b      	ldr	r3, [r3, #0]
34014146:	ed93 7b12 	vldr	d7, [r3, #72]	@ 0x48
3401414a:	4b66      	ldr	r3, [pc, #408]	@ (340142e4 <ISP_Algo_AWB_Process+0x4a4>)
3401414c:	681b      	ldr	r3, [r3, #0]
3401414e:	ee06 3a90 	vmov	s13, r3
34014152:	eeb8 6b66 	vcvt.f64.u32	d6, s13
34014156:	eeb4 7b46 	vcmp.f64	d7, d6
3401415a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401415e:	9305      	str	r3, [sp, #20]
34014160:	d103      	bne.n	3401416a <ISP_Algo_AWB_Process+0x32a>
34014162:	4b5e      	ldr	r3, [pc, #376]	@ (340142dc <ISP_Algo_AWB_Process+0x49c>)
34014164:	781b      	ldrb	r3, [r3, #0]
34014166:	2b01      	cmp	r3, #1
34014168:	d10f      	bne.n	3401418a <ISP_Algo_AWB_Process+0x34a>
            if ((pIspAWBestimator->out_temp == colorTempHistory[1]) && (reconfigureRequest != true))
3401416a:	eddb 6a01 	vldr	s13, [fp, #4]
3401416e:	eeb8 6b66 	vcvt.f64.u32	d6, s13
34014172:	eeb4 7b46 	vcmp.f64	d7, d6
34014176:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401417a:	d13b      	bne.n	340141f4 <ISP_Algo_AWB_Process+0x3b4>
3401417c:	4b57      	ldr	r3, [pc, #348]	@ (340142dc <ISP_Algo_AWB_Process+0x49c>)
3401417e:	781b      	ldrb	r3, [r3, #0]
34014180:	2b01      	cmp	r3, #1
34014182:	d037      	beq.n	340141f4 <ISP_Algo_AWB_Process+0x3b4>
              skip_stat_check_count = 0; //oscillation detected
34014184:	2300      	movs	r3, #0
34014186:	f88a 3000 	strb.w	r3, [sl]
  ISP_StatusTypeDef ret_stat, ret = ISP_OK;
3401418a:	2400      	movs	r4, #0
    reconfigureRequest = false;
3401418c:	2300      	movs	r3, #0
3401418e:	4a53      	ldr	r2, [pc, #332]	@ (340142dc <ISP_Algo_AWB_Process+0x49c>)
34014190:	7013      	strb	r3, [r2, #0]
    if (skip_stat_check_count > 0) skip_stat_check_count--;
34014192:	f89a 3000 	ldrb.w	r3, [sl]
34014196:	b113      	cbz	r3, 3401419e <ISP_Algo_AWB_Process+0x35e>
34014198:	3b01      	subs	r3, #1
3401419a:	f88a 3000 	strb.w	r3, [sl]
    statsHistory[1][0] = statsHistory[0][0];
3401419e:	683b      	ldr	r3, [r7, #0]
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
340141a0:	2205      	movs	r2, #5
    statsHistory[1][0] = statsHistory[0][0];
340141a2:	60fb      	str	r3, [r7, #12]
    statsHistory[1][1] = statsHistory[0][1];
340141a4:	687b      	ldr	r3, [r7, #4]
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
340141a6:	2502      	movs	r5, #2
    statsHistory[1][1] = statsHistory[0][1];
340141a8:	613b      	str	r3, [r7, #16]
    statsHistory[1][2] = statsHistory[0][2];
340141aa:	68bb      	ldr	r3, [r7, #8]
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
340141ac:	4630      	mov	r0, r6
    statsHistory[1][2] = statsHistory[0][2];
340141ae:	617b      	str	r3, [r7, #20]
    statsHistory[0][0] = stats.up.averageR;
340141b0:	f899 3000 	ldrb.w	r3, [r9]
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
340141b4:	494c      	ldr	r1, [pc, #304]	@ (340142e8 <ISP_Algo_AWB_Process+0x4a8>)
    statsHistory[0][0] = stats.up.averageR;
340141b6:	603b      	str	r3, [r7, #0]
    statsHistory[0][1] = stats.up.averageG;
340141b8:	f899 3001 	ldrb.w	r3, [r9, #1]
340141bc:	607b      	str	r3, [r7, #4]
    statsHistory[0][2] = stats.up.averageB;
340141be:	f899 3002 	ldrb.w	r3, [r9, #2]
340141c2:	60bb      	str	r3, [r7, #8]
    colorTempHistory[1] = colorTempHistory[0];
340141c4:	f8db 3000 	ldr.w	r3, [fp]
340141c8:	f8cb 3004 	str.w	r3, [fp, #4]
    colorTempHistory[0] = currentColorTemp;
340141cc:	4b45      	ldr	r3, [pc, #276]	@ (340142e4 <ISP_Algo_AWB_Process+0x4a4>)
340141ce:	681b      	ldr	r3, [r3, #0]
340141d0:	f8cb 3000 	str.w	r3, [fp]
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
340141d4:	2301      	movs	r3, #1
340141d6:	9500      	str	r5, [sp, #0]
340141d8:	e9cd 3201 	strd	r3, r2, [sp, #4]
340141dc:	4642      	mov	r2, r8
340141de:	4b43      	ldr	r3, [pc, #268]	@ (340142ec <ISP_Algo_AWB_Process+0x4ac>)
340141e0:	f001 f96e 	bl	340154c0 <ISP_SVC_Stats_GetNext>
    ret = (ret != ISP_OK) ? ret : ret_stat;
340141e4:	2c00      	cmp	r4, #0
340141e6:	bf18      	it	ne
340141e8:	4620      	movne	r0, r4
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
340141ea:	f888 5001 	strb.w	r5, [r8, #1]
    break;
340141ee:	e63b      	b.n	34013e68 <ISP_Algo_AWB_Process+0x28>
        stat_has_changed = true;
340141f0:	2401      	movs	r4, #1
340141f2:	e763      	b.n	340140bc <ISP_Algo_AWB_Process+0x27c>
              if (skip_stat_check_count <= ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION) skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION;
340141f4:	f89a 3000 	ldrb.w	r3, [sl]
              Meta.colorTemp = (uint32_t) pIspAWBestimator->out_temp;
340141f8:	eefc 6bc7 	vcvt.u32.f64	s13, d7
              if (skip_stat_check_count <= ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION) skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION;
340141fc:	2b06      	cmp	r3, #6
340141fe:	bf98      	it	ls
34014200:	2306      	movls	r3, #6
              Meta.colorTemp = (uint32_t) pIspAWBestimator->out_temp;
34014202:	4a3b      	ldr	r2, [pc, #236]	@ (340142f0 <ISP_Algo_AWB_Process+0x4b0>)
              if (skip_stat_check_count <= ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION) skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION;
34014204:	bf98      	it	ls
34014206:	f88a 3000 	strbls.w	r3, [sl]
              Meta.colorTemp = (uint32_t) pIspAWBestimator->out_temp;
3401420a:	edc2 6a04 	vstr	s13, [r2, #16]
              for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3401420e:	2305      	movs	r3, #5
34014210:	2200      	movs	r2, #0
34014212:	f505 718a 	add.w	r1, r5, #276	@ 0x114
                if (pIspAWBestimator->out_temp == IQParamConfig->AWBAlgo.referenceColorTemp[profId])
34014216:	ed91 6a01 	vldr	s12, [r1, #4]
3401421a:	eeb8 6b46 	vcvt.f64.u32	d6, s12
3401421e:	eeb4 7b46 	vcmp.f64	d7, d6
34014222:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34014226:	f101 0104 	add.w	r1, r1, #4
3401422a:	d010      	beq.n	3401424e <ISP_Algo_AWB_Process+0x40e>
              for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3401422c:	3b01      	subs	r3, #1
3401422e:	f102 0201 	add.w	r2, r2, #1
34014232:	d1f0      	bne.n	34014216 <ISP_Algo_AWB_Process+0x3d6>
                ret  = ISP_ERR_WB_COLORTEMP;
34014234:	2496      	movs	r4, #150	@ 0x96
34014236:	e7a9      	b.n	3401418c <ISP_Algo_AWB_Process+0x34c>
          ret = ISP_ERR_ALGO;
34014238:	24be      	movs	r4, #190	@ 0xbe
3401423a:	e7a7      	b.n	3401418c <ISP_Algo_AWB_Process+0x34c>
    printf("WARNING: Unknown AWB algo state\r\n");
3401423c:	482d      	ldr	r0, [pc, #180]	@ (340142f4 <ISP_Algo_AWB_Process+0x4b4>)
3401423e:	f005 fe05 	bl	34019e4c <puts>
    algo->state = ISP_ALGO_STATE_INIT;
34014242:	2300      	movs	r3, #0
34014244:	f888 3001 	strb.w	r3, [r8, #1]
    break;
34014248:	e60d      	b.n	34013e66 <ISP_Algo_AWB_Process+0x26>
      return ISP_ERR_ALGO;
3401424a:	20be      	movs	r0, #190	@ 0xbe
3401424c:	e60c      	b.n	34013e68 <ISP_Algo_AWB_Process+0x28>
                ColorConvConfig.enable = 1;
3401424e:	2301      	movs	r3, #1
                memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
34014250:	f04f 0e04 	mov.w	lr, #4
                ColorConvConfig.enable = 1;
34014254:	f88d 3058 	strb.w	r3, [sp, #88]	@ 0x58
                memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
34014258:	2324      	movs	r3, #36	@ 0x24
3401425a:	f04e e001 	dls	lr, lr
3401425e:	fb03 5302 	mla	r3, r3, r2, r5
34014262:	ac17      	add	r4, sp, #92	@ 0x5c
34014264:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
34014268:	46a4      	mov	ip, r4
3401426a:	6818      	ldr	r0, [r3, #0]
3401426c:	6859      	ldr	r1, [r3, #4]
3401426e:	3308      	adds	r3, #8
34014270:	e8ac 0003 	stmia.w	ip!, {r0, r1}
34014274:	4664      	mov	r4, ip
34014276:	f00f c809 	le	lr, 34014268 <ISP_Algo_AWB_Process+0x428>
3401427a:	9205      	str	r2, [sp, #20]
3401427c:	6818      	ldr	r0, [r3, #0]
                ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConvConfig);
3401427e:	a916      	add	r1, sp, #88	@ 0x58
                memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
34014280:	f8cc 0000 	str.w	r0, [ip]
                ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConvConfig);
34014284:	4630      	mov	r0, r6
34014286:	f000 fd53 	bl	34014d30 <ISP_SVC_ISP_SetColorConv>
                if (ret == ISP_OK)
3401428a:	9a05      	ldr	r2, [sp, #20]
3401428c:	4604      	mov	r4, r0
3401428e:	2800      	cmp	r0, #0
34014290:	f47f af7c 	bne.w	3401418c <ISP_Algo_AWB_Process+0x34c>
                  ISPGainConfig.enable = 1;
34014294:	2301      	movs	r3, #1
34014296:	eb05 0582 	add.w	r5, r5, r2, lsl #2
3401429a:	f88d 3030 	strb.w	r3, [sp, #48]	@ 0x30
                  ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
3401429e:	f8d5 312c 	ldr.w	r3, [r5, #300]	@ 0x12c
                  ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
340142a2:	4630      	mov	r0, r6
                  ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
340142a4:	930d      	str	r3, [sp, #52]	@ 0x34
                  ISPGainConfig.ispGainG = IQParamConfig->AWBAlgo.ispGainG[profId];
340142a6:	f8d5 3140 	ldr.w	r3, [r5, #320]	@ 0x140
                  ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
340142aa:	a90c      	add	r1, sp, #48	@ 0x30
                  ISPGainConfig.ispGainG = IQParamConfig->AWBAlgo.ispGainG[profId];
340142ac:	930e      	str	r3, [sp, #56]	@ 0x38
                  ISPGainConfig.ispGainB = IQParamConfig->AWBAlgo.ispGainB[profId];
340142ae:	f8d5 3154 	ldr.w	r3, [r5, #340]	@ 0x154
340142b2:	9205      	str	r2, [sp, #20]
340142b4:	930f      	str	r3, [sp, #60]	@ 0x3c
                  ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
340142b6:	f000 fc57 	bl	34014b68 <ISP_SVC_ISP_SetGain>
                  if (ret == ISP_OK)
340142ba:	4604      	mov	r4, r0
340142bc:	2800      	cmp	r0, #0
340142be:	f47f af65 	bne.w	3401418c <ISP_Algo_AWB_Process+0x34c>
                    currentColorTemp = (uint32_t) pIspAWBestimator->out_temp ;
340142c2:	4b07      	ldr	r3, [pc, #28]	@ (340142e0 <ISP_Algo_AWB_Process+0x4a0>)
                    current_awb_profId = profId;
340142c4:	9a05      	ldr	r2, [sp, #20]
                    currentColorTemp = (uint32_t) pIspAWBestimator->out_temp ;
340142c6:	681b      	ldr	r3, [r3, #0]
340142c8:	ed93 7b12 	vldr	d7, [r3, #72]	@ 0x48
340142cc:	eebc 7bc7 	vcvt.u32.f64	s14, d7
340142d0:	4b04      	ldr	r3, [pc, #16]	@ (340142e4 <ISP_Algo_AWB_Process+0x4a4>)
340142d2:	ed83 7a00 	vstr	s14, [r3]
                    current_awb_profId = profId;
340142d6:	4b08      	ldr	r3, [pc, #32]	@ (340142f8 <ISP_Algo_AWB_Process+0x4b8>)
340142d8:	601a      	str	r2, [r3, #0]
340142da:	e757      	b.n	3401418c <ISP_Algo_AWB_Process+0x34c>
340142dc:	340ce3b0 	.word	0x340ce3b0
340142e0:	340ce450 	.word	0x340ce450
340142e4:	340ce1a4 	.word	0x340ce1a4
340142e8:	340138db 	.word	0x340138db
340142ec:	340ce1cc 	.word	0x340ce1cc
340142f0:	340ce438 	.word	0x340ce438
340142f4:	34020e77 	.word	0x34020e77
340142f8:	340ce44c 	.word	0x340ce44c
340142fc:	340ce1a8 	.word	0x340ce1a8
34014300:	340b0f74 	.word	0x340b0f74
34014304:	340ce3a8 	.word	0x340ce3a8

34014308 <ISP_Algo_Init>:
  *         Register and initialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Init(ISP_HandleTypeDef *hIsp)
{
34014308:	b538      	push	{r3, r4, r5, lr}
3401430a:	4604      	mov	r4, r0
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  hIsp->algorithm = ISP_Algo_List;
3401430c:	2500      	movs	r5, #0
3401430e:	4b09      	ldr	r3, [pc, #36]	@ (34014334 <ISP_Algo_Init+0x2c>)
34014310:	6183      	str	r3, [r0, #24]

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
34014312:	69a3      	ldr	r3, [r4, #24]
34014314:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->Init != NULL))
34014316:	b921      	cbnz	r1, 34014322 <ISP_Algo_Init+0x1a>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34014318:	3504      	adds	r5, #4
3401431a:	2d0c      	cmp	r5, #12
3401431c:	d1f9      	bne.n	34014312 <ISP_Algo_Init+0xa>
        return ret;
      }
    }
  }

  return ISP_OK;
3401431e:	2000      	movs	r0, #0
}
34014320:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->Init != NULL))
34014322:	684b      	ldr	r3, [r1, #4]
34014324:	2b00      	cmp	r3, #0
34014326:	d0f7      	beq.n	34014318 <ISP_Algo_Init+0x10>
      ret = algo->Init((void*)hIsp, (void*)algo);
34014328:	4620      	mov	r0, r4
3401432a:	4798      	blx	r3
      if (ret != ISP_OK)
3401432c:	2800      	cmp	r0, #0
3401432e:	d0f3      	beq.n	34014318 <ISP_Algo_Init+0x10>
34014330:	e7f6      	b.n	34014320 <ISP_Algo_Init+0x18>
34014332:	bf00      	nop
34014334:	340b0f78 	.word	0x340b0f78

34014338 <ISP_Algo_DeInit>:
  *         Deinitialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_DeInit(ISP_HandleTypeDef *hIsp)
{
34014338:	b538      	push	{r3, r4, r5, lr}
3401433a:	4604      	mov	r4, r0
3401433c:	2500      	movs	r5, #0
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
3401433e:	69a3      	ldr	r3, [r4, #24]
34014340:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->DeInit != NULL))
34014342:	b921      	cbnz	r1, 3401434e <ISP_Algo_DeInit+0x16>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34014344:	3504      	adds	r5, #4
34014346:	2d0c      	cmp	r5, #12
34014348:	d1f9      	bne.n	3401433e <ISP_Algo_DeInit+0x6>
        return ret;
      }
    }
  }

  return ISP_OK;
3401434a:	2000      	movs	r0, #0
}
3401434c:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->DeInit != NULL))
3401434e:	688b      	ldr	r3, [r1, #8]
34014350:	2b00      	cmp	r3, #0
34014352:	d0f7      	beq.n	34014344 <ISP_Algo_DeInit+0xc>
      ret = algo->DeInit((void*)hIsp, (void*)algo);
34014354:	4620      	mov	r0, r4
34014356:	4798      	blx	r3
      if (ret != ISP_OK)
34014358:	2800      	cmp	r0, #0
3401435a:	d0f3      	beq.n	34014344 <ISP_Algo_DeInit+0xc>
3401435c:	e7f6      	b.n	3401434c <ISP_Algo_DeInit+0x14>

3401435e <ISP_Algo_Process>:
  *         Process all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Process(ISP_HandleTypeDef *hIsp)
{
3401435e:	b538      	push	{r3, r4, r5, lr}
34014360:	4604      	mov	r4, r0
34014362:	2500      	movs	r5, #0
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
34014364:	69a3      	ldr	r3, [r4, #24]
34014366:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->Process != NULL))
34014368:	b921      	cbnz	r1, 34014374 <ISP_Algo_Process+0x16>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3401436a:	3504      	adds	r5, #4
3401436c:	2d0c      	cmp	r5, #12
3401436e:	d1f9      	bne.n	34014364 <ISP_Algo_Process+0x6>
      }
#endif
    }
  }

  return ISP_OK;
34014370:	2000      	movs	r0, #0
}
34014372:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->Process != NULL))
34014374:	68cb      	ldr	r3, [r1, #12]
34014376:	2b00      	cmp	r3, #0
34014378:	d0f7      	beq.n	3401436a <ISP_Algo_Process+0xc>
      ret = algo->Process((void*)hIsp, (void*)algo);
3401437a:	4620      	mov	r0, r4
3401437c:	4798      	blx	r3
      if (ret != ISP_OK)
3401437e:	2800      	cmp	r0, #0
34014380:	d0f3      	beq.n	3401436a <ISP_Algo_Process+0xc>
34014382:	e7f6      	b.n	34014372 <ISP_Algo_Process+0x14>

34014384 <ISP_Init>:
ISP_StatusTypeDef ISP_Init(ISP_HandleTypeDef *hIsp,
                           void *hDcmipp,
                           uint32_t CameraInstance,
                           ISP_AppliHelpersTypeDef *pAppliHelpers,
                           const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
34014384:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34014386:	460e      	mov	r6, r1
34014388:	4617      	mov	r7, r2
3401438a:	461c      	mov	r4, r3
  ISP_StatusTypeDef ret;

  if ((hIsp == NULL) || (hDcmipp == NULL) || (pAppliHelpers == NULL))
3401438c:	4605      	mov	r5, r0
3401438e:	2800      	cmp	r0, #0
34014390:	d066      	beq.n	34014460 <ISP_Init+0xdc>
34014392:	2900      	cmp	r1, #0
34014394:	d064      	beq.n	34014460 <ISP_Init+0xdc>
34014396:	2b00      	cmp	r3, #0
34014398:	d062      	beq.n	34014460 <ISP_Init+0xdc>
  {
    return ISP_ERR_EINVAL;
  }

  memset(hIsp, 0, sizeof(*hIsp));
3401439a:	2280      	movs	r2, #128	@ 0x80
3401439c:	2100      	movs	r1, #0
3401439e:	3008      	adds	r0, #8
340143a0:	f005 fec0 	bl	3401a124 <memset>
  hIsp->cameraInstance = CameraInstance;
  hIsp->MainPipe_FrameCount = 0;
  hIsp->AncillaryPipe_FrameCount = 0;
  hIsp->DumpPipe_FrameCount = 0;

  hIsp->appliHelpers = *pAppliHelpers;
340143a4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  hIsp->cameraInstance = CameraInstance;
340143a6:	e9c5 6700 	strd	r6, r7, [r5]
  hIsp->appliHelpers = *pAppliHelpers;
340143aa:	f105 061c 	add.w	r6, r5, #28
340143ae:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340143b0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
340143b2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340143b4:	6823      	ldr	r3, [r4, #0]
340143b6:	6033      	str	r3, [r6, #0]
  /* Appli CB is mandatory for the sensor get/set exp/gain function */
  if (hIsp->appliHelpers.GetSensorInfo == NULL)
340143b8:	6aab      	ldr	r3, [r5, #40]	@ 0x28
340143ba:	b933      	cbnz	r3, 340143ca <ISP_Init+0x46>
  {
     printf("INFO: GetSensorInfo helper function is not implemented\r\n");
340143bc:	4829      	ldr	r0, [pc, #164]	@ (34014464 <ISP_Init+0xe0>)
      printf("INFO: SetSensorGain helper function is not implemented\r\n");
      return ISP_ERR_APP_HELPER_UNDEFINED;
  }
  if (hIsp->appliHelpers.GetSensorGain == NULL)
  {
     printf("INFO: GetSensorGain helper function is not implemented\r\n");
340143be:	f005 fd45 	bl	34019e4c <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
340143c2:	24b4      	movs	r4, #180	@ 0xb4

  /* Initialize the statistic engine */
  ISP_SVC_Stats_Init(hIsp);

  return ISP_OK;
}
340143c4:	4620      	mov	r0, r4
340143c6:	b003      	add	sp, #12
340143c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (hIsp->appliHelpers.SetSensorGain == NULL)
340143ca:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
340143cc:	b90b      	cbnz	r3, 340143d2 <ISP_Init+0x4e>
      printf("INFO: SetSensorGain helper function is not implemented\r\n");
340143ce:	4826      	ldr	r0, [pc, #152]	@ (34014468 <ISP_Init+0xe4>)
340143d0:	e7f5      	b.n	340143be <ISP_Init+0x3a>
  if (hIsp->appliHelpers.GetSensorGain == NULL)
340143d2:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
340143d4:	b90b      	cbnz	r3, 340143da <ISP_Init+0x56>
     printf("INFO: GetSensorGain helper function is not implemented\r\n");
340143d6:	4825      	ldr	r0, [pc, #148]	@ (3401446c <ISP_Init+0xe8>)
340143d8:	e7f1      	b.n	340143be <ISP_Init+0x3a>
  if (hIsp->appliHelpers.SetSensorExposure == NULL)
340143da:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
340143dc:	b90b      	cbnz	r3, 340143e2 <ISP_Init+0x5e>
      printf("INFO: SetSensorExposure helper function is not implemented\r\n");
340143de:	4824      	ldr	r0, [pc, #144]	@ (34014470 <ISP_Init+0xec>)
340143e0:	e7ed      	b.n	340143be <ISP_Init+0x3a>
  if (hIsp->appliHelpers.GetSensorExposure == NULL)
340143e2:	6bab      	ldr	r3, [r5, #56]	@ 0x38
340143e4:	b90b      	cbnz	r3, 340143ea <ISP_Init+0x66>
     printf("INFO: GetSensorExposure helper function is not implemented\r\n");
340143e6:	4823      	ldr	r0, [pc, #140]	@ (34014474 <ISP_Init+0xf0>)
340143e8:	e7e9      	b.n	340143be <ISP_Init+0x3a>
  ret = ISP_SVC_IQParam_Init(hIsp, ISP_IQParamCacheInit);
340143ea:	4628      	mov	r0, r5
340143ec:	9908      	ldr	r1, [sp, #32]
340143ee:	f000 fe17 	bl	34015020 <ISP_SVC_IQParam_Init>
  if (ret != ISP_OK)
340143f2:	4604      	mov	r4, r0
340143f4:	2800      	cmp	r0, #0
340143f6:	d1e5      	bne.n	340143c4 <ISP_Init+0x40>
  ret = ISP_SVC_Sensor_GetInfo(hIsp, &hIsp->sensorInfo);
340143f8:	4628      	mov	r0, r5
340143fa:	f105 014c 	add.w	r1, r5, #76	@ 0x4c
340143fe:	f000 fd67 	bl	34014ed0 <ISP_SVC_Sensor_GetInfo>
  if (ret != ISP_OK)
34014402:	4604      	mov	r4, r0
34014404:	2800      	cmp	r0, #0
34014406:	d1dd      	bne.n	340143c4 <ISP_Init+0x40>
  if ((hIsp->sensorInfo.width / ISP_DECIM_FACTOR_1) < ISP_RAW_MAX_WIDTH)
34014408:	6f2a      	ldr	r2, [r5, #112]	@ 0x70
3401440a:	f5b2 6f28 	cmp.w	r2, #2688	@ 0xa80
3401440e:	d30f      	bcc.n	34014430 <ISP_Init+0xac>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_2) < ISP_RAW_MAX_WIDTH)
34014410:	f5b2 5fa8 	cmp.w	r2, #5376	@ 0x1500
34014414:	d320      	bcc.n	34014458 <ISP_Init+0xd4>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_4) < ISP_RAW_MAX_WIDTH)
34014416:	f5b2 5f28 	cmp.w	r2, #10752	@ 0x2a00
3401441a:	d31f      	bcc.n	3401445c <ISP_Init+0xd8>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_8) < ISP_RAW_MAX_WIDTH)
3401441c:	f5b2 4fa8 	cmp.w	r2, #21504	@ 0x5400
34014420:	f04f 0308 	mov.w	r3, #8
34014424:	d305      	bcc.n	34014432 <ISP_Init+0xae>
    printf("ERROR: No possible decimation factor to target ISP RAW width constraint\r\n");
34014426:	4814      	ldr	r0, [pc, #80]	@ (34014478 <ISP_Init+0xf4>)
34014428:	f005 fd10 	bl	34019e4c <puts>
    return ISP_ERR_DECIMATION_EINVAL;
3401442c:	241e      	movs	r4, #30
3401442e:	e7c9      	b.n	340143c4 <ISP_Init+0x40>
34014430:	2301      	movs	r3, #1
  ret = ISP_SVC_ISP_SetDecimation(hIsp, &decimation);
34014432:	4628      	mov	r0, r5
34014434:	a901      	add	r1, sp, #4
    decimation.factor = ISP_DECIM_FACTOR_1;
34014436:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ISP_SVC_ISP_SetDecimation(hIsp, &decimation);
3401443a:	f000 fa25 	bl	34014888 <ISP_SVC_ISP_SetDecimation>
  if (ret != ISP_OK)
3401443e:	4604      	mov	r4, r0
34014440:	2800      	cmp	r0, #0
34014442:	d1bf      	bne.n	340143c4 <ISP_Init+0x40>
  ret = ISP_Algo_Init(hIsp);
34014444:	4628      	mov	r0, r5
34014446:	f7ff ff5f 	bl	34014308 <ISP_Algo_Init>
  if (ret != ISP_OK)
3401444a:	4604      	mov	r4, r0
3401444c:	2800      	cmp	r0, #0
3401444e:	d1b9      	bne.n	340143c4 <ISP_Init+0x40>
  ISP_SVC_Stats_Init(hIsp);
34014450:	4628      	mov	r0, r5
34014452:	f000 fdf3 	bl	3401503c <ISP_SVC_Stats_Init>
  return ISP_OK;
34014456:	e7b5      	b.n	340143c4 <ISP_Init+0x40>
34014458:	2302      	movs	r3, #2
3401445a:	e7ea      	b.n	34014432 <ISP_Init+0xae>
3401445c:	2304      	movs	r3, #4
3401445e:	e7e8      	b.n	34014432 <ISP_Init+0xae>
    return ISP_ERR_EINVAL;
34014460:	2401      	movs	r4, #1
34014462:	e7af      	b.n	340143c4 <ISP_Init+0x40>
34014464:	34020e98 	.word	0x34020e98
34014468:	34020ed0 	.word	0x34020ed0
3401446c:	34020f08 	.word	0x34020f08
34014470:	34020f40 	.word	0x34020f40
34014474:	34020f7c 	.word	0x34020f7c
34014478:	34020fb8 	.word	0x34020fb8

3401447c <ISP_DeInit>:
  *         Deinitializes the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_DeInit(ISP_HandleTypeDef *hIsp)
{
3401447c:	b538      	push	{r3, r4, r5, lr}
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
3401447e:	4605      	mov	r5, r0
34014480:	b150      	cbz	r0, 34014498 <ISP_DeInit+0x1c>
  {
    return ISP_ERR_EINVAL;
  }

  /* DeInitialize algorithms */
  ret = ISP_Algo_DeInit(hIsp);
34014482:	f7ff ff59 	bl	34014338 <ISP_Algo_DeInit>
  if (ret != ISP_OK)
34014486:	4604      	mov	r4, r0
34014488:	b920      	cbnz	r0, 34014494 <ISP_DeInit+0x18>
  {
    return ret;
  }

  /* Re-initialized the hIsp structure */
  memset(hIsp, 0, sizeof(*hIsp));
3401448a:	4601      	mov	r1, r0
3401448c:	2288      	movs	r2, #136	@ 0x88
3401448e:	4628      	mov	r0, r5
34014490:	f005 fe48 	bl	3401a124 <memset>

  return ISP_OK;
}
34014494:	4620      	mov	r0, r4
34014496:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_EINVAL;
34014498:	2401      	movs	r4, #1
3401449a:	e7fb      	b.n	34014494 <ISP_DeInit+0x18>
3401449c:	0000      	movs	r0, r0
	...

340144a0 <ISP_Start>:
  *         Configures the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_Start(ISP_HandleTypeDef *hIsp)
{
340144a0:	b567      	push	{r0, r1, r2, r5, r6, lr}
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
340144a2:	4605      	mov	r5, r0
340144a4:	2800      	cmp	r0, #0
340144a6:	f000 8095 	beq.w	340145d4 <ISP_Start+0x134>
  {
    return ISP_ERR_EINVAL;
  }

  ret = ISP_SVC_Misc_IsDCMIPPReady(hIsp);
340144aa:	f000 fd67 	bl	34014f7c <ISP_SVC_Misc_IsDCMIPPReady>
  if (ret != ISP_OK)
340144ae:	2800      	cmp	r0, #0
340144b0:	d149      	bne.n	34014546 <ISP_Start+0xa6>
  {
    return ret;
  }

  /* Get IQ Param config */
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
340144b2:	4628      	mov	r0, r5
340144b4:	f000 fdbe 	bl	34015034 <ISP_SVC_IQParam_Get>
340144b8:	4606      	mov	r6, r0

  /* Set static configurations */
  ret = ISP_SVC_ISP_SetDemosaicing(hIsp, &IQParamConfig->demosaicing);
340144ba:	f100 010c 	add.w	r1, r0, #12
340144be:	4628      	mov	r0, r5
340144c0:	f000 f982 	bl	340147c8 <ISP_SVC_ISP_SetDemosaicing>
  if (ret != ISP_OK)
340144c4:	2800      	cmp	r0, #0
340144c6:	d13e      	bne.n	34014546 <ISP_Start+0xa6>
  {
    return ret;
  }

  ret = ISP_SVC_ISP_SetStatRemoval(hIsp, &IQParamConfig->statRemoval);
340144c8:	4631      	mov	r1, r6
340144ca:	4628      	mov	r0, r5
340144cc:	f000 f9bb 	bl	34014846 <ISP_SVC_ISP_SetStatRemoval>
  if (ret != ISP_OK)
340144d0:	2800      	cmp	r0, #0
340144d2:	d138      	bne.n	34014546 <ISP_Start+0xa6>
  {
    return ret;
  }

  ret = ISP_SVC_ISP_SetContrast(hIsp, &IQParamConfig->contrast);
340144d4:	4628      	mov	r0, r5
340144d6:	f106 0114 	add.w	r1, r6, #20
340144da:	f000 fa09 	bl	340148f0 <ISP_SVC_ISP_SetContrast>
  if (ret != ISP_OK)
340144de:	bb90      	cbnz	r0, 34014546 <ISP_Start+0xa6>
  {
    return ret;
  }

  /* Set optional static configurations */
  if ((IQParamConfig->sensorGainStatic.gain != 0) && (!IQParamConfig->AECAlgo.enable))
340144e0:	6cf3      	ldr	r3, [r6, #76]	@ 0x4c
340144e2:	bb2b      	cbnz	r3, 34014530 <ISP_Start+0x90>
    {
      return ret;
    }
  }

  if ((IQParamConfig->sensorExposureStatic.exposure != 0) && (!IQParamConfig->AECAlgo.enable))
340144e4:	6d33      	ldr	r3, [r6, #80]	@ 0x50
340144e6:	bb83      	cbnz	r3, 3401454a <ISP_Start+0xaa>
    {
      return ret;
    }
  }

  if (IQParamConfig->badPixelStatic.enable != 0)
340144e8:	f896 305c 	ldrb.w	r3, [r6, #92]	@ 0x5c
340144ec:	b12b      	cbz	r3, 340144fa <ISP_Start+0x5a>
  {
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &IQParamConfig->badPixelStatic);
340144ee:	4628      	mov	r0, r5
340144f0:	f106 015c 	add.w	r1, r6, #92	@ 0x5c
340144f4:	f000 fac2 	bl	34014a7c <ISP_SVC_ISP_SetBadPixel>
    if (ret != ISP_OK)
340144f8:	bb28      	cbnz	r0, 34014546 <ISP_Start+0xa6>
    {
      return ret;
    }
  }

  if (IQParamConfig->blackLevelStatic.enable != 0)
340144fa:	f896 3064 	ldrb.w	r3, [r6, #100]	@ 0x64
340144fe:	b12b      	cbz	r3, 3401450c <ISP_Start+0x6c>
  {
    ret = ISP_SVC_ISP_SetBlackLevel(hIsp, &IQParamConfig->blackLevelStatic);
34014500:	4628      	mov	r0, r5
34014502:	f106 0164 	add.w	r1, r6, #100	@ 0x64
34014506:	f000 faee 	bl	34014ae6 <ISP_SVC_ISP_SetBlackLevel>
    if (ret != ISP_OK)
3401450a:	b9e0      	cbnz	r0, 34014546 <ISP_Start+0xa6>
    {
      return ret;
    }
  }

  if ((IQParamConfig->ispGainStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3401450c:	f896 321c 	ldrb.w	r3, [r6, #540]	@ 0x21c
34014510:	bb3b      	cbnz	r3, 34014562 <ISP_Start+0xc2>
    {
      return ret;
    }
  }

  if ((IQParamConfig->colorConvStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
34014512:	f896 322c 	ldrb.w	r3, [r6, #556]	@ 0x22c
34014516:	2b00      	cmp	r3, #0
34014518:	d12f      	bne.n	3401457a <ISP_Start+0xda>
      return ret;
    }
  }

  /* Configure statistic area if not already configured by ISP_SetStatArea() */
  if ((hIsp->statArea.XSize == 0) || (hIsp->statArea.YSize == 0))
3401451a:	692b      	ldr	r3, [r5, #16]
3401451c:	2b00      	cmp	r3, #0
3401451e:	d138      	bne.n	34014592 <ISP_Start+0xf2>
  {
    /* Configure statistic area from IQ params */
    ret = ISP_SVC_ISP_SetStatArea(hIsp, &IQParamConfig->statAreaStatic);
34014520:	4628      	mov	r0, r5
34014522:	f106 013c 	add.w	r1, r6, #60	@ 0x3c
34014526:	f000 fa5d 	bl	340149e4 <ISP_SVC_ISP_SetStatArea>
    if (ret != ISP_OK)
3401452a:	2800      	cmp	r0, #0
3401452c:	d034      	beq.n	34014598 <ISP_Start+0xf8>
3401452e:	e00a      	b.n	34014546 <ISP_Start+0xa6>
  if ((IQParamConfig->sensorGainStatic.gain != 0) && (!IQParamConfig->AECAlgo.enable))
34014530:	f896 3068 	ldrb.w	r3, [r6, #104]	@ 0x68
34014534:	2b00      	cmp	r3, #0
34014536:	d1d5      	bne.n	340144e4 <ISP_Start+0x44>
    ret = ISP_SVC_Sensor_SetGain(hIsp, &IQParamConfig->sensorGainStatic);
34014538:	4628      	mov	r0, r5
3401453a:	f106 014c 	add.w	r1, r6, #76	@ 0x4c
3401453e:	f000 fcd5 	bl	34014eec <ISP_SVC_Sensor_SetGain>
    if (ret != ISP_OK)
34014542:	2800      	cmp	r0, #0
34014544:	d0ce      	beq.n	340144e4 <ISP_Start+0x44>

  /* Initialize the exposure target based on the selected exposure compensation */
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));

  return ISP_OK;
}
34014546:	b003      	add	sp, #12
34014548:	bd60      	pop	{r5, r6, pc}
  if ((IQParamConfig->sensorExposureStatic.exposure != 0) && (!IQParamConfig->AECAlgo.enable))
3401454a:	f896 3068 	ldrb.w	r3, [r6, #104]	@ 0x68
3401454e:	2b00      	cmp	r3, #0
34014550:	d1ca      	bne.n	340144e8 <ISP_Start+0x48>
    ret = ISP_SVC_Sensor_SetExposure(hIsp, &IQParamConfig->sensorExposureStatic);
34014552:	4628      	mov	r0, r5
34014554:	f106 0150 	add.w	r1, r6, #80	@ 0x50
34014558:	f000 fcec 	bl	34014f34 <ISP_SVC_Sensor_SetExposure>
    if (ret != ISP_OK)
3401455c:	2800      	cmp	r0, #0
3401455e:	d0c3      	beq.n	340144e8 <ISP_Start+0x48>
34014560:	e7f1      	b.n	34014546 <ISP_Start+0xa6>
  if ((IQParamConfig->ispGainStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
34014562:	f896 3074 	ldrb.w	r3, [r6, #116]	@ 0x74
34014566:	2b00      	cmp	r3, #0
34014568:	d1d3      	bne.n	34014512 <ISP_Start+0x72>
    ret = ISP_SVC_ISP_SetGain(hIsp, &IQParamConfig->ispGainStatic);
3401456a:	4628      	mov	r0, r5
3401456c:	f506 7107 	add.w	r1, r6, #540	@ 0x21c
34014570:	f000 fafa 	bl	34014b68 <ISP_SVC_ISP_SetGain>
    if (ret != ISP_OK)
34014574:	2800      	cmp	r0, #0
34014576:	d0cc      	beq.n	34014512 <ISP_Start+0x72>
34014578:	e7e5      	b.n	34014546 <ISP_Start+0xa6>
  if ((IQParamConfig->colorConvStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3401457a:	f896 3074 	ldrb.w	r3, [r6, #116]	@ 0x74
3401457e:	2b00      	cmp	r3, #0
34014580:	d1cb      	bne.n	3401451a <ISP_Start+0x7a>
    ret = ISP_SVC_ISP_SetColorConv(hIsp, &IQParamConfig->colorConvStatic);
34014582:	4628      	mov	r0, r5
34014584:	f506 710b 	add.w	r1, r6, #556	@ 0x22c
34014588:	f000 fbd2 	bl	34014d30 <ISP_SVC_ISP_SetColorConv>
    if (ret != ISP_OK)
3401458c:	2800      	cmp	r0, #0
3401458e:	d0c4      	beq.n	3401451a <ISP_Start+0x7a>
34014590:	e7d9      	b.n	34014546 <ISP_Start+0xa6>
  if ((hIsp->statArea.XSize == 0) || (hIsp->statArea.YSize == 0))
34014592:	696b      	ldr	r3, [r5, #20]
34014594:	2b00      	cmp	r3, #0
34014596:	d0c3      	beq.n	34014520 <ISP_Start+0x80>
  ret = ISP_SVC_ISP_SetGamma(hIsp, &IQParamConfig->gamma);
34014598:	4628      	mov	r0, r5
3401459a:	f506 7115 	add.w	r1, r6, #596	@ 0x254
3401459e:	f000 fd1f 	bl	34014fe0 <ISP_SVC_ISP_SetGamma>
  if (ret != ISP_OK)
340145a2:	2800      	cmp	r0, #0
340145a4:	d1cf      	bne.n	34014546 <ISP_Start+0xa6>
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));
340145a6:	f996 3069 	ldrsb.w	r3, [r6, #105]	@ 0x69
340145aa:	eeb0 0b00 	vmov.f64	d0, #0	@ 0x40000000  2.0
340145ae:	ee01 3a10 	vmov	s2, r3
340145b2:	eeba 1aef 	vcvt.f32.s32	s2, s2, #1
340145b6:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
340145ba:	9001      	str	r0, [sp, #4]
340145bc:	f007 ff68 	bl	3401c490 <pow>
340145c0:	ed9f 7b05 	vldr	d7, [pc, #20]	@ 340145d8 <ISP_Start+0x138>
340145c4:	ee20 0b07 	vmul.f64	d0, d0, d7
340145c8:	eebc 0bc0 	vcvt.u32.f64	s0, d0
  return ISP_OK;
340145cc:	9801      	ldr	r0, [sp, #4]
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));
340145ce:	ed86 0a1b 	vstr	s0, [r6, #108]	@ 0x6c
  return ISP_OK;
340145d2:	e7b8      	b.n	34014546 <ISP_Start+0xa6>
    return ISP_ERR_EINVAL;
340145d4:	2001      	movs	r0, #1
340145d6:	e7b6      	b.n	34014546 <ISP_Start+0xa6>
340145d8:	00000000 	.word	0x00000000
340145dc:	404c0000 	.word	0x404c0000

340145e0 <ISP_BackgroundProcess>:
  *         Run the background process of the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_BackgroundProcess(ISP_HandleTypeDef *hIsp)
{
340145e0:	b538      	push	{r3, r4, r5, lr}
#ifdef ISP_MW_TUNING_TOOL_SUPPORT
  ISP_StatusTypeDef retCmdParser = ISP_OK;
  uint8_t *cmd;
#endif

  if (hIsp == NULL)
340145e2:	4605      	mov	r5, r0
340145e4:	b150      	cbz	r0, 340145fc <ISP_BackgroundProcess+0x1c>
    retCmdParser = ISP_CmdParser_ProcessCommand(hIsp, cmd);
  }
#endif

  /* Check if a statistics gathering cycle has been completed to call the statistic callbacks */
  retStats = ISP_SVC_Stats_ProcessCallbacks(hIsp);
340145e6:	f000 ff2d 	bl	34015444 <ISP_SVC_Stats_ProcessCallbacks>
340145ea:	4604      	mov	r4, r0

  /* Process the algorithms */
  retAlgo = ISP_Algo_Process(hIsp);
340145ec:	4628      	mov	r0, r5
340145ee:	f7ff feb6 	bl	3401435e <ISP_Algo_Process>
  else if (retAlgo != ISP_OK)
  {
    return retAlgo;
  }

  return ISP_OK;
340145f2:	2c00      	cmp	r4, #0
340145f4:	bf08      	it	eq
340145f6:	4604      	moveq	r4, r0
}
340145f8:	4620      	mov	r0, r4
340145fa:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_EINVAL;
340145fc:	2401      	movs	r4, #1
340145fe:	e7fb      	b.n	340145f8 <ISP_BackgroundProcess+0x18>

34014600 <ISP_ListWBRefModes>:
  * @param  hIsp: ISP device handle
  * @param  RefColorTemp: Array of reference color temperatures
  * @retval Operation status
  */
ISP_StatusTypeDef ISP_ListWBRefModes(ISP_HandleTypeDef *hIsp, uint32_t RefColorTemp[])
{
34014600:	b510      	push	{r4, lr}
34014602:	460c      	mov	r4, r1
  ISP_IQParamTypeDef *IQParamConfig;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34014604:	f000 fd16 	bl	34015034 <ISP_SVC_IQParam_Get>

  memcpy(RefColorTemp, IQParamConfig->AWBAlgo.referenceColorTemp, sizeof(IQParamConfig->AWBAlgo.referenceColorTemp));
34014608:	f04f 0e05 	mov.w	lr, #5
3401460c:	4621      	mov	r1, r4
3401460e:	f04e e001 	dls	lr, lr
34014612:	f500 708c 	add.w	r0, r0, #280	@ 0x118
34014616:	f850 3b04 	ldr.w	r3, [r0], #4
3401461a:	f841 3b04 	str.w	r3, [r1], #4
3401461e:	f00f c007 	le	lr, 34014616 <ISP_ListWBRefModes+0x16>

  return ISP_OK;
}
34014622:	2000      	movs	r0, #0
34014624:	bd10      	pop	{r4, pc}

34014626 <ISP_SetWBRefMode>:
  * @param  Automatic: 'true' if the AWB automatic mode is requested
  * @param  RefColorTemp: Reference color temperature (manual mode). Not significant if Automatic is set to 'true'
  * @retval Operation status
  */
ISP_StatusTypeDef ISP_SetWBRefMode(ISP_HandleTypeDef *hIsp, uint8_t Automatic, uint32_t RefColorTemp)
{
34014626:	b570      	push	{r4, r5, r6, lr}
34014628:	460e      	mov	r6, r1
3401462a:	b08e      	sub	sp, #56	@ 0x38
3401462c:	4604      	mov	r4, r0
3401462e:	4615      	mov	r5, r2
  ISP_ColorConvTypeDef ColorConv;
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;
  uint32_t index;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34014630:	f000 fd00 	bl	34015034 <ISP_SVC_IQParam_Get>

  if (Automatic)
34014634:	b12e      	cbz	r6, 34014642 <ISP_SetWBRefMode+0x1c>
  {
    /* Start the AWB algorithm */
    IQParamConfig->AWBAlgo.enable = 1;
34014636:	2301      	movs	r3, #1
34014638:	f880 3074 	strb.w	r3, [r0, #116]	@ 0x74
    {
      return ret;
    }
  }

  return ISP_OK;
3401463c:	2000      	movs	r0, #0
}
3401463e:	b00e      	add	sp, #56	@ 0x38
34014640:	bd70      	pop	{r4, r5, r6, pc}
    for (index = 0; index < ISP_AWB_COLORTEMP_REF; index++)
34014642:	4631      	mov	r1, r6
34014644:	2305      	movs	r3, #5
34014646:	f500 728a 	add.w	r2, r0, #276	@ 0x114
      if (IQParamConfig->AWBAlgo.referenceColorTemp[index] == RefColorTemp)
3401464a:	f852 6f04 	ldr.w	r6, [r2, #4]!
3401464e:	42ae      	cmp	r6, r5
34014650:	d005      	beq.n	3401465e <ISP_SetWBRefMode+0x38>
    for (index = 0; index < ISP_AWB_COLORTEMP_REF; index++)
34014652:	3b01      	subs	r3, #1
34014654:	f101 0101 	add.w	r1, r1, #1
34014658:	d1f7      	bne.n	3401464a <ISP_SetWBRefMode+0x24>
      return ISP_ERR_WB_COLORTEMP;
3401465a:	2096      	movs	r0, #150	@ 0x96
3401465c:	e7ef      	b.n	3401463e <ISP_SetWBRefMode+0x18>
    IQParamConfig->AWBAlgo.enable = 0;
3401465e:	2300      	movs	r3, #0
    memcpy(ColorConv.coeff, IQParamConfig->AWBAlgo.coeff[index], sizeof(ColorConv.coeff));
34014660:	f04f 0e04 	mov.w	lr, #4
    IQParamConfig->AWBAlgo.enable = 0;
34014664:	f880 3074 	strb.w	r3, [r0, #116]	@ 0x74
    ISPGain.enable = 1;
34014668:	eb00 0381 	add.w	r3, r0, r1, lsl #2
    ISPGain.ispGainR = IQParamConfig->AWBAlgo.ispGainR[index];
3401466c:	f8d3 612c 	ldr.w	r6, [r3, #300]	@ 0x12c
    ISPGain.enable = 1;
34014670:	2201      	movs	r2, #1
    ISPGain.ispGainR = IQParamConfig->AWBAlgo.ispGainR[index];
34014672:	9601      	str	r6, [sp, #4]
    ISPGain.ispGainG = IQParamConfig->AWBAlgo.ispGainG[index];
34014674:	f8d3 6140 	ldr.w	r6, [r3, #320]	@ 0x140
    ISPGain.ispGainB = IQParamConfig->AWBAlgo.ispGainB[index];
34014678:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
    memcpy(ColorConv.coeff, IQParamConfig->AWBAlgo.coeff[index], sizeof(ColorConv.coeff));
3401467c:	f04e e001 	dls	lr, lr
    ISPGain.ispGainB = IQParamConfig->AWBAlgo.ispGainB[index];
34014680:	9303      	str	r3, [sp, #12]
    memcpy(ColorConv.coeff, IQParamConfig->AWBAlgo.coeff[index], sizeof(ColorConv.coeff));
34014682:	2324      	movs	r3, #36	@ 0x24
34014684:	fb03 0301 	mla	r3, r3, r1, r0
    ISPGain.enable = 1;
34014688:	f88d 2000 	strb.w	r2, [sp]
    ColorConv.enable = 1;
3401468c:	f88d 2010 	strb.w	r2, [sp, #16]
    ISPGain.ispGainG = IQParamConfig->AWBAlgo.ispGainG[index];
34014690:	9602      	str	r6, [sp, #8]
    memcpy(ColorConv.coeff, IQParamConfig->AWBAlgo.coeff[index], sizeof(ColorConv.coeff));
34014692:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
34014696:	aa05      	add	r2, sp, #20
34014698:	4616      	mov	r6, r2
3401469a:	6818      	ldr	r0, [r3, #0]
3401469c:	6859      	ldr	r1, [r3, #4]
3401469e:	3308      	adds	r3, #8
340146a0:	c603      	stmia	r6!, {r0, r1}
340146a2:	4632      	mov	r2, r6
340146a4:	f00f c009 	le	lr, 34014698 <ISP_SetWBRefMode+0x72>
340146a8:	6818      	ldr	r0, [r3, #0]
    ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGain);
340146aa:	4669      	mov	r1, sp
    memcpy(ColorConv.coeff, IQParamConfig->AWBAlgo.coeff[index], sizeof(ColorConv.coeff));
340146ac:	6030      	str	r0, [r6, #0]
    ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGain);
340146ae:	4620      	mov	r0, r4
340146b0:	f000 fa5a 	bl	34014b68 <ISP_SVC_ISP_SetGain>
    if (ret != ISP_OK)
340146b4:	2800      	cmp	r0, #0
340146b6:	d1c2      	bne.n	3401463e <ISP_SetWBRefMode+0x18>
    ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConv);
340146b8:	4620      	mov	r0, r4
340146ba:	a904      	add	r1, sp, #16
340146bc:	f000 fb38 	bl	34014d30 <ISP_SVC_ISP_SetColorConv>
    if (ret != ISP_OK)
340146c0:	2800      	cmp	r0, #0
340146c2:	d1bc      	bne.n	3401463e <ISP_SetWBRefMode+0x18>
    ret = ISP_SVC_Misc_SetWBRefMode(hIsp, RefColorTemp);
340146c4:	4629      	mov	r1, r5
340146c6:	4620      	mov	r0, r4
340146c8:	f000 fc72 	bl	34014fb0 <ISP_SVC_Misc_SetWBRefMode>
    if (ret != ISP_OK)
340146cc:	e7b7      	b.n	3401463e <ISP_SetWBRefMode+0x18>

340146ce <ISP_GatherStatistics>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_GatherStatistics(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Stats_Gather(hIsp);
340146ce:	f000 bcbd 	b.w	3401504c <ISP_SVC_Stats_Gather>

340146d2 <ISP_IncMainFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Misc_IncMainFrameId(hIsp);
340146d2:	f000 bc5f 	b.w	34014f94 <ISP_SVC_Misc_IncMainFrameId>

340146d6 <ISP_IncAncillaryFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
	ISP_SVC_Misc_IncAncillaryFrameId(hIsp);
340146d6:	f000 bc63 	b.w	34014fa0 <ISP_SVC_Misc_IncAncillaryFrameId>

340146da <ISP_IncDumpFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Misc_IncDumpFrameId(hIsp);
340146da:	f000 bc65 	b.w	34014fa8 <ISP_SVC_Misc_IncDumpFrameId>
	...

340146e0 <GetAvgStats>:

  return (int32_t) Val;
}

static uint8_t GetAvgStats(ISP_HandleTypeDef *hIsp, ISP_SVC_StatLocation location, ISP_SVC_Component component, uint32_t accu)
{
340146e0:	b510      	push	{r4, lr}
  uint32_t nb_comp_pix, comp_divider;

  /* Number of pixels computed from Stat Area and considering decimation */
  nb_comp_pix = hIsp->statArea.XSize * hIsp->statArea.YSize;
340146e2:	e9d0 4004 	ldrd	r4, r0, [r0, #16]
340146e6:	4360      	muls	r0, r4
  nb_comp_pix /= ISP_DecimationValue.factor * ISP_DecimationValue.factor;
340146e8:	4c0d      	ldr	r4, [pc, #52]	@ (34014720 <GetAvgStats+0x40>)

  if (location == ISP_STAT_LOC_DOWN)
340146ea:	2902      	cmp	r1, #2
  nb_comp_pix /= ISP_DecimationValue.factor * ISP_DecimationValue.factor;
340146ec:	7824      	ldrb	r4, [r4, #0]
340146ee:	fb04 f404 	mul.w	r4, r4, r4
340146f2:	fbb0 f0f4 	udiv	r0, r0, r4
  if (location == ISP_STAT_LOC_DOWN)
340146f6:	d010      	beq.n	3401471a <GetAvgStats+0x3a>
  }
  else
  {
    /* Only raw bayer sensor expected */
    /* raw bayer: RGB component not present for all pixels */
    comp_divider = (component == ISP_GREEN) ? 2 : 4;
340146f8:	2a01      	cmp	r2, #1
340146fa:	bf14      	ite	ne
340146fc:	2204      	movne	r2, #4
340146fe:	2202      	moveq	r2, #2

  /* Number of pixels per component */
  nb_comp_pix /= comp_divider;

  /* Compute average (rounding to closest integer) */
  if (nb_comp_pix == 0)
34014700:	4282      	cmp	r2, r0
  nb_comp_pix /= comp_divider;
34014702:	bf9f      	itttt	ls
34014704:	fbb0 f0f2 	udivls	r0, r0, r2
  {
    return 0;
  }

  return (uint8_t)(((accu * 256) + (nb_comp_pix / 2)) / nb_comp_pix);
34014708:	0842      	lsrls	r2, r0, #1
3401470a:	eb02 2303 	addls.w	r3, r2, r3, lsl #8
3401470e:	fbb3 f0f0 	udivls	r0, r3, r0
    return 0;
34014712:	bf8c      	ite	hi
34014714:	2000      	movhi	r0, #0
  return (uint8_t)(((accu * 256) + (nb_comp_pix / 2)) / nb_comp_pix);
34014716:	b2c0      	uxtbls	r0, r0
}
34014718:	bd10      	pop	{r4, pc}
    comp_divider = 1;
3401471a:	2201      	movs	r2, #1
3401471c:	e7f0      	b.n	34014700 <GetAvgStats+0x20>
3401471e:	bf00      	nop
34014720:	340b103a 	.word	0x340b103a

34014724 <SetStatConfig>:
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
  }
}

static void SetStatConfig(DCMIPP_StatisticExtractionConfTypeDef *statConf, const DCMIPP_StatisticExtractionConfTypeDef *refConfig)
{
34014724:	b5f0      	push	{r4, r5, r6, r7, lr}
34014726:	460b      	mov	r3, r1
34014728:	4606      	mov	r6, r0
  for (int i = 0; i < 3; i++)
3401472a:	2400      	movs	r4, #0
  {
    statConf[i] = *refConfig;
3401472c:	270c      	movs	r7, #12
3401472e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
34014732:	fb07 6504 	mla	r5, r7, r4, r6
  for (int i = 0; i < 3; i++)
34014736:	3401      	adds	r4, #1
34014738:	2c03      	cmp	r4, #3
    statConf[i] = *refConfig;
3401473a:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  for (int i = 0; i < 3; i++)
3401473e:	d1f6      	bne.n	3401472e <SetStatConfig+0xa>
  }
}
34014740:	bdf0      	pop	{r4, r5, r6, r7, pc}

34014742 <ReadStatHistogram>:
{
34014742:	b570      	push	{r4, r5, r6, lr}
34014744:	4606      	mov	r6, r0
34014746:	460d      	mov	r5, r1
  for (uint8_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34014748:	2401      	movs	r4, #1
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
3401474a:	4622      	mov	r2, r4
  for (uint8_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3401474c:	3401      	adds	r4, #1
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
3401474e:	462b      	mov	r3, r5
34014750:	2101      	movs	r1, #1
34014752:	6830      	ldr	r0, [r6, #0]
  for (uint8_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34014754:	b2e4      	uxtb	r4, r4
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
34014756:	f7f2 ff2f 	bl	340075b8 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
  for (uint8_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3401475a:	2c04      	cmp	r4, #4
3401475c:	f105 0504 	add.w	r5, r5, #4
34014760:	d1f3      	bne.n	3401474a <ReadStatHistogram+0x8>
}
34014762:	bd70      	pop	{r4, r5, r6, pc}
34014764:	0000      	movs	r0, r0
	...

34014768 <LuminanceFromRGB>:
  }
  return stage;
}

uint8_t LuminanceFromRGB(uint8_t r, uint8_t g, uint8_t b)
{
34014768:	ee07 1a10 	vmov	s14, r1
3401476c:	ee05 0a10 	vmov	s10, r0
  /* Compute luminance from RGB components (BT.601) */
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
34014770:	ed9f 4b0f 	vldr	d4, [pc, #60]	@ 340147b0 <LuminanceFromRGB+0x48>
34014774:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
{
34014778:	ee06 2a10 	vmov	s12, r2
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
3401477c:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
34014780:	ee27 7b04 	vmul.f64	d7, d7, d4
34014784:	ed9f 4b0c 	vldr	d4, [pc, #48]	@ 340147b8 <LuminanceFromRGB+0x50>
34014788:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
3401478c:	eea5 7b04 	vfma.f64	d7, d5, d4
34014790:	ed9f 5b0b 	vldr	d5, [pc, #44]	@ 340147c0 <LuminanceFromRGB+0x58>
34014794:	eea6 7b05 	vfma.f64	d7, d6, d5
34014798:	eefc 7bc7 	vcvt.u32.f64	s15, d7
{
3401479c:	b082      	sub	sp, #8
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
3401479e:	edcd 7a01 	vstr	s15, [sp, #4]
}
340147a2:	f89d 0004 	ldrb.w	r0, [sp, #4]
340147a6:	b002      	add	sp, #8
340147a8:	4770      	bx	lr
340147aa:	bf00      	nop
340147ac:	f3af 8000 	nop.w
340147b0:	39581062 	.word	0x39581062
340147b4:	3fe2c8b4 	.word	0x3fe2c8b4
340147b8:	e5604189 	.word	0xe5604189
340147bc:	3fd322d0 	.word	0x3fd322d0
340147c0:	9fbe76c9 	.word	0x9fbe76c9
340147c4:	3fbd2f1a 	.word	0x3fbd2f1a

340147c8 <ISP_SVC_ISP_SetDemosaicing>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the demosaicing configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDemosaicing(ISP_HandleTypeDef *hIsp, ISP_DemosaicingTypeDef *pConfig)
{
340147c8:	b5f0      	push	{r4, r5, r6, r7, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_RawBayer2RGBConfTypeDef rawBayerCfg;

  if ((hIsp == NULL) || (pConfig == NULL) ||
340147ca:	4604      	mov	r4, r0
{
340147cc:	b087      	sub	sp, #28
  if ((hIsp == NULL) || (pConfig == NULL) ||
340147ce:	2800      	cmp	r0, #0
340147d0:	d037      	beq.n	34014842 <ISP_SVC_ISP_SetDemosaicing+0x7a>
340147d2:	2900      	cmp	r1, #0
340147d4:	d035      	beq.n	34014842 <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
340147d6:	788f      	ldrb	r7, [r1, #2]
  if ((hIsp == NULL) || (pConfig == NULL) ||
340147d8:	2f07      	cmp	r7, #7
340147da:	d832      	bhi.n	34014842 <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
340147dc:	78ce      	ldrb	r6, [r1, #3]
340147de:	2e07      	cmp	r6, #7
340147e0:	d82f      	bhi.n	34014842 <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
340147e2:	790d      	ldrb	r5, [r1, #4]
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
340147e4:	2d07      	cmp	r5, #7
340147e6:	d82c      	bhi.n	34014842 <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
340147e8:	7948      	ldrb	r0, [r1, #5]
340147ea:	2807      	cmp	r0, #7
340147ec:	d829      	bhi.n	34014842 <ISP_SVC_ISP_SetDemosaicing+0x7a>
  {
    return ISP_ERR_DEMOSAICING_EINVAL;
  }

  /* Do not enable demosaicing if the camera sensor is a monochrome sensor */
  if ((pConfig->enable == 0) || (pConfig->type == ISP_DEMOS_TYPE_MONO))
340147ee:	780b      	ldrb	r3, [r1, #0]
340147f0:	b113      	cbz	r3, 340147f8 <ISP_SVC_ISP_SetDemosaicing+0x30>
340147f2:	784a      	ldrb	r2, [r1, #1]
340147f4:	2a04      	cmp	r2, #4
340147f6:	d107      	bne.n	34014808 <ISP_SVC_ISP_SetDemosaicing+0x40>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
340147f8:	2101      	movs	r1, #1
340147fa:	6820      	ldr	r0, [r4, #0]
340147fc:	f7f2 f8cc 	bl	34006998 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
34014800:	b100      	cbz	r0, 34014804 <ISP_SVC_ISP_SetDemosaicing+0x3c>
  {
    return ISP_ERR_DEMOSAICING_HAL;
34014802:	200b      	movs	r0, #11
  }

  return ISP_OK;
}
34014804:	b007      	add	sp, #28
34014806:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch(pConfig->type)
34014808:	2a02      	cmp	r2, #2
3401480a:	d018      	beq.n	3401483e <ISP_SVC_ISP_SetDemosaicing+0x76>
3401480c:	1e51      	subs	r1, r2, #1
3401480e:	424b      	negs	r3, r1
34014810:	414b      	adcs	r3, r1
34014812:	2a03      	cmp	r2, #3
34014814:	ea4f 0343 	mov.w	r3, r3, lsl #1
34014818:	bf08      	it	eq
3401481a:	2306      	moveq	r3, #6
    rawBayerCfg.EdgeStrength = (uint32_t) pConfig->edge;
3401481c:	9005      	str	r0, [sp, #20]
    halStatus = HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &rawBayerCfg);
3401481e:	2101      	movs	r1, #1
34014820:	6820      	ldr	r0, [r4, #0]
34014822:	aa01      	add	r2, sp, #4
    rawBayerCfg.PeakStrength = (uint32_t) pConfig->peak;
34014824:	e9cd 3703 	strd	r3, r7, [sp, #12]
    rawBayerCfg.HLineStrength = (uint32_t) pConfig->lineH;
34014828:	e9cd 6501 	strd	r6, r5, [sp, #4]
    halStatus = HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &rawBayerCfg);
3401482c:	f7f2 f842 	bl	340068b4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>
    if (halStatus == HAL_OK)
34014830:	2800      	cmp	r0, #0
34014832:	d1e6      	bne.n	34014802 <ISP_SVC_ISP_SetDemosaicing+0x3a>
      halStatus = HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
34014834:	2101      	movs	r1, #1
34014836:	6820      	ldr	r0, [r4, #0]
34014838:	f7f2 f896 	bl	34006968 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>
3401483c:	e7e0      	b.n	34014800 <ISP_SVC_ISP_SetDemosaicing+0x38>
    switch(pConfig->type)
3401483e:	2304      	movs	r3, #4
34014840:	e7ec      	b.n	3401481c <ISP_SVC_ISP_SetDemosaicing+0x54>
    return ISP_ERR_DEMOSAICING_EINVAL;
34014842:	200a      	movs	r0, #10
34014844:	e7de      	b.n	34014804 <ISP_SVC_ISP_SetDemosaicing+0x3c>

34014846 <ISP_SVC_ISP_SetStatRemoval>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Stat Removal configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatRemoval(ISP_HandleTypeDef *hIsp, ISP_StatRemovalTypeDef *pConfig)
{
34014846:	b510      	push	{r4, lr}
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) ||
34014848:	4604      	mov	r4, r0
3401484a:	b1d8      	cbz	r0, 34014884 <ISP_SVC_ISP_SetStatRemoval+0x3e>
3401484c:	b1d1      	cbz	r1, 34014884 <ISP_SVC_ISP_SetStatRemoval+0x3e>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
3401484e:	684a      	ldr	r2, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34014850:	2a07      	cmp	r2, #7
34014852:	d817      	bhi.n	34014884 <ISP_SVC_ISP_SetStatRemoval+0x3e>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
34014854:	f640 70fe 	movw	r0, #4094	@ 0xffe
34014858:	688b      	ldr	r3, [r1, #8]
3401485a:	4283      	cmp	r3, r0
3401485c:	d812      	bhi.n	34014884 <ISP_SVC_ISP_SetStatRemoval+0x3e>
  {
    return ISP_ERR_STATREMOVAL_EINVAL;
  }

  if (pConfig->enable == 0)
3401485e:	7809      	ldrb	r1, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
34014860:	6820      	ldr	r0, [r4, #0]
  if (pConfig->enable == 0)
34014862:	b921      	cbnz	r1, 3401486e <ISP_SVC_ISP_SetStatRemoval+0x28>
    halStatus = HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
34014864:	2101      	movs	r1, #1
34014866:	f7f2 f8eb 	bl	34006a40 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
3401486a:	b128      	cbz	r0, 34014878 <ISP_SVC_ISP_SetStatRemoval+0x32>
3401486c:	e003      	b.n	34014876 <ISP_SVC_ISP_SetStatRemoval+0x30>
    halStatus = HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->nbHeadLines, pConfig->nbValidLines);
3401486e:	2101      	movs	r1, #1
34014870:	f7f2 f8aa 	bl	340069c8 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>
    if (halStatus == HAL_OK)
34014874:	b108      	cbz	r0, 3401487a <ISP_SVC_ISP_SetStatRemoval+0x34>
  {
    return ISP_ERR_STATREMOVAL_HAL;
34014876:	2015      	movs	r0, #21
  }

  return ISP_OK;
}
34014878:	bd10      	pop	{r4, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
3401487a:	2101      	movs	r1, #1
3401487c:	6820      	ldr	r0, [r4, #0]
3401487e:	f7f2 f8d1 	bl	34006a24 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>
34014882:	e7f2      	b.n	3401486a <ISP_SVC_ISP_SetStatRemoval+0x24>
    return ISP_ERR_STATREMOVAL_EINVAL;
34014884:	2014      	movs	r0, #20
34014886:	e7f7      	b.n	34014878 <ISP_SVC_ISP_SetStatRemoval+0x32>

34014888 <ISP_SVC_ISP_SetDecimation>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the decimation configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDecimation(ISP_HandleTypeDef *hIsp, ISP_DecimationTypeDef *pConfig)
{
34014888:	b537      	push	{r0, r1, r2, r4, r5, lr}
3401488a:	460c      	mov	r4, r1
  DCMIPP_DecimationConfTypeDef decimationCfg;
  ISP_StatusTypeDef ret = ISP_OK;

  /* Check handles validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401488c:	4605      	mov	r5, r0
3401488e:	b350      	cbz	r0, 340148e6 <ISP_SVC_ISP_SetDecimation+0x5e>
34014890:	b349      	cbz	r1, 340148e6 <ISP_SVC_ISP_SetDecimation+0x5e>
  {
    return ISP_ERR_DECIMATION_EINVAL;
  }

  switch (pConfig->factor)
34014892:	780b      	ldrb	r3, [r1, #0]
34014894:	3b01      	subs	r3, #1
34014896:	2b07      	cmp	r3, #7
34014898:	d825      	bhi.n	340148e6 <ISP_SVC_ISP_SetDecimation+0x5e>
3401489a:	e8df f003 	tbb	[pc, r3]
3401489e:	0417      	.short	0x0417
340148a0:	24241124 	.word	0x24241124
340148a4:	1424      	.short	0x1424
340148a6:	2308      	movs	r3, #8
340148a8:	2202      	movs	r2, #2
  {
  case ISP_DECIM_FACTOR_1:
    decimationCfg.VRatio = DCMIPP_VDEC_ALL;
    decimationCfg.HRatio = DCMIPP_HDEC_ALL;
340148aa:	e9cd 3200 	strd	r3, r2, [sp]

  default:
    return ISP_ERR_DECIMATION_EINVAL;
  }

  if (HAL_DCMIPP_PIPE_SetISPDecimationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &decimationCfg) != HAL_OK)
340148ae:	2101      	movs	r1, #1
340148b0:	466a      	mov	r2, sp
340148b2:	6828      	ldr	r0, [r5, #0]
340148b4:	f7f1 fdf6 	bl	340064a4 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>
340148b8:	b158      	cbz	r0, 340148d2 <ISP_SVC_ISP_SetDecimation+0x4a>
  {
    return ISP_ERR_DECIMATION_HAL;
340148ba:	201f      	movs	r0, #31

  /* Save decimation value */
  ISP_DecimationValue.factor = pConfig->factor;

  return ret;
}
340148bc:	b003      	add	sp, #12
340148be:	bd30      	pop	{r4, r5, pc}
    break;
340148c0:	2310      	movs	r3, #16
340148c2:	2204      	movs	r2, #4
340148c4:	e7f1      	b.n	340148aa <ISP_SVC_ISP_SetDecimation+0x22>
    break;
340148c6:	2318      	movs	r3, #24
340148c8:	2206      	movs	r2, #6
340148ca:	e7ee      	b.n	340148aa <ISP_SVC_ISP_SetDecimation+0x22>
  switch (pConfig->factor)
340148cc:	2300      	movs	r3, #0
340148ce:	461a      	mov	r2, r3
340148d0:	e7eb      	b.n	340148aa <ISP_SVC_ISP_SetDecimation+0x22>
  if (HAL_DCMIPP_PIPE_EnableISPDecimation(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
340148d2:	2101      	movs	r1, #1
340148d4:	6828      	ldr	r0, [r5, #0]
340148d6:	f7f1 fe23 	bl	34006520 <HAL_DCMIPP_PIPE_EnableISPDecimation>
340148da:	2800      	cmp	r0, #0
340148dc:	d1ed      	bne.n	340148ba <ISP_SVC_ISP_SetDecimation+0x32>
  ISP_DecimationValue.factor = pConfig->factor;
340148de:	7822      	ldrb	r2, [r4, #0]
340148e0:	4b02      	ldr	r3, [pc, #8]	@ (340148ec <ISP_SVC_ISP_SetDecimation+0x64>)
340148e2:	701a      	strb	r2, [r3, #0]
  return ret;
340148e4:	e7ea      	b.n	340148bc <ISP_SVC_ISP_SetDecimation+0x34>
  switch (pConfig->factor)
340148e6:	201e      	movs	r0, #30
340148e8:	e7e8      	b.n	340148bc <ISP_SVC_ISP_SetDecimation+0x34>
340148ea:	bf00      	nop
340148ec:	340b103a 	.word	0x340b103a

340148f0 <ISP_SVC_ISP_SetContrast>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the contrast configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetContrast(ISP_HandleTypeDef *hIsp, ISP_ContrastTypeDef *pConfig)
{
340148f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_ContrastConfTypeDef contrast;

  if ((hIsp == NULL) || (pConfig == NULL) ||
340148f4:	4605      	mov	r5, r0
{
340148f6:	b085      	sub	sp, #20
  if ((hIsp == NULL) || (pConfig == NULL) ||
340148f8:	2800      	cmp	r0, #0
340148fa:	d071      	beq.n	340149e0 <ISP_SVC_ISP_SetContrast+0xf0>
340148fc:	2900      	cmp	r1, #0
340148fe:	d06f      	beq.n	340149e0 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
34014900:	684b      	ldr	r3, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34014902:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
34014906:	d86b      	bhi.n	340149e0 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
34014908:	f8d1 9008 	ldr.w	r9, [r1, #8]
3401490c:	f5b9 7fc5 	cmp.w	r9, #394	@ 0x18a
34014910:	d866      	bhi.n	340149e0 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
34014912:	f8d1 800c 	ldr.w	r8, [r1, #12]
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
34014916:	f5b8 7fc5 	cmp.w	r8, #394	@ 0x18a
3401491a:	d861      	bhi.n	340149e0 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401491c:	f8d1 e010 	ldr.w	lr, [r1, #16]
34014920:	f5be 7fc5 	cmp.w	lr, #394	@ 0x18a
34014924:	d85c      	bhi.n	340149e0 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
34014926:	f8d1 c014 	ldr.w	ip, [r1, #20]
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401492a:	f5bc 7fc5 	cmp.w	ip, #394	@ 0x18a
3401492e:	d857      	bhi.n	340149e0 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
34014930:	698f      	ldr	r7, [r1, #24]
34014932:	f5b7 7fc5 	cmp.w	r7, #394	@ 0x18a
34014936:	d853      	bhi.n	340149e0 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
34014938:	69ce      	ldr	r6, [r1, #28]
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401493a:	f5b6 7fc5 	cmp.w	r6, #394	@ 0x18a
3401493e:	d84f      	bhi.n	340149e0 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
34014940:	6a0c      	ldr	r4, [r1, #32]
34014942:	f5b4 7fc5 	cmp.w	r4, #394	@ 0x18a
34014946:	d84b      	bhi.n	340149e0 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_256 > ISP_CONTAST_LUMCOEFF_MAX))
34014948:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401494a:	f5b2 7fc5 	cmp.w	r2, #394	@ 0x18a
3401494e:	d847      	bhi.n	340149e0 <ISP_SVC_ISP_SetContrast+0xf0>
  {
    return ISP_ERR_CONTRAST_EINVAL;
  }

  if (pConfig->enable == 0)
34014950:	7809      	ldrb	r1, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
34014952:	6800      	ldr	r0, [r0, #0]
  if (pConfig->enable == 0)
34014954:	b921      	cbnz	r1, 34014960 <ISP_SVC_ISP_SetContrast+0x70>
    halStatus = HAL_DCMIPP_PIPE_DisableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
34014956:	2101      	movs	r1, #1
34014958:	f7f2 fd46 	bl	340073e8 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
3401495c:	b3c0      	cbz	r0, 340149d0 <ISP_SVC_ISP_SetContrast+0xe0>
3401495e:	e036      	b.n	340149ce <ISP_SVC_ISP_SetContrast+0xde>
    contrast.LUM_0 = (uint8_t)((pConfig->coeff.LUM_0 * 16) / 100);
34014960:	0119      	lsls	r1, r3, #4
34014962:	2364      	movs	r3, #100	@ 0x64
    contrast.LUM_256 = (uint8_t)((pConfig->coeff.LUM_256 * 16) / 100);
34014964:	0112      	lsls	r2, r2, #4
    contrast.LUM_0 = (uint8_t)((pConfig->coeff.LUM_0 * 16) / 100);
34014966:	fbb1 f1f3 	udiv	r1, r1, r3
    contrast.LUM_256 = (uint8_t)((pConfig->coeff.LUM_256 * 16) / 100);
3401496a:	fbb2 f2f3 	udiv	r2, r2, r3
    contrast.LUM_32 = (uint8_t)((pConfig->coeff.LUM_32 * 16) / 100);
3401496e:	ea4f 1909 	mov.w	r9, r9, lsl #4
    contrast.LUM_64 = (uint8_t)((pConfig->coeff.LUM_64 * 16) / 100);
34014972:	ea4f 1808 	mov.w	r8, r8, lsl #4
    contrast.LUM_96 = (uint8_t)((pConfig->coeff.LUM_96 * 16) / 100);
34014976:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    contrast.LUM_128 = (uint8_t)((pConfig->coeff.LUM_128 * 16) / 100);
3401497a:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
    contrast.LUM_160 = (uint8_t)((pConfig->coeff.LUM_160 * 16) / 100);
3401497e:	013f      	lsls	r7, r7, #4
    contrast.LUM_192 = (uint8_t)((pConfig->coeff.LUM_192 * 16) / 100);
34014980:	0136      	lsls	r6, r6, #4
    contrast.LUM_224 = (uint8_t)((pConfig->coeff.LUM_224 * 16) / 100);
34014982:	0124      	lsls	r4, r4, #4
    contrast.LUM_32 = (uint8_t)((pConfig->coeff.LUM_32 * 16) / 100);
34014984:	fbb9 f9f3 	udiv	r9, r9, r3
    contrast.LUM_64 = (uint8_t)((pConfig->coeff.LUM_64 * 16) / 100);
34014988:	fbb8 f8f3 	udiv	r8, r8, r3
    contrast.LUM_96 = (uint8_t)((pConfig->coeff.LUM_96 * 16) / 100);
3401498c:	fbbe fef3 	udiv	lr, lr, r3
    contrast.LUM_128 = (uint8_t)((pConfig->coeff.LUM_128 * 16) / 100);
34014990:	fbbc fcf3 	udiv	ip, ip, r3
    contrast.LUM_160 = (uint8_t)((pConfig->coeff.LUM_160 * 16) / 100);
34014994:	fbb7 f7f3 	udiv	r7, r7, r3
    contrast.LUM_192 = (uint8_t)((pConfig->coeff.LUM_192 * 16) / 100);
34014998:	fbb6 f6f3 	udiv	r6, r6, r3
    contrast.LUM_224 = (uint8_t)((pConfig->coeff.LUM_224 * 16) / 100);
3401499c:	fbb4 f4f3 	udiv	r4, r4, r3
    contrast.LUM_0 = (uint8_t)((pConfig->coeff.LUM_0 * 16) / 100);
340149a0:	f88d 1004 	strb.w	r1, [sp, #4]
    contrast.LUM_256 = (uint8_t)((pConfig->coeff.LUM_256 * 16) / 100);
340149a4:	f88d 200c 	strb.w	r2, [sp, #12]
    halStatus = HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &contrast);
340149a8:	2101      	movs	r1, #1
340149aa:	aa01      	add	r2, sp, #4
    contrast.LUM_32 = (uint8_t)((pConfig->coeff.LUM_32 * 16) / 100);
340149ac:	f88d 9005 	strb.w	r9, [sp, #5]
    contrast.LUM_64 = (uint8_t)((pConfig->coeff.LUM_64 * 16) / 100);
340149b0:	f88d 8006 	strb.w	r8, [sp, #6]
    contrast.LUM_96 = (uint8_t)((pConfig->coeff.LUM_96 * 16) / 100);
340149b4:	f88d e007 	strb.w	lr, [sp, #7]
    contrast.LUM_128 = (uint8_t)((pConfig->coeff.LUM_128 * 16) / 100);
340149b8:	f88d c008 	strb.w	ip, [sp, #8]
    contrast.LUM_160 = (uint8_t)((pConfig->coeff.LUM_160 * 16) / 100);
340149bc:	f88d 7009 	strb.w	r7, [sp, #9]
    contrast.LUM_192 = (uint8_t)((pConfig->coeff.LUM_192 * 16) / 100);
340149c0:	f88d 600a 	strb.w	r6, [sp, #10]
    contrast.LUM_224 = (uint8_t)((pConfig->coeff.LUM_224 * 16) / 100);
340149c4:	f88d 400b 	strb.w	r4, [sp, #11]
    halStatus = HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &contrast);
340149c8:	f7f2 fc74 	bl	340072b4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>
    if (halStatus == HAL_OK)
340149cc:	b118      	cbz	r0, 340149d6 <ISP_SVC_ISP_SetContrast+0xe6>
  {
    return ISP_ERR_CONTRAST_HAL;
340149ce:	2029      	movs	r0, #41	@ 0x29
  }

  return ISP_OK;
}
340149d0:	b005      	add	sp, #20
340149d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
340149d6:	2101      	movs	r1, #1
340149d8:	6828      	ldr	r0, [r5, #0]
340149da:	f7f2 fced 	bl	340073b8 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>
340149de:	e7bd      	b.n	3401495c <ISP_SVC_ISP_SetContrast+0x6c>
    return ISP_ERR_CONTRAST_EINVAL;
340149e0:	2028      	movs	r0, #40	@ 0x28
340149e2:	e7f5      	b.n	340149d0 <ISP_SVC_ISP_SetContrast+0xe0>

340149e4 <ISP_SVC_ISP_SetStatArea>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to statistic area used by the IQ algorithms
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatArea(ISP_HandleTypeDef *hIsp, ISP_StatAreaTypeDef *pConfig)
{
340149e4:	b5f0      	push	{r4, r5, r6, r7, lr}
340149e6:	460e      	mov	r6, r1
  HAL_StatusTypeDef halStatus;
  DCMIPP_StatisticExtractionAreaConfTypeDef currentStatAreaCfg;
  ISP_StatusTypeDef ret = ISP_OK;

  if ((hIsp == NULL) || (pConfig == NULL) ||
340149e8:	4605      	mov	r5, r0
{
340149ea:	b085      	sub	sp, #20
  if ((hIsp == NULL) || (pConfig == NULL) ||
340149ec:	2800      	cmp	r0, #0
340149ee:	d041      	beq.n	34014a74 <ISP_SVC_ISP_SetStatArea+0x90>
340149f0:	2900      	cmp	r1, #0
340149f2:	d03f      	beq.n	34014a74 <ISP_SVC_ISP_SetStatArea+0x90>
340149f4:	f640 72fe 	movw	r2, #4094	@ 0xffe
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
340149f8:	6808      	ldr	r0, [r1, #0]
  if ((hIsp == NULL) || (pConfig == NULL) ||
340149fa:	4290      	cmp	r0, r2
340149fc:	d83a      	bhi.n	34014a74 <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
340149fe:	6849      	ldr	r1, [r1, #4]
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
34014a00:	4291      	cmp	r1, r2
34014a02:	d837      	bhi.n	34014a74 <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
34014a04:	68b3      	ldr	r3, [r6, #8]
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
34014a06:	4293      	cmp	r3, r2
34014a08:	d834      	bhi.n	34014a74 <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
34014a0a:	f640 74fa 	movw	r4, #4090	@ 0xffa
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
34014a0e:	68f2      	ldr	r2, [r6, #12]
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
34014a10:	1f17      	subs	r7, r2, #4
34014a12:	42a7      	cmp	r7, r4
34014a14:	d82e      	bhi.n	34014a74 <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
34014a16:	2b03      	cmp	r3, #3
34014a18:	d92c      	bls.n	34014a74 <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->XSize < ISP_STATWINDOW_MIN) ||
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
34014a1a:	6f2f      	ldr	r7, [r5, #112]	@ 0x70
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
34014a1c:	18c4      	adds	r4, r0, r3
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
34014a1e:	42bc      	cmp	r4, r7
34014a20:	d828      	bhi.n	34014a74 <ISP_SVC_ISP_SetStatArea+0x90>
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
34014a22:	6f6f      	ldr	r7, [r5, #116]	@ 0x74
      (pConfig->Y0 + pConfig->YSize > hIsp->sensorInfo.height))
34014a24:	188c      	adds	r4, r1, r2
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
34014a26:	42bc      	cmp	r4, r7
34014a28:	d824      	bhi.n	34014a74 <ISP_SVC_ISP_SetStatArea+0x90>
  {
    return ISP_ERR_STATAREA_EINVAL;
  }

  /* Set coordinates in the 'decimated' referential */
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
34014a2a:	4c13      	ldr	r4, [pc, #76]	@ (34014a78 <ISP_SVC_ISP_SetStatArea+0x94>)
34014a2c:	7824      	ldrb	r4, [r4, #0]
34014a2e:	fbb0 f0f4 	udiv	r0, r0, r4
  currentStatAreaCfg.VStart = pConfig->Y0 / ISP_DecimationValue.factor;
34014a32:	fbb1 f1f4 	udiv	r1, r1, r4
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
  currentStatAreaCfg.VSize = pConfig->YSize / ISP_DecimationValue.factor;
34014a36:	fbb2 f2f4 	udiv	r2, r2, r4
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
34014a3a:	fbb3 f3f4 	udiv	r3, r3, r4
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
34014a3e:	9001      	str	r0, [sp, #4]
  currentStatAreaCfg.VStart = pConfig->Y0 / ISP_DecimationValue.factor;
34014a40:	9100      	str	r1, [sp, #0]
  currentStatAreaCfg.VSize = pConfig->YSize / ISP_DecimationValue.factor;
34014a42:	9202      	str	r2, [sp, #8]

  if (HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1,
34014a44:	2101      	movs	r1, #1
34014a46:	466a      	mov	r2, sp
34014a48:	6828      	ldr	r0, [r5, #0]
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
34014a4a:	9303      	str	r3, [sp, #12]
  if (HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1,
34014a4c:	f7f2 fb18 	bl	34007080 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>
34014a50:	b118      	cbz	r0, 34014a5a <ISP_SVC_ISP_SetStatArea+0x76>
                                                          &currentStatAreaCfg) != HAL_OK)
  {
    return ISP_ERR_STATAREA_HAL;
34014a52:	2433      	movs	r4, #51	@ 0x33

  /* Update internal state */
  hIsp->statArea = *pConfig;

  return ret;
}
34014a54:	4620      	mov	r0, r4
34014a56:	b005      	add	sp, #20
34014a58:	bdf0      	pop	{r4, r5, r6, r7, pc}
    halStatus = HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1);
34014a5a:	2101      	movs	r1, #1
34014a5c:	6828      	ldr	r0, [r5, #0]
34014a5e:	f7f2 fb99 	bl	34007194 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>
  if (halStatus != HAL_OK)
34014a62:	4604      	mov	r4, r0
34014a64:	2800      	cmp	r0, #0
34014a66:	d1f4      	bne.n	34014a52 <ISP_SVC_ISP_SetStatArea+0x6e>
  hIsp->statArea = *pConfig;
34014a68:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
34014a6c:	3508      	adds	r5, #8
34014a6e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  return ret;
34014a72:	e7ef      	b.n	34014a54 <ISP_SVC_ISP_SetStatArea+0x70>
    return ISP_ERR_STATAREA_EINVAL;
34014a74:	2432      	movs	r4, #50	@ 0x32
34014a76:	e7ed      	b.n	34014a54 <ISP_SVC_ISP_SetStatArea+0x70>
34014a78:	340b103a 	.word	0x340b103a

34014a7c <ISP_SVC_ISP_SetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
34014a7c:	b510      	push	{r4, lr}
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) || (pConfig->strength > ISP_BADPIXEL_STRENGTH_MAX))
34014a7e:	4604      	mov	r4, r0
34014a80:	b1a8      	cbz	r0, 34014aae <ISP_SVC_ISP_SetBadPixel+0x32>
34014a82:	b1a1      	cbz	r1, 34014aae <ISP_SVC_ISP_SetBadPixel+0x32>
34014a84:	784a      	ldrb	r2, [r1, #1]
34014a86:	2a07      	cmp	r2, #7
34014a88:	d811      	bhi.n	34014aae <ISP_SVC_ISP_SetBadPixel+0x32>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
  }

  if (pConfig->enable == 0)
34014a8a:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
34014a8c:	6800      	ldr	r0, [r0, #0]
34014a8e:	2101      	movs	r1, #1
  if (pConfig->enable == 0)
34014a90:	b91b      	cbnz	r3, 34014a9a <ISP_SVC_ISP_SetBadPixel+0x1e>
    halStatus = HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
34014a92:	f7f2 f823 	bl	34006adc <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>
    }

    halStatus = HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
  }

  if (halStatus != HAL_OK)
34014a96:	b120      	cbz	r0, 34014aa2 <ISP_SVC_ISP_SetBadPixel+0x26>
34014a98:	e002      	b.n	34014aa0 <ISP_SVC_ISP_SetBadPixel+0x24>
    halStatus = HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->strength);
34014a9a:	f7f1 ffdf 	bl	34006a5c <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>
    if (halStatus != HAL_OK)
34014a9e:	b108      	cbz	r0, 34014aa4 <ISP_SVC_ISP_SetBadPixel+0x28>
      return ISP_ERR_BADPIXEL_HAL;
34014aa0:	203d      	movs	r0, #61	@ 0x3d
  {
    return ISP_ERR_BADPIXEL_HAL;
  }

  return ISP_OK;
}
34014aa2:	bd10      	pop	{r4, pc}
    halStatus = HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
34014aa4:	2101      	movs	r1, #1
34014aa6:	6820      	ldr	r0, [r4, #0]
34014aa8:	f7f2 f800 	bl	34006aac <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>
34014aac:	e7f3      	b.n	34014a96 <ISP_SVC_ISP_SetBadPixel+0x1a>
    return ISP_ERR_BADPIXEL_EINVAL;
34014aae:	203c      	movs	r0, #60	@ 0x3c
34014ab0:	e7f7      	b.n	34014aa2 <ISP_SVC_ISP_SetBadPixel+0x26>

34014ab2 <ISP_SVC_ISP_GetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
34014ab2:	b538      	push	{r3, r4, r5, lr}
34014ab4:	460d      	mov	r5, r1
  HAL_StatusTypeDef halStatus;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014ab6:	4604      	mov	r4, r0
34014ab8:	b198      	cbz	r0, 34014ae2 <ISP_SVC_ISP_GetBadPixel+0x30>
34014aba:	b191      	cbz	r1, 34014ae2 <ISP_SVC_ISP_GetBadPixel+0x30>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
34014abc:	2101      	movs	r1, #1
34014abe:	6800      	ldr	r0, [r0, #0]
34014ac0:	f7f2 f836 	bl	34006b30 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>
34014ac4:	7028      	strb	r0, [r5, #0]
  pConfig->strength = (uint8_t) HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1);
34014ac6:	2101      	movs	r1, #1
34014ac8:	6820      	ldr	r0, [r4, #0]
34014aca:	f7f2 f81f 	bl	34006b0c <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>
34014ace:	7068      	strb	r0, [r5, #1]

  halStatus = HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter(hIsp->hDcmipp, DCMIPP_PIPE1, &pConfig->count);
34014ad0:	2101      	movs	r1, #1
34014ad2:	6820      	ldr	r0, [r4, #0]
34014ad4:	1d2a      	adds	r2, r5, #4
34014ad6:	f7f2 f851 	bl	34006b7c <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>

  if (halStatus != HAL_OK)
  {
    return ISP_ERR_BADPIXEL_HAL;
34014ada:	2800      	cmp	r0, #0
34014adc:	bf18      	it	ne
34014ade:	203d      	movne	r0, #61	@ 0x3d
  }

  return ISP_OK;
}
34014ae0:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_BADPIXEL_EINVAL;
34014ae2:	203c      	movs	r0, #60	@ 0x3c
34014ae4:	e7fc      	b.n	34014ae0 <ISP_SVC_ISP_GetBadPixel+0x2e>

34014ae6 <ISP_SVC_ISP_SetBlackLevel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the black level configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBlackLevel(ISP_HandleTypeDef *hIsp, ISP_BlackLevelTypeDef *pConfig)
{
34014ae6:	b513      	push	{r0, r1, r4, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_BlackLevelConfTypeDef blackLevelConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014ae8:	4604      	mov	r4, r0
34014aea:	b1f0      	cbz	r0, 34014b2a <ISP_SVC_ISP_SetBlackLevel+0x44>
34014aec:	b1e9      	cbz	r1, 34014b2a <ISP_SVC_ISP_SetBlackLevel+0x44>
  {
    return ISP_ERR_BLACKLEVEL_EINVAL;
  }

  if (pConfig->enable == 0)
34014aee:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
34014af0:	6800      	ldr	r0, [r0, #0]
  if (pConfig->enable == 0)
34014af2:	b923      	cbnz	r3, 34014afe <ISP_SVC_ISP_SetBlackLevel+0x18>
    halStatus = HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
34014af4:	2101      	movs	r1, #1
34014af6:	f7f2 fa09 	bl	34006f0c <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
34014afa:	b178      	cbz	r0, 34014b1c <ISP_SVC_ISP_SetBlackLevel+0x36>
34014afc:	e00d      	b.n	34014b1a <ISP_SVC_ISP_SetBlackLevel+0x34>
    blackLevelConfig.RedCompBlackLevel = pConfig->BLCR;
34014afe:	784b      	ldrb	r3, [r1, #1]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
34014b00:	aa01      	add	r2, sp, #4
    blackLevelConfig.RedCompBlackLevel = pConfig->BLCR;
34014b02:	f88d 3004 	strb.w	r3, [sp, #4]
    blackLevelConfig.GreenCompBlackLevel = pConfig->BLCG;
34014b06:	788b      	ldrb	r3, [r1, #2]
34014b08:	f88d 3005 	strb.w	r3, [sp, #5]
    blackLevelConfig.BlueCompBlackLevel = pConfig->BLCB;
34014b0c:	78cb      	ldrb	r3, [r1, #3]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
34014b0e:	2101      	movs	r1, #1
    blackLevelConfig.BlueCompBlackLevel = pConfig->BLCB;
34014b10:	f88d 3006 	strb.w	r3, [sp, #6]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
34014b14:	f7f2 f9c0 	bl	34006e98 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>
    if (halStatus == HAL_OK)
34014b18:	b110      	cbz	r0, 34014b20 <ISP_SVC_ISP_SetBlackLevel+0x3a>
  {
    return ISP_ERR_BLACKLEVEL_HAL;
34014b1a:	2047      	movs	r0, #71	@ 0x47
  }

  return ISP_OK;
}
34014b1c:	b002      	add	sp, #8
34014b1e:	bd10      	pop	{r4, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
34014b20:	2101      	movs	r1, #1
34014b22:	6820      	ldr	r0, [r4, #0]
34014b24:	f7f2 f9da 	bl	34006edc <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>
34014b28:	e7e7      	b.n	34014afa <ISP_SVC_ISP_SetBlackLevel+0x14>
    return ISP_ERR_BLACKLEVEL_EINVAL;
34014b2a:	2046      	movs	r0, #70	@ 0x46
34014b2c:	e7f6      	b.n	34014b1c <ISP_SVC_ISP_SetBlackLevel+0x36>

34014b2e <ISP_SVC_ISP_GetBlackLevel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the black level configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetBlackLevel(ISP_HandleTypeDef *hIsp, ISP_BlackLevelTypeDef *pConfig)
{
34014b2e:	b537      	push	{r0, r1, r2, r4, r5, lr}
34014b30:	460c      	mov	r4, r1
  DCMIPP_BlackLevelConfTypeDef blackLevelConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014b32:	4605      	mov	r5, r0
34014b34:	b1b0      	cbz	r0, 34014b64 <ISP_SVC_ISP_GetBlackLevel+0x36>
34014b36:	b1a9      	cbz	r1, 34014b64 <ISP_SVC_ISP_GetBlackLevel+0x36>
  {
    return ISP_ERR_BLACKLEVEL_EINVAL;
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
34014b38:	2101      	movs	r1, #1
34014b3a:	6800      	ldr	r0, [r0, #0]
34014b3c:	f7f2 fa14 	bl	34006f68 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration>
34014b40:	7020      	strb	r0, [r4, #0]

  HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
34014b42:	6828      	ldr	r0, [r5, #0]
34014b44:	2101      	movs	r1, #1
34014b46:	aa01      	add	r2, sp, #4
34014b48:	f7f2 f9f8 	bl	34006f3c <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig>

  pConfig->BLCR = blackLevelConfig.RedCompBlackLevel;
  pConfig->BLCG = blackLevelConfig.GreenCompBlackLevel;
  pConfig->BLCB = blackLevelConfig.BlueCompBlackLevel;

  return ISP_OK;
34014b4c:	2000      	movs	r0, #0
  pConfig->BLCR = blackLevelConfig.RedCompBlackLevel;
34014b4e:	f89d 3004 	ldrb.w	r3, [sp, #4]
34014b52:	7063      	strb	r3, [r4, #1]
  pConfig->BLCG = blackLevelConfig.GreenCompBlackLevel;
34014b54:	f89d 3005 	ldrb.w	r3, [sp, #5]
34014b58:	70a3      	strb	r3, [r4, #2]
  pConfig->BLCB = blackLevelConfig.BlueCompBlackLevel;
34014b5a:	f89d 3006 	ldrb.w	r3, [sp, #6]
34014b5e:	70e3      	strb	r3, [r4, #3]
}
34014b60:	b003      	add	sp, #12
34014b62:	bd30      	pop	{r4, r5, pc}
    return ISP_ERR_BLACKLEVEL_EINVAL;
34014b64:	2046      	movs	r0, #70	@ 0x46
34014b66:	e7fb      	b.n	34014b60 <ISP_SVC_ISP_GetBlackLevel+0x32>

34014b68 <ISP_SVC_ISP_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGain(ISP_HandleTypeDef *hIsp, ISP_ISPGainTypeDef *pConfig)
{
34014b68:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_ExposureConfTypeDef exposureConfig;

  if ((hIsp == NULL) || (pConfig == NULL) ||
34014b6c:	4605      	mov	r5, r0
34014b6e:	2800      	cmp	r0, #0
34014b70:	f000 808b 	beq.w	34014c8a <ISP_SVC_ISP_SetGain+0x122>
34014b74:	2900      	cmp	r1, #0
34014b76:	f000 8088 	beq.w	34014c8a <ISP_SVC_ISP_SetGain+0x122>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
34014b7a:	684a      	ldr	r2, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34014b7c:	4b46      	ldr	r3, [pc, #280]	@ (34014c98 <ISP_SVC_ISP_SetGain+0x130>)
34014b7e:	429a      	cmp	r2, r3
34014b80:	f200 8083 	bhi.w	34014c8a <ISP_SVC_ISP_SetGain+0x122>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
34014b84:	f8d1 8008 	ldr.w	r8, [r1, #8]
34014b88:	4598      	cmp	r8, r3
34014b8a:	d87e      	bhi.n	34014c8a <ISP_SVC_ISP_SetGain+0x122>
34014b8c:	68cf      	ldr	r7, [r1, #12]
34014b8e:	429f      	cmp	r7, r3
34014b90:	d87b      	bhi.n	34014c8a <ISP_SVC_ISP_SetGain+0x122>
  {
    return ISP_ERR_ISPGAIN_EINVAL;
  }

  if (pConfig->enable == 0)
34014b92:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
34014b94:	6806      	ldr	r6, [r0, #0]
  if (pConfig->enable == 0)
34014b96:	b933      	cbnz	r3, 34014ba6 <ISP_SVC_ISP_SetGain+0x3e>
    halStatus = HAL_DCMIPP_PIPE_DisableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
34014b98:	2101      	movs	r1, #1
34014b9a:	4630      	mov	r0, r6
34014b9c:	f7f2 fb72 	bl	34007284 <HAL_DCMIPP_PIPE_DisableISPExposure>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
34014ba0:	2800      	cmp	r0, #0
34014ba2:	d05b      	beq.n	34014c5c <ISP_SVC_ISP_SetGain+0xf4>
34014ba4:	e059      	b.n	34014c5a <ISP_SVC_ISP_SetGain+0xf2>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014ba6:	2400      	movs	r4, #0
34014ba8:	4610      	mov	r0, r2
34014baa:	a339      	add	r3, pc, #228	@ (adr r3, 34014c90 <ISP_SVC_ISP_SetGain+0x128>)
34014bac:	e9d3 2300 	ldrd	r2, r3, [r3]
34014bb0:	4621      	mov	r1, r4
34014bb2:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
34014bb6:	f7ec fe19 	bl	340017ec <__aeabi_uldivmod>
  while (Val >= 256)
34014bba:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014bbc:	4682      	mov	sl, r0
34014bbe:	468b      	mov	fp, r1
  while (Val >= 256)
34014bc0:	4622      	mov	r2, r4
34014bc2:	f5ba 7f80 	cmp.w	sl, #256	@ 0x100
34014bc6:	f17b 0000 	sbcs.w	r0, fp, #0
34014bca:	f103 0101 	add.w	r1, r3, #1
34014bce:	d248      	bcs.n	34014c62 <ISP_SVC_ISP_SetGain+0xfa>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014bd0:	2400      	movs	r4, #0
  *pShift = 0;
34014bd2:	2a00      	cmp	r2, #0
34014bd4:	bf08      	it	eq
34014bd6:	4613      	moveq	r3, r2
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014bd8:	4640      	mov	r0, r8
34014bda:	4621      	mov	r1, r4
  *pShift = 0;
34014bdc:	f88d 3000 	strb.w	r3, [sp]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014be0:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
34014be4:	a32a      	add	r3, pc, #168	@ (adr r3, 34014c90 <ISP_SVC_ISP_SetGain+0x128>)
34014be6:	e9d3 2300 	ldrd	r2, r3, [r3]
  *pMultiplier = (uint8_t)Val;
34014bea:	f88d a001 	strb.w	sl, [sp, #1]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014bee:	f7ec fdfd 	bl	340017ec <__aeabi_uldivmod>
  while (Val >= 256)
34014bf2:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014bf4:	4680      	mov	r8, r0
34014bf6:	4689      	mov	r9, r1
  while (Val >= 256)
34014bf8:	4622      	mov	r2, r4
34014bfa:	f5b8 7f80 	cmp.w	r8, #256	@ 0x100
34014bfe:	f179 0000 	sbcs.w	r0, r9, #0
34014c02:	f103 0101 	add.w	r1, r3, #1
34014c06:	d231      	bcs.n	34014c6c <ISP_SVC_ISP_SetGain+0x104>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014c08:	2400      	movs	r4, #0
  *pShift = 0;
34014c0a:	2a00      	cmp	r2, #0
34014c0c:	bf08      	it	eq
34014c0e:	4613      	moveq	r3, r2
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014c10:	4638      	mov	r0, r7
34014c12:	4621      	mov	r1, r4
  *pShift = 0;
34014c14:	f88d 3002 	strb.w	r3, [sp, #2]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014c18:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
34014c1c:	a31c      	add	r3, pc, #112	@ (adr r3, 34014c90 <ISP_SVC_ISP_SetGain+0x128>)
34014c1e:	e9d3 2300 	ldrd	r2, r3, [r3]
  *pMultiplier = (uint8_t)Val;
34014c22:	f88d 8003 	strb.w	r8, [sp, #3]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014c26:	f7ec fde1 	bl	340017ec <__aeabi_uldivmod>
  while (Val >= 256)
34014c2a:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014c2c:	4680      	mov	r8, r0
34014c2e:	4689      	mov	r9, r1
  while (Val >= 256)
34014c30:	4622      	mov	r2, r4
34014c32:	f5b8 7f80 	cmp.w	r8, #256	@ 0x100
34014c36:	f179 0000 	sbcs.w	r0, r9, #0
34014c3a:	f103 0101 	add.w	r1, r3, #1
34014c3e:	d21a      	bcs.n	34014c76 <ISP_SVC_ISP_SetGain+0x10e>
  *pShift = 0;
34014c40:	2a00      	cmp	r2, #0
34014c42:	bf08      	it	eq
34014c44:	4613      	moveq	r3, r2
    halStatus = HAL_DCMIPP_PIPE_SetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
34014c46:	2101      	movs	r1, #1
34014c48:	466a      	mov	r2, sp
34014c4a:	4630      	mov	r0, r6
  *pShift = 0;
34014c4c:	f88d 3004 	strb.w	r3, [sp, #4]
  *pMultiplier = (uint8_t)Val;
34014c50:	f88d 8005 	strb.w	r8, [sp, #5]
    halStatus = HAL_DCMIPP_PIPE_SetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
34014c54:	f7f2 fab6 	bl	340071c4 <HAL_DCMIPP_PIPE_SetISPExposureConfig>
    if (halStatus == HAL_OK)
34014c58:	b190      	cbz	r0, 34014c80 <ISP_SVC_ISP_SetGain+0x118>
  {
    return ISP_ERR_ISPGAIN_HAL;
34014c5a:	2051      	movs	r0, #81	@ 0x51
  }

  return ISP_OK;
}
34014c5c:	b003      	add	sp, #12
34014c5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Val /= 2;
34014c62:	ea5a 0b5f 	orrs.w	fp, sl, pc, lsr #1
34014c66:	460b      	mov	r3, r1
34014c68:	2201      	movs	r2, #1
34014c6a:	e7aa      	b.n	34014bc2 <ISP_SVC_ISP_SetGain+0x5a>
34014c6c:	ea58 095f 	orrs.w	r9, r8, pc, lsr #1
34014c70:	460b      	mov	r3, r1
34014c72:	2201      	movs	r2, #1
34014c74:	e7c1      	b.n	34014bfa <ISP_SVC_ISP_SetGain+0x92>
34014c76:	ea58 095f 	orrs.w	r9, r8, pc, lsr #1
34014c7a:	460b      	mov	r3, r1
34014c7c:	2201      	movs	r2, #1
34014c7e:	e7d8      	b.n	34014c32 <ISP_SVC_ISP_SetGain+0xca>
      halStatus = HAL_DCMIPP_PIPE_EnableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
34014c80:	2101      	movs	r1, #1
34014c82:	6828      	ldr	r0, [r5, #0]
34014c84:	f7f2 fae6 	bl	34007254 <HAL_DCMIPP_PIPE_EnableISPExposure>
34014c88:	e78a      	b.n	34014ba0 <ISP_SVC_ISP_SetGain+0x38>
    return ISP_ERR_ISPGAIN_EINVAL;
34014c8a:	2050      	movs	r0, #80	@ 0x50
34014c8c:	e7e6      	b.n	34014c5c <ISP_SVC_ISP_SetGain+0xf4>
34014c8e:	bf00      	nop
34014c90:	05f5e100 	.word	0x05f5e100
34014c94:	00000000 	.word	0x00000000
34014c98:	5f5e1000 	.word	0x5f5e1000

34014c9c <ISP_SVC_ISP_GetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetGain(ISP_HandleTypeDef *hIsp, ISP_ISPGainTypeDef *pConfig)
{
34014c9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34014c9e:	460c      	mov	r4, r1
  DCMIPP_ExposureConfTypeDef exposureConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014ca0:	4605      	mov	r5, r0
34014ca2:	2800      	cmp	r0, #0
34014ca4:	d03f      	beq.n	34014d26 <ISP_SVC_ISP_GetGain+0x8a>
34014ca6:	2900      	cmp	r1, #0
34014ca8:	d03d      	beq.n	34014d26 <ISP_SVC_ISP_GetGain+0x8a>
  {
    return ISP_ERR_ISPGAIN_EINVAL;
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
34014caa:	2101      	movs	r1, #1
34014cac:	6800      	ldr	r0, [r0, #0]
34014cae:	f7f2 fd77 	bl	340077a0 <HAL_DCMIPP_PIPE_IsEnabledISPExposure>
34014cb2:	7020      	strb	r0, [r4, #0]
  HAL_DCMIPP_PIPE_GetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
34014cb4:	6828      	ldr	r0, [r5, #0]
34014cb6:	466a      	mov	r2, sp
34014cb8:	2101      	movs	r1, #1
34014cba:	f7f2 fcaf 	bl	3400761c <HAL_DCMIPP_PIPE_GetISPExposureConfig>
  uint64_t Val = (1 << Shift);
34014cbe:	2301      	movs	r3, #1
34014cc0:	f89d 1000 	ldrb.w	r1, [sp]
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
34014cc4:	f89d 2001 	ldrb.w	r2, [sp, #1]
  uint64_t Val = (1 << Shift);
34014cc8:	fa03 f101 	lsl.w	r1, r3, r1
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
34014ccc:	fb81 1002 	smull	r1, r0, r1, r2
34014cd0:	4a16      	ldr	r2, [pc, #88]	@ (34014d2c <ISP_SVC_ISP_GetGain+0x90>)
34014cd2:	fba1 1502 	umull	r1, r5, r1, r2
34014cd6:	460e      	mov	r6, r1
34014cd8:	fb02 5700 	mla	r7, r2, r0, r5
34014cdc:	ea56 17df 	orrs.w	r7, r6, pc, lsr #7
  uint64_t Val = (1 << Shift);
34014ce0:	f89d 0002 	ldrb.w	r0, [sp, #2]
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
34014ce4:	f89d 1003 	ldrb.w	r1, [sp, #3]
  uint64_t Val = (1 << Shift);
34014ce8:	fa03 f000 	lsl.w	r0, r3, r0
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
34014cec:	fb80 0101 	smull	r0, r1, r0, r1
34014cf0:	fba0 0502 	umull	r0, r5, r0, r2
  return (uint32_t) Val;
34014cf4:	6066      	str	r6, [r4, #4]
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
34014cf6:	4606      	mov	r6, r0
34014cf8:	fb02 5701 	mla	r7, r2, r1, r5
34014cfc:	ea56 17df 	orrs.w	r7, r6, pc, lsr #7
  uint64_t Val = (1 << Shift);
34014d00:	f89d 1004 	ldrb.w	r1, [sp, #4]
  return (uint32_t) Val;
34014d04:	60a6      	str	r6, [r4, #8]
  uint64_t Val = (1 << Shift);
34014d06:	408b      	lsls	r3, r1
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
34014d08:	f89d 1005 	ldrb.w	r1, [sp, #5]
34014d0c:	fb83 3501 	smull	r3, r5, r3, r1
34014d10:	fba3 3602 	umull	r3, r6, r3, r2
34014d14:	4618      	mov	r0, r3
34014d16:	fb02 6105 	mla	r1, r2, r5, r6
34014d1a:	ea50 11df 	orrs.w	r1, r0, pc, lsr #7
  return (uint32_t) Val;
34014d1e:	60e0      	str	r0, [r4, #12]

  pConfig->ispGainR = From_Shift_Multiplier(exposureConfig.ShiftRed, exposureConfig.MultiplierRed);
  pConfig->ispGainG = From_Shift_Multiplier(exposureConfig.ShiftGreen, exposureConfig.MultiplierGreen);
  pConfig->ispGainB = From_Shift_Multiplier(exposureConfig.ShiftBlue, exposureConfig.MultiplierBlue);

  return ISP_OK;
34014d20:	2000      	movs	r0, #0
}
34014d22:	b003      	add	sp, #12
34014d24:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ISP_ERR_ISPGAIN_EINVAL;
34014d26:	2050      	movs	r0, #80	@ 0x50
34014d28:	e7fb      	b.n	34014d22 <ISP_SVC_ISP_GetGain+0x86>
34014d2a:	bf00      	nop
34014d2c:	05f5e100 	.word	0x05f5e100

34014d30 <ISP_SVC_ISP_SetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
34014d30:	b570      	push	{r4, r5, r6, lr}
34014d32:	4605      	mov	r5, r0
34014d34:	b088      	sub	sp, #32
34014d36:	460c      	mov	r4, r1
  HAL_StatusTypeDef halStatus;
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;
  uint32_t i, j;

  memset(&colorConvConfig, 0, sizeof(colorConvConfig));
34014d38:	221a      	movs	r2, #26
34014d3a:	2100      	movs	r1, #0
34014d3c:	a801      	add	r0, sp, #4
34014d3e:	f005 f9f1 	bl	3401a124 <memset>

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014d42:	b16d      	cbz	r5, 34014d60 <ISP_SVC_ISP_SetColorConv+0x30>
34014d44:	b164      	cbz	r4, 34014d60 <ISP_SVC_ISP_SetColorConv+0x30>
34014d46:	4623      	mov	r3, r4

  for (i = 0; i < 3; i++)
  {
    for (j = 0; j < 3; j++)
    {
      if ((pConfig->coeff[i][j] > ISP_COLORCONV_MAX) || (pConfig->coeff[i][j] < -ISP_COLORCONV_MAX))
34014d48:	483a      	ldr	r0, [pc, #232]	@ (34014e34 <ISP_SVC_ISP_SetColorConv+0x104>)
34014d4a:	4a3b      	ldr	r2, [pc, #236]	@ (34014e38 <ISP_SVC_ISP_SetColorConv+0x108>)
34014d4c:	f104 0624 	add.w	r6, r4, #36	@ 0x24
34014d50:	6859      	ldr	r1, [r3, #4]
34014d52:	4401      	add	r1, r0
34014d54:	4291      	cmp	r1, r2
34014d56:	d803      	bhi.n	34014d60 <ISP_SVC_ISP_SetColorConv+0x30>
34014d58:	6899      	ldr	r1, [r3, #8]
34014d5a:	4401      	add	r1, r0
34014d5c:	4291      	cmp	r1, r2
34014d5e:	d901      	bls.n	34014d64 <ISP_SVC_ISP_SetColorConv+0x34>
    return ISP_ERR_COLORCONV_EINVAL;
34014d60:	205a      	movs	r0, #90	@ 0x5a
34014d62:	e05f      	b.n	34014e24 <ISP_SVC_ISP_SetColorConv+0xf4>
      if ((pConfig->coeff[i][j] > ISP_COLORCONV_MAX) || (pConfig->coeff[i][j] < -ISP_COLORCONV_MAX))
34014d64:	68d9      	ldr	r1, [r3, #12]
34014d66:	4401      	add	r1, r0
34014d68:	4291      	cmp	r1, r2
34014d6a:	d8f9      	bhi.n	34014d60 <ISP_SVC_ISP_SetColorConv+0x30>
  for (i = 0; i < 3; i++)
34014d6c:	330c      	adds	r3, #12
34014d6e:	42b3      	cmp	r3, r6
34014d70:	d1ee      	bne.n	34014d50 <ISP_SVC_ISP_SetColorConv+0x20>
        return ISP_ERR_COLORCONV_EINVAL;
      }
    }
  }

  if (pConfig->enable == 0)
34014d72:	7823      	ldrb	r3, [r4, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34014d74:	682e      	ldr	r6, [r5, #0]
  if (pConfig->enable == 0)
34014d76:	b933      	cbnz	r3, 34014d86 <ISP_SVC_ISP_SetColorConv+0x56>
    halStatus = HAL_DCMIPP_PIPE_DisableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34014d78:	2101      	movs	r1, #1
34014d7a:	4630      	mov	r0, r6
34014d7c:	f7f2 f874 	bl	34006e68 <HAL_DCMIPP_PIPE_DisableISPColorConversion>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
34014d80:	2800      	cmp	r0, #0
34014d82:	d04f      	beq.n	34014e24 <ISP_SVC_ISP_SetColorConv+0xf4>
34014d84:	e04d      	b.n	34014e22 <ISP_SVC_ISP_SetColorConv+0xf2>
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014d86:	6860      	ldr	r0, [r4, #4]
34014d88:	2300      	movs	r3, #0
34014d8a:	4a2c      	ldr	r2, [pc, #176]	@ (34014e3c <ISP_SVC_ISP_SetColorConv+0x10c>)
34014d8c:	17c1      	asrs	r1, r0, #31
34014d8e:	f7ec fcdd 	bl	3400174c <__aeabi_ldivmod>
  return (int16_t) Val;
34014d92:	f8ad 0006 	strh.w	r0, [sp, #6]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014d96:	68a0      	ldr	r0, [r4, #8]
34014d98:	2300      	movs	r3, #0
34014d9a:	4a28      	ldr	r2, [pc, #160]	@ (34014e3c <ISP_SVC_ISP_SetColorConv+0x10c>)
34014d9c:	17c1      	asrs	r1, r0, #31
34014d9e:	f7ec fcd5 	bl	3400174c <__aeabi_ldivmod>
  return (int16_t) Val;
34014da2:	f8ad 0008 	strh.w	r0, [sp, #8]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014da6:	68e0      	ldr	r0, [r4, #12]
34014da8:	2300      	movs	r3, #0
34014daa:	4a24      	ldr	r2, [pc, #144]	@ (34014e3c <ISP_SVC_ISP_SetColorConv+0x10c>)
34014dac:	17c1      	asrs	r1, r0, #31
34014dae:	f7ec fccd 	bl	3400174c <__aeabi_ldivmod>
  return (int16_t) Val;
34014db2:	f8ad 000a 	strh.w	r0, [sp, #10]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014db6:	6920      	ldr	r0, [r4, #16]
34014db8:	2300      	movs	r3, #0
34014dba:	4a20      	ldr	r2, [pc, #128]	@ (34014e3c <ISP_SVC_ISP_SetColorConv+0x10c>)
34014dbc:	17c1      	asrs	r1, r0, #31
34014dbe:	f7ec fcc5 	bl	3400174c <__aeabi_ldivmod>
  return (int16_t) Val;
34014dc2:	f8ad 000e 	strh.w	r0, [sp, #14]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014dc6:	6960      	ldr	r0, [r4, #20]
34014dc8:	2300      	movs	r3, #0
34014dca:	4a1c      	ldr	r2, [pc, #112]	@ (34014e3c <ISP_SVC_ISP_SetColorConv+0x10c>)
34014dcc:	17c1      	asrs	r1, r0, #31
34014dce:	f7ec fcbd 	bl	3400174c <__aeabi_ldivmod>
  return (int16_t) Val;
34014dd2:	f8ad 0010 	strh.w	r0, [sp, #16]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014dd6:	69a0      	ldr	r0, [r4, #24]
34014dd8:	2300      	movs	r3, #0
34014dda:	4a18      	ldr	r2, [pc, #96]	@ (34014e3c <ISP_SVC_ISP_SetColorConv+0x10c>)
34014ddc:	17c1      	asrs	r1, r0, #31
34014dde:	f7ec fcb5 	bl	3400174c <__aeabi_ldivmod>
  return (int16_t) Val;
34014de2:	f8ad 0012 	strh.w	r0, [sp, #18]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014de6:	69e0      	ldr	r0, [r4, #28]
34014de8:	2300      	movs	r3, #0
34014dea:	4a14      	ldr	r2, [pc, #80]	@ (34014e3c <ISP_SVC_ISP_SetColorConv+0x10c>)
34014dec:	17c1      	asrs	r1, r0, #31
34014dee:	f7ec fcad 	bl	3400174c <__aeabi_ldivmod>
  return (int16_t) Val;
34014df2:	f8ad 0016 	strh.w	r0, [sp, #22]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014df6:	6a20      	ldr	r0, [r4, #32]
34014df8:	2300      	movs	r3, #0
34014dfa:	4a10      	ldr	r2, [pc, #64]	@ (34014e3c <ISP_SVC_ISP_SetColorConv+0x10c>)
34014dfc:	17c1      	asrs	r1, r0, #31
34014dfe:	f7ec fca5 	bl	3400174c <__aeabi_ldivmod>
  return (int16_t) Val;
34014e02:	f8ad 0018 	strh.w	r0, [sp, #24]
  int64_t Val = Coeff;
34014e06:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014e08:	4a0c      	ldr	r2, [pc, #48]	@ (34014e3c <ISP_SVC_ISP_SetColorConv+0x10c>)
34014e0a:	2300      	movs	r3, #0
34014e0c:	17c1      	asrs	r1, r0, #31
34014e0e:	f7ec fc9d 	bl	3400174c <__aeabi_ldivmod>
    halStatus = HAL_DCMIPP_PIPE_SetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
34014e12:	2101      	movs	r1, #1
  return (int16_t) Val;
34014e14:	f8ad 001a 	strh.w	r0, [sp, #26]
    halStatus = HAL_DCMIPP_PIPE_SetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
34014e18:	aa01      	add	r2, sp, #4
34014e1a:	4630      	mov	r0, r6
34014e1c:	f7f1 feca 	bl	34006bb4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>
    if (halStatus == HAL_OK)
34014e20:	b110      	cbz	r0, 34014e28 <ISP_SVC_ISP_SetColorConv+0xf8>
  {
    return ISP_ERR_COLORCONV_HAL;
34014e22:	205b      	movs	r0, #91	@ 0x5b
  }

  return ISP_OK;
}
34014e24:	b008      	add	sp, #32
34014e26:	bd70      	pop	{r4, r5, r6, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34014e28:	2101      	movs	r1, #1
34014e2a:	6828      	ldr	r0, [r5, #0]
34014e2c:	f7f2 f804 	bl	34006e38 <HAL_DCMIPP_PIPE_EnableISPColorConversion>
34014e30:	e7a6      	b.n	34014d80 <ISP_SVC_ISP_SetColorConv+0x50>
34014e32:	bf00      	nop
34014e34:	17c841c0 	.word	0x17c841c0
34014e38:	2f908380 	.word	0x2f908380
34014e3c:	0005f5e1 	.word	0x0005f5e1

34014e40 <ISP_SVC_ISP_GetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
34014e40:	b530      	push	{r4, r5, lr}
34014e42:	460c      	mov	r4, r1
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014e44:	4605      	mov	r5, r0
{
34014e46:	b089      	sub	sp, #36	@ 0x24
  if ((hIsp == NULL) || (pConfig == NULL))
34014e48:	2800      	cmp	r0, #0
34014e4a:	d03c      	beq.n	34014ec6 <ISP_SVC_ISP_GetColorConv+0x86>
34014e4c:	2900      	cmp	r1, #0
34014e4e:	d03a      	beq.n	34014ec6 <ISP_SVC_ISP_GetColorConv+0x86>
  {
    return ISP_ERR_COLORCONV_EINVAL;
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34014e50:	2101      	movs	r1, #1
34014e52:	6800      	ldr	r0, [r0, #0]
34014e54:	f7f2 fcca 	bl	340077ec <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>
34014e58:	7020      	strb	r0, [r4, #0]

  HAL_DCMIPP_PIPE_GetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
34014e5a:	2101      	movs	r1, #1
34014e5c:	6828      	ldr	r0, [r5, #0]
34014e5e:	aa01      	add	r2, sp, #4
34014e60:	f7f2 fbfc 	bl	3400765c <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014e64:	4b19      	ldr	r3, [pc, #100]	@ (34014ecc <ISP_SVC_ISP_GetColorConv+0x8c>)
  int64_t Val = Reg;
34014e66:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
  pConfig->coeff[1][2] = From_CConv_Reg(colorConvConfig.GB);
  pConfig->coeff[2][0] = From_CConv_Reg(colorConvConfig.BR);
  pConfig->coeff[2][1] = From_CConv_Reg(colorConvConfig.BG);
  pConfig->coeff[2][2] = From_CConv_Reg(colorConvConfig.BB);

  return ISP_OK;
34014e6a:	2000      	movs	r0, #0
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014e6c:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014e70:	6062      	str	r2, [r4, #4]
  int64_t Val = Reg;
34014e72:	f9bd 2008 	ldrsh.w	r2, [sp, #8]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014e76:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014e7a:	60a2      	str	r2, [r4, #8]
  int64_t Val = Reg;
34014e7c:	f9bd 200a 	ldrsh.w	r2, [sp, #10]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014e80:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014e84:	60e2      	str	r2, [r4, #12]
  int64_t Val = Reg;
34014e86:	f9bd 200e 	ldrsh.w	r2, [sp, #14]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014e8a:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014e8e:	6122      	str	r2, [r4, #16]
  int64_t Val = Reg;
34014e90:	f9bd 2010 	ldrsh.w	r2, [sp, #16]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014e94:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014e98:	6162      	str	r2, [r4, #20]
  int64_t Val = Reg;
34014e9a:	f9bd 2012 	ldrsh.w	r2, [sp, #18]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014e9e:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014ea2:	61a2      	str	r2, [r4, #24]
  int64_t Val = Reg;
34014ea4:	f9bd 2016 	ldrsh.w	r2, [sp, #22]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014ea8:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014eac:	61e2      	str	r2, [r4, #28]
  int64_t Val = Reg;
34014eae:	f9bd 2018 	ldrsh.w	r2, [sp, #24]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014eb2:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014eb6:	6222      	str	r2, [r4, #32]
  int64_t Val = Reg;
34014eb8:	f9bd 201a 	ldrsh.w	r2, [sp, #26]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014ebc:	fba2 2303 	umull	r2, r3, r2, r3
  return (int32_t) Val;
34014ec0:	6262      	str	r2, [r4, #36]	@ 0x24
}
34014ec2:	b009      	add	sp, #36	@ 0x24
34014ec4:	bd30      	pop	{r4, r5, pc}
    return ISP_ERR_COLORCONV_EINVAL;
34014ec6:	205a      	movs	r0, #90	@ 0x5a
34014ec8:	e7fb      	b.n	34014ec2 <ISP_SVC_ISP_GetColorConv+0x82>
34014eca:	bf00      	nop
34014ecc:	0005f5e1 	.word	0x0005f5e1

34014ed0 <ISP_SVC_Sensor_GetInfo>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor info
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetInfo(ISP_HandleTypeDef *hIsp, ISP_SensorInfoTypeDef *pConfig)
{
34014ed0:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014ed2:	b138      	cbz	r0, 34014ee4 <ISP_SVC_Sensor_GetInfo+0x14>
34014ed4:	b131      	cbz	r1, 34014ee4 <ISP_SVC_Sensor_GetInfo+0x14>
  {
    return ISP_ERR_SENSORINFO_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorInfo != NULL)
34014ed6:	6a83      	ldr	r3, [r0, #40]	@ 0x28
34014ed8:	b113      	cbz	r3, 34014ee0 <ISP_SVC_Sensor_GetInfo+0x10>
  {
    if (hIsp->appliHelpers.GetSensorInfo(hIsp->cameraInstance, pConfig) != 0)
34014eda:	6840      	ldr	r0, [r0, #4]
34014edc:	4798      	blx	r3
34014ede:	b918      	cbnz	r0, 34014ee8 <ISP_SVC_Sensor_GetInfo+0x18>
    {
      return ISP_ERR_SENSORINFO;
    }
  }

  return ISP_OK;
34014ee0:	2000      	movs	r0, #0
}
34014ee2:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSORINFO_EINVAL;
34014ee4:	206e      	movs	r0, #110	@ 0x6e
34014ee6:	e7fc      	b.n	34014ee2 <ISP_SVC_Sensor_GetInfo+0x12>
      return ISP_ERR_SENSORINFO;
34014ee8:	206f      	movs	r0, #111	@ 0x6f
34014eea:	e7fa      	b.n	34014ee2 <ISP_SVC_Sensor_GetInfo+0x12>

34014eec <ISP_SVC_Sensor_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
34014eec:	b510      	push	{r4, lr}
34014eee:	460c      	mov	r4, r1
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014ef0:	b170      	cbz	r0, 34014f10 <ISP_SVC_Sensor_SetGain+0x24>
34014ef2:	b169      	cbz	r1, 34014f10 <ISP_SVC_Sensor_SetGain+0x24>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
  }

  if (hIsp->appliHelpers.SetSensorGain != NULL)
34014ef4:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
  {
    if (hIsp->appliHelpers.SetSensorGain(hIsp->cameraInstance, (int32_t)pConfig->gain) != 0)
34014ef6:	6809      	ldr	r1, [r1, #0]
  if (hIsp->appliHelpers.SetSensorGain != NULL)
34014ef8:	b923      	cbnz	r3, 34014f04 <ISP_SVC_Sensor_SetGain+0x18>
    }
  }

  Meta.gain = pConfig->gain;

  return ISP_OK;
34014efa:	2000      	movs	r0, #0
  Meta.gain = pConfig->gain;
34014efc:	6822      	ldr	r2, [r4, #0]
34014efe:	4b05      	ldr	r3, [pc, #20]	@ (34014f14 <ISP_SVC_Sensor_SetGain+0x28>)
34014f00:	609a      	str	r2, [r3, #8]
}
34014f02:	bd10      	pop	{r4, pc}
    if (hIsp->appliHelpers.SetSensorGain(hIsp->cameraInstance, (int32_t)pConfig->gain) != 0)
34014f04:	6840      	ldr	r0, [r0, #4]
34014f06:	4798      	blx	r3
34014f08:	2800      	cmp	r0, #0
34014f0a:	d0f6      	beq.n	34014efa <ISP_SVC_Sensor_SetGain+0xe>
      return ISP_ERR_SENSORGAIN;
34014f0c:	2079      	movs	r0, #121	@ 0x79
34014f0e:	e7f8      	b.n	34014f02 <ISP_SVC_Sensor_SetGain+0x16>
    return ISP_ERR_SENSORGAIN_EINVAL;
34014f10:	2078      	movs	r0, #120	@ 0x78
34014f12:	e7f6      	b.n	34014f02 <ISP_SVC_Sensor_SetGain+0x16>
34014f14:	340ce438 	.word	0x340ce438

34014f18 <ISP_SVC_Sensor_GetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
34014f18:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014f1a:	b138      	cbz	r0, 34014f2c <ISP_SVC_Sensor_GetGain+0x14>
34014f1c:	b131      	cbz	r1, 34014f2c <ISP_SVC_Sensor_GetGain+0x14>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorGain != NULL)
34014f1e:	6b03      	ldr	r3, [r0, #48]	@ 0x30
34014f20:	b113      	cbz	r3, 34014f28 <ISP_SVC_Sensor_GetGain+0x10>
  {
    if (hIsp->appliHelpers.GetSensorGain(hIsp->cameraInstance, (int32_t *)&pConfig->gain) != 0)
34014f22:	6840      	ldr	r0, [r0, #4]
34014f24:	4798      	blx	r3
34014f26:	b918      	cbnz	r0, 34014f30 <ISP_SVC_Sensor_GetGain+0x18>
    {
      return ISP_ERR_SENSORGAIN;
    }
  }

  return ISP_OK;
34014f28:	2000      	movs	r0, #0
}
34014f2a:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSORGAIN_EINVAL;
34014f2c:	2078      	movs	r0, #120	@ 0x78
34014f2e:	e7fc      	b.n	34014f2a <ISP_SVC_Sensor_GetGain+0x12>
      return ISP_ERR_SENSORGAIN;
34014f30:	2079      	movs	r0, #121	@ 0x79
34014f32:	e7fa      	b.n	34014f2a <ISP_SVC_Sensor_GetGain+0x12>

34014f34 <ISP_SVC_Sensor_SetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
34014f34:	b510      	push	{r4, lr}
34014f36:	460c      	mov	r4, r1
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014f38:	b170      	cbz	r0, 34014f58 <ISP_SVC_Sensor_SetExposure+0x24>
34014f3a:	b169      	cbz	r1, 34014f58 <ISP_SVC_Sensor_SetExposure+0x24>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
  }

  if (hIsp->appliHelpers.SetSensorExposure != NULL)
34014f3c:	6b43      	ldr	r3, [r0, #52]	@ 0x34
  {
    if (hIsp->appliHelpers.SetSensorExposure(hIsp->cameraInstance, (int32_t)pConfig->exposure) != 0)
34014f3e:	6809      	ldr	r1, [r1, #0]
  if (hIsp->appliHelpers.SetSensorExposure != NULL)
34014f40:	b923      	cbnz	r3, 34014f4c <ISP_SVC_Sensor_SetExposure+0x18>
    }
  }

  Meta.exposure = pConfig->exposure;

  return ISP_OK;
34014f42:	2000      	movs	r0, #0
  Meta.exposure = pConfig->exposure;
34014f44:	6822      	ldr	r2, [r4, #0]
34014f46:	4b05      	ldr	r3, [pc, #20]	@ (34014f5c <ISP_SVC_Sensor_SetExposure+0x28>)
34014f48:	60da      	str	r2, [r3, #12]
}
34014f4a:	bd10      	pop	{r4, pc}
    if (hIsp->appliHelpers.SetSensorExposure(hIsp->cameraInstance, (int32_t)pConfig->exposure) != 0)
34014f4c:	6840      	ldr	r0, [r0, #4]
34014f4e:	4798      	blx	r3
34014f50:	2800      	cmp	r0, #0
34014f52:	d0f6      	beq.n	34014f42 <ISP_SVC_Sensor_SetExposure+0xe>
      return ISP_ERR_SENSOREXPOSURE;
34014f54:	2083      	movs	r0, #131	@ 0x83
34014f56:	e7f8      	b.n	34014f4a <ISP_SVC_Sensor_SetExposure+0x16>
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
34014f58:	2082      	movs	r0, #130	@ 0x82
34014f5a:	e7f6      	b.n	34014f4a <ISP_SVC_Sensor_SetExposure+0x16>
34014f5c:	340ce438 	.word	0x340ce438

34014f60 <ISP_SVC_Sensor_GetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
34014f60:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014f62:	b138      	cbz	r0, 34014f74 <ISP_SVC_Sensor_GetExposure+0x14>
34014f64:	b131      	cbz	r1, 34014f74 <ISP_SVC_Sensor_GetExposure+0x14>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorExposure != NULL)
34014f66:	6b83      	ldr	r3, [r0, #56]	@ 0x38
34014f68:	b113      	cbz	r3, 34014f70 <ISP_SVC_Sensor_GetExposure+0x10>
  {
    if (hIsp->appliHelpers.GetSensorExposure(hIsp->cameraInstance, (int32_t *)&pConfig->exposure) != 0)
34014f6a:	6840      	ldr	r0, [r0, #4]
34014f6c:	4798      	blx	r3
34014f6e:	b918      	cbnz	r0, 34014f78 <ISP_SVC_Sensor_GetExposure+0x18>
    {
      return ISP_ERR_SENSOREXPOSURE;
    }
  }

  return ISP_OK;
34014f70:	2000      	movs	r0, #0
}
34014f72:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
34014f74:	2082      	movs	r0, #130	@ 0x82
34014f76:	e7fc      	b.n	34014f72 <ISP_SVC_Sensor_GetExposure+0x12>
      return ISP_ERR_SENSOREXPOSURE;
34014f78:	2083      	movs	r0, #131	@ 0x83
34014f7a:	e7fa      	b.n	34014f72 <ISP_SVC_Sensor_GetExposure+0x12>

34014f7c <ISP_SVC_Misc_IsDCMIPPReady>:
  *         Check that the DCMIPP device is ready
  * @param  hIsp: ISP device handle
  * @retval ISP_OK if DCMIPP is running, ISP_FAIL otherwise
  */
ISP_StatusTypeDef ISP_SVC_Misc_IsDCMIPPReady(ISP_HandleTypeDef *hIsp)
{
34014f7c:	b508      	push	{r3, lr}
  /* Check handle validity */
  if (hIsp == NULL)
34014f7e:	b138      	cbz	r0, 34014f90 <ISP_SVC_Misc_IsDCMIPPReady+0x14>
  {
    return ISP_ERR_EINVAL;
  }

  if (HAL_DCMIPP_GetState(hIsp->hDcmipp) != HAL_DCMIPP_STATE_READY)
34014f80:	6800      	ldr	r0, [r0, #0]
34014f82:	f7f2 fc59 	bl	34007838 <HAL_DCMIPP_GetState>
  {
    return ISP_ERR_DCMIPP_STATE;
  }

  return ISP_OK;
34014f86:	2802      	cmp	r0, #2
34014f88:	bf14      	ite	ne
34014f8a:	208c      	movne	r0, #140	@ 0x8c
34014f8c:	2000      	moveq	r0, #0
}
34014f8e:	bd08      	pop	{r3, pc}
    return ISP_ERR_EINVAL;
34014f90:	2001      	movs	r0, #1
34014f92:	e7fc      	b.n	34014f8e <ISP_SVC_Misc_IsDCMIPPReady+0x12>

34014f94 <ISP_SVC_Misc_IncMainFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->MainPipe_FrameCount++;
34014f94:	6c03      	ldr	r3, [r0, #64]	@ 0x40
34014f96:	3301      	adds	r3, #1
34014f98:	6403      	str	r3, [r0, #64]	@ 0x40
}
34014f9a:	4770      	bx	lr

34014f9c <ISP_SVC_Misc_GetMainFrameId>:
  * @retval Id of the last frame output on the main pipe
  */
uint32_t ISP_SVC_Misc_GetMainFrameId(ISP_HandleTypeDef *hIsp)
{
  return hIsp->MainPipe_FrameCount;
}
34014f9c:	6c00      	ldr	r0, [r0, #64]	@ 0x40
34014f9e:	4770      	bx	lr

34014fa0 <ISP_SVC_Misc_IncAncillaryFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->AncillaryPipe_FrameCount++;
34014fa0:	6c43      	ldr	r3, [r0, #68]	@ 0x44
34014fa2:	3301      	adds	r3, #1
34014fa4:	6443      	str	r3, [r0, #68]	@ 0x44
}
34014fa6:	4770      	bx	lr

34014fa8 <ISP_SVC_Misc_IncDumpFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->DumpPipe_FrameCount++;
34014fa8:	6c83      	ldr	r3, [r0, #72]	@ 0x48
34014faa:	3301      	adds	r3, #1
34014fac:	6483      	str	r3, [r0, #72]	@ 0x48
}
34014fae:	4770      	bx	lr

34014fb0 <ISP_SVC_Misc_SetWBRefMode>:
  */
ISP_StatusTypeDef ISP_SVC_Misc_SetWBRefMode(ISP_HandleTypeDef *hIsp, uint32_t RefColorTemp)
{
  (void)hIsp; /* unused */

  ISP_ManualWBRefColorTemp = RefColorTemp;
34014fb0:	4b01      	ldr	r3, [pc, #4]	@ (34014fb8 <ISP_SVC_Misc_SetWBRefMode+0x8>)

  return ISP_OK;
}
34014fb2:	2000      	movs	r0, #0
  ISP_ManualWBRefColorTemp = RefColorTemp;
34014fb4:	6019      	str	r1, [r3, #0]
}
34014fb6:	4770      	bx	lr
34014fb8:	340ce810 	.word	0x340ce810

34014fbc <ISP_SVC_Misc_IsGammaEnabled>:
  * @param  hIsp: ISP device handle
  * @param  Pipe: DCMIPP pipe line
  * @retval 1 if enabled 0 otherwise
  */
bool ISP_SVC_Misc_IsGammaEnabled(ISP_HandleTypeDef *hIsp, uint32_t Pipe)
{
34014fbc:	b508      	push	{r3, lr}
  uint8_t ret;

  /* Check handle validity */
  if (hIsp == NULL)
34014fbe:	b168      	cbz	r0, 34014fdc <ISP_SVC_Misc_IsGammaEnabled+0x20>
  {
    return ISP_ERR_EINVAL;
  }

  switch(Pipe)
34014fc0:	2901      	cmp	r1, #1
34014fc2:	d006      	beq.n	34014fd2 <ISP_SVC_Misc_IsGammaEnabled+0x16>
34014fc4:	2902      	cmp	r1, #2
34014fc6:	d004      	beq.n	34014fd2 <ISP_SVC_Misc_IsGammaEnabled+0x16>
34014fc8:	2000      	movs	r0, #0
    break;
  default:
    ret = 0; /*  No gamma on pipe 0 */
  }

  return ret;
34014fca:	3800      	subs	r0, #0
34014fcc:	bf18      	it	ne
34014fce:	2001      	movne	r0, #1
}
34014fd0:	bd08      	pop	{r3, pc}
    ret = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2);
34014fd2:	6800      	ldr	r0, [r0, #0]
34014fd4:	f7f1 fc42 	bl	3400685c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>
34014fd8:	b2c0      	uxtb	r0, r0
    break;
34014fda:	e7f6      	b.n	34014fca <ISP_SVC_Misc_IsGammaEnabled+0xe>
    return ISP_ERR_EINVAL;
34014fdc:	2001      	movs	r0, #1
34014fde:	e7f7      	b.n	34014fd0 <ISP_SVC_Misc_IsGammaEnabled+0x14>

34014fe0 <ISP_SVC_ISP_SetGamma>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gamma configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGamma(ISP_HandleTypeDef *hIsp, ISP_GammaTypeDef *pConfig)
{
34014fe0:	b510      	push	{r4, lr}
  if ((hIsp == NULL) || (pConfig == NULL))
34014fe2:	4604      	mov	r4, r0
34014fe4:	b908      	cbnz	r0, 34014fea <ISP_SVC_ISP_SetGamma+0xa>
  {
    return ISP_ERR_DCMIPP_GAMMA;
34014fe6:	2095      	movs	r0, #149	@ 0x95
      return ISP_ERR_DCMIPP_GAMMA;
    }
  }

  return ISP_OK;
}
34014fe8:	bd10      	pop	{r4, pc}
  if ((hIsp == NULL) || (pConfig == NULL))
34014fea:	2900      	cmp	r1, #0
34014fec:	d0fb      	beq.n	34014fe6 <ISP_SVC_ISP_SetGamma+0x6>
  if (pConfig->enable == 0)
34014fee:	780b      	ldrb	r3, [r1, #0]
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34014ff0:	6800      	ldr	r0, [r0, #0]
34014ff2:	2101      	movs	r1, #1
  if (pConfig->enable == 0)
34014ff4:	b95b      	cbnz	r3, 3401500e <ISP_SVC_ISP_SetGamma+0x2e>
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34014ff6:	f7f1 fc0f 	bl	34006818 <HAL_DCMIPP_PIPE_DisableGammaConversion>
34014ffa:	2800      	cmp	r0, #0
34014ffc:	d1f3      	bne.n	34014fe6 <ISP_SVC_ISP_SetGamma+0x6>
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
34014ffe:	2102      	movs	r1, #2
34015000:	6820      	ldr	r0, [r4, #0]
34015002:	f7f1 fc09 	bl	34006818 <HAL_DCMIPP_PIPE_DisableGammaConversion>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
34015006:	2800      	cmp	r0, #0
34015008:	d1ed      	bne.n	34014fe6 <ISP_SVC_ISP_SetGamma+0x6>
  return ISP_OK;
3401500a:	2000      	movs	r0, #0
3401500c:	e7ec      	b.n	34014fe8 <ISP_SVC_ISP_SetGamma+0x8>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3401500e:	f7f1 fbe1 	bl	340067d4 <HAL_DCMIPP_PIPE_EnableGammaConversion>
34015012:	2800      	cmp	r0, #0
34015014:	d1e7      	bne.n	34014fe6 <ISP_SVC_ISP_SetGamma+0x6>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
34015016:	2102      	movs	r1, #2
34015018:	6820      	ldr	r0, [r4, #0]
3401501a:	f7f1 fbdb 	bl	340067d4 <HAL_DCMIPP_PIPE_EnableGammaConversion>
3401501e:	e7f2      	b.n	34015006 <ISP_SVC_ISP_SetGamma+0x26>

34015020 <ISP_SVC_IQParam_Init>:
  *         Initialize the IQ parameters cache with values from non volatile memory
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_IQParam_Init(ISP_HandleTypeDef *hIsp, const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
34015020:	b508      	push	{r3, lr}
  (void)hIsp; /* unused */

  ISP_IQParamCache = *ISP_IQParamCacheInit;
34015022:	f44f 7216 	mov.w	r2, #600	@ 0x258
34015026:	4802      	ldr	r0, [pc, #8]	@ (34015030 <ISP_SVC_IQParam_Init+0x10>)
34015028:	f005 fb13 	bl	3401a652 <memcpy>
  return ISP_OK;
}
3401502c:	2000      	movs	r0, #0
3401502e:	bd08      	pop	{r3, pc}
34015030:	340ce5b8 	.word	0x340ce5b8

34015034 <ISP_SVC_IQParam_Get>:
ISP_IQParamTypeDef *ISP_SVC_IQParam_Get(ISP_HandleTypeDef *hIsp)
{
  (void)hIsp; /* unused */

  return &ISP_IQParamCache;
}
34015034:	4800      	ldr	r0, [pc, #0]	@ (34015038 <ISP_SVC_IQParam_Get+0x4>)
34015036:	4770      	bx	lr
34015038:	340ce5b8 	.word	0x340ce5b8

3401503c <ISP_SVC_Stats_Init>:
  * @retval None
  */
void ISP_SVC_Stats_Init(ISP_HandleTypeDef *hIsp)
{
  UNUSED(hIsp);
  memset(&ISP_SVC_StatEngine, 0, sizeof(ISP_SVC_StatEngineTypeDef));
3401503c:	f44f 72b0 	mov.w	r2, #352	@ 0x160
34015040:	2100      	movs	r1, #0
34015042:	4801      	ldr	r0, [pc, #4]	@ (34015048 <ISP_SVC_Stats_Init+0xc>)
34015044:	f005 b86e 	b.w	3401a124 <memset>
34015048:	340ce458 	.word	0x340ce458

3401504c <ISP_SVC_Stats_Gather>:
  *         Gather statistics
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Gather(ISP_HandleTypeDef *hIsp)
{
3401504c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ISP_SVC_StatStateTypeDef *ongoing;
  uint32_t avgR, avgG, avgB, frameId;
  uint8_t i;

  /* Check handle validity */
  if (hIsp == NULL)
34015050:	4605      	mov	r5, r0
{
34015052:	b08d      	sub	sp, #52	@ 0x34
  if (hIsp == NULL)
34015054:	b928      	cbnz	r0, 34015062 <ISP_SVC_Stats_Gather+0x16>
  {
    printf("ERROR: ISP handle is NULL\r\n");
34015056:	48ab      	ldr	r0, [pc, #684]	@ (34015304 <ISP_SVC_Stats_Gather+0x2b8>)

  /* Save the two last processed stages and go to next stage */
  stagePrevious2 = stagePrevious1;
  stagePrevious1 = ISP_SVC_StatEngine.stage;
  ISP_SVC_StatEngine.stage = GetNextStatStage(ISP_SVC_StatEngine.stage);
}
34015058:	b00d      	add	sp, #52	@ 0x34
3401505a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    printf("ERROR: ISP handle is NULL\r\n");
3401505e:	f004 bef5 	b.w	34019e4c <puts>
  if (hIsp->hDcmipp == NULL)
34015062:	6800      	ldr	r0, [r0, #0]
34015064:	2800      	cmp	r0, #0
34015066:	f000 80b5 	beq.w	340151d4 <ISP_SVC_Stats_Gather+0x188>
  switch(stagePrevious2)
3401506a:	f8df 92f4 	ldr.w	r9, [pc, #756]	@ 34015360 <ISP_SVC_Stats_Gather+0x314>
3401506e:	4ca6      	ldr	r4, [pc, #664]	@ (34015308 <ISP_SVC_Stats_Gather+0x2bc>)
34015070:	f899 3000 	ldrb.w	r3, [r9]
34015074:	2b09      	cmp	r3, #9
34015076:	d836      	bhi.n	340150e6 <ISP_SVC_Stats_Gather+0x9a>
34015078:	e8df f003 	tbb	[pc, r3]
3401507c:	46443f05 	.word	0x46443f05
34015080:	8c8a4a48 	.word	0x8c8a4a48
34015084:	908e      	.short	0x908e
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
34015086:	2201      	movs	r2, #1
34015088:	466b      	mov	r3, sp
3401508a:	4611      	mov	r1, r2
3401508c:	f7f2 fa94 	bl	340075b8 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
34015090:	2202      	movs	r2, #2
34015092:	2101      	movs	r1, #1
34015094:	ab01      	add	r3, sp, #4
34015096:	6828      	ldr	r0, [r5, #0]
34015098:	f7f2 fa8e 	bl	340075b8 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
3401509c:	2203      	movs	r2, #3
3401509e:	2101      	movs	r1, #1
340150a0:	ab02      	add	r3, sp, #8
340150a2:	6828      	ldr	r0, [r5, #0]
340150a4:	f7f2 fa88 	bl	340075b8 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
340150a8:	2101      	movs	r1, #1
340150aa:	2200      	movs	r2, #0
340150ac:	9b00      	ldr	r3, [sp, #0]
340150ae:	4628      	mov	r0, r5
340150b0:	f7ff fb16 	bl	340146e0 <GetAvgStats>
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
340150b4:	460a      	mov	r2, r1
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
340150b6:	4606      	mov	r6, r0
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
340150b8:	9b01      	ldr	r3, [sp, #4]
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
340150ba:	f884 007c 	strb.w	r0, [r4, #124]	@ 0x7c
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
340150be:	4628      	mov	r0, r5
340150c0:	f7ff fb0e 	bl	340146e0 <GetAvgStats>
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
340150c4:	2202      	movs	r2, #2
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
340150c6:	4607      	mov	r7, r0
340150c8:	f884 007d 	strb.w	r0, [r4, #125]	@ 0x7d
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
340150cc:	9b02      	ldr	r3, [sp, #8]
340150ce:	4628      	mov	r0, r5
340150d0:	f7ff fb06 	bl	340146e0 <GetAvgStats>
    ongoing->up.averageL = LuminanceFromRGB(ongoing->up.averageR, ongoing->up.averageG, ongoing->up.averageB);
340150d4:	4639      	mov	r1, r7
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
340150d6:	4602      	mov	r2, r0
340150d8:	f884 007e 	strb.w	r0, [r4, #126]	@ 0x7e
    ongoing->up.averageL = LuminanceFromRGB(ongoing->up.averageR, ongoing->up.averageG, ongoing->up.averageB);
340150dc:	4630      	mov	r0, r6
340150de:	f7ff fb43 	bl	34014768 <LuminanceFromRGB>
340150e2:	f884 007f 	strb.w	r0, [r4, #127]	@ 0x7f
  switch(ISP_SVC_StatEngine.stage)
340150e6:	7823      	ldrb	r3, [r4, #0]
340150e8:	2b09      	cmp	r3, #9
340150ea:	d866      	bhi.n	340151ba <ISP_SVC_Stats_Gather+0x16e>
340150ec:	e8df f003 	tbb	[pc, r3]
340150f0:	87858075 	.word	0x87858075
340150f4:	8d8b5889 	.word	0x8d8b5889
340150f8:	918f      	.short	0x918f
    ReadStatHistogram(hIsp, &ongoing->up.histogram[0]);
340150fa:	4984      	ldr	r1, [pc, #528]	@ (3401530c <ISP_SVC_Stats_Gather+0x2c0>)
    ReadStatHistogram(hIsp, &ongoing->down.histogram[9]);
340150fc:	4628      	mov	r0, r5
340150fe:	f7ff fb20 	bl	34014742 <ReadStatHistogram>
    break;
34015102:	e7f0      	b.n	340150e6 <ISP_SVC_Stats_Gather+0x9a>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[3]);
34015104:	4982      	ldr	r1, [pc, #520]	@ (34015310 <ISP_SVC_Stats_Gather+0x2c4>)
34015106:	e7f9      	b.n	340150fc <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[6]);
34015108:	4982      	ldr	r1, [pc, #520]	@ (34015314 <ISP_SVC_Stats_Gather+0x2c8>)
3401510a:	e7f7      	b.n	340150fc <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[9]);
3401510c:	4982      	ldr	r1, [pc, #520]	@ (34015318 <ISP_SVC_Stats_Gather+0x2cc>)
3401510e:	e7f5      	b.n	340150fc <ISP_SVC_Stats_Gather+0xb0>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
34015110:	2201      	movs	r2, #1
34015112:	466b      	mov	r3, sp
34015114:	4611      	mov	r1, r2
34015116:	f7f2 fa4f 	bl	340075b8 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
3401511a:	2202      	movs	r2, #2
3401511c:	2101      	movs	r1, #1
3401511e:	ab01      	add	r3, sp, #4
34015120:	6828      	ldr	r0, [r5, #0]
34015122:	f7f2 fa49 	bl	340075b8 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
34015126:	2203      	movs	r2, #3
34015128:	2101      	movs	r1, #1
3401512a:	ab02      	add	r3, sp, #8
3401512c:	6828      	ldr	r0, [r5, #0]
3401512e:	f7f2 fa43 	bl	340075b8 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    ongoing->down.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_RED, avgR);
34015132:	2102      	movs	r1, #2
34015134:	2200      	movs	r2, #0
34015136:	9b00      	ldr	r3, [sp, #0]
34015138:	4628      	mov	r0, r5
3401513a:	f7ff fad1 	bl	340146e0 <GetAvgStats>
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
3401513e:	2201      	movs	r2, #1
34015140:	9b01      	ldr	r3, [sp, #4]
    ongoing->down.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_RED, avgR);
34015142:	f884 00b0 	strb.w	r0, [r4, #176]	@ 0xb0
34015146:	4607      	mov	r7, r0
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
34015148:	4628      	mov	r0, r5
3401514a:	f7ff fac9 	bl	340146e0 <GetAvgStats>
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
3401514e:	460a      	mov	r2, r1
34015150:	9b02      	ldr	r3, [sp, #8]
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
34015152:	f884 00b1 	strb.w	r0, [r4, #177]	@ 0xb1
34015156:	4606      	mov	r6, r0
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
34015158:	4628      	mov	r0, r5
3401515a:	f7ff fac1 	bl	340146e0 <GetAvgStats>
3401515e:	f884 00b2 	strb.w	r0, [r4, #178]	@ 0xb2
    if ((hIsp->sensorInfo.bayer_pattern == ISP_DEMOS_TYPE_MONO) || (!IQParamConfig->demosaicing.enable))
34015162:	f895 306c 	ldrb.w	r3, [r5, #108]	@ 0x6c
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
34015166:	4602      	mov	r2, r0
    if ((hIsp->sensorInfo.bayer_pattern == ISP_DEMOS_TYPE_MONO) || (!IQParamConfig->demosaicing.enable))
34015168:	2b04      	cmp	r3, #4
3401516a:	d002      	beq.n	34015172 <ISP_SVC_Stats_Gather+0x126>
3401516c:	4b6b      	ldr	r3, [pc, #428]	@ (3401531c <ISP_SVC_Stats_Gather+0x2d0>)
3401516e:	7b1b      	ldrb	r3, [r3, #12]
34015170:	b93b      	cbnz	r3, 34015182 <ISP_SVC_Stats_Gather+0x136>
  uint32_t lum = (uint32_t)r + g + b;
34015172:	443e      	add	r6, r7
34015174:	4416      	add	r6, r2
  return (uint8_t)((lum > 255)? 255 : lum);
34015176:	2eff      	cmp	r6, #255	@ 0xff
34015178:	bf28      	it	cs
3401517a:	26ff      	movcs	r6, #255	@ 0xff
      ongoing->down.averageL = LuminanceFromRGBMono(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
3401517c:	f884 60b3 	strb.w	r6, [r4, #179]	@ 0xb3
34015180:	e7b1      	b.n	340150e6 <ISP_SVC_Stats_Gather+0x9a>
      ongoing->down.averageL = LuminanceFromRGB(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
34015182:	4631      	mov	r1, r6
34015184:	4638      	mov	r0, r7
34015186:	f7ff faef 	bl	34014768 <LuminanceFromRGB>
3401518a:	f884 00b3 	strb.w	r0, [r4, #179]	@ 0xb3
3401518e:	e7aa      	b.n	340150e6 <ISP_SVC_Stats_Gather+0x9a>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[0]);
34015190:	4963      	ldr	r1, [pc, #396]	@ (34015320 <ISP_SVC_Stats_Gather+0x2d4>)
34015192:	e7b3      	b.n	340150fc <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[3]);
34015194:	4963      	ldr	r1, [pc, #396]	@ (34015324 <ISP_SVC_Stats_Gather+0x2d8>)
34015196:	e7b1      	b.n	340150fc <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[6]);
34015198:	4963      	ldr	r1, [pc, #396]	@ (34015328 <ISP_SVC_Stats_Gather+0x2dc>)
3401519a:	e7af      	b.n	340150fc <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[9]);
3401519c:	4963      	ldr	r1, [pc, #396]	@ (3401532c <ISP_SVC_Stats_Gather+0x2e0>)
3401519e:	e7ad      	b.n	340150fc <ISP_SVC_Stats_Gather+0xb0>
      statConf[i].Source = avgRGBDown[i];
340151a0:	2300      	movs	r3, #0
340151a2:	2240      	movs	r2, #64	@ 0x40
340151a4:	e9cd 3203 	strd	r3, r2, [sp, #12]
340151a8:	2250      	movs	r2, #80	@ 0x50
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
340151aa:	e9cd 2307 	strd	r2, r3, [sp, #28]
      statConf[i].Source = avgRGBDown[i];
340151ae:	2260      	movs	r2, #96	@ 0x60
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
340151b0:	e9cd 3305 	strd	r3, r3, [sp, #20]
340151b4:	9309      	str	r3, [sp, #36]	@ 0x24
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
340151b6:	e9cd 230a 	strd	r2, r3, [sp, #40]	@ 0x28
{
340151ba:	f04f 0801 	mov.w	r8, #1
340151be:	af03      	add	r7, sp, #12
    if (HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, i, &statConf[i - DCMIPP_STATEXT_MODULE1]) != HAL_OK)
340151c0:	463b      	mov	r3, r7
340151c2:	4642      	mov	r2, r8
340151c4:	2101      	movs	r1, #1
340151c6:	6828      	ldr	r0, [r5, #0]
340151c8:	f7f1 fef4 	bl	34006fb4 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>
340151cc:	b318      	cbz	r0, 34015216 <ISP_SVC_Stats_Gather+0x1ca>
      printf("ERROR: can't set Statistic Extraction config\r\n");
340151ce:	4858      	ldr	r0, [pc, #352]	@ (34015330 <ISP_SVC_Stats_Gather+0x2e4>)
      printf("ERROR: can't enable Statistic Extraction config\r\n");
340151d0:	f004 fe3c 	bl	34019e4c <puts>
}
340151d4:	b00d      	add	sp, #52	@ 0x34
340151d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
340151da:	2300      	movs	r3, #0
      statConf[i].Source = avgRGBUp[i];
340151dc:	2210      	movs	r2, #16
340151de:	e9cd 3303 	strd	r3, r3, [sp, #12]
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
340151e2:	e9cd 2307 	strd	r2, r3, [sp, #28]
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
340151e6:	e9cd 3305 	strd	r3, r3, [sp, #20]
      statConf[i].Source = avgRGBUp[i];
340151ea:	2220      	movs	r2, #32
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
340151ec:	9309      	str	r3, [sp, #36]	@ 0x24
      statConf[i].Source = avgRGBUp[i];
340151ee:	e7e2      	b.n	340151b6 <ISP_SVC_Stats_Gather+0x16a>
    SetStatConfig(statConf, &statConfUpBins_0_2);
340151f0:	4950      	ldr	r1, [pc, #320]	@ (34015334 <ISP_SVC_Stats_Gather+0x2e8>)
    SetStatConfig(statConf, &statConfDownBins_9_11);
340151f2:	a803      	add	r0, sp, #12
340151f4:	f7ff fa96 	bl	34014724 <SetStatConfig>
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
340151f8:	e7df      	b.n	340151ba <ISP_SVC_Stats_Gather+0x16e>
    SetStatConfig(statConf, &statConfUpBins_3_5);
340151fa:	494f      	ldr	r1, [pc, #316]	@ (34015338 <ISP_SVC_Stats_Gather+0x2ec>)
340151fc:	e7f9      	b.n	340151f2 <ISP_SVC_Stats_Gather+0x1a6>
    SetStatConfig(statConf, &statConfUpBins_6_8);
340151fe:	494f      	ldr	r1, [pc, #316]	@ (3401533c <ISP_SVC_Stats_Gather+0x2f0>)
34015200:	e7f7      	b.n	340151f2 <ISP_SVC_Stats_Gather+0x1a6>
    SetStatConfig(statConf, &statConfUpBins_9_11);
34015202:	494f      	ldr	r1, [pc, #316]	@ (34015340 <ISP_SVC_Stats_Gather+0x2f4>)
34015204:	e7f5      	b.n	340151f2 <ISP_SVC_Stats_Gather+0x1a6>
    SetStatConfig(statConf, &statConfDownBins_0_2);
34015206:	494f      	ldr	r1, [pc, #316]	@ (34015344 <ISP_SVC_Stats_Gather+0x2f8>)
34015208:	e7f3      	b.n	340151f2 <ISP_SVC_Stats_Gather+0x1a6>
    SetStatConfig(statConf, &statConfDownBins_3_5);
3401520a:	494f      	ldr	r1, [pc, #316]	@ (34015348 <ISP_SVC_Stats_Gather+0x2fc>)
3401520c:	e7f1      	b.n	340151f2 <ISP_SVC_Stats_Gather+0x1a6>
    SetStatConfig(statConf, &statConfDownBins_6_8);
3401520e:	494f      	ldr	r1, [pc, #316]	@ (3401534c <ISP_SVC_Stats_Gather+0x300>)
34015210:	e7ef      	b.n	340151f2 <ISP_SVC_Stats_Gather+0x1a6>
    SetStatConfig(statConf, &statConfDownBins_9_11);
34015212:	494f      	ldr	r1, [pc, #316]	@ (34015350 <ISP_SVC_Stats_Gather+0x304>)
34015214:	e7ed      	b.n	340151f2 <ISP_SVC_Stats_Gather+0x1a6>
    if (HAL_DCMIPP_PIPE_EnableISPStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1, i) != HAL_OK)
34015216:	4642      	mov	r2, r8
34015218:	2101      	movs	r1, #1
3401521a:	6828      	ldr	r0, [r5, #0]
3401521c:	f7f1 ff82 	bl	34007124 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>
34015220:	4606      	mov	r6, r0
34015222:	b108      	cbz	r0, 34015228 <ISP_SVC_Stats_Gather+0x1dc>
      printf("ERROR: can't enable Statistic Extraction config\r\n");
34015224:	484b      	ldr	r0, [pc, #300]	@ (34015354 <ISP_SVC_Stats_Gather+0x308>)
34015226:	e7d3      	b.n	340151d0 <ISP_SVC_Stats_Gather+0x184>
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34015228:	f108 0801 	add.w	r8, r8, #1
3401522c:	fa5f f888 	uxtb.w	r8, r8
34015230:	f1b8 0f04 	cmp.w	r8, #4
34015234:	f107 070c 	add.w	r7, r7, #12
34015238:	d1c2      	bne.n	340151c0 <ISP_SVC_Stats_Gather+0x174>
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
3401523a:	f894 8158 	ldrb.w	r8, [r4, #344]	@ 0x158
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
3401523e:	f899 b000 	ldrb.w	fp, [r9]
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
34015242:	f018 0f05 	tst.w	r8, #5
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
34015246:	bf0c      	ite	eq
34015248:	2301      	moveq	r3, #1
3401524a:	2300      	movne	r3, #0
  return hIsp->MainPipe_FrameCount;
3401524c:	f8d5 a040 	ldr.w	sl, [r5, #64]	@ 0x40
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG) ||
34015250:	f894 7159 	ldrb.w	r7, [r4, #345]	@ 0x159
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
34015254:	455b      	cmp	r3, fp
    ongoing->upFrameIdStart = frameId;
34015256:	bf08      	it	eq
34015258:	f8c4 a0e4 	streq.w	sl, [r4, #228]	@ 0xe4
      stage = ISP_STAT_CFG_DOWN_AVG;
3401525c:	f017 0f05 	tst.w	r7, #5
34015260:	bf0c      	ite	eq
34015262:	2306      	moveq	r3, #6
34015264:	2305      	movne	r3, #5
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_DOWN))
34015266:	459b      	cmp	fp, r3
34015268:	d17c      	bne.n	34015364 <ISP_SVC_Stats_Gather+0x318>
    ongoing->downFrameIdStart = frameId;
3401526a:	f8c4 a0ec 	str.w	sl, [r4, #236]	@ 0xec
      stage = ISP_STAT_CFG_DOWN_BINS_9_11;
3401526e:	f017 0f06 	tst.w	r7, #6
34015272:	bf0c      	ite	eq
34015274:	2305      	moveq	r3, #5
34015276:	2309      	movne	r3, #9
  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_DOWN)) && (ongoing->downFrameIdStart != 0))
34015278:	459b      	cmp	fp, r3
3401527a:	d11e      	bne.n	340152ba <ISP_SVC_Stats_Gather+0x26e>
3401527c:	f8d4 e0ec 	ldr.w	lr, [r4, #236]	@ 0xec
34015280:	f1be 0f00 	cmp.w	lr, #0
34015284:	d019      	beq.n	340152ba <ISP_SVC_Stats_Gather+0x26e>
    ISP_SVC_StatEngine.last.down = ongoing->down;
34015286:	4d34      	ldr	r5, [pc, #208]	@ (34015358 <ISP_SVC_Stats_Gather+0x30c>)
    ISP_SVC_StatEngine.last.downFrameIdStart = ongoing->downFrameIdStart;
34015288:	e9c4 ea1d 	strd	lr, sl, [r4, #116]	@ 0x74
    ISP_SVC_StatEngine.last.down = ongoing->down;
3401528c:	f105 0c78 	add.w	ip, r5, #120	@ 0x78
34015290:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34015294:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34015296:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
3401529a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3401529c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
340152a0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
340152a2:	4628      	mov	r0, r5
340152a4:	f8dc 3000 	ldr.w	r3, [ip]
    memset(&ongoing->down, 0, sizeof(ongoing->down));
340152a8:	2234      	movs	r2, #52	@ 0x34
    ISP_SVC_StatEngine.last.down = ongoing->down;
340152aa:	f840 3b48 	str.w	r3, [r0], #72
    memset(&ongoing->down, 0, sizeof(ongoing->down));
340152ae:	2100      	movs	r1, #0
340152b0:	f004 ff38 	bl	3401a124 <memset>
    ongoing->downFrameIdStart = 0;
340152b4:	2300      	movs	r3, #0
    ongoing->downFrameIdEnd = 0;
340152b6:	e9c4 333b 	strd	r3, r3, [r4, #236]	@ 0xec
  if (((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
340152ba:	ea48 0307 	orr.w	r3, r8, r7
340152be:	075a      	lsls	r2, r3, #29
340152c0:	d50b      	bpl.n	340152da <ISP_SVC_Stats_Gather+0x28e>
       (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP)) &&
340152c2:	f8d4 315c 	ldr.w	r3, [r4, #348]	@ 0x15c
340152c6:	4553      	cmp	r3, sl
    ISP_SVC_StatEngine.upRequest &= ~ISP_STAT_TYPE_ALL_TMP;
340152c8:	bf3f      	itttt	cc
340152ca:	f028 0804 	biccc.w	r8, r8, #4
    ISP_SVC_StatEngine.downRequest &= ~ISP_STAT_TYPE_ALL_TMP;
340152ce:	f027 0704 	biccc.w	r7, r7, #4
    ISP_SVC_StatEngine.upRequest &= ~ISP_STAT_TYPE_ALL_TMP;
340152d2:	f884 8158 	strbcc.w	r8, [r4, #344]	@ 0x158
    ISP_SVC_StatEngine.downRequest &= ~ISP_STAT_TYPE_ALL_TMP;
340152d6:	f884 7159 	strbcc.w	r7, [r4, #345]	@ 0x159
  stagePrevious2 = stagePrevious1;
340152da:	4b20      	ldr	r3, [pc, #128]	@ (3401535c <ISP_SVC_Stats_Gather+0x310>)
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
340152dc:	f894 1158 	ldrb.w	r1, [r4, #344]	@ 0x158
  stagePrevious2 = stagePrevious1;
340152e0:	781a      	ldrb	r2, [r3, #0]
340152e2:	f889 2000 	strb.w	r2, [r9]
  stagePrevious1 = ISP_SVC_StatEngine.stage;
340152e6:	7822      	ldrb	r2, [r4, #0]
340152e8:	701a      	strb	r2, [r3, #0]
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
340152ea:	074b      	lsls	r3, r1, #29
340152ec:	d403      	bmi.n	340152f6 <ISP_SVC_Stats_Gather+0x2aa>
      (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
340152ee:	f894 3159 	ldrb.w	r3, [r4, #345]	@ 0x159
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
340152f2:	075f      	lsls	r7, r3, #29
340152f4:	d560      	bpl.n	340153b8 <ISP_SVC_Stats_Gather+0x36c>
    next = (ISP_SVC_StatEngineStage) ((current < ISP_STAT_CFG_LAST) ? current + 1 : ISP_STAT_CFG_UP_AVG);
340152f6:	1c53      	adds	r3, r2, #1
340152f8:	b2db      	uxtb	r3, r3
340152fa:	2a09      	cmp	r2, #9
340152fc:	bf38      	it	cc
340152fe:	461e      	movcc	r6, r3
  ISP_SVC_StatEngine.stage = GetNextStatStage(ISP_SVC_StatEngine.stage);
34015300:	7026      	strb	r6, [r4, #0]
34015302:	e767      	b.n	340151d4 <ISP_SVC_Stats_Gather+0x188>
34015304:	34021001 	.word	0x34021001
34015308:	340ce458 	.word	0x340ce458
3401530c:	340ce4d8 	.word	0x340ce4d8
34015310:	340ce4e4 	.word	0x340ce4e4
34015314:	340ce4f0 	.word	0x340ce4f0
34015318:	340ce4fc 	.word	0x340ce4fc
3401531c:	340ce5b8 	.word	0x340ce5b8
34015320:	340ce50c 	.word	0x340ce50c
34015324:	340ce518 	.word	0x340ce518
34015328:	340ce524 	.word	0x340ce524
3401532c:	340ce530 	.word	0x340ce530
34015330:	3402101c 	.word	0x3402101c
34015334:	340ad4fc 	.word	0x340ad4fc
34015338:	340ad4f0 	.word	0x340ad4f0
3401533c:	340ad4e4 	.word	0x340ad4e4
34015340:	340ad4d8 	.word	0x340ad4d8
34015344:	340ad4cc 	.word	0x340ad4cc
34015348:	340ad4c0 	.word	0x340ad4c0
3401534c:	340ad4b4 	.word	0x340ad4b4
34015350:	340ad4a8 	.word	0x340ad4a8
34015354:	3402104a 	.word	0x3402104a
34015358:	340ce490 	.word	0x340ce490
3401535c:	340b1038 	.word	0x340b1038
34015360:	340b1039 	.word	0x340b1039
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS) ||
34015364:	f018 0f06 	tst.w	r8, #6
34015368:	bf14      	ite	ne
3401536a:	2301      	movne	r3, #1
3401536c:	2300      	moveq	r3, #0
  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_UP)) && (ongoing->upFrameIdStart != 0))
3401536e:	ebbb 0f83 	cmp.w	fp, r3, lsl #2
34015372:	f47f af7c 	bne.w	3401526e <ISP_SVC_Stats_Gather+0x222>
34015376:	f8d4 e0e4 	ldr.w	lr, [r4, #228]	@ 0xe4
3401537a:	f1be 0f00 	cmp.w	lr, #0
3401537e:	f43f af76 	beq.w	3401526e <ISP_SVC_Stats_Gather+0x222>
    ISP_SVC_StatEngine.last.up = ongoing->up;
34015382:	4d2f      	ldr	r5, [pc, #188]	@ (34015440 <ISP_SVC_Stats_Gather+0x3f4>)
    ISP_SVC_StatEngine.last.upFrameIdStart = ongoing->upFrameIdStart;
34015384:	e9c4 ea1b 	strd	lr, sl, [r4, #108]	@ 0x6c
    ISP_SVC_StatEngine.last.up = ongoing->up;
34015388:	f105 0c78 	add.w	ip, r5, #120	@ 0x78
3401538c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34015390:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34015392:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34015396:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34015398:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
3401539c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3401539e:	4628      	mov	r0, r5
340153a0:	f8dc 3000 	ldr.w	r3, [ip]
    memset(&ongoing->up, 0, sizeof(ongoing->up));
340153a4:	2234      	movs	r2, #52	@ 0x34
    ISP_SVC_StatEngine.last.up = ongoing->up;
340153a6:	f840 3b48 	str.w	r3, [r0], #72
    memset(&ongoing->up, 0, sizeof(ongoing->up));
340153aa:	2100      	movs	r1, #0
340153ac:	f004 feba 	bl	3401a124 <memset>
    ongoing->upFrameIdStart = 0;
340153b0:	2300      	movs	r3, #0
    ongoing->upFrameIdEnd = 0;
340153b2:	e9c4 3339 	strd	r3, r3, [r4, #228]	@ 0xe4
340153b6:	e75a      	b.n	3401526e <ISP_SVC_Stats_Gather+0x222>
  switch (current)
340153b8:	2a09      	cmp	r2, #9
340153ba:	d836      	bhi.n	3401542a <ISP_SVC_Stats_Gather+0x3de>
340153bc:	e8df f002 	tbb	[pc, r2]
340153c0:	35353505 	.word	0x35353505
340153c4:	35351d11 	.word	0x35351d11
340153c8:	2a35      	.short	0x2a35
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
340153ca:	078d      	lsls	r5, r1, #30
340153cc:	d434      	bmi.n	34015438 <ISP_SVC_Stats_Gather+0x3ec>
    else if (ISP_SVC_StatEngine.downRequest &  ISP_STAT_TYPE_AVG)
340153ce:	07d8      	lsls	r0, r3, #31
340153d0:	d434      	bmi.n	3401543c <ISP_SVC_Stats_Gather+0x3f0>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
340153d2:	f013 0602 	ands.w	r6, r3, #2
340153d6:	d12b      	bne.n	34015430 <ISP_SVC_Stats_Gather+0x3e4>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
340153d8:	f011 0f01 	tst.w	r1, #1
340153dc:	bf08      	it	eq
340153de:	2609      	moveq	r6, #9
340153e0:	e78e      	b.n	34015300 <ISP_SVC_Stats_Gather+0x2b4>
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
340153e2:	07da      	lsls	r2, r3, #31
340153e4:	d42a      	bmi.n	3401543c <ISP_SVC_Stats_Gather+0x3f0>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
340153e6:	f013 0602 	ands.w	r6, r3, #2
340153ea:	d121      	bne.n	34015430 <ISP_SVC_Stats_Gather+0x3e4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
340153ec:	07cb      	lsls	r3, r1, #31
340153ee:	d487      	bmi.n	34015300 <ISP_SVC_Stats_Gather+0x2b4>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
340153f0:	f011 0f02 	tst.w	r1, #2
340153f4:	bf18      	it	ne
340153f6:	2601      	movne	r6, #1
340153f8:	e7f0      	b.n	340153dc <ISP_SVC_Stats_Gather+0x390>
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
340153fa:	f013 0602 	ands.w	r6, r3, #2
340153fe:	d117      	bne.n	34015430 <ISP_SVC_Stats_Gather+0x3e4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34015400:	07cf      	lsls	r7, r1, #31
34015402:	f53f af7d 	bmi.w	34015300 <ISP_SVC_Stats_Gather+0x2b4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
34015406:	078d      	lsls	r5, r1, #30
34015408:	d416      	bmi.n	34015438 <ISP_SVC_Stats_Gather+0x3ec>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
3401540a:	f013 0f01 	tst.w	r3, #1
3401540e:	bf18      	it	ne
34015410:	4616      	movne	r6, r2
34015412:	e7e3      	b.n	340153dc <ISP_SVC_Stats_Gather+0x390>
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34015414:	07c8      	lsls	r0, r1, #31
34015416:	d40d      	bmi.n	34015434 <ISP_SVC_Stats_Gather+0x3e8>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
34015418:	0789      	lsls	r1, r1, #30
3401541a:	d40d      	bmi.n	34015438 <ISP_SVC_Stats_Gather+0x3ec>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
3401541c:	07da      	lsls	r2, r3, #31
3401541e:	d40d      	bmi.n	3401543c <ISP_SVC_Stats_Gather+0x3f0>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
34015420:	f013 0f02 	tst.w	r3, #2
34015424:	bf18      	it	ne
34015426:	2606      	movne	r6, #6
34015428:	e7d8      	b.n	340153dc <ISP_SVC_Stats_Gather+0x390>
    next = (ISP_SVC_StatEngineStage) (current + 1);
3401542a:	3201      	adds	r2, #1
3401542c:	b2d6      	uxtb	r6, r2
    break;
3401542e:	e767      	b.n	34015300 <ISP_SVC_Stats_Gather+0x2b4>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
34015430:	2606      	movs	r6, #6
34015432:	e765      	b.n	34015300 <ISP_SVC_Stats_Gather+0x2b4>
    next = (ISP_SVC_StatEngineStage) ((current < ISP_STAT_CFG_LAST) ? current + 1 : ISP_STAT_CFG_UP_AVG);
34015434:	2600      	movs	r6, #0
34015436:	e763      	b.n	34015300 <ISP_SVC_Stats_Gather+0x2b4>
      next = ISP_STAT_CFG_UP_BINS_0_2;
34015438:	2601      	movs	r6, #1
3401543a:	e761      	b.n	34015300 <ISP_SVC_Stats_Gather+0x2b4>
      next = ISP_STAT_CFG_DOWN_AVG;
3401543c:	2605      	movs	r6, #5
3401543e:	e75f      	b.n	34015300 <ISP_SVC_Stats_Gather+0x2b4>
34015440:	340ce45c 	.word	0x340ce45c

34015444 <ISP_SVC_Stats_ProcessCallbacks>:
  *         If the conditions are met, call the client registered callbacks
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_ProcessCallbacks(ISP_HandleTypeDef *hIsp)
{
34015444:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  (void)hIsp; /* unused */
  ISP_SVC_StatStateTypeDef *pLastStat;
  ISP_SVC_StatRegisteredClient *client;
  ISP_StatusTypeDef retcb, ret = ISP_OK;
34015448:	2500      	movs	r5, #0
3401544a:	4c1c      	ldr	r4, [pc, #112]	@ (340154bc <ISP_SVC_Stats_ProcessCallbacks+0x78>)
{
3401544c:	2705      	movs	r7, #5
3401544e:	4626      	mov	r6, r4
      {
        ret = retcb;
      }

      /* Remove the client from the registered list */
      client->callback = NULL;
34015450:	46a9      	mov	r9, r5
      *(client->pStats) = *pLastStat;
34015452:	f104 0804 	add.w	r8, r4, #4
    if (client->callback == NULL)
34015456:	f8d4 a0f4 	ldr.w	sl, [r4, #244]	@ 0xf4
3401545a:	f1ba 0f00 	cmp.w	sl, #0
3401545e:	d016      	beq.n	3401548e <ISP_SVC_Stats_ProcessCallbacks+0x4a>
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
34015460:	f894 3104 	ldrb.w	r3, [r4, #260]	@ 0x104
34015464:	2b02      	cmp	r3, #2
34015466:	d119      	bne.n	3401549c <ISP_SVC_Stats_ProcessCallbacks+0x58>
34015468:	f8d4 2100 	ldr.w	r2, [r4, #256]	@ 0x100
3401546c:	6f73      	ldr	r3, [r6, #116]	@ 0x74
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
3401546e:	429a      	cmp	r2, r3
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
34015470:	d80d      	bhi.n	3401548e <ISP_SVC_Stats_ProcessCallbacks+0x4a>
      *(client->pStats) = *pLastStat;
34015472:	2278      	movs	r2, #120	@ 0x78
34015474:	4641      	mov	r1, r8
34015476:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
3401547a:	f005 f8ea 	bl	3401a652 <memcpy>
      retcb = client->callback(client->pAlgo);
3401547e:	f8d4 00f8 	ldr.w	r0, [r4, #248]	@ 0xf8
34015482:	47d0      	blx	sl
      if (retcb != ISP_OK)
34015484:	2800      	cmp	r0, #0
      client->callback = NULL;
34015486:	bf18      	it	ne
34015488:	4605      	movne	r5, r0
3401548a:	f8c4 90f4 	str.w	r9, [r4, #244]	@ 0xf4
  for (uint32_t i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3401548e:	3f01      	subs	r7, #1
34015490:	f104 0414 	add.w	r4, r4, #20
34015494:	d1df      	bne.n	34015456 <ISP_SVC_Stats_ProcessCallbacks+0x12>
    }
  }

  return ret;
}
34015496:	4628      	mov	r0, r5
34015498:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
3401549c:	2b01      	cmp	r3, #1
3401549e:	d103      	bne.n	340154a8 <ISP_SVC_Stats_ProcessCallbacks+0x64>
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
340154a0:	f8d4 2100 	ldr.w	r2, [r4, #256]	@ 0x100
340154a4:	6ef3      	ldr	r3, [r6, #108]	@ 0x6c
340154a6:	e7e2      	b.n	3401546e <ISP_SVC_Stats_ProcessCallbacks+0x2a>
340154a8:	2b03      	cmp	r3, #3
340154aa:	d1f0      	bne.n	3401548e <ISP_SVC_Stats_ProcessCallbacks+0x4a>
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
340154ac:	f8d4 3100 	ldr.w	r3, [r4, #256]	@ 0x100
340154b0:	6ef2      	ldr	r2, [r6, #108]	@ 0x6c
340154b2:	4293      	cmp	r3, r2
340154b4:	d8eb      	bhi.n	3401548e <ISP_SVC_Stats_ProcessCallbacks+0x4a>
340154b6:	6f72      	ldr	r2, [r6, #116]	@ 0x74
340154b8:	4293      	cmp	r3, r2
340154ba:	e7d9      	b.n	34015470 <ISP_SVC_Stats_ProcessCallbacks+0x2c>
340154bc:	340ce458 	.word	0x340ce458

340154c0 <ISP_SVC_Stats_GetNext>:
  * @param  frameDelay: number of frames to wait before considering the stats as valid
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_GetNext(ISP_HandleTypeDef *hIsp, ISP_stat_ready_cb callback, ISP_AlgoTypeDef *pAlgo, ISP_SVC_StatStateTypeDef *pStats,
                                        ISP_SVC_StatLocation location, ISP_SVC_StatType type, uint32_t frameDelay)
{
340154c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
340154c4:	4691      	mov	r9, r2
340154c6:	f89d c01c 	ldrb.w	ip, [sp, #28]
340154ca:	f89d 5020 	ldrb.w	r5, [sp, #32]
  uint32_t i, refFrameId;

  /* Check handle validity */
  if ((hIsp == NULL) || (pStats == NULL))
340154ce:	b1b0      	cbz	r0, 340154fe <ISP_SVC_Stats_GetNext+0x3e>
340154d0:	b1ab      	cbz	r3, 340154fe <ISP_SVC_Stats_GetNext+0x3e>
  return hIsp->MainPipe_FrameCount;
340154d2:	4e1e      	ldr	r6, [pc, #120]	@ (3401554c <ISP_SVC_Stats_GetNext+0x8c>)
  }

  refFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp) + frameDelay;

  /* Register the callback */
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
340154d4:	f04f 0e00 	mov.w	lr, #0
340154d8:	4634      	mov	r4, r6
340154da:	f04f 0805 	mov.w	r8, #5
  return hIsp->MainPipe_FrameCount;
340154de:	6c00      	ldr	r0, [r0, #64]	@ 0x40
  refFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp) + frameDelay;
340154e0:	9f09      	ldr	r7, [sp, #36]	@ 0x24
340154e2:	4407      	add	r7, r0
  {
    if (ISP_SVC_StatEngine.client[i].callback == NULL)
340154e4:	f8d6 20f4 	ldr.w	r2, [r6, #244]	@ 0xf4
340154e8:	b15a      	cbz	r2, 34015502 <ISP_SVC_Stats_GetNext+0x42>
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
340154ea:	f1b8 0801 	subs.w	r8, r8, #1
340154ee:	f10e 0e01 	add.w	lr, lr, #1
340154f2:	f106 0614 	add.w	r6, r6, #20
340154f6:	d1f5      	bne.n	340154e4 <ISP_SVC_Stats_GetNext+0x24>
  }

  if (i == ISP_SVC_STAT_MAX_CB)
  {
    /* Too much callback registered */
    return ISP_ERR_STAT_MAXCLIENTS;
340154f8:	20ac      	movs	r0, #172	@ 0xac
  ISP_SVC_StatEngine.client[i].location = location;
  ISP_SVC_StatEngine.client[i].type = type;
  ISP_SVC_StatEngine.client[i].refFrameId = refFrameId;

  return ISP_OK;
}
340154fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return ISP_ERR_EINVAL;
340154fe:	2001      	movs	r0, #1
34015500:	e7fb      	b.n	340154fa <ISP_SVC_Stats_GetNext+0x3a>
  if (location & ISP_STAT_LOC_UP)
34015502:	f01c 0f01 	tst.w	ip, #1
34015506:	d004      	beq.n	34015512 <ISP_SVC_Stats_GetNext+0x52>
    ISP_SVC_StatEngine.upRequest |= type;
34015508:	f894 6158 	ldrb.w	r6, [r4, #344]	@ 0x158
3401550c:	432e      	orrs	r6, r5
3401550e:	f884 6158 	strb.w	r6, [r4, #344]	@ 0x158
  if (location & ISP_STAT_LOC_DOWN)
34015512:	f01c 0f02 	tst.w	ip, #2
    ISP_SVC_StatEngine.downRequest |= type;
34015516:	bf1e      	ittt	ne
34015518:	f894 6159 	ldrbne.w	r6, [r4, #345]	@ 0x159
3401551c:	432e      	orrne	r6, r5
3401551e:	f884 6159 	strbne.w	r6, [r4, #345]	@ 0x159
  if (type == ISP_STAT_TYPE_ALL_TMP)
34015522:	2d04      	cmp	r5, #4
    ISP_SVC_StatEngine.requestAllCounter = ISP_SVC_Misc_GetMainFrameId(hIsp) + 3 * ISP_STAT_CFG_CYCLE_SIZE;
34015524:	bf04      	itt	eq
34015526:	301e      	addeq	r0, #30
34015528:	f8c4 015c 	streq.w	r0, [r4, #348]	@ 0x15c
  ISP_SVC_StatEngine.client[i].callback = callback;
3401552c:	2014      	movs	r0, #20
3401552e:	fb00 400e 	mla	r0, r0, lr, r4
  ISP_SVC_StatEngine.client[i].pAlgo = pAlgo;
34015532:	e9c0 193d 	strd	r1, r9, [r0, #244]	@ 0xf4
  ISP_SVC_StatEngine.client[i].pStats = pStats;
34015536:	f8c0 30fc 	str.w	r3, [r0, #252]	@ 0xfc
  ISP_SVC_StatEngine.client[i].location = location;
3401553a:	f880 c104 	strb.w	ip, [r0, #260]	@ 0x104
  ISP_SVC_StatEngine.client[i].type = type;
3401553e:	f880 5105 	strb.w	r5, [r0, #261]	@ 0x105
  ISP_SVC_StatEngine.client[i].refFrameId = refFrameId;
34015542:	f8c0 7100 	str.w	r7, [r0, #256]	@ 0x100
  return ISP_OK;
34015546:	2000      	movs	r0, #0
34015548:	e7d7      	b.n	340154fa <ISP_SVC_Stats_GetNext+0x3a>
3401554a:	bf00      	nop
3401554c:	340ce458 	.word	0x340ce458

34015550 <UTIL_LCD_SetFuncDriver>:
/**
  * @brief  Link board LCD drivers to STM32 LCD Utility drivers
  * @param  pDrv Structure of LCD functions
  */
void UTIL_LCD_SetFuncDriver(const LCD_UTILS_Drv_t *pDrv)
{
34015550:	b570      	push	{r4, r5, r6, lr}
  FuncDriver.GetXSize       = pDrv->GetXSize;
  FuncDriver.GetYSize       = pDrv->GetYSize;
  FuncDriver.SetLayer       = pDrv->SetLayer;
  FuncDriver.GetFormat      = pDrv->GetFormat;

  DrawProp->LcdLayer = 0;
34015552:	2600      	movs	r6, #0
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
34015554:	4c16      	ldr	r4, [pc, #88]	@ (340155b0 <UTIL_LCD_SetFuncDriver+0x60>)
34015556:	6803      	ldr	r3, [r0, #0]
  FuncDriver.GetYSize       = pDrv->GetYSize;
34015558:	6a02      	ldr	r2, [r0, #32]
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
3401555a:	6023      	str	r3, [r4, #0]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
3401555c:	6843      	ldr	r3, [r0, #4]
  FuncDriver.GetYSize       = pDrv->GetYSize;
3401555e:	6222      	str	r2, [r4, #32]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
34015560:	6063      	str	r3, [r4, #4]
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
34015562:	6883      	ldr	r3, [r0, #8]
  FuncDriver.SetLayer       = pDrv->SetLayer;
34015564:	6a42      	ldr	r2, [r0, #36]	@ 0x24
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
34015566:	60a3      	str	r3, [r4, #8]
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
34015568:	68c3      	ldr	r3, [r0, #12]
  DrawProp->LcdLayer = 0;
3401556a:	4d12      	ldr	r5, [pc, #72]	@ (340155b4 <UTIL_LCD_SetFuncDriver+0x64>)
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
3401556c:	60e3      	str	r3, [r4, #12]
  FuncDriver.FillRect       = pDrv->FillRect;
3401556e:	6903      	ldr	r3, [r0, #16]
  FuncDriver.SetLayer       = pDrv->SetLayer;
34015570:	6262      	str	r2, [r4, #36]	@ 0x24
  FuncDriver.FillRect       = pDrv->FillRect;
34015572:	6123      	str	r3, [r4, #16]
  FuncDriver.GetPixel       = pDrv->GetPixel;
34015574:	6943      	ldr	r3, [r0, #20]
  FuncDriver.GetFormat      = pDrv->GetFormat;
34015576:	6a82      	ldr	r2, [r0, #40]	@ 0x28
  FuncDriver.GetPixel       = pDrv->GetPixel;
34015578:	6163      	str	r3, [r4, #20]
  FuncDriver.SetPixel       = pDrv->SetPixel;
3401557a:	6983      	ldr	r3, [r0, #24]
  DrawProp->LcdDevice = 0;
  FuncDriver.GetXSize(0, &DrawProp[DrawProp->LcdLayer].LcdXsize);
3401557c:	f105 0114 	add.w	r1, r5, #20
  FuncDriver.SetPixel       = pDrv->SetPixel;
34015580:	61a3      	str	r3, [r4, #24]
  FuncDriver.GetXSize       = pDrv->GetXSize;
34015582:	69c3      	ldr	r3, [r0, #28]
  DrawProp->LcdDevice = 0;
34015584:	e9c5 6603 	strd	r6, r6, [r5, #12]
  FuncDriver.GetXSize(0, &DrawProp[DrawProp->LcdLayer].LcdXsize);
34015588:	4630      	mov	r0, r6
  FuncDriver.GetXSize       = pDrv->GetXSize;
3401558a:	61e3      	str	r3, [r4, #28]
  FuncDriver.GetFormat      = pDrv->GetFormat;
3401558c:	62a2      	str	r2, [r4, #40]	@ 0x28
  FuncDriver.GetXSize(0, &DrawProp[DrawProp->LcdLayer].LcdXsize);
3401558e:	4798      	blx	r3
  FuncDriver.GetYSize(0, &DrawProp[DrawProp->LcdLayer].LcdYsize);
34015590:	68e9      	ldr	r1, [r5, #12]
34015592:	6a23      	ldr	r3, [r4, #32]
34015594:	eb05 1141 	add.w	r1, r5, r1, lsl #5
34015598:	4630      	mov	r0, r6
3401559a:	3118      	adds	r1, #24
3401559c:	4798      	blx	r3
  FuncDriver.GetFormat(0, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
3401559e:	68eb      	ldr	r3, [r5, #12]
340155a0:	4630      	mov	r0, r6
340155a2:	eb05 1143 	add.w	r1, r5, r3, lsl #5
340155a6:	311c      	adds	r1, #28
340155a8:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
}
340155aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  FuncDriver.GetFormat(0, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
340155ae:	4718      	bx	r3
340155b0:	340ce814 	.word	0x340ce814
340155b4:	340ce840 	.word	0x340ce840

340155b8 <UTIL_LCD_SetLayer>:
/**
  * @brief  Set the LCD layer.
  * @param  Layer  LCD layer
  */
void UTIL_LCD_SetLayer(uint32_t Layer)
{
340155b8:	b570      	push	{r4, r5, r6, lr}
  if(FuncDriver.SetLayer != NULL)
340155ba:	4e10      	ldr	r6, [pc, #64]	@ (340155fc <UTIL_LCD_SetLayer+0x44>)
{
340155bc:	4605      	mov	r5, r0
  if(FuncDriver.SetLayer != NULL)
340155be:	6a73      	ldr	r3, [r6, #36]	@ 0x24
340155c0:	b1db      	cbz	r3, 340155fa <UTIL_LCD_SetLayer+0x42>
  {
    if(FuncDriver.SetLayer(DrawProp->LcdDevice, Layer) == 0)
340155c2:	4c0f      	ldr	r4, [pc, #60]	@ (34015600 <UTIL_LCD_SetLayer+0x48>)
340155c4:	4601      	mov	r1, r0
340155c6:	6920      	ldr	r0, [r4, #16]
340155c8:	4798      	blx	r3
340155ca:	b9b0      	cbnz	r0, 340155fa <UTIL_LCD_SetLayer+0x42>
    {
      DrawProp->LcdLayer = Layer;
      FuncDriver.GetXSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdXsize);
340155cc:	eb04 1145 	add.w	r1, r4, r5, lsl #5
340155d0:	69f3      	ldr	r3, [r6, #28]
340155d2:	6920      	ldr	r0, [r4, #16]
      DrawProp->LcdLayer = Layer;
340155d4:	60e5      	str	r5, [r4, #12]
      FuncDriver.GetXSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdXsize);
340155d6:	3114      	adds	r1, #20
340155d8:	4798      	blx	r3
      FuncDriver.GetYSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdYsize);
340155da:	68e1      	ldr	r1, [r4, #12]
340155dc:	6a33      	ldr	r3, [r6, #32]
340155de:	eb04 1141 	add.w	r1, r4, r1, lsl #5
340155e2:	6920      	ldr	r0, [r4, #16]
340155e4:	3118      	adds	r1, #24
340155e6:	4798      	blx	r3
      FuncDriver.GetFormat(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
340155e8:	68e1      	ldr	r1, [r4, #12]
340155ea:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
340155ec:	eb04 1141 	add.w	r1, r4, r1, lsl #5
340155f0:	6920      	ldr	r0, [r4, #16]
340155f2:	311c      	adds	r1, #28
    }
  }
}
340155f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      FuncDriver.GetFormat(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
340155f8:	4718      	bx	r3
}
340155fa:	bd70      	pop	{r4, r5, r6, pc}
340155fc:	340ce814 	.word	0x340ce814
34015600:	340ce840 	.word	0x340ce840

34015604 <UTIL_LCD_SetTextColor>:
  * @brief  Sets the LCD text color.
  * @param  Color  Text color code
  */
void UTIL_LCD_SetTextColor(uint32_t Color)
{
  DrawProp[DrawProp->LcdLayer].TextColor = Color;
34015604:	4a02      	ldr	r2, [pc, #8]	@ (34015610 <UTIL_LCD_SetTextColor+0xc>)
34015606:	68d3      	ldr	r3, [r2, #12]
34015608:	015b      	lsls	r3, r3, #5
3401560a:	50d0      	str	r0, [r2, r3]
}
3401560c:	4770      	bx	lr
3401560e:	bf00      	nop
34015610:	340ce840 	.word	0x340ce840

34015614 <UTIL_LCD_SetBackColor>:
  * @brief  Sets the LCD background color.
  * @param  Color  Layer background color code
  */
void UTIL_LCD_SetBackColor(uint32_t Color)
{
  DrawProp[DrawProp->LcdLayer].BackColor = Color;
34015614:	4b02      	ldr	r3, [pc, #8]	@ (34015620 <UTIL_LCD_SetBackColor+0xc>)
34015616:	68da      	ldr	r2, [r3, #12]
34015618:	eb03 1342 	add.w	r3, r3, r2, lsl #5
3401561c:	6058      	str	r0, [r3, #4]
}
3401561e:	4770      	bx	lr
34015620:	340ce840 	.word	0x340ce840

34015624 <UTIL_LCD_SetFont>:
  * @brief  Sets the LCD text font.
  * @param  fonts  Layer font to be used
  */
void UTIL_LCD_SetFont(sFONT *fonts)
{
  DrawProp[DrawProp->LcdLayer].pFont = fonts;
34015624:	4b02      	ldr	r3, [pc, #8]	@ (34015630 <UTIL_LCD_SetFont+0xc>)
34015626:	68da      	ldr	r2, [r3, #12]
34015628:	eb03 1342 	add.w	r3, r3, r2, lsl #5
3401562c:	6098      	str	r0, [r3, #8]
}
3401562e:	4770      	bx	lr
34015630:	340ce840 	.word	0x340ce840

34015634 <UTIL_LCD_GetFont>:
  * @brief  Gets the LCD text font.
  * @retval Used layer font
  */
sFONT *UTIL_LCD_GetFont(void)
{
  return DrawProp[DrawProp->LcdLayer].pFont;
34015634:	4b02      	ldr	r3, [pc, #8]	@ (34015640 <UTIL_LCD_GetFont+0xc>)
34015636:	68da      	ldr	r2, [r3, #12]
34015638:	eb03 1342 	add.w	r3, r3, r2, lsl #5
}
3401563c:	6898      	ldr	r0, [r3, #8]
3401563e:	4770      	bx	lr
34015640:	340ce840 	.word	0x340ce840

34015644 <UTIL_LCD_FillRGBRect>:
  * @param  Xpos    X position
  * @param  Ypos    Y position
  * @param  Length  Line length
  */
void UTIL_LCD_FillRGBRect(uint32_t Xpos, uint32_t Ypos, uint8_t *pData, uint32_t Width, uint32_t Height)
{
34015644:	b513      	push	{r0, r1, r4, lr}
  /* Write RGB rectangle data */
  FuncDriver.FillRGBRect(DrawProp->LcdDevice, Xpos, Ypos, pData, Width, Height);
34015646:	9c04      	ldr	r4, [sp, #16]
34015648:	e9cd 3400 	strd	r3, r4, [sp]
3401564c:	4b04      	ldr	r3, [pc, #16]	@ (34015660 <UTIL_LCD_FillRGBRect+0x1c>)
3401564e:	685c      	ldr	r4, [r3, #4]
34015650:	4613      	mov	r3, r2
34015652:	460a      	mov	r2, r1
34015654:	4601      	mov	r1, r0
34015656:	4803      	ldr	r0, [pc, #12]	@ (34015664 <UTIL_LCD_FillRGBRect+0x20>)
34015658:	6900      	ldr	r0, [r0, #16]
3401565a:	47a0      	blx	r4
}
3401565c:	b002      	add	sp, #8
3401565e:	bd10      	pop	{r4, pc}
34015660:	340ce814 	.word	0x340ce814
34015664:	340ce840 	.word	0x340ce840

34015668 <UTIL_LCD_DrawHLine>:
  * @param  Ypos    Y position
  * @param  Length  Line length
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawHLine(uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
34015668:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3401566a:	4606      	mov	r6, r0
  /* Write line */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401566c:	4817      	ldr	r0, [pc, #92]	@ (340156cc <UTIL_LCD_DrawHLine+0x64>)
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
3401566e:	4d18      	ldr	r5, [pc, #96]	@ (340156d0 <UTIL_LCD_DrawHLine+0x68>)
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015670:	68c4      	ldr	r4, [r0, #12]
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
34015672:	68ad      	ldr	r5, [r5, #8]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015674:	eb00 1444 	add.w	r4, r0, r4, lsl #5
34015678:	69e4      	ldr	r4, [r4, #28]
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
3401567a:	6900      	ldr	r0, [r0, #16]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401567c:	2c02      	cmp	r4, #2
3401567e:	d110      	bne.n	340156a2 <UTIL_LCD_DrawHLine+0x3a>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
34015680:	095c      	lsrs	r4, r3, #5
34015682:	0a1f      	lsrs	r7, r3, #8
34015684:	f404 64fc 	and.w	r4, r4, #2016	@ 0x7e0
34015688:	f407 4778 	and.w	r7, r7, #63488	@ 0xf800
3401568c:	433c      	orrs	r4, r7
3401568e:	f3c3 03c4 	ubfx	r3, r3, #3, #5
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
  }
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
34015692:	431c      	orrs	r4, r3
34015694:	9400      	str	r4, [sp, #0]
  }
  else /*LCD_PIXEL_FORMAT_ARGB8888*/
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
34015696:	4613      	mov	r3, r2
34015698:	460a      	mov	r2, r1
3401569a:	4631      	mov	r1, r6
3401569c:	47a8      	blx	r5
  }
}
3401569e:	b003      	add	sp, #12
340156a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
340156a2:	2c01      	cmp	r4, #1
340156a4:	d103      	bne.n	340156ae <UTIL_LCD_DrawHLine+0x46>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
340156a6:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
340156aa:	9300      	str	r3, [sp, #0]
340156ac:	e7f3      	b.n	34015696 <UTIL_LCD_DrawHLine+0x2e>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
340156ae:	2c04      	cmp	r4, #4
340156b0:	d1fb      	bne.n	340156aa <UTIL_LCD_DrawHLine+0x42>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
340156b2:	0f1f      	lsrs	r7, r3, #28
340156b4:	f3c3 1403 	ubfx	r4, r3, #4, #4
340156b8:	ea44 3407 	orr.w	r4, r4, r7, lsl #12
340156bc:	0a1f      	lsrs	r7, r3, #8
340156be:	f007 07f0 	and.w	r7, r7, #240	@ 0xf0
340156c2:	0b1b      	lsrs	r3, r3, #12
340156c4:	433c      	orrs	r4, r7
340156c6:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340156ca:	e7e2      	b.n	34015692 <UTIL_LCD_DrawHLine+0x2a>
340156cc:	340ce840 	.word	0x340ce840
340156d0:	340ce814 	.word	0x340ce814

340156d4 <UTIL_LCD_DrawVLine>:
  * @param  Ypos    Y position
  * @param  Length  Line length
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawVLine(uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
340156d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
340156d6:	4606      	mov	r6, r0
  /* Write line */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340156d8:	4817      	ldr	r0, [pc, #92]	@ (34015738 <UTIL_LCD_DrawVLine+0x64>)
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
340156da:	4d18      	ldr	r5, [pc, #96]	@ (3401573c <UTIL_LCD_DrawVLine+0x68>)
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340156dc:	68c4      	ldr	r4, [r0, #12]
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
340156de:	68ed      	ldr	r5, [r5, #12]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340156e0:	eb00 1444 	add.w	r4, r0, r4, lsl #5
340156e4:	69e4      	ldr	r4, [r4, #28]
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
340156e6:	6900      	ldr	r0, [r0, #16]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340156e8:	2c02      	cmp	r4, #2
340156ea:	d110      	bne.n	3401570e <UTIL_LCD_DrawVLine+0x3a>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
340156ec:	095c      	lsrs	r4, r3, #5
340156ee:	0a1f      	lsrs	r7, r3, #8
340156f0:	f404 64fc 	and.w	r4, r4, #2016	@ 0x7e0
340156f4:	f407 4778 	and.w	r7, r7, #63488	@ 0xf800
340156f8:	433c      	orrs	r4, r7
340156fa:	f3c3 03c4 	ubfx	r3, r3, #3, #5
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
  }
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
340156fe:	431c      	orrs	r4, r3
34015700:	9400      	str	r4, [sp, #0]
  }
  else /*LCD_PIXEL_FORMAT_ARGB888*/
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
34015702:	4613      	mov	r3, r2
34015704:	460a      	mov	r2, r1
34015706:	4631      	mov	r1, r6
34015708:	47a8      	blx	r5
  }
}
3401570a:	b003      	add	sp, #12
3401570c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
3401570e:	2c01      	cmp	r4, #1
34015710:	d103      	bne.n	3401571a <UTIL_LCD_DrawVLine+0x46>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
34015712:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
34015716:	9300      	str	r3, [sp, #0]
34015718:	e7f3      	b.n	34015702 <UTIL_LCD_DrawVLine+0x2e>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
3401571a:	2c04      	cmp	r4, #4
3401571c:	d1fb      	bne.n	34015716 <UTIL_LCD_DrawVLine+0x42>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
3401571e:	0f1f      	lsrs	r7, r3, #28
34015720:	f3c3 1403 	ubfx	r4, r3, #4, #4
34015724:	ea44 3407 	orr.w	r4, r4, r7, lsl #12
34015728:	0a1f      	lsrs	r7, r3, #8
3401572a:	f007 07f0 	and.w	r7, r7, #240	@ 0xf0
3401572e:	0b1b      	lsrs	r3, r3, #12
34015730:	433c      	orrs	r4, r7
34015732:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34015736:	e7e2      	b.n	340156fe <UTIL_LCD_DrawVLine+0x2a>
34015738:	340ce840 	.word	0x340ce840
3401573c:	340ce814 	.word	0x340ce814

34015740 <UTIL_LCD_DisplayChar>:
  * @param  Ypos Line where to display the character shape.
  * @param  Ascii Character ascii code
  *           This parameter must be a number between Min_Data = 0x20 and Max_Data = 0x7E
  */
void UTIL_LCD_DisplayChar(uint32_t Xpos, uint32_t Ypos, uint8_t Ascii)
{
34015740:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
34015744:	f8df 81e0 	ldr.w	r8, [pc, #480]	@ 34015928 <UTIL_LCD_DisplayChar+0x1e8>
{
34015748:	b0a3      	sub	sp, #140	@ 0x8c
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
3401574a:	f8d8 300c 	ldr.w	r3, [r8, #12]
{
3401574e:	9108      	str	r1, [sp, #32]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
34015750:	eb08 1343 	add.w	r3, r8, r3, lsl #5
34015754:	6899      	ldr	r1, [r3, #8]
{
34015756:	9005      	str	r0, [sp, #20]
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
34015758:	88cb      	ldrh	r3, [r1, #6]
3401575a:	888c      	ldrh	r4, [r1, #4]
3401575c:	9307      	str	r3, [sp, #28]
  uint8_t rgb8[24*4];
  uint16_t* rgb16 = (uint16_t*)rgb8;
  uint32_t* argb32 = (uint32_t*)rgb8;
  uint16_t* argb4444 = (uint16_t*)rgb8;

  offset =  8 *((width + 7)/8) -  width ;
3401575e:	1de3      	adds	r3, r4, #7
34015760:	f023 0007 	bic.w	r0, r3, #7
34015764:	9003      	str	r0, [sp, #12]

  for(i = 0; i < height; i++)
  {
    pchar = ((uint8_t *)pData + (width + 7)/8 * i);
34015766:	08d8      	lsrs	r0, r3, #3
34015768:	9006      	str	r0, [sp, #24]
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
    }
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
    {
      for (j = 0; j < width*3; j = j+ 3)
3401576a:	eb04 0044 	add.w	r0, r4, r4, lsl #1
3401576e:	9009      	str	r0, [sp, #36]	@ 0x24
34015770:	9808      	ldr	r0, [sp, #32]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
34015772:	3a20      	subs	r2, #32
34015774:	3001      	adds	r0, #1
34015776:	9004      	str	r0, [sp, #16]
34015778:	9807      	ldr	r0, [sp, #28]
3401577a:	680d      	ldr	r5, [r1, #0]
3401577c:	4342      	muls	r2, r0
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
3401577e:	10db      	asrs	r3, r3, #3
34015780:	fb03 5502 	mla	r5, r3, r2, r5
34015784:	9b04      	ldr	r3, [sp, #16]
  for(i = 0; i < height; i++)
34015786:	9a08      	ldr	r2, [sp, #32]
34015788:	1e59      	subs	r1, r3, #1
3401578a:	1a9b      	subs	r3, r3, r2
3401578c:	9a07      	ldr	r2, [sp, #28]
3401578e:	3b01      	subs	r3, #1
34015790:	429a      	cmp	r2, r3
34015792:	d802      	bhi.n	3401579a <UTIL_LCD_DisplayChar+0x5a>
}
34015794:	b023      	add	sp, #140	@ 0x8c
34015796:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch(((width + 7)/8))
3401579a:	9806      	ldr	r0, [sp, #24]
      line =  pchar[0];
3401579c:	782b      	ldrb	r3, [r5, #0]
    switch(((width + 7)/8))
3401579e:	2801      	cmp	r0, #1
      line =  pchar[0];
340157a0:	461a      	mov	r2, r3
    switch(((width + 7)/8))
340157a2:	d004      	beq.n	340157ae <UTIL_LCD_DisplayChar+0x6e>
340157a4:	2802      	cmp	r0, #2
340157a6:	d127      	bne.n	340157f8 <UTIL_LCD_DisplayChar+0xb8>
      line =  (pchar[0]<< 8) | pchar[1];
340157a8:	882a      	ldrh	r2, [r5, #0]
340157aa:	ba52      	rev16	r2, r2
340157ac:	b292      	uxth	r2, r2
    if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340157ae:	f8d8 000c 	ldr.w	r0, [r8, #12]
340157b2:	eb08 1040 	add.w	r0, r8, r0, lsl #5
340157b6:	69c7      	ldr	r7, [r0, #28]
340157b8:	2f02      	cmp	r7, #2
340157ba:	d13c      	bne.n	34015836 <UTIL_LCD_DisplayChar+0xf6>
340157bc:	f04f 0c01 	mov.w	ip, #1
        if(line & (1 << (width- j + offset- 1)))
340157c0:	9b03      	ldr	r3, [sp, #12]
      for (j = 0; j < width; j++)
340157c2:	f04f 0e00 	mov.w	lr, #0
        if(line & (1 << (width- j + offset- 1)))
340157c6:	f103 3aff 	add.w	sl, r3, #4294967295
340157ca:	4663      	mov	r3, ip
340157cc:	4574      	cmp	r4, lr
340157ce:	eb04 0603 	add.w	r6, r4, r3
340157d2:	bf08      	it	eq
340157d4:	4666      	moveq	r6, ip
340157d6:	f10d 0928 	add.w	r9, sp, #40	@ 0x28
      for (j = 0; j < width; j++)
340157da:	3e01      	subs	r6, #1
340157dc:	d113      	bne.n	34015806 <UTIL_LCD_DisplayChar+0xc6>
        else
        {
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].BackColor);
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, (uint8_t*)&argb4444[0], width, 1);
340157de:	f8cd c000 	str.w	ip, [sp]
        else
        {
          argb32[j] = DrawProp[DrawProp->LcdLayer].BackColor;
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
340157e2:	4623      	mov	r3, r4
340157e4:	9805      	ldr	r0, [sp, #20]
340157e6:	aa0a      	add	r2, sp, #40	@ 0x28
340157e8:	f7ff ff2c 	bl	34015644 <UTIL_LCD_FillRGBRect>
  for(i = 0; i < height; i++)
340157ec:	9b04      	ldr	r3, [sp, #16]
340157ee:	3301      	adds	r3, #1
340157f0:	9304      	str	r3, [sp, #16]
340157f2:	9b06      	ldr	r3, [sp, #24]
340157f4:	441d      	add	r5, r3
340157f6:	e7c5      	b.n	34015784 <UTIL_LCD_DisplayChar+0x44>
      line =  (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];
340157f8:	786a      	ldrb	r2, [r5, #1]
340157fa:	041b      	lsls	r3, r3, #16
340157fc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
34015800:	78aa      	ldrb	r2, [r5, #2]
34015802:	431a      	orrs	r2, r3
      break;
34015804:	e7d3      	b.n	340157ae <UTIL_LCD_DisplayChar+0x6e>
        if(line & (1 << (width- j + offset- 1)))
34015806:	ebaa 030e 	sub.w	r3, sl, lr
3401580a:	fa0c f303 	lsl.w	r3, ip, r3
3401580e:	4213      	tst	r3, r2
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].TextColor);
34015810:	bf14      	ite	ne
34015812:	6807      	ldrne	r7, [r0, #0]
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].BackColor);
34015814:	6847      	ldreq	r7, [r0, #4]
      for (j = 0; j < width; j++)
34015816:	f10e 0e01 	add.w	lr, lr, #1
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].BackColor);
3401581a:	f3c7 03c4 	ubfx	r3, r7, #3, #5
3401581e:	ea4f 4bd7 	mov.w	fp, r7, lsr #19
34015822:	097f      	lsrs	r7, r7, #5
34015824:	ea43 23cb 	orr.w	r3, r3, fp, lsl #11
34015828:	f407 67fc 	and.w	r7, r7, #2016	@ 0x7e0
3401582c:	433b      	orrs	r3, r7
3401582e:	b29b      	uxth	r3, r3
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].TextColor);
34015830:	f829 3b02 	strh.w	r3, [r9], #2
      for (j = 0; j < width; j++)
34015834:	e7d1      	b.n	340157da <UTIL_LCD_DisplayChar+0x9a>
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
34015836:	2f01      	cmp	r7, #1
34015838:	d126      	bne.n	34015888 <UTIL_LCD_DisplayChar+0x148>
      for (j = 0; j < width*3; j = j+ 3)
3401583a:	f04f 0c00 	mov.w	ip, #0
        if(line & (1 << (width- j/3 + offset- 1)))
3401583e:	f04f 0b03 	mov.w	fp, #3
34015842:	9b03      	ldr	r3, [sp, #12]
34015844:	ae0a      	add	r6, sp, #40	@ 0x28
34015846:	f103 3aff 	add.w	sl, r3, #4294967295
      for (j = 0; j < width*3; j = j+ 3)
3401584a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401584c:	459c      	cmp	ip, r3
3401584e:	d302      	bcc.n	34015856 <UTIL_LCD_DisplayChar+0x116>
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
34015850:	2301      	movs	r3, #1
34015852:	9300      	str	r3, [sp, #0]
34015854:	e7c5      	b.n	340157e2 <UTIL_LCD_DisplayChar+0xa2>
        if(line & (1 << (width- j/3 + offset- 1)))
34015856:	fbbc f3fb 	udiv	r3, ip, fp
3401585a:	ebaa 0303 	sub.w	r3, sl, r3
3401585e:	fa07 f303 	lsl.w	r3, r7, r3
34015862:	4213      	tst	r3, r2
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) & 0xFFU;
34015864:	bf14      	ite	ne
34015866:	6803      	ldrne	r3, [r0, #0]
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) & 0xFFU;
34015868:	6843      	ldreq	r3, [r0, #4]
      for (j = 0; j < width*3; j = j+ 3)
3401586a:	f10c 0c03 	add.w	ip, ip, #3
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) & 0xFFU;
3401586e:	fa5f f983 	uxtb.w	r9, r3
          rgb8[j + 1U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) >> 8) & 0xFFU;
34015872:	f3c3 2e07 	ubfx	lr, r3, #8, #8
          rgb8[j + 2U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) >> 16) & 0xFFU;
34015876:	f3c3 4307 	ubfx	r3, r3, #16, #8
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) & 0xFFU;
3401587a:	f886 9000 	strb.w	r9, [r6]
          rgb8[j + 1U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) >> 8) & 0xFFU;
3401587e:	f886 e001 	strb.w	lr, [r6, #1]
          rgb8[j + 2U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) >> 16) & 0xFFU;
34015882:	70b3      	strb	r3, [r6, #2]
      for (j = 0; j < width*3; j = j+ 3)
34015884:	3603      	adds	r6, #3
34015886:	e7e0      	b.n	3401584a <UTIL_LCD_DisplayChar+0x10a>
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
34015888:	2f04      	cmp	r7, #4
3401588a:	d01f      	beq.n	340158cc <UTIL_LCD_DisplayChar+0x18c>
        if(line & (1 << (width- j + offset- 1)))
3401588c:	f04f 0a01 	mov.w	sl, #1
      for (j = 0; j < width; j++)
34015890:	2700      	movs	r7, #0
34015892:	4656      	mov	r6, sl
        if(line & (1 << (width- j + offset- 1)))
34015894:	9b03      	ldr	r3, [sp, #12]
34015896:	42bc      	cmp	r4, r7
34015898:	f103 3bff 	add.w	fp, r3, #4294967295
3401589c:	eb04 0306 	add.w	r3, r4, r6
340158a0:	bf14      	ite	ne
340158a2:	469c      	movne	ip, r3
340158a4:	46d4      	moveq	ip, sl
340158a6:	f10d 0928 	add.w	r9, sp, #40	@ 0x28
      for (j = 0; j < width; j++)
340158aa:	f1bc 0c01 	subs.w	ip, ip, #1
340158ae:	d0cf      	beq.n	34015850 <UTIL_LCD_DisplayChar+0x110>
        if(line & (1 << (width- j + offset- 1)))
340158b0:	ebab 0e07 	sub.w	lr, fp, r7
340158b4:	6843      	ldr	r3, [r0, #4]
340158b6:	fa0a fe0e 	lsl.w	lr, sl, lr
340158ba:	ea1e 0f02 	tst.w	lr, r2
          argb32[j] = DrawProp[DrawProp->LcdLayer].TextColor;
340158be:	6806      	ldr	r6, [r0, #0]
        if(line & (1 << (width- j + offset- 1)))
340158c0:	bf08      	it	eq
340158c2:	461e      	moveq	r6, r3
      for (j = 0; j < width; j++)
340158c4:	3701      	adds	r7, #1
          argb32[j] = DrawProp[DrawProp->LcdLayer].TextColor;
340158c6:	f849 6b04 	str.w	r6, [r9], #4
      for (j = 0; j < width; j++)
340158ca:	e7ee      	b.n	340158aa <UTIL_LCD_DisplayChar+0x16a>
340158cc:	f04f 0c01 	mov.w	ip, #1
        if(line & (1 << (width- j + offset- 1)))
340158d0:	9b03      	ldr	r3, [sp, #12]
      for (j = 0; j < width; j++)
340158d2:	f04f 0e00 	mov.w	lr, #0
        if(line & (1 << (width- j + offset- 1)))
340158d6:	f103 3bff 	add.w	fp, r3, #4294967295
340158da:	4663      	mov	r3, ip
340158dc:	4574      	cmp	r4, lr
340158de:	eb04 0603 	add.w	r6, r4, r3
340158e2:	bf08      	it	eq
340158e4:	4666      	moveq	r6, ip
340158e6:	f10d 0a28 	add.w	sl, sp, #40	@ 0x28
      for (j = 0; j < width; j++)
340158ea:	3e01      	subs	r6, #1
340158ec:	f43f af77 	beq.w	340157de <UTIL_LCD_DisplayChar+0x9e>
        if(line & (1 << (width- j + offset- 1)))
340158f0:	ebab 030e 	sub.w	r3, fp, lr
340158f4:	fa0c f303 	lsl.w	r3, ip, r3
340158f8:	4213      	tst	r3, r2
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].TextColor);
340158fa:	bf14      	ite	ne
340158fc:	6807      	ldrne	r7, [r0, #0]
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].BackColor);
340158fe:	6847      	ldreq	r7, [r0, #4]
      for (j = 0; j < width; j++)
34015900:	f10e 0e01 	add.w	lr, lr, #1
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].BackColor);
34015904:	0f3b      	lsrs	r3, r7, #28
34015906:	f3c7 1903 	ubfx	r9, r7, #4, #4
3401590a:	ea49 3903 	orr.w	r9, r9, r3, lsl #12
3401590e:	0a3b      	lsrs	r3, r7, #8
34015910:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
34015914:	0b3f      	lsrs	r7, r7, #12
34015916:	ea49 0303 	orr.w	r3, r9, r3
3401591a:	f407 6770 	and.w	r7, r7, #3840	@ 0xf00
3401591e:	433b      	orrs	r3, r7
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].TextColor);
34015920:	f82a 3b02 	strh.w	r3, [sl], #2
      for (j = 0; j < width; j++)
34015924:	e7e1      	b.n	340158ea <UTIL_LCD_DisplayChar+0x1aa>
34015926:	bf00      	nop
34015928:	340ce840 	.word	0x340ce840

3401592c <UTIL_LCD_DisplayStringAt>:
{
3401592c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  xsize = (DrawProp[DrawProp->LcdLayer].LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
34015930:	f8df 8088 	ldr.w	r8, [pc, #136]	@ 340159bc <UTIL_LCD_DisplayStringAt+0x90>
{
34015934:	4605      	mov	r5, r0
  while (*ptr++) size ++ ;
34015936:	4610      	mov	r0, r2
{
34015938:	4699      	mov	r9, r3
3401593a:	4616      	mov	r6, r2
3401593c:	460f      	mov	r7, r1
  while (*ptr++) size ++ ;
3401593e:	f7eb fefd 	bl	3400173c <strlen>
  xsize = (DrawProp[DrawProp->LcdLayer].LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
34015942:	f8d8 300c 	ldr.w	r3, [r8, #12]
  switch (Mode)
34015946:	f1b9 0f01 	cmp.w	r9, #1
  xsize = (DrawProp[DrawProp->LcdLayer].LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
3401594a:	eb08 1343 	add.w	r3, r8, r3, lsl #5
3401594e:	689a      	ldr	r2, [r3, #8]
34015950:	695c      	ldr	r4, [r3, #20]
34015952:	8892      	ldrh	r2, [r2, #4]
34015954:	fbb4 f4f2 	udiv	r4, r4, r2
      refcolumn = - Xpos + ((xsize - size)*DrawProp[DrawProp->LcdLayer].pFont->Width);
34015958:	eba4 0400 	sub.w	r4, r4, r0
3401595c:	fb02 f404 	mul.w	r4, r2, r4
  switch (Mode)
34015960:	d01b      	beq.n	3401599a <UTIL_LCD_DisplayStringAt+0x6e>
      refcolumn = - Xpos + ((xsize - size)*DrawProp[DrawProp->LcdLayer].pFont->Width);
34015962:	1b64      	subs	r4, r4, r5
34015964:	f1b9 0f02 	cmp.w	r9, #2
34015968:	bf08      	it	eq
3401596a:	4625      	moveq	r5, r4
  if ((refcolumn < 1) || (refcolumn >= 0x8000))
3401596c:	f647 73fe 	movw	r3, #32766	@ 0x7ffe
34015970:	1e6a      	subs	r2, r5, #1
    refcolumn = 1;
34015972:	429a      	cmp	r2, r3
34015974:	bf88      	it	hi
34015976:	2501      	movhi	r5, #1
34015978:	2400      	movs	r4, #0
  while ((*Text != 0) & (((DrawProp[DrawProp->LcdLayer].LcdXsize - (i*DrawProp[DrawProp->LcdLayer].pFont->Width)) & 0xFFFF) >= DrawProp[DrawProp->LcdLayer].pFont->Width))
3401597a:	f8d8 300c 	ldr.w	r3, [r8, #12]
3401597e:	5d32      	ldrb	r2, [r6, r4]
34015980:	eb08 1343 	add.w	r3, r8, r3, lsl #5
34015984:	6899      	ldr	r1, [r3, #8]
34015986:	695b      	ldr	r3, [r3, #20]
34015988:	8889      	ldrh	r1, [r1, #4]
3401598a:	fb04 3311 	mls	r3, r4, r1, r3
3401598e:	b29b      	uxth	r3, r3
34015990:	4299      	cmp	r1, r3
34015992:	d800      	bhi.n	34015996 <UTIL_LCD_DisplayStringAt+0x6a>
34015994:	b922      	cbnz	r2, 340159a0 <UTIL_LCD_DisplayStringAt+0x74>
}
34015996:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      refcolumn = Xpos + ((xsize - size)* DrawProp[DrawProp->LcdLayer].pFont->Width) / 2;
3401599a:	eb05 0554 	add.w	r5, r5, r4, lsr #1
      break;
3401599e:	e7e5      	b.n	3401596c <UTIL_LCD_DisplayStringAt+0x40>
    UTIL_LCD_DisplayChar(refcolumn, Ypos, *Text);
340159a0:	4628      	mov	r0, r5
340159a2:	4639      	mov	r1, r7
340159a4:	f7ff fecc 	bl	34015740 <UTIL_LCD_DisplayChar>
    refcolumn += DrawProp[DrawProp->LcdLayer].pFont->Width;
340159a8:	f8d8 300c 	ldr.w	r3, [r8, #12]
    i++;
340159ac:	3401      	adds	r4, #1
    refcolumn += DrawProp[DrawProp->LcdLayer].pFont->Width;
340159ae:	eb08 1343 	add.w	r3, r8, r3, lsl #5
340159b2:	689b      	ldr	r3, [r3, #8]
340159b4:	889b      	ldrh	r3, [r3, #4]
340159b6:	441d      	add	r5, r3
    i++;
340159b8:	e7df      	b.n	3401597a <UTIL_LCD_DisplayStringAt+0x4e>
340159ba:	bf00      	nop
340159bc:	340ce840 	.word	0x340ce840

340159c0 <UTIL_LCD_DrawRect>:
{
340159c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
340159c4:	461f      	mov	r7, r3
340159c6:	460e      	mov	r6, r1
340159c8:	4605      	mov	r5, r0
340159ca:	4614      	mov	r4, r2
340159cc:	f8dd 8018 	ldr.w	r8, [sp, #24]
  UTIL_LCD_DrawHLine(Xpos, Ypos, Width, Color);
340159d0:	4643      	mov	r3, r8
340159d2:	f7ff fe49 	bl	34015668 <UTIL_LCD_DrawHLine>
  UTIL_LCD_DrawHLine(Xpos, (Ypos+ Height - 1U), Width, Color);
340159d6:	1e79      	subs	r1, r7, #1
340159d8:	4643      	mov	r3, r8
340159da:	4622      	mov	r2, r4
340159dc:	4628      	mov	r0, r5
340159de:	4431      	add	r1, r6
340159e0:	f7ff fe42 	bl	34015668 <UTIL_LCD_DrawHLine>
  UTIL_LCD_DrawVLine((Xpos + Width - 1U), Ypos, Height, Color);
340159e4:	3c01      	subs	r4, #1
  UTIL_LCD_DrawVLine(Xpos, Ypos, Height, Color);
340159e6:	4643      	mov	r3, r8
340159e8:	463a      	mov	r2, r7
340159ea:	4631      	mov	r1, r6
340159ec:	4628      	mov	r0, r5
340159ee:	f7ff fe71 	bl	340156d4 <UTIL_LCD_DrawVLine>
  UTIL_LCD_DrawVLine((Xpos + Width - 1U), Ypos, Height, Color);
340159f2:	4643      	mov	r3, r8
340159f4:	463a      	mov	r2, r7
340159f6:	4631      	mov	r1, r6
340159f8:	1960      	adds	r0, r4, r5
}
340159fa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  UTIL_LCD_DrawVLine((Xpos + Width - 1U), Ypos, Height, Color);
340159fe:	f7ff be69 	b.w	340156d4 <UTIL_LCD_DrawVLine>
	...

34015a04 <UTIL_LCD_FillRect>:
{
34015a04:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34015a06:	4607      	mov	r7, r0
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015a08:	481a      	ldr	r0, [pc, #104]	@ (34015a74 <UTIL_LCD_FillRect+0x70>)
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
34015a0a:	4e1b      	ldr	r6, [pc, #108]	@ (34015a78 <UTIL_LCD_FillRect+0x74>)
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015a0c:	68c5      	ldr	r5, [r0, #12]
{
34015a0e:	9c08      	ldr	r4, [sp, #32]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015a10:	eb00 1545 	add.w	r5, r0, r5, lsl #5
34015a14:	69ed      	ldr	r5, [r5, #28]
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
34015a16:	6936      	ldr	r6, [r6, #16]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015a18:	2d02      	cmp	r5, #2
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
34015a1a:	6900      	ldr	r0, [r0, #16]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015a1c:	d10c      	bne.n	34015a38 <UTIL_LCD_FillRect+0x34>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
34015a1e:	0965      	lsrs	r5, r4, #5
34015a20:	ea4f 2c14 	mov.w	ip, r4, lsr #8
34015a24:	f405 65fc 	and.w	r5, r5, #2016	@ 0x7e0
34015a28:	f40c 4c78 	and.w	ip, ip, #63488	@ 0xf800
34015a2c:	ea45 050c 	orr.w	r5, r5, ip
34015a30:	f3c4 04c4 	ubfx	r4, r4, #3, #5
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
34015a34:	432c      	orrs	r4, r5
34015a36:	e003      	b.n	34015a40 <UTIL_LCD_FillRect+0x3c>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
34015a38:	2d01      	cmp	r5, #1
34015a3a:	d109      	bne.n	34015a50 <UTIL_LCD_FillRect+0x4c>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB888(Color));
34015a3c:	f024 447f 	bic.w	r4, r4, #4278190080	@ 0xff000000
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
34015a40:	e9cd 3400 	strd	r3, r4, [sp]
34015a44:	4613      	mov	r3, r2
34015a46:	460a      	mov	r2, r1
34015a48:	4639      	mov	r1, r7
34015a4a:	47b0      	blx	r6
}
34015a4c:	b003      	add	sp, #12
34015a4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
34015a50:	2d04      	cmp	r5, #4
34015a52:	d1f5      	bne.n	34015a40 <UTIL_LCD_FillRect+0x3c>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
34015a54:	ea4f 7c14 	mov.w	ip, r4, lsr #28
34015a58:	f3c4 1503 	ubfx	r5, r4, #4, #4
34015a5c:	ea45 350c 	orr.w	r5, r5, ip, lsl #12
34015a60:	ea4f 2c14 	mov.w	ip, r4, lsr #8
34015a64:	f00c 0cf0 	and.w	ip, ip, #240	@ 0xf0
34015a68:	0b24      	lsrs	r4, r4, #12
34015a6a:	ea45 050c 	orr.w	r5, r5, ip
34015a6e:	f404 6470 	and.w	r4, r4, #3840	@ 0xf00
34015a72:	e7df      	b.n	34015a34 <UTIL_LCD_FillRect+0x30>
34015a74:	340ce840 	.word	0x340ce840
34015a78:	340ce814 	.word	0x340ce814

34015a7c <UTIL_LCD_Clear>:
{
34015a7c:	b507      	push	{r0, r1, r2, lr}
  UTIL_LCD_FillRect(0, 0, DrawProp[DrawProp->LcdLayer].LcdXsize, DrawProp[DrawProp->LcdLayer].LcdYsize, Color);
34015a7e:	2100      	movs	r1, #0
34015a80:	4a06      	ldr	r2, [pc, #24]	@ (34015a9c <UTIL_LCD_Clear+0x20>)
34015a82:	68d3      	ldr	r3, [r2, #12]
34015a84:	9000      	str	r0, [sp, #0]
34015a86:	eb02 1243 	add.w	r2, r2, r3, lsl #5
34015a8a:	4608      	mov	r0, r1
34015a8c:	e9d2 2305 	ldrd	r2, r3, [r2, #20]
34015a90:	f7ff ffb8 	bl	34015a04 <UTIL_LCD_FillRect>
}
34015a94:	b003      	add	sp, #12
34015a96:	f85d fb04 	ldr.w	pc, [sp], #4
34015a9a:	bf00      	nop
34015a9c:	340ce840 	.word	0x340ce840

34015aa0 <st_yolox_nms_comparator>:

    float32_t diff = 0.0;
    float32_t a_weighted_conf = 0.0;
    float32_t b_weighted_conf = 0.0;

    if (a.class_index == AI_ST_YOLOX_PP_SORT_CLASS)
34015aa0:	4b0f      	ldr	r3, [pc, #60]	@ (34015ae0 <st_yolox_nms_comparator+0x40>)
{
34015aa2:	b510      	push	{r4, lr}
    if (a.class_index == AI_ST_YOLOX_PP_SORT_CLASS)
34015aa4:	681b      	ldr	r3, [r3, #0]
34015aa6:	6944      	ldr	r4, [r0, #20]
    od_pp_outBuffer_t b = *(od_pp_outBuffer_t *)pb;
34015aa8:	694a      	ldr	r2, [r1, #20]
    if (a.class_index == AI_ST_YOLOX_PP_SORT_CLASS)
34015aaa:	42a3      	cmp	r3, r4
    od_pp_outBuffer_t a = *(od_pp_outBuffer_t *)pa;
34015aac:	bf0c      	ite	eq
34015aae:	edd0 7a04 	vldreq	s15, [r0, #16]
    {
        a_weighted_conf = a.conf;
    }
    else
    {
         a_weighted_conf = 0.0;
34015ab2:	eddf 7a0c 	vldrne	s15, [pc, #48]	@ 34015ae4 <st_yolox_nms_comparator+0x44>
    }

    if (b.class_index == AI_ST_YOLOX_PP_SORT_CLASS)
34015ab6:	4293      	cmp	r3, r2
    od_pp_outBuffer_t b = *(od_pp_outBuffer_t *)pb;
34015ab8:	bf0c      	ite	eq
34015aba:	ed91 7a04 	vldreq	s14, [r1, #16]
    {
        b_weighted_conf = b.conf;
    }
    else
    {
         b_weighted_conf = 0.0;
34015abe:	ed9f 7a09 	vldrne	s14, [pc, #36]	@ 34015ae4 <st_yolox_nms_comparator+0x44>
    }

    diff = a_weighted_conf - b_weighted_conf;
34015ac2:	ee77 7ac7 	vsub.f32	s15, s15, s14

    if (diff < 0) return 1;
34015ac6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34015aca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015ace:	d404      	bmi.n	34015ada <st_yolox_nms_comparator+0x3a>
    else if (diff > 0) return -1;
34015ad0:	bfcc      	ite	gt
34015ad2:	f04f 30ff 	movgt.w	r0, #4294967295
34015ad6:	2000      	movle	r0, #0
    return 0;
}
34015ad8:	bd10      	pop	{r4, pc}
    if (diff < 0) return 1;
34015ada:	2001      	movs	r0, #1
34015adc:	e7fc      	b.n	34015ad8 <st_yolox_nms_comparator+0x38>
34015ade:	bf00      	nop
34015ae0:	340ce880 	.word	0x340ce880
34015ae4:	00000000 	.word	0x00000000

34015ae8 <st_yolox_pp_nmsFiltering_centroid>:

int32_t st_yolox_pp_nmsFiltering_centroid(od_pp_out_t *pOutput,
                                          od_st_yolox_pp_static_param_t *pInput_static_param)
{
34015ae8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
34015aec:	4605      	mov	r5, r0
34015aee:	460e      	mov	r6, r1
    int32_t j, k, limit_counter, detections_per_class;
    for (k = 0; k < pInput_static_param->nb_classes; ++k)
34015af0:	2700      	movs	r7, #0
            {
                if (pOutput->pOutBuff[i].conf == 0) continue;
                float32_t *a = &(pOutput->pOutBuff[i].x_center);
                for (j = i + 1; j < detections_per_class; j ++)
                {
                    if (pOutput->pOutBuff[j].conf == 0) continue;
34015af2:	f04f 0800 	mov.w	r8, #0
    for (k = 0; k < pInput_static_param->nb_classes; ++k)
34015af6:	6833      	ldr	r3, [r6, #0]
34015af8:	42bb      	cmp	r3, r7
34015afa:	dc03      	bgt.n	34015b04 <st_yolox_pp_nmsFiltering_centroid+0x1c>
                }
            }
        }
    }
    return (AI_OD_POSTPROCESS_ERROR_NO);
}
34015afc:	2000      	movs	r0, #0
34015afe:	b003      	add	sp, #12
34015b00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for (int32_t i = 0; i < pInput_static_param->nb_detect ; i ++)
34015b04:	2200      	movs	r2, #0
34015b06:	6bf1      	ldr	r1, [r6, #60]	@ 0x3c
        AI_ST_YOLOX_PP_SORT_CLASS = k;
34015b08:	4b36      	ldr	r3, [pc, #216]	@ (34015be4 <st_yolox_pp_nmsFiltering_centroid+0xfc>)
34015b0a:	4291      	cmp	r1, r2
34015b0c:	601f      	str	r7, [r3, #0]
        detections_per_class = 0;
34015b0e:	4614      	mov	r4, r2
34015b10:	f101 0301 	add.w	r3, r1, #1
            if(pOutput->pOutBuff[i].class_index == k)
34015b14:	f04f 0c18 	mov.w	ip, #24
34015b18:	bfb8      	it	lt
34015b1a:	2301      	movlt	r3, #1
        for (int32_t i = 0; i < pInput_static_param->nb_detect ; i ++)
34015b1c:	3b01      	subs	r3, #1
34015b1e:	d103      	bne.n	34015b28 <st_yolox_pp_nmsFiltering_centroid+0x40>
        if (detections_per_class > 0)
34015b20:	2c00      	cmp	r4, #0
34015b22:	dc0a      	bgt.n	34015b3a <st_yolox_pp_nmsFiltering_centroid+0x52>
    for (k = 0; k < pInput_static_param->nb_classes; ++k)
34015b24:	3701      	adds	r7, #1
34015b26:	e7e6      	b.n	34015af6 <st_yolox_pp_nmsFiltering_centroid+0xe>
            if(pOutput->pOutBuff[i].class_index == k)
34015b28:	6828      	ldr	r0, [r5, #0]
34015b2a:	fb0c 0002 	mla	r0, ip, r2, r0
34015b2e:	6940      	ldr	r0, [r0, #20]
        for (int32_t i = 0; i < pInput_static_param->nb_detect ; i ++)
34015b30:	3201      	adds	r2, #1
                detections_per_class++;
34015b32:	42b8      	cmp	r0, r7
34015b34:	ea54 9414 			@ <UNDEFINED> instruction: 0xea549414
        for (int32_t i = 0; i < pInput_static_param->nb_detect ; i ++)
34015b38:	e7f0      	b.n	34015b1c <st_yolox_pp_nmsFiltering_centroid+0x34>
            qsort(pOutput->pOutBuff,
34015b3a:	2218      	movs	r2, #24
34015b3c:	4b2a      	ldr	r3, [pc, #168]	@ (34015be8 <st_yolox_pp_nmsFiltering_centroid+0x100>)
34015b3e:	6828      	ldr	r0, [r5, #0]
34015b40:	f003 fac7 	bl	340190d2 <qsort>
            for (int32_t i = 0; i < detections_per_class ; i ++)
34015b44:	f04f 0900 	mov.w	r9, #0
                if (pOutput->pOutBuff[i].conf == 0) continue;
34015b48:	f04f 0b18 	mov.w	fp, #24
34015b4c:	6828      	ldr	r0, [r5, #0]
34015b4e:	fb0b 0009 	mla	r0, fp, r9, r0
34015b52:	edd0 7a04 	vldr	s15, [r0, #16]
34015b56:	eef5 7a40 	vcmp.f32	s15, #0.0
34015b5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                for (j = i + 1; j < detections_per_class; j ++)
34015b5e:	f109 0901 	add.w	r9, r9, #1
                if (pOutput->pOutBuff[i].conf == 0) continue;
34015b62:	d119      	bne.n	34015b98 <st_yolox_pp_nmsFiltering_centroid+0xb0>
            for (int32_t i = 0; i < detections_per_class ; i ++)
34015b64:	454c      	cmp	r4, r9
34015b66:	d1f1      	bne.n	34015b4c <st_yolox_pp_nmsFiltering_centroid+0x64>
            for (int32_t i = 0; i < detections_per_class; i++)
34015b68:	2300      	movs	r3, #0
                    (pOutput->pOutBuff[i].conf != 0))
34015b6a:	f04f 0e18 	mov.w	lr, #24
        limit_counter = 0;
34015b6e:	461a      	mov	r2, r3
                if ((limit_counter < pInput_static_param->max_boxes_limit) &&
34015b70:	6a70      	ldr	r0, [r6, #36]	@ 0x24
                    (pOutput->pOutBuff[i].conf != 0))
34015b72:	f8d5 c000 	ldr.w	ip, [r5]
                if ((limit_counter < pInput_static_param->max_boxes_limit) &&
34015b76:	4290      	cmp	r0, r2
                    (pOutput->pOutBuff[i].conf != 0))
34015b78:	fb0e c103 	mla	r1, lr, r3, ip
                if ((limit_counter < pInput_static_param->max_boxes_limit) &&
34015b7c:	dd2f      	ble.n	34015bde <st_yolox_pp_nmsFiltering_centroid+0xf6>
34015b7e:	edd1 7a04 	vldr	s15, [r1, #16]
34015b82:	eef5 7a40 	vcmp.f32	s15, #0.0
34015b86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015b8a:	d028      	beq.n	34015bde <st_yolox_pp_nmsFiltering_centroid+0xf6>
                    limit_counter++;
34015b8c:	3201      	adds	r2, #1
            for (int32_t i = 0; i < detections_per_class; i++)
34015b8e:	3c01      	subs	r4, #1
34015b90:	f103 0301 	add.w	r3, r3, #1
34015b94:	d1ef      	bne.n	34015b76 <st_yolox_pp_nmsFiltering_centroid+0x8e>
34015b96:	e7c5      	b.n	34015b24 <st_yolox_pp_nmsFiltering_centroid+0x3c>
                for (j = i + 1; j < detections_per_class; j ++)
34015b98:	46ca      	mov	sl, r9
34015b9a:	45a2      	cmp	sl, r4
                    if (pOutput->pOutBuff[j].conf == 0) continue;
34015b9c:	6829      	ldr	r1, [r5, #0]
                for (j = i + 1; j < detections_per_class; j ++)
34015b9e:	dae1      	bge.n	34015b64 <st_yolox_pp_nmsFiltering_centroid+0x7c>
                    if (pOutput->pOutBuff[j].conf == 0) continue;
34015ba0:	fb0b f30a 	mul.w	r3, fp, sl
34015ba4:	4419      	add	r1, r3
34015ba6:	edd1 7a04 	vldr	s15, [r1, #16]
34015baa:	eef5 7a40 	vcmp.f32	s15, #0.0
34015bae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015bb2:	9301      	str	r3, [sp, #4]
34015bb4:	d010      	beq.n	34015bd8 <st_yolox_pp_nmsFiltering_centroid+0xf0>
                    if (vision_models_box_iou(a, b) > pInput_static_param->iou_threshold)
34015bb6:	9000      	str	r0, [sp, #0]
34015bb8:	f000 faa4 	bl	34016104 <vision_models_box_iou>
34015bbc:	edd6 7a0b 	vldr	s15, [r6, #44]	@ 0x2c
34015bc0:	eeb4 0ae7 	vcmpe.f32	s0, s15
34015bc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                        pOutput->pOutBuff[j].conf = 0;
34015bc8:	bfc4      	itt	gt
34015bca:	682a      	ldrgt	r2, [r5, #0]
34015bcc:	9b01      	ldrgt	r3, [sp, #4]
                    if (vision_models_box_iou(a, b) > pInput_static_param->iou_threshold)
34015bce:	9800      	ldr	r0, [sp, #0]
                        pOutput->pOutBuff[j].conf = 0;
34015bd0:	bfc4      	itt	gt
34015bd2:	18d2      	addgt	r2, r2, r3
34015bd4:	f8c2 8010 	strgt.w	r8, [r2, #16]
                for (j = i + 1; j < detections_per_class; j ++)
34015bd8:	f10a 0a01 	add.w	sl, sl, #1
34015bdc:	e7dd      	b.n	34015b9a <st_yolox_pp_nmsFiltering_centroid+0xb2>
                    pOutput->pOutBuff[i].conf = 0;
34015bde:	f8c1 8010 	str.w	r8, [r1, #16]
34015be2:	e7d4      	b.n	34015b8e <st_yolox_pp_nmsFiltering_centroid+0xa6>
34015be4:	340ce880 	.word	0x340ce880
34015be8:	34015aa1 	.word	0x34015aa1

34015bec <st_yolox_pp_scoreFiltering_centroid>:


int32_t st_yolox_pp_scoreFiltering_centroid(od_pp_out_t *pOutput,
                                            od_st_yolox_pp_static_param_t *pInput_static_param)
{
34015bec:	b5f0      	push	{r4, r5, r6, r7, lr}
    int32_t det_count = 0;

    for (int32_t i = 0; i < pInput_static_param->nb_detect; i++)
34015bee:	2600      	movs	r6, #0
34015bf0:	6bcb      	ldr	r3, [r1, #60]	@ 0x3c
    int32_t det_count = 0;
34015bf2:	4635      	mov	r5, r6
34015bf4:	42b3      	cmp	r3, r6
34015bf6:	f103 0201 	add.w	r2, r3, #1
    {
        if (pOutput->pOutBuff[i].conf >= pInput_static_param->conf_threshold)
34015bfa:	f04f 0718 	mov.w	r7, #24
34015bfe:	bfb8      	it	lt
34015c00:	2201      	movlt	r2, #1
    for (int32_t i = 0; i < pInput_static_param->nb_detect; i++)
34015c02:	3a01      	subs	r2, #1
34015c04:	d102      	bne.n	34015c0c <st_yolox_pp_scoreFiltering_centroid+0x20>
            pOutput->pOutBuff[det_count].conf = pOutput->pOutBuff[i].conf;
            pOutput->pOutBuff[det_count].class_index = pOutput->pOutBuff[i].class_index;
            det_count++;
        }
    }
    pOutput->nb_detect = det_count;
34015c06:	6045      	str	r5, [r0, #4]

    return (AI_OD_POSTPROCESS_ERROR_NO);
}
34015c08:	2000      	movs	r0, #0
34015c0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (pOutput->pOutBuff[i].conf >= pInput_static_param->conf_threshold)
34015c0c:	6803      	ldr	r3, [r0, #0]
34015c0e:	ed91 7a0a 	vldr	s14, [r1, #40]	@ 0x28
34015c12:	fb07 3406 	mla	r4, r7, r6, r3
34015c16:	edd4 7a04 	vldr	s15, [r4, #16]
34015c1a:	eef4 7ac7 	vcmpe.f32	s15, s14
34015c1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015c22:	db16      	blt.n	34015c52 <st_yolox_pp_scoreFiltering_centroid+0x66>
            pOutput->pOutBuff[det_count].x_center = pOutput->pOutBuff[i].x_center;
34015c24:	fb07 3305 	mla	r3, r7, r5, r3
34015c28:	f8d4 c000 	ldr.w	ip, [r4]
            det_count++;
34015c2c:	3501      	adds	r5, #1
            pOutput->pOutBuff[det_count].x_center = pOutput->pOutBuff[i].x_center;
34015c2e:	f8c3 c000 	str.w	ip, [r3]
            pOutput->pOutBuff[det_count].y_center = pOutput->pOutBuff[i].y_center;
34015c32:	f8d4 c004 	ldr.w	ip, [r4, #4]
34015c36:	f8c3 c004 	str.w	ip, [r3, #4]
            pOutput->pOutBuff[det_count].width = pOutput->pOutBuff[i].width;
34015c3a:	f8d4 c008 	ldr.w	ip, [r4, #8]
34015c3e:	f8c3 c008 	str.w	ip, [r3, #8]
            pOutput->pOutBuff[det_count].height = pOutput->pOutBuff[i].height;
34015c42:	f8d4 c00c 	ldr.w	ip, [r4, #12]
            pOutput->pOutBuff[det_count].conf = pOutput->pOutBuff[i].conf;
34015c46:	edc3 7a04 	vstr	s15, [r3, #16]
            pOutput->pOutBuff[det_count].class_index = pOutput->pOutBuff[i].class_index;
34015c4a:	6964      	ldr	r4, [r4, #20]
            pOutput->pOutBuff[det_count].height = pOutput->pOutBuff[i].height;
34015c4c:	f8c3 c00c 	str.w	ip, [r3, #12]
            pOutput->pOutBuff[det_count].class_index = pOutput->pOutBuff[i].class_index;
34015c50:	615c      	str	r4, [r3, #20]
    for (int32_t i = 0; i < pInput_static_param->nb_detect; i++)
34015c52:	3601      	adds	r6, #1
34015c54:	e7d5      	b.n	34015c02 <st_yolox_pp_scoreFiltering_centroid+0x16>
	...

34015c58 <st_yolox_pp_level_decode_and_store_is8>:
                                               int32_t grid_height,
                                               od_st_yolox_pp_static_param_t *pInput_static_param,
                                               float32_t raw_scale,
                                               int8_t raw_zp)

{
34015c58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34015c5c:	ed2d 8b06 	vpush	{d8-d10}
34015c60:	b08d      	sub	sp, #52	@ 0x34
34015c62:	9304      	str	r3, [sp, #16]
  int32_t el_offset    = 0;
  int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
  float32_t grid_width_inv = 1.0f / grid_width;
34015c64:	eddd 7a04 	vldr	s15, [sp, #16]
34015c68:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
34015c6c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
34015c70:	eec7 8a87 	vdiv.f32	s17, s15, s14
  float32_t grid_height_inv = 1.0f / grid_height;
34015c74:	ed9d 7a1c 	vldr	s14, [sp, #112]	@ 0x70
34015c78:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
{
34015c7c:	9e1d      	ldr	r6, [sp, #116]	@ 0x74
34015c7e:	e9cd 0207 	strd	r0, r2, [sp, #28]
  int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
34015c82:	6833      	ldr	r3, [r6, #0]
{
34015c84:	eeb0 8a40 	vmov.f32	s16, s0
  int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
34015c88:	1d5a      	adds	r2, r3, #5
34015c8a:	9205      	str	r2, [sp, #20]


  int32_t det_count = pInput_static_param->nb_detect;
  od_pp_outBuffer_t *pOutBuff = (od_pp_outBuffer_t *)pOutput->pOutBuff;
34015c8c:	680a      	ldr	r2, [r1, #0]

  if ( 1 == pInput_static_param->nb_classes) {
34015c8e:	2b01      	cmp	r3, #1
  float32_t grid_height_inv = 1.0f / grid_height;
34015c90:	ee87 9a87 	vdiv.f32	s18, s15, s14
{
34015c94:	f99d 4078 	ldrsb.w	r4, [sp, #120]	@ 0x78
  int32_t det_count = pInput_static_param->nb_detect;
34015c98:	6bf7      	ldr	r7, [r6, #60]	@ 0x3c
  od_pp_outBuffer_t *pOutBuff = (od_pp_outBuffer_t *)pOutput->pOutBuff;
34015c9a:	9206      	str	r2, [sp, #24]
  if ( 1 == pInput_static_param->nb_classes) {
34015c9c:	f040 817f 	bne.w	34015f9e <st_yolox_pp_level_decode_and_store_is8+0x346>

    float32_t computedThreshold = -logf( 1 / pInput_static_param->conf_threshold - 1);
34015ca0:	ed96 7a0a 	vldr	s14, [r6, #40]	@ 0x28
34015ca4:	ee87 0a87 	vdiv.f32	s0, s15, s14
34015ca8:	ee30 0a67 	vsub.f32	s0, s0, s15
34015cac:	f006 feb4 	bl	3401ca18 <logf>
34015cb0:	eeb1 0a40 	vneg.f32	s0, s0
    int8_t threshold_s8  = (int8_t)(computedThreshold / raw_scale + 0.5 + raw_zp);
34015cb4:	ee80 7a08 	vdiv.f32	s14, s0, s16
34015cb8:	eeb6 6b00 	vmov.f64	d6, #96	@ 0x3f000000  0.5
34015cbc:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34015cc0:	ee37 7b06 	vadd.f64	d7, d7, d6
34015cc4:	ee06 4a90 	vmov	s13, r4
34015cc8:	eeb8 6be6 	vcvt.f64.s32	d6, s13
34015ccc:	ee37 7b06 	vadd.f64	d7, d7, d6
34015cd0:	eefd 7bc7 	vcvt.s32.f64	s15, d7

    for (int32_t row = 0; row < grid_width; ++row)
34015cd4:	f04f 0900 	mov.w	r9, #0
    int8_t threshold_s8  = (int8_t)(computedThreshold / raw_scale + 0.5 + raw_zp);
34015cd8:	edcd 7a02 	vstr	s15, [sp, #8]
  int32_t el_offset    = 0;
34015cdc:	46cb      	mov	fp, r9
    int8_t threshold_s8  = (int8_t)(computedThreshold / raw_scale + 0.5 + raw_zp);
34015cde:	f99d 3008 	ldrsb.w	r3, [sp, #8]
34015ce2:	9302      	str	r3, [sp, #8]
    for (int32_t row = 0; row < grid_width; ++row)
34015ce4:	9b04      	ldr	r3, [sp, #16]
34015ce6:	4599      	cmp	r9, r3
34015ce8:	f2c0 8089 	blt.w	34015dfe <st_yolox_pp_level_decode_and_store_is8+0x1a6>
  } //  else (nb_classes != 1)
  pInput_static_param->nb_detect = det_count;

  return det_count;

}
34015cec:	4638      	mov	r0, r7
  pInput_static_param->nb_detect = det_count;
34015cee:	63f7      	str	r7, [r6, #60]	@ 0x3c
}
34015cf0:	b00d      	add	sp, #52	@ 0x34
34015cf2:	ecbd 8b06 	vpop	{d8-d10}
34015cf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          if ( pInbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] >= threshold_s8) {
34015cfa:	f995 1004 	ldrsb.w	r1, [r5, #4]
34015cfe:	9802      	ldr	r0, [sp, #8]
34015d00:	4281      	cmp	r1, r0
34015d02:	db67      	blt.n	34015dd4 <st_yolox_pp_level_decode_and_store_is8+0x17c>
34015d04:	9303      	str	r3, [sp, #12]
            dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] - raw_zp) * raw_scale;
34015d06:	1b0b      	subs	r3, r1, r4
34015d08:	ee00 3a10 	vmov	s0, r3
34015d0c:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
            float32_t prob = vision_models_sigmoid_f(dequant);
34015d10:	ee20 0a08 	vmul.f32	s0, s0, s16
34015d14:	9205      	str	r2, [sp, #20]
34015d16:	f000 f98f 	bl	34016038 <vision_models_sigmoid_f>
            pOutBuff[det_count].conf = prob;
34015d1a:	2218      	movs	r2, #24
34015d1c:	9b06      	ldr	r3, [sp, #24]
34015d1e:	fb02 3807 	mla	r8, r2, r7, r3
            pOutBuff[det_count].class_index = 0;
34015d22:	2300      	movs	r3, #0
            pOutBuff[det_count].conf = prob;
34015d24:	ed88 0a04 	vstr	s0, [r8, #16]
            pOutBuff[det_count].class_index = 0;
34015d28:	f8c8 3014 	str.w	r3, [r8, #20]
            dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_XCENTER] - raw_zp) * raw_scale;
34015d2c:	f995 1000 	ldrsb.w	r1, [r5]
            det_count++;
34015d30:	3701      	adds	r7, #1
            dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_XCENTER] - raw_zp) * raw_scale;
34015d32:	1b0b      	subs	r3, r1, r4
34015d34:	ee00 3a10 	vmov	s0, r3
34015d38:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
            pOutBuff[det_count].x_center   = (col + vision_models_sigmoid_f(dequant)) * grid_width_inv;
34015d3c:	ee20 0a08 	vmul.f32	s0, s0, s16
34015d40:	f000 f97a 	bl	34016038 <vision_models_sigmoid_f>
34015d44:	9b03      	ldr	r3, [sp, #12]
34015d46:	ee07 3a90 	vmov	s15, r3
34015d4a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34015d4e:	ee77 7a80 	vadd.f32	s15, s15, s0
34015d52:	ee67 7aa8 	vmul.f32	s15, s15, s17
34015d56:	edc8 7a00 	vstr	s15, [r8]
            dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_YCENTER] - raw_zp) * raw_scale;
34015d5a:	f995 1001 	ldrsb.w	r1, [r5, #1]
34015d5e:	1b0b      	subs	r3, r1, r4
34015d60:	ee00 3a10 	vmov	s0, r3
34015d64:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
            pOutBuff[det_count].y_center   = (row + vision_models_sigmoid_f(dequant)) * grid_height_inv;
34015d68:	ee20 0a08 	vmul.f32	s0, s0, s16
34015d6c:	f000 f964 	bl	34016038 <vision_models_sigmoid_f>
34015d70:	ee07 9a90 	vmov	s15, r9
34015d74:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34015d78:	ee77 7a80 	vadd.f32	s15, s15, s0
34015d7c:	ee67 7a89 	vmul.f32	s15, s15, s18
34015d80:	edc8 7a01 	vstr	s15, [r8, #4]
            dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_WIDTHREL] - raw_zp) * raw_scale;
34015d84:	f995 1002 	ldrsb.w	r1, [r5, #2]
            anchor                          = (float32_t)(pAnchors[2 * anch + 0]);
34015d88:	edda 9a00 	vldr	s19, [sl]
            dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_WIDTHREL] - raw_zp) * raw_scale;
34015d8c:	1b0b      	subs	r3, r1, r4
34015d8e:	ee00 3a10 	vmov	s0, r3
34015d92:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
            pOutBuff[det_count].width      = (anchor * expf(dequant)) * grid_width_inv;
34015d96:	ee20 0a08 	vmul.f32	s0, s0, s16
34015d9a:	f006 fdc9 	bl	3401c930 <expf>
34015d9e:	ee20 0a29 	vmul.f32	s0, s0, s19
34015da2:	ee20 0a28 	vmul.f32	s0, s0, s17
34015da6:	ed88 0a02 	vstr	s0, [r8, #8]
            dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_HEIGHTREL] - raw_zp) * raw_scale;
34015daa:	f995 1003 	ldrsb.w	r1, [r5, #3]
            anchor                          = (float32_t)(pAnchors[2 * anch + 1]);
34015dae:	edda 9a01 	vldr	s19, [sl, #4]
            dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_HEIGHTREL] - raw_zp) * raw_scale;
34015db2:	1b0b      	subs	r3, r1, r4
34015db4:	ee00 3a10 	vmov	s0, r3
34015db8:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
            pOutBuff[det_count].height     = (anchor * expf(dequant)) * grid_height_inv;
34015dbc:	ee20 0a08 	vmul.f32	s0, s0, s16
34015dc0:	f006 fdb6 	bl	3401c930 <expf>
34015dc4:	ee20 0a29 	vmul.f32	s0, s0, s19
34015dc8:	ee20 0a09 	vmul.f32	s0, s0, s18
34015dcc:	ed88 0a03 	vstr	s0, [r8, #12]
            det_count++;
34015dd0:	9a05      	ldr	r2, [sp, #20]
34015dd2:	9b03      	ldr	r3, [sp, #12]
        for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
34015dd4:	3201      	adds	r2, #1
34015dd6:	3506      	adds	r5, #6
34015dd8:	f10a 0a08 	add.w	sl, sl, #8
34015ddc:	6871      	ldr	r1, [r6, #4]
34015dde:	4291      	cmp	r1, r2
34015de0:	dc8b      	bgt.n	34015cfa <st_yolox_pp_level_decode_and_store_is8+0xa2>
34015de2:	2106      	movs	r1, #6
34015de4:	fb01 bb02 	mla	fp, r1, r2, fp
      for (int32_t col = 0; col < grid_height; ++col)
34015de8:	3301      	adds	r3, #1
34015dea:	9a1c      	ldr	r2, [sp, #112]	@ 0x70
34015dec:	4293      	cmp	r3, r2
34015dee:	da08      	bge.n	34015e02 <st_yolox_pp_level_decode_and_store_is8+0x1aa>
34015df0:	9a07      	ldr	r2, [sp, #28]
34015df2:	f8dd a020 	ldr.w	sl, [sp, #32]
34015df6:	eb02 050b 	add.w	r5, r2, fp
        for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
34015dfa:	2200      	movs	r2, #0
34015dfc:	e7ee      	b.n	34015ddc <st_yolox_pp_level_decode_and_store_is8+0x184>
      for (int32_t col = 0; col < grid_height; ++col)
34015dfe:	2300      	movs	r3, #0
34015e00:	e7f3      	b.n	34015dea <st_yolox_pp_level_decode_and_store_is8+0x192>
    for (int32_t row = 0; row < grid_width; ++row)
34015e02:	f109 0901 	add.w	r9, r9, #1
34015e06:	e76d      	b.n	34015ce4 <st_yolox_pp_level_decode_and_store_is8+0x8c>
          vision_models_maxi_p_is8ou8(&pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
34015e08:	2301      	movs	r3, #1
34015e0a:	9301      	str	r3, [sp, #4]
34015e0c:	f10d 032f 	add.w	r3, sp, #47	@ 0x2f
34015e10:	9300      	str	r3, [sp, #0]
34015e12:	464a      	mov	r2, r9
34015e14:	4628      	mov	r0, r5
34015e16:	6831      	ldr	r1, [r6, #0]
34015e18:	f10d 032e 	add.w	r3, sp, #46	@ 0x2e
34015e1c:	f000 f9d4 	bl	340161c8 <vision_models_maxi_p_is8ou8>
          dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] - raw_zp) * raw_scale;
34015e20:	462a      	mov	r2, r5
34015e22:	f912 3d01 	ldrsb.w	r3, [r2, #-1]!
          for (int _i = 0; _i < pInput_static_param->nb_classes; _i++) {
34015e26:	f04f 0b00 	mov.w	fp, #0
          dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] - raw_zp) * raw_scale;
34015e2a:	1b1b      	subs	r3, r3, r4
34015e2c:	ee00 3a10 	vmov	s0, r3
34015e30:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
          float32_t prob = vision_models_sigmoid_f(dequant);
34015e34:	ee20 0a08 	vmul.f32	s0, s0, s16
          dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] - raw_zp) * raw_scale;
34015e38:	9209      	str	r2, [sp, #36]	@ 0x24
          float32_t prob = vision_models_sigmoid_f(dequant);
34015e3a:	f000 f8fd 	bl	34016038 <vision_models_sigmoid_f>
          float32_t sumf = 0.0;
34015e3e:	ed9f aa5a 	vldr	s20, [pc, #360]	@ 34015fa8 <st_yolox_pp_level_decode_and_store_is8+0x350>
          float32_t prob = vision_models_sigmoid_f(dequant);
34015e42:	eef0 9a40 	vmov.f32	s19, s0
          for (int _i = 0; _i < pInput_static_param->nb_classes; _i++) {
34015e46:	6833      	ldr	r3, [r6, #0]
34015e48:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34015e4a:	455b      	cmp	r3, fp
34015e4c:	f300 808e 	bgt.w	34015f6c <st_yolox_pp_level_decode_and_store_is8+0x314>
          dequant = (float32_t)((int32_t)best_score_s8 - raw_zp) * raw_scale;
34015e50:	f99d 302e 	ldrsb.w	r3, [sp, #46]	@ 0x2e
34015e54:	1b1b      	subs	r3, r3, r4
34015e56:	ee00 3a10 	vmov	s0, r3
34015e5a:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
          best_score = expf(dequant) / sumf;
34015e5e:	ee20 0a08 	vmul.f32	s0, s0, s16
34015e62:	f006 fd65 	bl	3401c930 <expf>
34015e66:	eec0 7a0a 	vdiv.f32	s15, s0, s20
          best_score *= prob;
34015e6a:	ee69 9aa7 	vmul.f32	s19, s19, s15
          if (best_score >= pInput_static_param->conf_threshold)
34015e6e:	edd6 7a0a 	vldr	s15, [r6, #40]	@ 0x28
34015e72:	eef4 7ae9 	vcmpe.f32	s15, s19
34015e76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015e7a:	d85a      	bhi.n	34015f32 <st_yolox_pp_level_decode_and_store_is8+0x2da>
            dequant                         = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_XCENTER] - raw_zp) * raw_scale;
34015e7c:	f915 3c05 	ldrsb.w	r3, [r5, #-5]
34015e80:	1b1b      	subs	r3, r3, r4
34015e82:	ee00 3a10 	vmov	s0, r3
34015e86:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
            pOutBuff[det_count].x_center    = (col + vision_models_sigmoid_f(dequant)) * grid_width_inv;
34015e8a:	ee20 0a08 	vmul.f32	s0, s0, s16
34015e8e:	f000 f8d3 	bl	34016038 <vision_models_sigmoid_f>
34015e92:	eddd 7a02 	vldr	s15, [sp, #8]
34015e96:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34015e9a:	ee77 7a80 	vadd.f32	s15, s15, s0
34015e9e:	2318      	movs	r3, #24
34015ea0:	ee67 7aa8 	vmul.f32	s15, s15, s17
34015ea4:	9a06      	ldr	r2, [sp, #24]
34015ea6:	fb03 2b07 	mla	fp, r3, r7, r2
34015eaa:	edcb 7a00 	vstr	s15, [fp]
            dequant                         = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_YCENTER] - raw_zp) * raw_scale;
34015eae:	f915 2c04 	ldrsb.w	r2, [r5, #-4]
            det_count++;
34015eb2:	3701      	adds	r7, #1
            dequant                         = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_YCENTER] - raw_zp) * raw_scale;
34015eb4:	1b13      	subs	r3, r2, r4
34015eb6:	ee00 3a10 	vmov	s0, r3
34015eba:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
            pOutBuff[det_count].y_center    = (row + vision_models_sigmoid_f(dequant)) * grid_height_inv;
34015ebe:	ee20 0a08 	vmul.f32	s0, s0, s16
34015ec2:	f000 f8b9 	bl	34016038 <vision_models_sigmoid_f>
34015ec6:	ee07 8a90 	vmov	s15, r8
34015eca:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34015ece:	ee77 7a80 	vadd.f32	s15, s15, s0
34015ed2:	ee67 7a89 	vmul.f32	s15, s15, s18
34015ed6:	edcb 7a01 	vstr	s15, [fp, #4]
            dequant                         = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_WIDTHREL] - raw_zp) * raw_scale;
34015eda:	f915 2c03 	ldrsb.w	r2, [r5, #-3]
            anchor                          = (float32_t)pAnchors[2 * anch + 0];
34015ede:	ed9a aa00 	vldr	s20, [sl]
            dequant                         = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_WIDTHREL] - raw_zp) * raw_scale;
34015ee2:	1b13      	subs	r3, r2, r4
34015ee4:	ee00 3a10 	vmov	s0, r3
34015ee8:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
            pOutBuff[det_count].width       = (anchor * expf(dequant)) * grid_width_inv;
34015eec:	ee20 0a08 	vmul.f32	s0, s0, s16
34015ef0:	f006 fd1e 	bl	3401c930 <expf>
34015ef4:	ee20 0a0a 	vmul.f32	s0, s0, s20
34015ef8:	ee20 0a28 	vmul.f32	s0, s0, s17
34015efc:	ed8b 0a02 	vstr	s0, [fp, #8]
            dequant                         = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_HEIGHTREL] - raw_zp) * raw_scale;
34015f00:	f915 2c02 	ldrsb.w	r2, [r5, #-2]
            anchor                          = (float32_t)pAnchors[2 * anch + 1];
34015f04:	ed9a aa01 	vldr	s20, [sl, #4]
            dequant                         = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_HEIGHTREL] - raw_zp) * raw_scale;
34015f08:	1b13      	subs	r3, r2, r4
34015f0a:	ee00 3a10 	vmov	s0, r3
34015f0e:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
            pOutBuff[det_count].height      = (anchor * expf(dequant)) * grid_height_inv;
34015f12:	ee20 0a08 	vmul.f32	s0, s0, s16
34015f16:	f006 fd0b 	bl	3401c930 <expf>
34015f1a:	ee20 0a0a 	vmul.f32	s0, s0, s20
34015f1e:	ee20 0a09 	vmul.f32	s0, s0, s18
            pOutBuff[det_count].conf        = best_score;
34015f22:	edcb 9a04 	vstr	s19, [fp, #16]
            pOutBuff[det_count].height      = (anchor * expf(dequant)) * grid_height_inv;
34015f26:	ed8b 0a03 	vstr	s0, [fp, #12]
            pOutBuff[det_count].class_index = class_index_u8;
34015f2a:	f89d 202f 	ldrb.w	r2, [sp, #47]	@ 0x2f
34015f2e:	f8cb 2014 	str.w	r2, [fp, #20]
          el_offset += anch_stride;
34015f32:	9b03      	ldr	r3, [sp, #12]
34015f34:	9a05      	ldr	r2, [sp, #20]
        for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
34015f36:	f109 0901 	add.w	r9, r9, #1
          el_offset += anch_stride;
34015f3a:	4413      	add	r3, r2
34015f3c:	9303      	str	r3, [sp, #12]
        for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
34015f3e:	f10a 0a08 	add.w	sl, sl, #8
34015f42:	4415      	add	r5, r2
34015f44:	6873      	ldr	r3, [r6, #4]
34015f46:	454b      	cmp	r3, r9
34015f48:	f73f af5e 	bgt.w	34015e08 <st_yolox_pp_level_decode_and_store_is8+0x1b0>
      for (int32_t col = 0; col < grid_height; ++col)
34015f4c:	9b02      	ldr	r3, [sp, #8]
34015f4e:	3301      	adds	r3, #1
34015f50:	9302      	str	r3, [sp, #8]
34015f52:	9b02      	ldr	r3, [sp, #8]
34015f54:	9a1c      	ldr	r2, [sp, #112]	@ 0x70
34015f56:	4293      	cmp	r3, r2
34015f58:	da19      	bge.n	34015f8e <st_yolox_pp_level_decode_and_store_is8+0x336>
34015f5a:	9b03      	ldr	r3, [sp, #12]
        for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
34015f5c:	f04f 0900 	mov.w	r9, #0
34015f60:	1d5d      	adds	r5, r3, #5
34015f62:	9b07      	ldr	r3, [sp, #28]
34015f64:	f8dd a020 	ldr.w	sl, [sp, #32]
34015f68:	441d      	add	r5, r3
34015f6a:	e7eb      	b.n	34015f44 <st_yolox_pp_level_decode_and_store_is8+0x2ec>
              dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + _i] - raw_zp) * raw_scale;
34015f6c:	f912 3f01 	ldrsb.w	r3, [r2, #1]!
          for (int _i = 0; _i < pInput_static_param->nb_classes; _i++) {
34015f70:	f10b 0b01 	add.w	fp, fp, #1
              dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + _i] - raw_zp) * raw_scale;
34015f74:	1b1b      	subs	r3, r3, r4
34015f76:	ee00 3a10 	vmov	s0, r3
34015f7a:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
              sumf+= expf(dequant);
34015f7e:	ee20 0a08 	vmul.f32	s0, s0, s16
              dequant = (float32_t)((int32_t)pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + _i] - raw_zp) * raw_scale;
34015f82:	9209      	str	r2, [sp, #36]	@ 0x24
              sumf+= expf(dequant);
34015f84:	f006 fcd4 	bl	3401c930 <expf>
34015f88:	ee3a aa00 	vadd.f32	s20, s20, s0
          for (int _i = 0; _i < pInput_static_param->nb_classes; _i++) {
34015f8c:	e75b      	b.n	34015e46 <st_yolox_pp_level_decode_and_store_is8+0x1ee>
    for (int32_t row = 0; row < grid_width; ++row)
34015f8e:	f108 0801 	add.w	r8, r8, #1
34015f92:	9b04      	ldr	r3, [sp, #16]
34015f94:	4598      	cmp	r8, r3
34015f96:	f6bf aea9 	bge.w	34015cec <st_yolox_pp_level_decode_and_store_is8+0x94>
      for (int32_t col = 0; col < grid_height; ++col)
34015f9a:	2300      	movs	r3, #0
34015f9c:	e7d8      	b.n	34015f50 <st_yolox_pp_level_decode_and_store_is8+0x2f8>
    for (int32_t row = 0; row < grid_width; ++row)
34015f9e:	f04f 0800 	mov.w	r8, #0
  int32_t el_offset    = 0;
34015fa2:	f8cd 800c 	str.w	r8, [sp, #12]
34015fa6:	e7f4      	b.n	34015f92 <st_yolox_pp_level_decode_and_store_is8+0x33a>
34015fa8:	00000000 	.word	0x00000000

34015fac <st_yolox_pp_getNNBoxes_centroid_is8>:
}

int32_t st_yolox_pp_getNNBoxes_centroid_is8(od_st_yolox_pp_in_t *pInput,
                                            od_pp_out_t *pOut,
                                            od_st_yolox_pp_static_param_t *pInput_static_param)
{
34015fac:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34015fae:	4614      	mov	r4, r2
34015fb0:	4605      	mov	r5, r0
34015fb2:	460e      	mov	r6, r1
    int8_t zp = pInput_static_param->raw_l_zero_point;
    grid_width = pInput_static_param->grid_width_L;
    grid_height = pInput_static_param->grid_height_L;
    pInbuff = (int8_t *)pInput->pRaw_detections_L;
    pAnchors = (float32_t *)pInput_static_param->pAnchors_L;
    st_yolox_pp_level_decode_and_store_is8(pInbuff, pOut, pAnchors, grid_width, grid_height,pInput_static_param, scale, zp);
34015fb4:	f992 304c 	ldrsb.w	r3, [r2, #76]	@ 0x4c
34015fb8:	e9cd 2301 	strd	r2, r3, [sp, #4]
34015fbc:	68d3      	ldr	r3, [r2, #12]
34015fbe:	9300      	str	r3, [sp, #0]
34015fc0:	ed92 0a10 	vldr	s0, [r2, #64]	@ 0x40
34015fc4:	6893      	ldr	r3, [r2, #8]
34015fc6:	6800      	ldr	r0, [r0, #0]
34015fc8:	6b12      	ldr	r2, [r2, #48]	@ 0x30
34015fca:	f7ff fe45 	bl	34015c58 <st_yolox_pp_level_decode_and_store_is8>
    grid_height = pInput_static_param->grid_height_M;
    pInbuff = (int8_t *)pInput->pRaw_detections_M;
    pAnchors = (float32_t *)pInput_static_param->pAnchors_M;


    st_yolox_pp_level_decode_and_store_is8(pInbuff, pOut, pAnchors, grid_width, grid_height,pInput_static_param, scale, zp);
34015fce:	f994 304d 	ldrsb.w	r3, [r4, #77]	@ 0x4d
34015fd2:	4631      	mov	r1, r6
34015fd4:	e9cd 4301 	strd	r4, r3, [sp, #4]
34015fd8:	6963      	ldr	r3, [r4, #20]
34015fda:	9300      	str	r3, [sp, #0]
34015fdc:	ed94 0a11 	vldr	s0, [r4, #68]	@ 0x44
34015fe0:	6923      	ldr	r3, [r4, #16]
34015fe2:	6b62      	ldr	r2, [r4, #52]	@ 0x34
34015fe4:	6868      	ldr	r0, [r5, #4]
34015fe6:	f7ff fe37 	bl	34015c58 <st_yolox_pp_level_decode_and_store_is8>
    grid_width = pInput_static_param->grid_width_S;
    grid_height = pInput_static_param->grid_height_S;
    pInbuff = (int8_t *)pInput->pRaw_detections_S;
    pAnchors = (float32_t *)pInput_static_param->pAnchors_S;

    st_yolox_pp_level_decode_and_store_is8(pInbuff, pOut, pAnchors, grid_width, grid_height,pInput_static_param, scale, zp);
34015fea:	f994 304e 	ldrsb.w	r3, [r4, #78]	@ 0x4e
34015fee:	4631      	mov	r1, r6
34015ff0:	e9cd 4301 	strd	r4, r3, [sp, #4]
34015ff4:	69e3      	ldr	r3, [r4, #28]
34015ff6:	9300      	str	r3, [sp, #0]
34015ff8:	ed94 0a12 	vldr	s0, [r4, #72]	@ 0x48
34015ffc:	69a3      	ldr	r3, [r4, #24]
34015ffe:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
34016000:	68a8      	ldr	r0, [r5, #8]
34016002:	f7ff fe29 	bl	34015c58 <st_yolox_pp_level_decode_and_store_is8>

    return (error);
}
34016006:	2000      	movs	r0, #0
34016008:	b004      	add	sp, #16
3401600a:	bd70      	pop	{r4, r5, r6, pc}

3401600c <od_st_yolox_pp_reset>:


/* ----------------------       Exported routines      ---------------------- */

int32_t od_st_yolox_pp_reset(od_st_yolox_pp_static_param_t *pInput_static_param)
{
3401600c:	4603      	mov	r3, r0
    /* Initializations */
    pInput_static_param->nb_detect = 0;
3401600e:	2000      	movs	r0, #0
34016010:	63d8      	str	r0, [r3, #60]	@ 0x3c

	return (AI_OD_POSTPROCESS_ERROR_NO);
}
34016012:	4770      	bx	lr

34016014 <od_st_yolox_pp_process_int8>:
}

int32_t od_st_yolox_pp_process_int8(od_st_yolox_pp_in_t *pInput,
                                    od_pp_out_t *pOutput,
                                    od_st_yolox_pp_static_param_t *pInput_static_param)
{
34016014:	b538      	push	{r3, r4, r5, lr}
34016016:	460c      	mov	r4, r1
34016018:	4615      	mov	r5, r2
    int32_t error   = AI_OD_POSTPROCESS_ERROR_NO;

    /* Call Get NN boxes first */
    error = st_yolox_pp_getNNBoxes_centroid_is8(pInput,
3401601a:	f7ff ffc7 	bl	34015fac <st_yolox_pp_getNNBoxes_centroid_is8>
                                            pOutput,
                                            pInput_static_param);
    if (error != AI_OD_POSTPROCESS_ERROR_NO) return (error);
3401601e:	b950      	cbnz	r0, 34016036 <od_st_yolox_pp_process_int8+0x22>

    /* Then NMS */
    error = st_yolox_pp_nmsFiltering_centroid(pOutput,
34016020:	4629      	mov	r1, r5
34016022:	4620      	mov	r0, r4
34016024:	f7ff fd60 	bl	34015ae8 <st_yolox_pp_nmsFiltering_centroid>
                                              pInput_static_param);
    if (error != AI_OD_POSTPROCESS_ERROR_NO) return (error);
34016028:	b928      	cbnz	r0, 34016036 <od_st_yolox_pp_process_int8+0x22>

    /* And score re-filtering */
    error = st_yolox_pp_scoreFiltering_centroid(pOutput,
3401602a:	4629      	mov	r1, r5
3401602c:	4620      	mov	r0, r4
                                                pInput_static_param);

    return (error);
}
3401602e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    error = st_yolox_pp_scoreFiltering_centroid(pOutput,
34016032:	f7ff bddb 	b.w	34015bec <st_yolox_pp_scoreFiltering_centroid>
}
34016036:	bd38      	pop	{r3, r4, r5, pc}

34016038 <vision_models_sigmoid_f>:
#include "vision_models_pp.h"



float32_t vision_models_sigmoid_f(float32_t x)
{
34016038:	b508      	push	{r3, lr}
  return (1.0f / (1.0f + expf(-x)));
3401603a:	eeb1 0a40 	vneg.f32	s0, s0
3401603e:	f006 fc77 	bl	3401c930 <expf>
34016042:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
34016046:	ee30 0a27 	vadd.f32	s0, s0, s15
}
3401604a:	ee87 0a80 	vdiv.f32	s0, s15, s0
3401604e:	bd08      	pop	{r3, pc}

34016050 <overlap>:

//***************iou ********
//inline
float32_t overlap(float32_t x1, float32_t w1, float32_t x2, float32_t w2)
{
  float32_t l1 = x1 - w1 / 2;
34016050:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
34016054:	ee60 0aa7 	vmul.f32	s1, s1, s15
  float32_t l2 = x2 - w2 / 2;
34016058:	ee61 1aa7 	vmul.f32	s3, s3, s15
  float32_t l1 = x1 - w1 / 2;
3401605c:	ee30 7a60 	vsub.f32	s14, s0, s1
  float32_t l2 = x2 - w2 / 2;
34016060:	ee71 7a61 	vsub.f32	s15, s2, s3
  float32_t left = l1 > l2 ? l1 : l2;
  float32_t r1 = x1 + w1 / 2;
34016064:	ee70 0a80 	vadd.f32	s1, s1, s0
  float32_t left = l1 > l2 ? l1 : l2;
34016068:	eeb4 7a67 	vcmp.f32	s14, s15
  float32_t r2 = x2 + w2 / 2;
3401606c:	ee31 1a81 	vadd.f32	s2, s3, s2
  float32_t left = l1 > l2 ? l1 : l2;
34016070:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t right = r1 < r2 ? r1 : r2;
34016074:	eef4 0a41 	vcmp.f32	s1, s2
  float32_t left = l1 > l2 ? l1 : l2;
34016078:	fe77 7a27 	vselgt.f32	s15, s14, s15
  float32_t right = r1 < r2 ? r1 : r2;
3401607c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34016080:	bf48      	it	mi
34016082:	eeb0 1a60 	vmovmi.f32	s2, s1
  return (right - left);
}
34016086:	ee31 0a67 	vsub.f32	s0, s2, s15
3401608a:	4770      	bx	lr

3401608c <box_intersection>:

//inline
float32_t box_intersection(float32_t *a, float32_t *b)
{
  float32_t w = overlap(a[0], a[2], b[0], b[2]);
3401608c:	edd1 1a02 	vldr	s3, [r1, #8]
34016090:	ed91 1a00 	vldr	s2, [r1]
34016094:	edd0 0a02 	vldr	s1, [r0, #8]
34016098:	ed90 0a00 	vldr	s0, [r0]
{
3401609c:	b508      	push	{r3, lr}
  float32_t w = overlap(a[0], a[2], b[0], b[2]);
3401609e:	f7ff ffd7 	bl	34016050 <overlap>
  float32_t h = overlap(a[1], a[3], b[1], b[3]);
  if (w < 0 || h < 0) return 0;
340160a2:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
340160a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t w = overlap(a[0], a[2], b[0], b[2]);
340160aa:	eef0 6a40 	vmov.f32	s13, s0
  if (w < 0 || h < 0) return 0;
340160ae:	d411      	bmi.n	340160d4 <box_intersection+0x48>
  float32_t h = overlap(a[1], a[3], b[1], b[3]);
340160b0:	edd1 1a03 	vldr	s3, [r1, #12]
340160b4:	ed91 1a01 	vldr	s2, [r1, #4]
340160b8:	edd0 0a03 	vldr	s1, [r0, #12]
340160bc:	ed90 0a01 	vldr	s0, [r0, #4]
340160c0:	f7ff ffc6 	bl	34016050 <overlap>
  if (w < 0 || h < 0) return 0;
340160c4:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
340160c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340160cc:	d402      	bmi.n	340160d4 <box_intersection+0x48>
  float32_t area = w * h;
340160ce:	ee26 0a80 	vmul.f32	s0, s13, s0
  return (area);
}
340160d2:	bd08      	pop	{r3, pc}
  if (w < 0 || h < 0) return 0;
340160d4:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 340160dc <box_intersection+0x50>
340160d8:	e7fb      	b.n	340160d2 <box_intersection+0x46>
340160da:	bf00      	nop
340160dc:	00000000 	.word	0x00000000

340160e0 <box_union>:

//inline
float32_t box_union(float32_t *a, float32_t *b)
{
340160e0:	b510      	push	{r4, lr}
  float32_t i = box_intersection(a, b);
340160e2:	f7ff ffd3 	bl	3401608c <box_intersection>
  float32_t u = a[2] * a[3] + b[2] * b[3] - i;
340160e6:	ed91 7a03 	vldr	s14, [r1, #12]
340160ea:	edd1 7a02 	vldr	s15, [r1, #8]
340160ee:	edd0 6a02 	vldr	s13, [r0, #8]
340160f2:	ee67 7a87 	vmul.f32	s15, s15, s14
340160f6:	ed90 7a03 	vldr	s14, [r0, #12]
340160fa:	eee6 7a87 	vfma.f32	s15, s13, s14
  return (u);
}
340160fe:	ee37 0ac0 	vsub.f32	s0, s15, s0
34016102:	bd10      	pop	{r4, pc}

34016104 <vision_models_box_iou>:


float32_t vision_models_box_iou(float32_t *a, float32_t *b)
{
34016104:	b508      	push	{r3, lr}
  float32_t I = box_intersection(a, b);
34016106:	f7ff ffc1 	bl	3401608c <box_intersection>
  float32_t U = box_union(a, b);
 if (I == 0 || U == 0)
3401610a:	eeb5 0a40 	vcmp.f32	s0, #0.0
3401610e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t I = box_intersection(a, b);
34016112:	eeb0 6a40 	vmov.f32	s12, s0
 if (I == 0 || U == 0)
34016116:	d00b      	beq.n	34016130 <vision_models_box_iou+0x2c>
  float32_t U = box_union(a, b);
34016118:	f7ff ffe2 	bl	340160e0 <box_union>
 if (I == 0 || U == 0)
3401611c:	eeb5 0a40 	vcmp.f32	s0, #0.0
34016120:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t U = box_union(a, b);
34016124:	eef0 7a40 	vmov.f32	s15, s0
 if (I == 0 || U == 0)
34016128:	d002      	beq.n	34016130 <vision_models_box_iou+0x2c>
  {
    return 0;
  }
  return (I / U);
3401612a:	ee86 0a27 	vdiv.f32	s0, s12, s15
}
3401612e:	bd08      	pop	{r3, pc}
    return 0;
34016130:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 34016138 <vision_models_box_iou+0x34>
34016134:	e7fb      	b.n	3401612e <vision_models_box_iou+0x2a>
34016136:	bf00      	nop
34016138:	00000000 	.word	0x00000000

3401613c <vision_models_maxi_p_is8ou16>:
#endif

}

void vision_models_maxi_p_is8ou16(int8_t *arr, uint32_t len_arr, uint32_t offset, int8_t *maxim, uint16_t *index, uint32_t parallelize)
{
3401613c:	b5f0      	push	{r4, r5, r6, r7, lr}

__extension__ extern __inline int16x8_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vdupq_n_s16 (int16_t __a)
{
  return __builtin_mve_vdupq_n_sv8hi (__a);
3401613e:	f44f 4400 	mov.w	r4, #32768	@ 0x8000
34016142:	ed2d 8b08 	vpush	{d8-d11}
#ifdef VISION_MODELS_MAXI_P_IS8OU16_MVE
  int16x8_t   s16x8_max_val = vdupq_n_s16(SHRT_MIN);
  uint16x8_t   u16x8_max_idx = vdupq_n_u16(0);

  parallelize = MIN(parallelize, 8);
34016146:	9d0e      	ldr	r5, [sp, #56]	@ 0x38
34016148:	eea6 4b30 	vdup.16	q3, r4
3401614c:	2d08      	cmp	r5, #8
3401614e:	bf28      	it	cs
34016150:	2508      	movcs	r5, #8

__extension__ extern __inline uint16x8_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vdupq_n_u16 (uint16_t __a)
{
  return __builtin_mve_vdupq_n_uv8hi (__a);
34016152:	2400      	movs	r4, #0

__extension__ extern __inline mve_pred16_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vctp16q (uint32_t __a)
{
  return __builtin_mve_vctp16qv8bi (__a);
34016154:	f015 e801 	bfcsel	0, 3401515a <ISP_SVC_Stats_Gather+0x10e>, 2, pl

__extension__ extern __inline uint16x8_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vidupq_n_u16 (uint32_t __a, const int __imm)
{
  return __builtin_mve_vidupq_n_uv8hi (__a, __imm);
34016158:	4626      	mov	r6, r4
  return __builtin_mve_vctp16qv8bi (__a);
3401615a:	eefd 5a10 	vmrs	r5, <impl def 0xd>
  mve_pred16_t p = vctp16q(parallelize);

  uint16x8_t u16x8_idx = vdupq_n_u16(0);
  uint16x8_t u16x8_offset = vidupq_n_u16(0,1) * (uint16_t)offset;
3401615e:	eea0 2b30 	vdup.16	q0, r2
  return __builtin_mve_vdupq_n_uv8hi (__a);
34016162:	eea4 4b30 	vdup.16	q2, r4
  return __builtin_mve_vidupq_n_uv8hi (__a, __imm);
34016166:	ee17 8f6e 	cdp	15, 1, cr8, cr7, cr14, {3}
  return __builtin_mve_vctp16qv8bi (__a);
3401616a:	b2ad      	uxth	r5, r5
  return __builtin_mve_vdupq_n_uv8hi (__a);
3401616c:	ef24 2154 	vorr	q1, q2, q2
34016170:	ef10 0958 	vmul.i16	q0, q0, q4

  for (uint8_t i = 0; i < len_arr; i++)
34016174:	4622      	mov	r2, r4
  return __builtin_mve_vldrbq_gather_offset_z_sv8hi ((__builtin_neon_qi *) __base, __offset, __p);
34016176:	462f      	mov	r7, r5

    // according to p0: update with s16x8_val or keep s16x8_blk_minmax_val
    s16x8_max_val = vpselq_s16(s16x8_val, s16x8_max_val, p0);
    /* according to p0: store per-lane extrema indexes*/
    u16x8_max_idx = vpselq_u16(u16x8_idx, u16x8_max_idx, p0);
    u16x8_idx+=1;
34016178:	ef80 a851 	vmov.i16	q5, #1	@ 0x0001
3401617c:	b2d4      	uxtb	r4, r2
  for (uint8_t i = 0; i < len_arr; i++)
3401617e:	42a1      	cmp	r1, r4
34016180:	eb00 0602 	add.w	r6, r0, r2
34016184:	f102 0201 	add.w	r2, r2, #1
34016188:	d80d      	bhi.n	340161a6 <vision_models_maxi_p_is8ou16+0x6a>
  __builtin_mve_vstrhq_p_uv8hi ((__builtin_neon_hi *) __addr, __value, __p);
3401618a:	eeed 5a10 	vmsr	<impl def 0xd>, r5
3401618e:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
34016190:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016194:	ed82 5e80 	stc	14, cr5, [r2, #512]	@ 0x200
  __builtin_mve_vstrbq_p_sv8hi ((__builtin_neon_qi *) __addr, __value, __p);
34016198:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401619c:	ed83 6e80 	stc	14, cr6, [r3, #512]	@ 0x200
    }
    maxim++;
    index++;
  }
#endif
}
340161a0:	ecbd 8b08 	vpop	{d8-d11}
340161a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return __builtin_mve_vldrbq_gather_offset_z_sv8hi ((__builtin_neon_qi *) __base, __offset, __p);
340161a6:	eeed 7a10 	vmsr	<impl def 0xd>, r7
340161aa:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
340161ae:	ec96 8e80 	ldc	14, cr8, [r6], {128}	@ 0x80
  return __builtin_mve_vcmpgtq_m_sv8hi (__a, __b, __p);
340161b2:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
340161b6:	fe19 1f07 	cdp2	15, 1, cr1, cr9, cr7, {0}
  return __builtin_mve_vpselq_uv8hi (__a, __b, __p);
340161ba:	fe33 4f05 	cdp2	15, 3, cr4, cr3, cr5, {0}
  return __builtin_mve_vpselq_sv8hi (__a, __b, __p);
340161be:	fe39 6f07 	cdp2	15, 3, cr6, cr9, cr7, {0}
    u16x8_idx+=1;
340161c2:	ef12 284a 	vadd.i16	q1, q1, q5
  for (uint8_t i = 0; i < len_arr; i++)
340161c6:	e7d9      	b.n	3401617c <vision_models_maxi_p_is8ou16+0x40>

340161c8 <vision_models_maxi_p_is8ou8>:
{
340161c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340161cc:	ed2d 8b08 	vpush	{d8-d11}
  if (15*offset < UCHAR_MAX) {
340161d0:	ebc2 1602 	rsb	r6, r2, r2, lsl #4
{
340161d4:	b089      	sub	sp, #36	@ 0x24
  if (15*offset < UCHAR_MAX) {
340161d6:	2efe      	cmp	r6, #254	@ 0xfe
{
340161d8:	4681      	mov	r9, r0
340161da:	e9dd 451a 	ldrd	r4, r5, [sp, #104]	@ 0x68
340161de:	4690      	mov	r8, r2
340161e0:	469b      	mov	fp, r3
340161e2:	9103      	str	r1, [sp, #12]
  if (15*offset < UCHAR_MAX) {
340161e4:	d841      	bhi.n	3401626a <vision_models_maxi_p_is8ou8+0xa2>
  return __builtin_mve_vdupq_n_sv16qi (__a);
340161e6:	2380      	movs	r3, #128	@ 0x80
    parallelize = MIN(parallelize, 16);
340161e8:	2d10      	cmp	r5, #16
340161ea:	bf28      	it	cs
340161ec:	2510      	movcs	r5, #16
340161ee:	eee6 3b10 	vdup.8	q3, r3
  return __builtin_mve_vdupq_n_uv16qi (__a);
340161f2:	2300      	movs	r3, #0
  return __builtin_mve_vctp8qv16bi (__a);
340161f4:	f005 e801 	bfcsel	0, 340151fa <ISP_SVC_Stats_Gather+0x1ae>, 2, ne
  return __builtin_mve_vidupq_n_uv16qi (__a, __imm);
340161f8:	4618      	mov	r0, r3
  return __builtin_mve_vctp8qv16bi (__a);
340161fa:	eefd 2a10 	vmrs	r2, <impl def 0xd>
  return __builtin_mve_vidupq_n_uv16qi (__a, __imm);
340161fe:	ee01 8f6e 	cdp	15, 0, cr8, cr1, cr14, {3}
  return __builtin_mve_vdupq_n_uv16qi (__a);
34016202:	eee4 3b10 	vdup.8	q2, r3
    uint8x16_t u8x16_offset = vidupq_n_u8(0,1) * (uint8_t)offset;
34016206:	eee0 8b10 	vdup.8	q0, r8
  return __builtin_mve_vctp8qv16bi (__a);
3401620a:	b292      	uxth	r2, r2
  return __builtin_mve_vdupq_n_uv16qi (__a);
3401620c:	ef24 2154 	vorr	q1, q2, q2
34016210:	ef00 0958 	vmul.i8	q0, q0, q4
  return __builtin_mve_vldrbq_gather_offset_z_sv16qi ((__builtin_neon_qi *) __base, __offset, __p);
34016214:	4610      	mov	r0, r2
      u8x16_idx+=1;
34016216:	ef80 ae51 	vmov.i8	q5, #1	@ 0x01
    for (uint8_t i = 0; i < len_arr; i++)
3401621a:	9e03      	ldr	r6, [sp, #12]
3401621c:	b2d9      	uxtb	r1, r3
3401621e:	42b1      	cmp	r1, r6
34016220:	eb09 0503 	add.w	r5, r9, r3
34016224:	f103 0301 	add.w	r3, r3, #1
34016228:	d30e      	bcc.n	34016248 <vision_models_maxi_p_is8ou8+0x80>
  __builtin_mve_vstrbq_p_uv16qi ((__builtin_neon_qi *) __addr, __value, __p);
3401622a:	eeed 2a10 	vmsr	<impl def 0xd>, r2
3401622e:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016232:	ed84 5e00 	stc	14, cr5, [r4]
  __builtin_mve_vstrbq_p_sv16qi ((__builtin_neon_qi *) __addr, __value, __p);
34016236:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401623a:	ed8b 7e00 	stc	14, cr7, [fp]
}
3401623e:	b009      	add	sp, #36	@ 0x24
34016240:	ecbd 8b08 	vpop	{d8-d11}
34016244:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  return __builtin_mve_vldrbq_gather_offset_z_sv16qi ((__builtin_neon_qi *) __base, __offset, __p);
34016248:	eeed 0a10 	vmsr	<impl def 0xd>, r0
3401624c:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016250:	fc95 8e00 	ldc2	14, cr8, [r5], {0}
  return __builtin_mve_vcmpgtq_m_sv16qi (__a, __b, __p);
34016254:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016258:	fe09 1f07 	cdp2	15, 0, cr1, cr9, cr7, {0}
  return __builtin_mve_vpselq_uv16qi (__a, __b, __p);
3401625c:	fe33 4f05 	cdp2	15, 3, cr4, cr3, cr5, {0}
  return __builtin_mve_vpselq_sv16qi (__a, __b, __p);
34016260:	fe39 6f07 	cdp2	15, 3, cr6, cr9, cr7, {0}
      u8x16_idx+=1;
34016264:	ef02 284a 	vadd.i8	q1, q1, q5
    for (uint8_t i = 0; i < len_arr; i++)
34016268:	e7d7      	b.n	3401621a <vision_models_maxi_p_is8ou8+0x52>
    uint16_t _parallelize = MIN(8,parallelize);
3401626a:	2d08      	cmp	r5, #8
3401626c:	462e      	mov	r6, r5
3401626e:	bf28      	it	cs
34016270:	2608      	movcs	r6, #8
    vision_models_maxi_p_is8ou16(arr,len_arr,offset,maxim,_tmpIdx,_parallelize);
34016272:	af04      	add	r7, sp, #16
34016274:	9601      	str	r6, [sp, #4]
34016276:	9700      	str	r7, [sp, #0]
34016278:	f7ff ff60 	bl	3401613c <vision_models_maxi_p_is8ou16>
    maxim+=_parallelize;
3401627c:	46ba      	mov	sl, r7
    for ( uint16_t i = 0; i < _parallelize; i++) {
3401627e:	4638      	mov	r0, r7
34016280:	4621      	mov	r1, r4
    maxim+=_parallelize;
34016282:	4433      	add	r3, r6
    for ( uint16_t i = 0; i < _parallelize; i++) {
34016284:	eb04 0b06 	add.w	fp, r4, r6
34016288:	1c72      	adds	r2, r6, #1
3401628a:	3a01      	subs	r2, #1
3401628c:	d113      	bne.n	340162b6 <vision_models_maxi_p_is8ou8+0xee>
    parallelize-=_parallelize;
3401628e:	1baa      	subs	r2, r5, r6
    vision_models_maxi_p_is8ou16(arr,len_arr,offset,maxim,_tmpIdx,parallelize);
34016290:	e9cd 7200 	strd	r7, r2, [sp]
34016294:	fb08 9006 	mla	r0, r8, r6, r9
34016298:	4642      	mov	r2, r8
3401629a:	9903      	ldr	r1, [sp, #12]
3401629c:	f7ff ff4e 	bl	3401613c <vision_models_maxi_p_is8ou16>
    for ( uint32_t i = 0; i < parallelize; i++) {
340162a0:	442c      	add	r4, r5
340162a2:	eba4 040b 	sub.w	r4, r4, fp
340162a6:	3401      	adds	r4, #1
340162a8:	3c01      	subs	r4, #1
340162aa:	d0c8      	beq.n	3401623e <vision_models_maxi_p_is8ou8+0x76>
      *index++ = _tmpIdx[i];
340162ac:	f83a 3b02 	ldrh.w	r3, [sl], #2
340162b0:	f80b 3b01 	strb.w	r3, [fp], #1
    for ( uint32_t i = 0; i < parallelize; i++) {
340162b4:	e7f8      	b.n	340162a8 <vision_models_maxi_p_is8ou8+0xe0>
      *index++ = _tmpIdx[i];
340162b6:	f830 cb02 	ldrh.w	ip, [r0], #2
340162ba:	f801 cb01 	strb.w	ip, [r1], #1
    for ( uint16_t i = 0; i < _parallelize; i++) {
340162be:	e7e4      	b.n	3401628a <vision_models_maxi_p_is8ou8+0xc2>

340162c0 <LL_ATON_Init>:
/**
 * @brief  ATON global initialization. Initializes clocks and bus interfaces. Must be called before anything else
 * @retval Always zero
 */
int LL_ATON_Init(void)
{
340162c0:	b510      	push	{r4, lr}
  if (done != 0)
340162c2:	4ba3      	ldr	r3, [pc, #652]	@ (34016550 <LL_ATON_Init+0x290>)
{
340162c4:	b088      	sub	sp, #32
  if (done != 0)
340162c6:	781a      	ldrb	r2, [r3, #0]
340162c8:	b90a      	cbnz	r2, 340162ce <LL_ATON_Init+0xe>
  done = 1;
340162ca:	2201      	movs	r2, #1
340162cc:	701a      	strb	r2, [r3, #0]
  int i;

  ll_aton_static_checks();

  /* Clear pipeline */
  t = ATON_CLKCTRL_CTRL_GET(0);
340162ce:	4ba1      	ldr	r3, [pc, #644]	@ (34016554 <LL_ATON_Init+0x294>)
340162d0:	681a      	ldr	r2, [r3, #0]
  t = ATON_CLKCTRL_CTRL_SET_CLR(t, 1);
340162d2:	f042 0202 	orr.w	r2, r2, #2
  ATON_CLKCTRL_CTRL_SET(0, t);
340162d6:	601a      	str	r2, [r3, #0]

  /* Enable all ATON clocks */
  ATON_CLKCTRL_CTRL_SET(0, 1);
340162d8:	2201      	movs	r2, #1
340162da:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES0_SET(0, 0xffffffff);
340162dc:	f04f 32ff 	mov.w	r2, #4294967295
340162e0:	609a      	str	r2, [r3, #8]
  ATON_CLKCTRL_AGATES1_SET(0, 0xffffffff);
340162e2:	60da      	str	r2, [r3, #12]

#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_EC_TRACE)
  ATON_CLKCTRL_BGATES_SET(0, (1 << ATON_EPOCHCTRL_CLKB_CLK(0)));
#else
  ATON_CLKCTRL_BGATES_SET(0, 0x0);
340162e4:	2200      	movs	r2, #0
340162e6:	611a      	str	r2, [r3, #16]
#ifdef ATON_CLKCTRL_BGATES1_OFFSET
  ATON_CLKCTRL_BGATES1_SET(0, 0xffffffff);
#endif

  /* Check that RTL and ATON.h match. Only check first unit */
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
340162e8:	f503 43a0 	add.w	r3, r3, #20480	@ 0x5000
340162ec:	685c      	ldr	r4, [r3, #4]
340162ee:	2c00      	cmp	r4, #0
340162f0:	d0fc      	beq.n	340162ec <LL_ATON_Init+0x2c>
340162f2:	f245 0301 	movw	r3, #20481	@ 0x5001
340162f6:	b2a2      	uxth	r2, r4
340162f8:	429a      	cmp	r2, r3
340162fa:	f040 8092 	bne.w	34016422 <LL_ATON_Init+0x162>

#ifdef ATON_CONVACC_NUM
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
340162fe:	4b96      	ldr	r3, [pc, #600]	@ (34016558 <LL_ATON_Init+0x298>)
34016300:	685c      	ldr	r4, [r3, #4]
34016302:	2c00      	cmp	r4, #0
34016304:	d0fc      	beq.n	34016300 <LL_ATON_Init+0x40>
34016306:	f245 1317 	movw	r3, #20759	@ 0x5117
3401630a:	b2a2      	uxth	r2, r4
3401630c:	429a      	cmp	r2, r3
3401630e:	f040 80b0 	bne.w	34016472 <LL_ATON_Init+0x1b2>
#endif

#ifdef ATON_POOL_NUM
  ASSERT_UNITS_VERS_W_MSG(POOL, t);
34016312:	4b92      	ldr	r3, [pc, #584]	@ (3401655c <LL_ATON_Init+0x29c>)
34016314:	685c      	ldr	r4, [r3, #4]
34016316:	2c00      	cmp	r4, #0
34016318:	d0fc      	beq.n	34016314 <LL_ATON_Init+0x54>
3401631a:	f241 131c 	movw	r3, #4380	@ 0x111c
3401631e:	b2a2      	uxth	r2, r4
34016320:	429a      	cmp	r2, r3
34016322:	f040 80cc 	bne.w	340164be <LL_ATON_Init+0x1fe>
#endif

#ifdef ATON_ARITH_NUM
  ASSERT_UNITS_VERS_W_MSG(ARITH, t);
34016326:	4b8e      	ldr	r3, [pc, #568]	@ (34016560 <LL_ATON_Init+0x2a0>)
34016328:	685c      	ldr	r4, [r3, #4]
3401632a:	2c00      	cmp	r4, #0
3401632c:	d0fc      	beq.n	34016328 <LL_ATON_Init+0x68>
3401632e:	f241 031a 	movw	r3, #4122	@ 0x101a
34016332:	b2a2      	uxth	r2, r4
34016334:	429a      	cmp	r2, r3
34016336:	f040 80e6 	bne.w	34016506 <LL_ATON_Init+0x246>
#endif

#ifdef ATON_ACTIV_NUM
  ASSERT_UNITS_VERS_W_MSG(ACTIV, t);
3401633a:	4b8a      	ldr	r3, [pc, #552]	@ (34016564 <LL_ATON_Init+0x2a4>)
3401633c:	685c      	ldr	r4, [r3, #4]
3401633e:	2c00      	cmp	r4, #0
34016340:	d0fc      	beq.n	3401633c <LL_ATON_Init+0x7c>
34016342:	f241 131b 	movw	r3, #4379	@ 0x111b
34016346:	b2a2      	uxth	r2, r4
34016348:	429a      	cmp	r2, r3
3401634a:	f040 812d 	bne.w	340165a8 <LL_ATON_Init+0x2e8>
#endif

#ifdef ATON_DECUN_NUM
  ASSERT_UNITS_VERS_W_MSG(DECUN, t);
3401634e:	4b86      	ldr	r3, [pc, #536]	@ (34016568 <LL_ATON_Init+0x2a8>)
34016350:	685c      	ldr	r4, [r3, #4]
34016352:	2c00      	cmp	r4, #0
34016354:	d0fc      	beq.n	34016350 <LL_ATON_Init+0x90>
34016356:	f641 2319 	movw	r3, #6681	@ 0x1a19
3401635a:	b2a2      	uxth	r2, r4
3401635c:	429a      	cmp	r2, r3
3401635e:	f040 8147 	bne.w	340165f0 <LL_ATON_Init+0x330>
#endif

#ifdef ATON_EPOCHCTRL_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(EPOCHCTRL, t);
34016362:	4b82      	ldr	r3, [pc, #520]	@ (3401656c <LL_ATON_Init+0x2ac>)
34016364:	685c      	ldr	r4, [r3, #4]
34016366:	2c00      	cmp	r4, #0
34016368:	d0fc      	beq.n	34016364 <LL_ATON_Init+0xa4>
3401636a:	f241 1321 	movw	r3, #4385	@ 0x1121
3401636e:	b2a2      	uxth	r2, r4
34016370:	429a      	cmp	r2, r3
34016372:	f040 8162 	bne.w	3401663a <LL_ATON_Init+0x37a>
#endif

#ifdef ATON_RECBUF_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(RECBUF, t);
34016376:	4b7e      	ldr	r3, [pc, #504]	@ (34016570 <LL_ATON_Init+0x2b0>)
34016378:	685c      	ldr	r4, [r3, #4]
3401637a:	2c00      	cmp	r4, #0
3401637c:	d0fc      	beq.n	34016378 <LL_ATON_Init+0xb8>
3401637e:	f243 2320 	movw	r3, #12832	@ 0x3220
34016382:	b2a2      	uxth	r2, r4
34016384:	429a      	cmp	r2, r3
34016386:	f040 817c 	bne.w	34016682 <LL_ATON_Init+0x3c2>

#ifdef ATON_IMC_NUM
  ASSERT_UNITS_VERS_W_MSG(IMC, t);
#endif

  ASSERT_UNITS_VERS_W_MSG(CLKCTRL, t);
3401638a:	4b72      	ldr	r3, [pc, #456]	@ (34016554 <LL_ATON_Init+0x294>)
3401638c:	685c      	ldr	r4, [r3, #4]
3401638e:	2c00      	cmp	r4, #0
34016390:	d0fc      	beq.n	3401638c <LL_ATON_Init+0xcc>
34016392:	f241 231f 	movw	r3, #4639	@ 0x121f
34016396:	b2a2      	uxth	r2, r4
34016398:	429a      	cmp	r2, r3
3401639a:	f040 8198 	bne.w	340166ce <LL_ATON_Init+0x40e>

  ASSERT_UNITS_VERS_W_MSG(INTCTRL, t);
3401639e:	4b75      	ldr	r3, [pc, #468]	@ (34016574 <LL_ATON_Init+0x2b4>)
340163a0:	685c      	ldr	r4, [r3, #4]
340163a2:	2c00      	cmp	r4, #0
340163a4:	d0fc      	beq.n	340163a0 <LL_ATON_Init+0xe0>
340163a6:	f241 131e 	movw	r3, #4382	@ 0x111e
340163aa:	b2a2      	uxth	r2, r4
340163ac:	429a      	cmp	r2, r3
340163ae:	f040 81b4 	bne.w	3401671a <LL_ATON_Init+0x45a>

  ASSERT_UNITS_VERS_W_MSG(STRSWITCH, t);
340163b2:	4b71      	ldr	r3, [pc, #452]	@ (34016578 <LL_ATON_Init+0x2b8>)
340163b4:	685c      	ldr	r4, [r3, #4]
340163b6:	2c00      	cmp	r4, #0
340163b8:	d0fc      	beq.n	340163b4 <LL_ATON_Init+0xf4>
340163ba:	b2a3      	uxth	r3, r4
340163bc:	f5b3 5fb0 	cmp.w	r3, #5632	@ 0x1600
340163c0:	f040 81cf 	bne.w	34016762 <LL_ATON_Init+0x4a2>

  ASSERT_UNITS_VERS_W_MSG(BUSIF, t);
340163c4:	4a6d      	ldr	r2, [pc, #436]	@ (3401657c <LL_ATON_Init+0x2bc>)
340163c6:	6854      	ldr	r4, [r2, #4]
340163c8:	2c00      	cmp	r4, #0
340163ca:	d0fc      	beq.n	340163c6 <LL_ATON_Init+0x106>
340163cc:	f245 031d 	movw	r3, #20509	@ 0x501d
340163d0:	b2a1      	uxth	r1, r4
340163d2:	4299      	cmp	r1, r3
340163d4:	f000 81ec 	beq.w	340167b0 <LL_ATON_Init+0x4f0>
340163d8:	f004 f8f8 	bl	3401a5cc <__errno>
340163dc:	6803      	ldr	r3, [r0, #0]
340163de:	2b00      	cmp	r3, #0
340163e0:	f000 81e4 	beq.w	340167ac <LL_ATON_Init+0x4ec>
340163e4:	f004 f8f2 	bl	3401a5cc <__errno>
340163e8:	6800      	ldr	r0, [r0, #0]
340163ea:	f004 f889 	bl	3401a500 <strerror>
340163ee:	4603      	mov	r3, r0
340163f0:	2205      	movs	r2, #5
340163f2:	2100      	movs	r1, #0
340163f4:	e9cd 2105 	strd	r2, r1, [sp, #20]
340163f8:	221d      	movs	r2, #29
340163fa:	9204      	str	r2, [sp, #16]
340163fc:	f3c4 2203 	ubfx	r2, r4, #8, #4
34016400:	9203      	str	r2, [sp, #12]
34016402:	f3c4 3203 	ubfx	r2, r4, #12, #4
34016406:	9202      	str	r2, [sp, #8]
34016408:	4a5d      	ldr	r2, [pc, #372]	@ (34016580 <LL_ATON_Init+0x2c0>)
3401640a:	b2e4      	uxtb	r4, r4
3401640c:	495d      	ldr	r1, [pc, #372]	@ (34016584 <LL_ATON_Init+0x2c4>)
3401640e:	9200      	str	r2, [sp, #0]
34016410:	485d      	ldr	r0, [pc, #372]	@ (34016588 <LL_ATON_Init+0x2c8>)
34016412:	22fb      	movs	r2, #251	@ 0xfb
34016414:	9401      	str	r4, [sp, #4]
34016416:	f003 fcb1 	bl	34019d7c <iprintf>
3401641a:	21fb      	movs	r1, #251	@ 0xfb
3401641c:	4b5b      	ldr	r3, [pc, #364]	@ (3401658c <LL_ATON_Init+0x2cc>)
3401641e:	4a5c      	ldr	r2, [pc, #368]	@ (34016590 <LL_ATON_Init+0x2d0>)
34016420:	e022      	b.n	34016468 <LL_ATON_Init+0x1a8>
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
34016422:	f004 f8d3 	bl	3401a5cc <__errno>
34016426:	6803      	ldr	r3, [r0, #0]
34016428:	b30b      	cbz	r3, 3401646e <LL_ATON_Init+0x1ae>
3401642a:	f004 f8cf 	bl	3401a5cc <__errno>
3401642e:	6800      	ldr	r0, [r0, #0]
34016430:	f004 f866 	bl	3401a500 <strerror>
34016434:	4603      	mov	r3, r0
34016436:	2205      	movs	r2, #5
34016438:	f04f 0e00 	mov.w	lr, #0
3401643c:	e9cd 2e05 	strd	r2, lr, [sp, #20]
34016440:	2201      	movs	r2, #1
34016442:	9204      	str	r2, [sp, #16]
34016444:	f3c4 2203 	ubfx	r2, r4, #8, #4
34016448:	9203      	str	r2, [sp, #12]
3401644a:	f3c4 3203 	ubfx	r2, r4, #12, #4
3401644e:	9202      	str	r2, [sp, #8]
34016450:	4a50      	ldr	r2, [pc, #320]	@ (34016594 <LL_ATON_Init+0x2d4>)
34016452:	b2e4      	uxtb	r4, r4
34016454:	494b      	ldr	r1, [pc, #300]	@ (34016584 <LL_ATON_Init+0x2c4>)
34016456:	9200      	str	r2, [sp, #0]
34016458:	484b      	ldr	r0, [pc, #300]	@ (34016588 <LL_ATON_Init+0x2c8>)
3401645a:	22c7      	movs	r2, #199	@ 0xc7
3401645c:	9401      	str	r4, [sp, #4]
3401645e:	f003 fc8d 	bl	34019d7c <iprintf>
34016462:	21c7      	movs	r1, #199	@ 0xc7
34016464:	4b49      	ldr	r3, [pc, #292]	@ (3401658c <LL_ATON_Init+0x2cc>)
34016466:	4a4a      	ldr	r2, [pc, #296]	@ (34016590 <LL_ATON_Init+0x2d0>)
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
34016468:	4846      	ldr	r0, [pc, #280]	@ (34016584 <LL_ATON_Init+0x2c4>)
3401646a:	f002 fcf7 	bl	34018e5c <__assert_func>
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
3401646e:	4b4a      	ldr	r3, [pc, #296]	@ (34016598 <LL_ATON_Init+0x2d8>)
34016470:	e7e1      	b.n	34016436 <LL_ATON_Init+0x176>
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
34016472:	f004 f8ab 	bl	3401a5cc <__errno>
34016476:	6803      	ldr	r3, [r0, #0]
34016478:	b1fb      	cbz	r3, 340164ba <LL_ATON_Init+0x1fa>
3401647a:	f004 f8a7 	bl	3401a5cc <__errno>
3401647e:	6800      	ldr	r0, [r0, #0]
34016480:	f004 f83e 	bl	3401a500 <strerror>
34016484:	4603      	mov	r3, r0
34016486:	2205      	movs	r2, #5
34016488:	f04f 0c01 	mov.w	ip, #1
3401648c:	e9cd 2c05 	strd	r2, ip, [sp, #20]
34016490:	2217      	movs	r2, #23
34016492:	9204      	str	r2, [sp, #16]
34016494:	f3c4 2203 	ubfx	r2, r4, #8, #4
34016498:	9203      	str	r2, [sp, #12]
3401649a:	f3c4 3203 	ubfx	r2, r4, #12, #4
3401649e:	9202      	str	r2, [sp, #8]
340164a0:	4a3e      	ldr	r2, [pc, #248]	@ (3401659c <LL_ATON_Init+0x2dc>)
340164a2:	b2e4      	uxtb	r4, r4
340164a4:	4937      	ldr	r1, [pc, #220]	@ (34016584 <LL_ATON_Init+0x2c4>)
340164a6:	9200      	str	r2, [sp, #0]
340164a8:	4837      	ldr	r0, [pc, #220]	@ (34016588 <LL_ATON_Init+0x2c8>)
340164aa:	22ca      	movs	r2, #202	@ 0xca
340164ac:	9401      	str	r4, [sp, #4]
340164ae:	f003 fc65 	bl	34019d7c <iprintf>
340164b2:	21ca      	movs	r1, #202	@ 0xca
340164b4:	4b35      	ldr	r3, [pc, #212]	@ (3401658c <LL_ATON_Init+0x2cc>)
340164b6:	4a36      	ldr	r2, [pc, #216]	@ (34016590 <LL_ATON_Init+0x2d0>)
340164b8:	e7d6      	b.n	34016468 <LL_ATON_Init+0x1a8>
340164ba:	4b37      	ldr	r3, [pc, #220]	@ (34016598 <LL_ATON_Init+0x2d8>)
340164bc:	e7e3      	b.n	34016486 <LL_ATON_Init+0x1c6>
  ASSERT_UNITS_VERS_W_MSG(POOL, t);
340164be:	f004 f885 	bl	3401a5cc <__errno>
340164c2:	6803      	ldr	r3, [r0, #0]
340164c4:	b1eb      	cbz	r3, 34016502 <LL_ATON_Init+0x242>
340164c6:	f004 f881 	bl	3401a5cc <__errno>
340164ca:	6800      	ldr	r0, [r0, #0]
340164cc:	f004 f818 	bl	3401a500 <strerror>
340164d0:	4603      	mov	r3, r0
340164d2:	2201      	movs	r2, #1
340164d4:	e9cd 2205 	strd	r2, r2, [sp, #20]
340164d8:	221c      	movs	r2, #28
340164da:	9204      	str	r2, [sp, #16]
340164dc:	f3c4 2203 	ubfx	r2, r4, #8, #4
340164e0:	9203      	str	r2, [sp, #12]
340164e2:	f3c4 3203 	ubfx	r2, r4, #12, #4
340164e6:	9202      	str	r2, [sp, #8]
340164e8:	4a2d      	ldr	r2, [pc, #180]	@ (340165a0 <LL_ATON_Init+0x2e0>)
340164ea:	b2e4      	uxtb	r4, r4
340164ec:	4925      	ldr	r1, [pc, #148]	@ (34016584 <LL_ATON_Init+0x2c4>)
340164ee:	9200      	str	r2, [sp, #0]
340164f0:	4825      	ldr	r0, [pc, #148]	@ (34016588 <LL_ATON_Init+0x2c8>)
340164f2:	22ce      	movs	r2, #206	@ 0xce
340164f4:	9401      	str	r4, [sp, #4]
340164f6:	f003 fc41 	bl	34019d7c <iprintf>
340164fa:	21ce      	movs	r1, #206	@ 0xce
340164fc:	4b23      	ldr	r3, [pc, #140]	@ (3401658c <LL_ATON_Init+0x2cc>)
340164fe:	4a24      	ldr	r2, [pc, #144]	@ (34016590 <LL_ATON_Init+0x2d0>)
34016500:	e7b2      	b.n	34016468 <LL_ATON_Init+0x1a8>
34016502:	4b25      	ldr	r3, [pc, #148]	@ (34016598 <LL_ATON_Init+0x2d8>)
34016504:	e7e5      	b.n	340164d2 <LL_ATON_Init+0x212>
  ASSERT_UNITS_VERS_W_MSG(ARITH, t);
34016506:	f004 f861 	bl	3401a5cc <__errno>
3401650a:	6803      	ldr	r3, [r0, #0]
3401650c:	b1f3      	cbz	r3, 3401654c <LL_ATON_Init+0x28c>
3401650e:	f004 f85d 	bl	3401a5cc <__errno>
34016512:	6800      	ldr	r0, [r0, #0]
34016514:	f003 fff4 	bl	3401a500 <strerror>
34016518:	4603      	mov	r3, r0
3401651a:	2201      	movs	r2, #1
3401651c:	2000      	movs	r0, #0
3401651e:	e9cd 2005 	strd	r2, r0, [sp, #20]
34016522:	221a      	movs	r2, #26
34016524:	9204      	str	r2, [sp, #16]
34016526:	f3c4 2203 	ubfx	r2, r4, #8, #4
3401652a:	9203      	str	r2, [sp, #12]
3401652c:	f3c4 3203 	ubfx	r2, r4, #12, #4
34016530:	9202      	str	r2, [sp, #8]
34016532:	4a1c      	ldr	r2, [pc, #112]	@ (340165a4 <LL_ATON_Init+0x2e4>)
34016534:	b2e4      	uxtb	r4, r4
34016536:	4913      	ldr	r1, [pc, #76]	@ (34016584 <LL_ATON_Init+0x2c4>)
34016538:	9200      	str	r2, [sp, #0]
3401653a:	4813      	ldr	r0, [pc, #76]	@ (34016588 <LL_ATON_Init+0x2c8>)
3401653c:	22d2      	movs	r2, #210	@ 0xd2
3401653e:	9401      	str	r4, [sp, #4]
34016540:	f003 fc1c 	bl	34019d7c <iprintf>
34016544:	21d2      	movs	r1, #210	@ 0xd2
34016546:	4b11      	ldr	r3, [pc, #68]	@ (3401658c <LL_ATON_Init+0x2cc>)
34016548:	4a11      	ldr	r2, [pc, #68]	@ (34016590 <LL_ATON_Init+0x2d0>)
3401654a:	e78d      	b.n	34016468 <LL_ATON_Init+0x1a8>
3401654c:	4b12      	ldr	r3, [pc, #72]	@ (34016598 <LL_ATON_Init+0x2d8>)
3401654e:	e7e4      	b.n	3401651a <LL_ATON_Init+0x25a>
34016550:	340ce884 	.word	0x340ce884
34016554:	580e0000 	.word	0x580e0000
34016558:	580ef000 	.word	0x580ef000
3401655c:	580fb000 	.word	0x580fb000
34016560:	580f7000 	.word	0x580f7000
34016564:	580f5000 	.word	0x580f5000
34016568:	580f3000 	.word	0x580f3000
3401656c:	580fe000 	.word	0x580fe000
34016570:	580fd000 	.word	0x580fd000
34016574:	580e1000 	.word	0x580e1000
34016578:	580e4000 	.word	0x580e4000
3401657c:	580e2000 	.word	0x580e2000
34016580:	340211e0 	.word	0x340211e0
34016584:	34021080 	.word	0x34021080
34016588:	3402112b 	.word	0x3402112b
3401658c:	340217f8 	.word	0x340217f8
34016590:	340ae40a 	.word	0x340ae40a
34016594:	3402118f 	.word	0x3402118f
34016598:	3402107b 	.word	0x3402107b
3401659c:	34021196 	.word	0x34021196
340165a0:	3402119e 	.word	0x3402119e
340165a4:	340211a3 	.word	0x340211a3
  ASSERT_UNITS_VERS_W_MSG(ACTIV, t);
340165a8:	f004 f810 	bl	3401a5cc <__errno>
340165ac:	6803      	ldr	r3, [r0, #0]
340165ae:	b1eb      	cbz	r3, 340165ec <LL_ATON_Init+0x32c>
340165b0:	f004 f80c 	bl	3401a5cc <__errno>
340165b4:	6800      	ldr	r0, [r0, #0]
340165b6:	f003 ffa3 	bl	3401a500 <strerror>
340165ba:	4603      	mov	r3, r0
340165bc:	2201      	movs	r2, #1
340165be:	e9cd 2205 	strd	r2, r2, [sp, #20]
340165c2:	221b      	movs	r2, #27
340165c4:	9204      	str	r2, [sp, #16]
340165c6:	f3c4 2203 	ubfx	r2, r4, #8, #4
340165ca:	9203      	str	r2, [sp, #12]
340165cc:	f3c4 3203 	ubfx	r2, r4, #12, #4
340165d0:	9202      	str	r2, [sp, #8]
340165d2:	4a7c      	ldr	r2, [pc, #496]	@ (340167c4 <LL_ATON_Init+0x504>)
340165d4:	b2e4      	uxtb	r4, r4
340165d6:	497c      	ldr	r1, [pc, #496]	@ (340167c8 <LL_ATON_Init+0x508>)
340165d8:	9200      	str	r2, [sp, #0]
340165da:	487c      	ldr	r0, [pc, #496]	@ (340167cc <LL_ATON_Init+0x50c>)
340165dc:	22d6      	movs	r2, #214	@ 0xd6
340165de:	9401      	str	r4, [sp, #4]
340165e0:	f003 fbcc 	bl	34019d7c <iprintf>
340165e4:	21d6      	movs	r1, #214	@ 0xd6
340165e6:	4b7a      	ldr	r3, [pc, #488]	@ (340167d0 <LL_ATON_Init+0x510>)
340165e8:	4a7a      	ldr	r2, [pc, #488]	@ (340167d4 <LL_ATON_Init+0x514>)
340165ea:	e73d      	b.n	34016468 <LL_ATON_Init+0x1a8>
340165ec:	4b7a      	ldr	r3, [pc, #488]	@ (340167d8 <LL_ATON_Init+0x518>)
340165ee:	e7e5      	b.n	340165bc <LL_ATON_Init+0x2fc>
  ASSERT_UNITS_VERS_W_MSG(DECUN, t);
340165f0:	f003 ffec 	bl	3401a5cc <__errno>
340165f4:	6803      	ldr	r3, [r0, #0]
340165f6:	b1f3      	cbz	r3, 34016636 <LL_ATON_Init+0x376>
340165f8:	f003 ffe8 	bl	3401a5cc <__errno>
340165fc:	6800      	ldr	r0, [r0, #0]
340165fe:	f003 ff7f 	bl	3401a500 <strerror>
34016602:	4603      	mov	r3, r0
34016604:	2201      	movs	r2, #1
34016606:	210a      	movs	r1, #10
34016608:	e9cd 2105 	strd	r2, r1, [sp, #20]
3401660c:	2219      	movs	r2, #25
3401660e:	9204      	str	r2, [sp, #16]
34016610:	f3c4 2203 	ubfx	r2, r4, #8, #4
34016614:	9203      	str	r2, [sp, #12]
34016616:	f3c4 3203 	ubfx	r2, r4, #12, #4
3401661a:	9202      	str	r2, [sp, #8]
3401661c:	4a6f      	ldr	r2, [pc, #444]	@ (340167dc <LL_ATON_Init+0x51c>)
3401661e:	b2e4      	uxtb	r4, r4
34016620:	4969      	ldr	r1, [pc, #420]	@ (340167c8 <LL_ATON_Init+0x508>)
34016622:	9200      	str	r2, [sp, #0]
34016624:	4869      	ldr	r0, [pc, #420]	@ (340167cc <LL_ATON_Init+0x50c>)
34016626:	22da      	movs	r2, #218	@ 0xda
34016628:	9401      	str	r4, [sp, #4]
3401662a:	f003 fba7 	bl	34019d7c <iprintf>
3401662e:	21da      	movs	r1, #218	@ 0xda
34016630:	4b67      	ldr	r3, [pc, #412]	@ (340167d0 <LL_ATON_Init+0x510>)
34016632:	4a68      	ldr	r2, [pc, #416]	@ (340167d4 <LL_ATON_Init+0x514>)
34016634:	e718      	b.n	34016468 <LL_ATON_Init+0x1a8>
34016636:	4b68      	ldr	r3, [pc, #416]	@ (340167d8 <LL_ATON_Init+0x518>)
34016638:	e7e4      	b.n	34016604 <LL_ATON_Init+0x344>
  ASSERT_UNITS_VERS_W_MSG(EPOCHCTRL, t);
3401663a:	f003 ffc7 	bl	3401a5cc <__errno>
3401663e:	6803      	ldr	r3, [r0, #0]
34016640:	b1eb      	cbz	r3, 3401667e <LL_ATON_Init+0x3be>
34016642:	f003 ffc3 	bl	3401a5cc <__errno>
34016646:	6800      	ldr	r0, [r0, #0]
34016648:	f003 ff5a 	bl	3401a500 <strerror>
3401664c:	4603      	mov	r3, r0
3401664e:	2201      	movs	r2, #1
34016650:	e9cd 2205 	strd	r2, r2, [sp, #20]
34016654:	2221      	movs	r2, #33	@ 0x21
34016656:	9204      	str	r2, [sp, #16]
34016658:	f3c4 2203 	ubfx	r2, r4, #8, #4
3401665c:	9203      	str	r2, [sp, #12]
3401665e:	f3c4 3203 	ubfx	r2, r4, #12, #4
34016662:	9202      	str	r2, [sp, #8]
34016664:	4a5e      	ldr	r2, [pc, #376]	@ (340167e0 <LL_ATON_Init+0x520>)
34016666:	b2e4      	uxtb	r4, r4
34016668:	4957      	ldr	r1, [pc, #348]	@ (340167c8 <LL_ATON_Init+0x508>)
3401666a:	9200      	str	r2, [sp, #0]
3401666c:	4857      	ldr	r0, [pc, #348]	@ (340167cc <LL_ATON_Init+0x50c>)
3401666e:	22de      	movs	r2, #222	@ 0xde
34016670:	9401      	str	r4, [sp, #4]
34016672:	f003 fb83 	bl	34019d7c <iprintf>
34016676:	21de      	movs	r1, #222	@ 0xde
34016678:	4b55      	ldr	r3, [pc, #340]	@ (340167d0 <LL_ATON_Init+0x510>)
3401667a:	4a56      	ldr	r2, [pc, #344]	@ (340167d4 <LL_ATON_Init+0x514>)
3401667c:	e6f4      	b.n	34016468 <LL_ATON_Init+0x1a8>
3401667e:	4b56      	ldr	r3, [pc, #344]	@ (340167d8 <LL_ATON_Init+0x518>)
34016680:	e7e5      	b.n	3401664e <LL_ATON_Init+0x38e>
  ASSERT_UNITS_VERS_W_MSG(RECBUF, t);
34016682:	f003 ffa3 	bl	3401a5cc <__errno>
34016686:	6803      	ldr	r3, [r0, #0]
34016688:	b1fb      	cbz	r3, 340166ca <LL_ATON_Init+0x40a>
3401668a:	f003 ff9f 	bl	3401a5cc <__errno>
3401668e:	6800      	ldr	r0, [r0, #0]
34016690:	f003 ff36 	bl	3401a500 <strerror>
34016694:	4603      	mov	r3, r0
34016696:	2203      	movs	r2, #3
34016698:	f04f 0e02 	mov.w	lr, #2
3401669c:	e9cd 2e05 	strd	r2, lr, [sp, #20]
340166a0:	2220      	movs	r2, #32
340166a2:	9204      	str	r2, [sp, #16]
340166a4:	f3c4 2203 	ubfx	r2, r4, #8, #4
340166a8:	9203      	str	r2, [sp, #12]
340166aa:	f3c4 3203 	ubfx	r2, r4, #12, #4
340166ae:	9202      	str	r2, [sp, #8]
340166b0:	4a4c      	ldr	r2, [pc, #304]	@ (340167e4 <LL_ATON_Init+0x524>)
340166b2:	b2e4      	uxtb	r4, r4
340166b4:	4944      	ldr	r1, [pc, #272]	@ (340167c8 <LL_ATON_Init+0x508>)
340166b6:	9200      	str	r2, [sp, #0]
340166b8:	4844      	ldr	r0, [pc, #272]	@ (340167cc <LL_ATON_Init+0x50c>)
340166ba:	22e2      	movs	r2, #226	@ 0xe2
340166bc:	9401      	str	r4, [sp, #4]
340166be:	f003 fb5d 	bl	34019d7c <iprintf>
340166c2:	21e2      	movs	r1, #226	@ 0xe2
340166c4:	4b42      	ldr	r3, [pc, #264]	@ (340167d0 <LL_ATON_Init+0x510>)
340166c6:	4a43      	ldr	r2, [pc, #268]	@ (340167d4 <LL_ATON_Init+0x514>)
340166c8:	e6ce      	b.n	34016468 <LL_ATON_Init+0x1a8>
340166ca:	4b43      	ldr	r3, [pc, #268]	@ (340167d8 <LL_ATON_Init+0x518>)
340166cc:	e7e3      	b.n	34016696 <LL_ATON_Init+0x3d6>
  ASSERT_UNITS_VERS_W_MSG(CLKCTRL, t);
340166ce:	f003 ff7d 	bl	3401a5cc <__errno>
340166d2:	6803      	ldr	r3, [r0, #0]
340166d4:	b1fb      	cbz	r3, 34016716 <LL_ATON_Init+0x456>
340166d6:	f003 ff79 	bl	3401a5cc <__errno>
340166da:	6800      	ldr	r0, [r0, #0]
340166dc:	f003 ff10 	bl	3401a500 <strerror>
340166e0:	4603      	mov	r3, r0
340166e2:	2201      	movs	r2, #1
340166e4:	f04f 0c02 	mov.w	ip, #2
340166e8:	e9cd 2c05 	strd	r2, ip, [sp, #20]
340166ec:	221f      	movs	r2, #31
340166ee:	9204      	str	r2, [sp, #16]
340166f0:	f3c4 2203 	ubfx	r2, r4, #8, #4
340166f4:	9203      	str	r2, [sp, #12]
340166f6:	f3c4 3203 	ubfx	r2, r4, #12, #4
340166fa:	9202      	str	r2, [sp, #8]
340166fc:	4a3a      	ldr	r2, [pc, #232]	@ (340167e8 <LL_ATON_Init+0x528>)
340166fe:	b2e4      	uxtb	r4, r4
34016700:	4931      	ldr	r1, [pc, #196]	@ (340167c8 <LL_ATON_Init+0x508>)
34016702:	9200      	str	r2, [sp, #0]
34016704:	4831      	ldr	r0, [pc, #196]	@ (340167cc <LL_ATON_Init+0x50c>)
34016706:	22f5      	movs	r2, #245	@ 0xf5
34016708:	9401      	str	r4, [sp, #4]
3401670a:	f003 fb37 	bl	34019d7c <iprintf>
3401670e:	21f5      	movs	r1, #245	@ 0xf5
34016710:	4b2f      	ldr	r3, [pc, #188]	@ (340167d0 <LL_ATON_Init+0x510>)
34016712:	4a30      	ldr	r2, [pc, #192]	@ (340167d4 <LL_ATON_Init+0x514>)
34016714:	e6a8      	b.n	34016468 <LL_ATON_Init+0x1a8>
34016716:	4b30      	ldr	r3, [pc, #192]	@ (340167d8 <LL_ATON_Init+0x518>)
34016718:	e7e3      	b.n	340166e2 <LL_ATON_Init+0x422>
  ASSERT_UNITS_VERS_W_MSG(INTCTRL, t);
3401671a:	f003 ff57 	bl	3401a5cc <__errno>
3401671e:	6803      	ldr	r3, [r0, #0]
34016720:	b1eb      	cbz	r3, 3401675e <LL_ATON_Init+0x49e>
34016722:	f003 ff53 	bl	3401a5cc <__errno>
34016726:	6800      	ldr	r0, [r0, #0]
34016728:	f003 feea 	bl	3401a500 <strerror>
3401672c:	4603      	mov	r3, r0
3401672e:	2201      	movs	r2, #1
34016730:	e9cd 2205 	strd	r2, r2, [sp, #20]
34016734:	221e      	movs	r2, #30
34016736:	9204      	str	r2, [sp, #16]
34016738:	f3c4 2203 	ubfx	r2, r4, #8, #4
3401673c:	9203      	str	r2, [sp, #12]
3401673e:	f3c4 3203 	ubfx	r2, r4, #12, #4
34016742:	9202      	str	r2, [sp, #8]
34016744:	4a29      	ldr	r2, [pc, #164]	@ (340167ec <LL_ATON_Init+0x52c>)
34016746:	b2e4      	uxtb	r4, r4
34016748:	491f      	ldr	r1, [pc, #124]	@ (340167c8 <LL_ATON_Init+0x508>)
3401674a:	9200      	str	r2, [sp, #0]
3401674c:	481f      	ldr	r0, [pc, #124]	@ (340167cc <LL_ATON_Init+0x50c>)
3401674e:	22f7      	movs	r2, #247	@ 0xf7
34016750:	9401      	str	r4, [sp, #4]
34016752:	f003 fb13 	bl	34019d7c <iprintf>
34016756:	21f7      	movs	r1, #247	@ 0xf7
34016758:	4b1d      	ldr	r3, [pc, #116]	@ (340167d0 <LL_ATON_Init+0x510>)
3401675a:	4a1e      	ldr	r2, [pc, #120]	@ (340167d4 <LL_ATON_Init+0x514>)
3401675c:	e684      	b.n	34016468 <LL_ATON_Init+0x1a8>
3401675e:	4b1e      	ldr	r3, [pc, #120]	@ (340167d8 <LL_ATON_Init+0x518>)
34016760:	e7e5      	b.n	3401672e <LL_ATON_Init+0x46e>
  ASSERT_UNITS_VERS_W_MSG(STRSWITCH, t);
34016762:	f003 ff33 	bl	3401a5cc <__errno>
34016766:	6803      	ldr	r3, [r0, #0]
34016768:	b1f3      	cbz	r3, 340167a8 <LL_ATON_Init+0x4e8>
3401676a:	f003 ff2f 	bl	3401a5cc <__errno>
3401676e:	6800      	ldr	r0, [r0, #0]
34016770:	f003 fec6 	bl	3401a500 <strerror>
34016774:	4603      	mov	r3, r0
34016776:	2201      	movs	r2, #1
34016778:	2006      	movs	r0, #6
3401677a:	e9cd 2005 	strd	r2, r0, [sp, #20]
3401677e:	2200      	movs	r2, #0
34016780:	9204      	str	r2, [sp, #16]
34016782:	f3c4 2203 	ubfx	r2, r4, #8, #4
34016786:	9203      	str	r2, [sp, #12]
34016788:	f3c4 3203 	ubfx	r2, r4, #12, #4
3401678c:	9202      	str	r2, [sp, #8]
3401678e:	4a18      	ldr	r2, [pc, #96]	@ (340167f0 <LL_ATON_Init+0x530>)
34016790:	b2e4      	uxtb	r4, r4
34016792:	490d      	ldr	r1, [pc, #52]	@ (340167c8 <LL_ATON_Init+0x508>)
34016794:	9200      	str	r2, [sp, #0]
34016796:	480d      	ldr	r0, [pc, #52]	@ (340167cc <LL_ATON_Init+0x50c>)
34016798:	22f9      	movs	r2, #249	@ 0xf9
3401679a:	9401      	str	r4, [sp, #4]
3401679c:	f003 faee 	bl	34019d7c <iprintf>
340167a0:	21f9      	movs	r1, #249	@ 0xf9
340167a2:	4b0b      	ldr	r3, [pc, #44]	@ (340167d0 <LL_ATON_Init+0x510>)
340167a4:	4a0b      	ldr	r2, [pc, #44]	@ (340167d4 <LL_ATON_Init+0x514>)
340167a6:	e65f      	b.n	34016468 <LL_ATON_Init+0x1a8>
340167a8:	4b0b      	ldr	r3, [pc, #44]	@ (340167d8 <LL_ATON_Init+0x518>)
340167aa:	e7e4      	b.n	34016776 <LL_ATON_Init+0x4b6>
  ASSERT_UNITS_VERS_W_MSG(BUSIF, t);
340167ac:	4b0a      	ldr	r3, [pc, #40]	@ (340167d8 <LL_ATON_Init+0x518>)
340167ae:	e61f      	b.n	340163f0 <LL_ATON_Init+0x130>

  /* Enable Bus Interfaces */
  for (i = 0; i < ATON_BUSIF_NUM; i++)
  {
    ATON_BUSIF_CTRL_SET(i, 1);
340167b0:	2301      	movs	r3, #1

  /* Enable Interrupt Controller */
  ATON_INTCTRL_CTRL_SET(0, 1);

  return 0;
}
340167b2:	2000      	movs	r0, #0
    ATON_BUSIF_CTRL_SET(i, 1);
340167b4:	6013      	str	r3, [r2, #0]
340167b6:	4a0f      	ldr	r2, [pc, #60]	@ (340167f4 <LL_ATON_Init+0x534>)
340167b8:	6013      	str	r3, [r2, #0]
  ATON_INTCTRL_CTRL_SET(0, 1);
340167ba:	f5a2 5200 	sub.w	r2, r2, #8192	@ 0x2000
340167be:	6013      	str	r3, [r2, #0]
}
340167c0:	b008      	add	sp, #32
340167c2:	bd10      	pop	{r4, pc}
340167c4:	340211a9 	.word	0x340211a9
340167c8:	34021080 	.word	0x34021080
340167cc:	3402112b 	.word	0x3402112b
340167d0:	340217f8 	.word	0x340217f8
340167d4:	340ae40a 	.word	0x340ae40a
340167d8:	3402107b 	.word	0x3402107b
340167dc:	340211af 	.word	0x340211af
340167e0:	340211b5 	.word	0x340211b5
340167e4:	340211bf 	.word	0x340211bf
340167e8:	340211c6 	.word	0x340211c6
340167ec:	340211ce 	.word	0x340211ce
340167f0:	340211d6 	.word	0x340211d6
340167f4:	580e3000 	.word	0x580e3000

340167f8 <LL_ATON_EnableUnits_Init>:
 * @param  n Lenght of the initialization array
 * @retval Error code
 * @todo   Add boundary checks
 */
int LL_ATON_EnableUnits_Init(const LL_ATON_EnableUnits_InitTypeDef *LL_ATON_EnableUnits_InitStruct, int n)
{
340167f8:	b5f0      	push	{r4, r5, r6, r7, lr}
  int i;
  enum AccelUnitsType unitType;
  uint32_t unitId;

  for (i = 0; i < n; i++)
340167fa:	2400      	movs	r4, #0
340167fc:	42a1      	cmp	r1, r4
340167fe:	f101 0201 	add.w	r2, r1, #1
34016802:	bfb8      	it	lt
34016804:	2201      	movlt	r2, #1
#endif // !POOL_RC14
      break;
#endif
#ifdef ATON_RECBUF_NUM
    case RECBUF:
      ATON_ENABLE(RECBUF, unitId);
34016806:	4d1e      	ldr	r5, [pc, #120]	@ (34016880 <LL_ATON_EnableUnits_Init+0x88>)
      ATON_CONVACC_CTRL_SET(unitId, ATON_CONVACC_CTRL_SET_EN(Conv_ctrl_bits[unitId], 1));
34016808:	4f1e      	ldr	r7, [pc, #120]	@ (34016884 <LL_ATON_EnableUnits_Init+0x8c>)
    unitId = LL_ATON_EnableUnits_InitStruct[i].unit.unit_num;
3401680a:	1c86      	adds	r6, r0, #2
  for (i = 0; i < n; i++)
3401680c:	3a01      	subs	r2, #1
3401680e:	d101      	bne.n	34016814 <LL_ATON_EnableUnits_Init+0x1c>
      break;
    }
  }

  return 0;
}
34016810:	2000      	movs	r0, #0
34016812:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch (unitType)
34016814:	f810 1024 	ldrb.w	r1, [r0, r4, lsl #2]
    unitId = LL_ATON_EnableUnits_InitStruct[i].unit.unit_num;
34016818:	f836 3024 	ldrh.w	r3, [r6, r4, lsl #2]
    switch (unitType)
3401681c:	2908      	cmp	r1, #8
3401681e:	d818      	bhi.n	34016852 <LL_ATON_EnableUnits_Init+0x5a>
34016820:	e8df f001 	tbb	[pc, r1]
34016824:	190e1705 	.word	0x190e1705
34016828:	1725211d 	.word	0x1725211d
3401682c:	29          	.byte	0x29
3401682d:	00          	.byte	0x00
      ATON_ENABLE(STRENG, unitId);
3401682e:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34016832:	33e5      	adds	r3, #229	@ 0xe5
      ATON_ENABLE(DECUN, unitId);
34016834:	031b      	lsls	r3, r3, #12
34016836:	6819      	ldr	r1, [r3, #0]
34016838:	f041 0101 	orr.w	r1, r1, #1
3401683c:	6019      	str	r1, [r3, #0]
      break;
3401683e:	e008      	b.n	34016852 <LL_ATON_EnableUnits_Init+0x5a>
      ATON_CONVACC_CTRL_SET(unitId, ATON_CONVACC_CTRL_SET_EN(Conv_ctrl_bits[unitId], 1));
34016840:	f503 21b0 	add.w	r1, r3, #360448	@ 0x58000
34016844:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
34016848:	31ef      	adds	r1, #239	@ 0xef
3401684a:	0309      	lsls	r1, r1, #12
3401684c:	f043 0301 	orr.w	r3, r3, #1
34016850:	600b      	str	r3, [r1, #0]
  for (i = 0; i < n; i++)
34016852:	3401      	adds	r4, #1
34016854:	e7da      	b.n	3401680c <LL_ATON_EnableUnits_Init+0x14>
      ATON_ENABLE(DECUN, unitId);
34016856:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
3401685a:	33f3      	adds	r3, #243	@ 0xf3
3401685c:	e7ea      	b.n	34016834 <LL_ATON_EnableUnits_Init+0x3c>
      ATON_ENABLE(ACTIV, unitId);
3401685e:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34016862:	33f5      	adds	r3, #245	@ 0xf5
34016864:	e7e6      	b.n	34016834 <LL_ATON_EnableUnits_Init+0x3c>
      ATON_ENABLE(ARITH, unitId);
34016866:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
3401686a:	33f7      	adds	r3, #247	@ 0xf7
3401686c:	e7e2      	b.n	34016834 <LL_ATON_EnableUnits_Init+0x3c>
      ATON_ENABLE(POOL, unitId);
3401686e:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34016872:	33fb      	adds	r3, #251	@ 0xfb
34016874:	e7de      	b.n	34016834 <LL_ATON_EnableUnits_Init+0x3c>
      ATON_ENABLE(RECBUF, unitId);
34016876:	682b      	ldr	r3, [r5, #0]
34016878:	f043 0301 	orr.w	r3, r3, #1
3401687c:	602b      	str	r3, [r5, #0]
      break;
3401687e:	e7e8      	b.n	34016852 <LL_ATON_EnableUnits_Init+0x5a>
34016880:	580fd000 	.word	0x580fd000
34016884:	340ce888 	.word	0x340ce888

34016888 <__atonn_getSrcPortID>:
}
#endif

unsigned __atonn_getSrcPortID(enum SwitchUnitsType sut, unsigned char su_num, enum AccelUnitsType aut,
                              unsigned char au_num, unsigned char port)
{
34016888:	b538      	push	{r3, r4, r5, lr}
3401688a:	4605      	mov	r5, r0
3401688c:	f89d 4010 	ldrb.w	r4, [sp, #16]
  // FIXME
  LL_ATON_ASSERT(su_num == 0);
34016890:	4608      	mov	r0, r1
34016892:	b131      	cbz	r1, 340168a2 <__atonn_getSrcPortID+0x1a>
34016894:	f44f 7152 	mov.w	r1, #840	@ 0x348
34016898:	4b3d      	ldr	r3, [pc, #244]	@ (34016990 <__atonn_getSrcPortID+0x108>)
3401689a:	4a3e      	ldr	r2, [pc, #248]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
  case STRSWITCH:
    switch (aut)
    {
#if defined(ATON_STRENG_NUM)
    case STRENG:
      LL_ATON_ASSERT(port == 0);
3401689c:	483e      	ldr	r0, [pc, #248]	@ (34016998 <__atonn_getSrcPortID+0x110>)
3401689e:	f002 fadd 	bl	34018e5c <__assert_func>
  switch (sut)
340168a2:	b125      	cbz	r5, 340168ae <__atonn_getSrcPortID+0x26>
340168a4:	2d01      	cmp	r5, #1
340168a6:	d068      	beq.n	3401697a <__atonn_getSrcPortID+0xf2>
340168a8:	2d02      	cmp	r5, #2
340168aa:	d06b      	beq.n	34016984 <__atonn_getSrcPortID+0xfc>
    // TODO
    LL_ATON_ASSERT(0);
    break;
  }
  return 0;
}
340168ac:	bd38      	pop	{r3, r4, r5, pc}
    switch (aut)
340168ae:	2a06      	cmp	r2, #6
340168b0:	d85e      	bhi.n	34016970 <__atonn_getSrcPortID+0xe8>
340168b2:	e8df f002 	tbb	[pc, r2]
340168b6:	5d04      	.short	0x5d04
340168b8:	3f302112 	.word	0x3f302112
340168bc:	4e          	.byte	0x4e
340168bd:	00          	.byte	0x00
      LL_ATON_ASSERT(port == 0);
340168be:	b124      	cbz	r4, 340168ca <__atonn_getSrcPortID+0x42>
340168c0:	f44f 7154 	mov.w	r1, #848	@ 0x350
340168c4:	4b35      	ldr	r3, [pc, #212]	@ (3401699c <__atonn_getSrcPortID+0x114>)
340168c6:	4a33      	ldr	r2, [pc, #204]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
340168c8:	e7e8      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_STRENG_NUM);
340168ca:	2b09      	cmp	r3, #9
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, STRENG, 0, 0) + au_num;
340168cc:	4618      	mov	r0, r3
      LL_ATON_ASSERT(au_num < ATON_STRENG_NUM);
340168ce:	d9ed      	bls.n	340168ac <__atonn_getSrcPortID+0x24>
340168d0:	f240 3151 	movw	r1, #849	@ 0x351
340168d4:	4b32      	ldr	r3, [pc, #200]	@ (340169a0 <__atonn_getSrcPortID+0x118>)
340168d6:	4a2f      	ldr	r2, [pc, #188]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
340168d8:	e7e0      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(port == 0);
340168da:	b124      	cbz	r4, 340168e6 <__atonn_getSrcPortID+0x5e>
340168dc:	f240 3157 	movw	r1, #855	@ 0x357
340168e0:	4b2e      	ldr	r3, [pc, #184]	@ (3401699c <__atonn_getSrcPortID+0x114>)
340168e2:	4a2c      	ldr	r2, [pc, #176]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
340168e4:	e7da      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_CONVACC_NUM);
340168e6:	2b03      	cmp	r3, #3
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, CONVACC, 0, 0) + au_num;
340168e8:	f103 000a 	add.w	r0, r3, #10
      LL_ATON_ASSERT(au_num < ATON_CONVACC_NUM);
340168ec:	d9de      	bls.n	340168ac <__atonn_getSrcPortID+0x24>
340168ee:	f44f 7156 	mov.w	r1, #856	@ 0x358
340168f2:	4b2c      	ldr	r3, [pc, #176]	@ (340169a4 <__atonn_getSrcPortID+0x11c>)
340168f4:	4a27      	ldr	r2, [pc, #156]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
340168f6:	e7d1      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(port == 0);
340168f8:	b124      	cbz	r4, 34016904 <__atonn_getSrcPortID+0x7c>
340168fa:	f240 315e 	movw	r1, #862	@ 0x35e
340168fe:	4b27      	ldr	r3, [pc, #156]	@ (3401699c <__atonn_getSrcPortID+0x114>)
34016900:	4a24      	ldr	r2, [pc, #144]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
34016902:	e7cb      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_DECUN_NUM);
34016904:	2b01      	cmp	r3, #1
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, DECUN, 0, 0) + au_num;
34016906:	f103 000e 	add.w	r0, r3, #14
      LL_ATON_ASSERT(au_num < ATON_DECUN_NUM);
3401690a:	d9cf      	bls.n	340168ac <__atonn_getSrcPortID+0x24>
3401690c:	f240 315f 	movw	r1, #863	@ 0x35f
34016910:	4b25      	ldr	r3, [pc, #148]	@ (340169a8 <__atonn_getSrcPortID+0x120>)
34016912:	4a20      	ldr	r2, [pc, #128]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
34016914:	e7c2      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(port == 0);
34016916:	b124      	cbz	r4, 34016922 <__atonn_getSrcPortID+0x9a>
34016918:	f240 3165 	movw	r1, #869	@ 0x365
3401691c:	4b1f      	ldr	r3, [pc, #124]	@ (3401699c <__atonn_getSrcPortID+0x114>)
3401691e:	4a1d      	ldr	r2, [pc, #116]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
34016920:	e7bc      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_ACTIV_NUM);
34016922:	2b01      	cmp	r3, #1
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, ACTIV, 0, 0) + au_num;
34016924:	f103 0010 	add.w	r0, r3, #16
      LL_ATON_ASSERT(au_num < ATON_ACTIV_NUM);
34016928:	d9c0      	bls.n	340168ac <__atonn_getSrcPortID+0x24>
3401692a:	f240 3166 	movw	r1, #870	@ 0x366
3401692e:	4b1e      	ldr	r3, [pc, #120]	@ (340169a8 <__atonn_getSrcPortID+0x120>)
34016930:	4a18      	ldr	r2, [pc, #96]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
34016932:	e7b3      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(port == 0);
34016934:	b124      	cbz	r4, 34016940 <__atonn_getSrcPortID+0xb8>
34016936:	f44f 715b 	mov.w	r1, #876	@ 0x36c
3401693a:	4b18      	ldr	r3, [pc, #96]	@ (3401699c <__atonn_getSrcPortID+0x114>)
3401693c:	4a15      	ldr	r2, [pc, #84]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
3401693e:	e7ad      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_ARITH_NUM);
34016940:	2b03      	cmp	r3, #3
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, ARITH, 0, 0) + au_num;
34016942:	f103 0012 	add.w	r0, r3, #18
      LL_ATON_ASSERT(au_num < ATON_ARITH_NUM);
34016946:	d9b1      	bls.n	340168ac <__atonn_getSrcPortID+0x24>
34016948:	f240 316d 	movw	r1, #877	@ 0x36d
3401694c:	4b15      	ldr	r3, [pc, #84]	@ (340169a4 <__atonn_getSrcPortID+0x11c>)
3401694e:	4a11      	ldr	r2, [pc, #68]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
34016950:	e7a4      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(port == 0);
34016952:	b124      	cbz	r4, 3401695e <__atonn_getSrcPortID+0xd6>
34016954:	f240 3173 	movw	r1, #883	@ 0x373
34016958:	4b10      	ldr	r3, [pc, #64]	@ (3401699c <__atonn_getSrcPortID+0x114>)
3401695a:	4a0e      	ldr	r2, [pc, #56]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
3401695c:	e79e      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_POOL_NUM);
3401695e:	2b01      	cmp	r3, #1
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, POOL, 0, 0) + au_num;
34016960:	f103 0016 	add.w	r0, r3, #22
      LL_ATON_ASSERT(au_num < ATON_POOL_NUM);
34016964:	d9a2      	bls.n	340168ac <__atonn_getSrcPortID+0x24>
34016966:	f44f 715d 	mov.w	r1, #884	@ 0x374
3401696a:	4b0f      	ldr	r3, [pc, #60]	@ (340169a8 <__atonn_getSrcPortID+0x120>)
3401696c:	4a09      	ldr	r2, [pc, #36]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
3401696e:	e795      	b.n	3401689c <__atonn_getSrcPortID+0x14>
      LL_ATON_ASSERT(0);
34016970:	f240 3179 	movw	r1, #889	@ 0x379
34016974:	4b0d      	ldr	r3, [pc, #52]	@ (340169ac <__atonn_getSrcPortID+0x124>)
34016976:	4a07      	ldr	r2, [pc, #28]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
34016978:	e790      	b.n	3401689c <__atonn_getSrcPortID+0x14>
    LL_ATON_ASSERT(0);
3401697a:	f240 317f 	movw	r1, #895	@ 0x37f
3401697e:	4b0b      	ldr	r3, [pc, #44]	@ (340169ac <__atonn_getSrcPortID+0x124>)
34016980:	4a04      	ldr	r2, [pc, #16]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
34016982:	e78b      	b.n	3401689c <__atonn_getSrcPortID+0x14>
    LL_ATON_ASSERT(0);
34016984:	f240 3183 	movw	r1, #899	@ 0x383
34016988:	4b08      	ldr	r3, [pc, #32]	@ (340169ac <__atonn_getSrcPortID+0x124>)
3401698a:	4a02      	ldr	r2, [pc, #8]	@ (34016994 <__atonn_getSrcPortID+0x10c>)
3401698c:	e786      	b.n	3401689c <__atonn_getSrcPortID+0x14>
3401698e:	bf00      	nop
34016990:	340211e6 	.word	0x340211e6
34016994:	340ae3f5 	.word	0x340ae3f5
34016998:	34021080 	.word	0x34021080
3401699c:	340211f2 	.word	0x340211f2
340169a0:	340211fc 	.word	0x340211fc
340169a4:	34021208 	.word	0x34021208
340169a8:	34021213 	.word	0x34021213
340169ac:	340217f8 	.word	0x340217f8

340169b0 <__atonn_getDstPortID>:

unsigned __atonn_getDstPortID(enum SwitchUnitsType sut, unsigned char su_num, enum AccelUnitsType aut,
                              unsigned char au_num, unsigned char port)
{
340169b0:	b538      	push	{r3, r4, r5, lr}
340169b2:	4605      	mov	r5, r0
340169b4:	f89d 4010 	ldrb.w	r4, [sp, #16]
  // FIXME
  LL_ATON_ASSERT(su_num == 0);
340169b8:	4608      	mov	r0, r1
340169ba:	b131      	cbz	r1, 340169ca <__atonn_getDstPortID+0x1a>
340169bc:	f240 318d 	movw	r1, #909	@ 0x38d
340169c0:	4b46      	ldr	r3, [pc, #280]	@ (34016adc <__atonn_getDstPortID+0x12c>)
340169c2:	4a47      	ldr	r2, [pc, #284]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
  case STRSWITCH:
    switch (aut)
    {
#if defined(ATON_STRENG_NUM)
    case STRENG:
      LL_ATON_ASSERT(port == 0);
340169c4:	4847      	ldr	r0, [pc, #284]	@ (34016ae4 <__atonn_getDstPortID+0x134>)
340169c6:	f002 fa49 	bl	34018e5c <__assert_func>
  switch (sut)
340169ca:	b125      	cbz	r5, 340169d6 <__atonn_getDstPortID+0x26>
340169cc:	2d01      	cmp	r5, #1
340169ce:	d07a      	beq.n	34016ac6 <__atonn_getDstPortID+0x116>
340169d0:	2d02      	cmp	r5, #2
340169d2:	d07d      	beq.n	34016ad0 <__atonn_getDstPortID+0x120>
    // TODO
    LL_ATON_ASSERT(0);
    break;
  }
  return 0;
}
340169d4:	bd38      	pop	{r3, r4, r5, pc}
    switch (aut)
340169d6:	2a06      	cmp	r2, #6
340169d8:	d870      	bhi.n	34016abc <__atonn_getDstPortID+0x10c>
340169da:	e8df f002 	tbb	[pc, r2]
340169de:	6f04      	.short	0x6f04
340169e0:	4c3d2915 	.word	0x4c3d2915
340169e4:	60          	.byte	0x60
340169e5:	00          	.byte	0x00
      LL_ATON_ASSERT(port == 0);
340169e6:	b124      	cbz	r4, 340169f2 <__atonn_getDstPortID+0x42>
340169e8:	f240 3195 	movw	r1, #917	@ 0x395
340169ec:	4b3e      	ldr	r3, [pc, #248]	@ (34016ae8 <__atonn_getDstPortID+0x138>)
340169ee:	4a3c      	ldr	r2, [pc, #240]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
340169f0:	e7e8      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_STRENG_NUM);
340169f2:	2b09      	cmp	r3, #9
340169f4:	d904      	bls.n	34016a00 <__atonn_getDstPortID+0x50>
340169f6:	f240 3196 	movw	r1, #918	@ 0x396
340169fa:	4b3c      	ldr	r3, [pc, #240]	@ (34016aec <__atonn_getDstPortID+0x13c>)
340169fc:	4a38      	ldr	r2, [pc, #224]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
340169fe:	e7e1      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, STRENG, 0, 0) + (0x4 * au_num);
34016a00:	2008      	movs	r0, #8
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, POOL, 0, 0) + (0x4 * au_num);
34016a02:	eb00 0083 	add.w	r0, r0, r3, lsl #2
34016a06:	e7e5      	b.n	340169d4 <__atonn_getDstPortID+0x24>
      LL_ATON_ASSERT(port < 3);
34016a08:	2c02      	cmp	r4, #2
34016a0a:	d904      	bls.n	34016a16 <__atonn_getDstPortID+0x66>
34016a0c:	f44f 7167 	mov.w	r1, #924	@ 0x39c
34016a10:	4b37      	ldr	r3, [pc, #220]	@ (34016af0 <__atonn_getDstPortID+0x140>)
34016a12:	4a33      	ldr	r2, [pc, #204]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016a14:	e7d6      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_CONVACC_NUM);
34016a16:	2b03      	cmp	r3, #3
34016a18:	d904      	bls.n	34016a24 <__atonn_getDstPortID+0x74>
34016a1a:	f240 319d 	movw	r1, #925	@ 0x39d
34016a1e:	4b35      	ldr	r3, [pc, #212]	@ (34016af4 <__atonn_getDstPortID+0x144>)
34016a20:	4a2f      	ldr	r2, [pc, #188]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016a22:	e7cf      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, CONVACC, 0, 0) + (0x4 * (3 * au_num + port));
34016a24:	2003      	movs	r0, #3
34016a26:	fb10 4003 	smlabb	r0, r0, r3, r4
34016a2a:	0080      	lsls	r0, r0, #2
34016a2c:	3030      	adds	r0, #48	@ 0x30
34016a2e:	e7d1      	b.n	340169d4 <__atonn_getDstPortID+0x24>
      LL_ATON_ASSERT(port < 2);
34016a30:	2c01      	cmp	r4, #1
34016a32:	d904      	bls.n	34016a3e <__atonn_getDstPortID+0x8e>
34016a34:	f240 31a3 	movw	r1, #931	@ 0x3a3
34016a38:	4b2f      	ldr	r3, [pc, #188]	@ (34016af8 <__atonn_getDstPortID+0x148>)
34016a3a:	4a29      	ldr	r2, [pc, #164]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016a3c:	e7c2      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_DECUN_NUM);
34016a3e:	2b01      	cmp	r3, #1
34016a40:	d904      	bls.n	34016a4c <__atonn_getDstPortID+0x9c>
34016a42:	f44f 7169 	mov.w	r1, #932	@ 0x3a4
34016a46:	4b2d      	ldr	r3, [pc, #180]	@ (34016afc <__atonn_getDstPortID+0x14c>)
34016a48:	4a25      	ldr	r2, [pc, #148]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016a4a:	e7bb      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, DECUN, 0, 0) + (0x4 * (2 * au_num + port));
34016a4c:	eb04 0443 	add.w	r4, r4, r3, lsl #1
34016a50:	00a4      	lsls	r4, r4, #2
34016a52:	f104 0060 	add.w	r0, r4, #96	@ 0x60
34016a56:	e7bd      	b.n	340169d4 <__atonn_getDstPortID+0x24>
      LL_ATON_ASSERT(port == 0);
34016a58:	b124      	cbz	r4, 34016a64 <__atonn_getDstPortID+0xb4>
34016a5a:	f240 31aa 	movw	r1, #938	@ 0x3aa
34016a5e:	4b22      	ldr	r3, [pc, #136]	@ (34016ae8 <__atonn_getDstPortID+0x138>)
34016a60:	4a1f      	ldr	r2, [pc, #124]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016a62:	e7af      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_ACTIV_NUM);
34016a64:	2b01      	cmp	r3, #1
34016a66:	d904      	bls.n	34016a72 <__atonn_getDstPortID+0xc2>
34016a68:	f240 31ab 	movw	r1, #939	@ 0x3ab
34016a6c:	4b23      	ldr	r3, [pc, #140]	@ (34016afc <__atonn_getDstPortID+0x14c>)
34016a6e:	4a1c      	ldr	r2, [pc, #112]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016a70:	e7a8      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, ACTIV, 0, 0) + (0x4 * au_num);
34016a72:	2070      	movs	r0, #112	@ 0x70
34016a74:	e7c5      	b.n	34016a02 <__atonn_getDstPortID+0x52>
      LL_ATON_ASSERT(port < 2);
34016a76:	2c01      	cmp	r4, #1
34016a78:	d904      	bls.n	34016a84 <__atonn_getDstPortID+0xd4>
34016a7a:	f240 31b1 	movw	r1, #945	@ 0x3b1
34016a7e:	4b1e      	ldr	r3, [pc, #120]	@ (34016af8 <__atonn_getDstPortID+0x148>)
34016a80:	4a17      	ldr	r2, [pc, #92]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016a82:	e79f      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_ARITH_NUM);
34016a84:	2b03      	cmp	r3, #3
34016a86:	d904      	bls.n	34016a92 <__atonn_getDstPortID+0xe2>
34016a88:	f240 31b2 	movw	r1, #946	@ 0x3b2
34016a8c:	4b19      	ldr	r3, [pc, #100]	@ (34016af4 <__atonn_getDstPortID+0x144>)
34016a8e:	4a14      	ldr	r2, [pc, #80]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016a90:	e798      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, ARITH, 0, 0) + (0x4 * (2 * au_num + port));
34016a92:	eb04 0443 	add.w	r4, r4, r3, lsl #1
34016a96:	00a4      	lsls	r4, r4, #2
34016a98:	f104 0078 	add.w	r0, r4, #120	@ 0x78
34016a9c:	e79a      	b.n	340169d4 <__atonn_getDstPortID+0x24>
      LL_ATON_ASSERT(port == 0);
34016a9e:	b124      	cbz	r4, 34016aaa <__atonn_getDstPortID+0xfa>
34016aa0:	f44f 716e 	mov.w	r1, #952	@ 0x3b8
34016aa4:	4b10      	ldr	r3, [pc, #64]	@ (34016ae8 <__atonn_getDstPortID+0x138>)
34016aa6:	4a0e      	ldr	r2, [pc, #56]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016aa8:	e78c      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      LL_ATON_ASSERT(au_num < ATON_POOL_NUM);
34016aaa:	2b01      	cmp	r3, #1
34016aac:	d904      	bls.n	34016ab8 <__atonn_getDstPortID+0x108>
34016aae:	f240 31b9 	movw	r1, #953	@ 0x3b9
34016ab2:	4b12      	ldr	r3, [pc, #72]	@ (34016afc <__atonn_getDstPortID+0x14c>)
34016ab4:	4a0a      	ldr	r2, [pc, #40]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016ab6:	e785      	b.n	340169c4 <__atonn_getDstPortID+0x14>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, POOL, 0, 0) + (0x4 * au_num);
34016ab8:	2098      	movs	r0, #152	@ 0x98
34016aba:	e7a2      	b.n	34016a02 <__atonn_getDstPortID+0x52>
      LL_ATON_ASSERT(0);
34016abc:	f240 31be 	movw	r1, #958	@ 0x3be
34016ac0:	4b0f      	ldr	r3, [pc, #60]	@ (34016b00 <__atonn_getDstPortID+0x150>)
34016ac2:	4a07      	ldr	r2, [pc, #28]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016ac4:	e77e      	b.n	340169c4 <__atonn_getDstPortID+0x14>
    LL_ATON_ASSERT(0);
34016ac6:	f44f 7171 	mov.w	r1, #964	@ 0x3c4
34016aca:	4b0d      	ldr	r3, [pc, #52]	@ (34016b00 <__atonn_getDstPortID+0x150>)
34016acc:	4a04      	ldr	r2, [pc, #16]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016ace:	e779      	b.n	340169c4 <__atonn_getDstPortID+0x14>
    LL_ATON_ASSERT(0);
34016ad0:	f44f 7172 	mov.w	r1, #968	@ 0x3c8
34016ad4:	4b0a      	ldr	r3, [pc, #40]	@ (34016b00 <__atonn_getDstPortID+0x150>)
34016ad6:	4a02      	ldr	r2, [pc, #8]	@ (34016ae0 <__atonn_getDstPortID+0x130>)
34016ad8:	e774      	b.n	340169c4 <__atonn_getDstPortID+0x14>
34016ada:	bf00      	nop
34016adc:	340211e6 	.word	0x340211e6
34016ae0:	340ae3e0 	.word	0x340ae3e0
34016ae4:	34021080 	.word	0x34021080
34016ae8:	340211f2 	.word	0x340211f2
34016aec:	340211fc 	.word	0x340211fc
34016af0:	3402121e 	.word	0x3402121e
34016af4:	34021208 	.word	0x34021208
34016af8:	340####MQTT_PASS####7 	.word	0x340####MQTT_PASS####7
34016afc:	34021213 	.word	0x34021213
34016b00:	340217f8 	.word	0x340217f8

34016b04 <LL_Switch_Init_NoReset>:
  unsigned int fnr_mask[ATON_SWITCH_CONTEXT_NUM] = {ATON_STRSWITCH_DST_FNR0_MASK, ATON_STRSWITCH_DST_FNR1_MASK};

  /* Enable Switch */
  t = ATON_STRSWITCH_CTRL_DT;
  t = ATON_STRSWITCH_CTRL_SET_EN(t, 1);
  ATON_STRSWITCH_CTRL_SET(0, t);
34016b04:	2301      	movs	r3, #1
34016b06:	4a13      	ldr	r2, [pc, #76]	@ (34016b54 <LL_Switch_Init_NoReset+0x50>)
34016b08:	2900      	cmp	r1, #0
{
34016b0a:	b530      	push	{r4, r5, lr}
  ATON_STRSWITCH_CTRL_SET(0, t);
34016b0c:	6013      	str	r3, [r2, #0]

  for (i = 0; i < n; i++)
34016b0e:	eb01 0203 	add.w	r2, r1, r3
34016b12:	bfb8      	it	lt
34016b14:	461a      	movlt	r2, r3
34016b16:	3a01      	subs	r2, #1
34016b18:	d101      	bne.n	34016b1e <LL_Switch_Init_NoReset+0x1a>

    ATON_REG_WRITE(reg, t);
  }

  return 0;
}
34016b1a:	2000      	movs	r0, #0
34016b1c:	bd30      	pop	{r4, r5, pc}
    t |= ((LL_Switch_InitStruct[i].context0 != 0) << en_shift[0]);
34016b1e:	7b84      	ldrb	r4, [r0, #14]
    t |= (ATONN_SRCPORT_ID(LL_Switch_InitStruct[i].source1) << link_shift[1]);
34016b20:	e9d0 5300 	ldrd	r5, r3, [r0]
34016b24:	045b      	lsls	r3, r3, #17
    t |= ((LL_Switch_InitStruct[i].frames1 << fnr_shift[1]) & fnr_mask[1]);
34016b26:	ea43 0345 	orr.w	r3, r3, r5, lsl #1
    t |= ((LL_Switch_InitStruct[i].context0 != 0) << en_shift[0]);
34016b2a:	f004 0501 	and.w	r5, r4, #1
    t |= ((LL_Switch_InitStruct[i].frames1 << fnr_shift[1]) & fnr_mask[1]);
34016b2e:	432b      	orrs	r3, r5
    t |= ((LL_Switch_InitStruct[i].frames0 << fnr_shift[0]) & fnr_mask[0]);
34016b30:	7b05      	ldrb	r5, [r0, #12]
    reg = (uint32_t *)(ATON_STRSWITCH_BASE(0) + ATONN_DSTPORT_ID(LL_Switch_InitStruct[i].dest));
34016b32:	6881      	ldr	r1, [r0, #8]
    t |= ((LL_Switch_InitStruct[i].frames1 << fnr_shift[1]) & fnr_mask[1]);
34016b34:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
34016b38:	7b45      	ldrb	r5, [r0, #13]
    reg = (uint32_t *)(ATON_STRSWITCH_BASE(0) + ATONN_DSTPORT_ID(LL_Switch_InitStruct[i].dest));
34016b3a:	f101 41b0 	add.w	r1, r1, #1476395008	@ 0x58000000
    t |= ((LL_Switch_InitStruct[i].frames1 << fnr_shift[1]) & fnr_mask[1]);
34016b3e:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    t |= ((LL_Switch_InitStruct[i].context1 != 0) << en_shift[1]);
34016b42:	f3c4 0440 	ubfx	r4, r4, #1, #1
    reg = (uint32_t *)(ATON_STRSWITCH_BASE(0) + ATONN_DSTPORT_ID(LL_Switch_InitStruct[i].dest));
34016b46:	f501 2164 	add.w	r1, r1, #933888	@ 0xe4000
    t |= ((LL_Switch_InitStruct[i].frames1 << fnr_shift[1]) & fnr_mask[1]);
34016b4a:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
    ATON_REG_WRITE(reg, t);
34016b4e:	600b      	str	r3, [r1, #0]
  for (i = 0; i < n; i++)
34016b50:	3010      	adds	r0, #16
34016b52:	e7e0      	b.n	34016b16 <LL_Switch_Init_NoReset+0x12>
34016b54:	580e4000 	.word	0x580e4000

34016b58 <LL_Switch_Init>:
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_EC_TRACE)
  ll_aton_static_checks();
#endif

  /* Clear Configuration */
  ATON_DISABLE_CLR_CONFCLR(STRSWITCH, 0);
34016b58:	2202      	movs	r2, #2
34016b5a:	4b06      	ldr	r3, [pc, #24]	@ (34016b74 <LL_Switch_Init+0x1c>)
34016b5c:	601a      	str	r2, [r3, #0]
34016b5e:	681a      	ldr	r2, [r3, #0]
34016b60:	0792      	lsls	r2, r2, #30
34016b62:	d4fc      	bmi.n	34016b5e <LL_Switch_Init+0x6>
34016b64:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34016b68:	601a      	str	r2, [r3, #0]
34016b6a:	681a      	ldr	r2, [r3, #0]
34016b6c:	0052      	lsls	r2, r2, #1
34016b6e:	d4fc      	bmi.n	34016b6a <LL_Switch_Init+0x12>

  return LL_Switch_Init_NoReset(LL_Switch_InitStruct, n);
34016b70:	f7ff bfc8 	b.w	34016b04 <LL_Switch_Init_NoReset>
34016b74:	580e4000 	.word	0x580e4000

34016b78 <LL_Switch_Deinit>:
 * @param  LL_Switch_InitStruct Pointer to structure(s) describing ports to be disconnected
 * @param  n Number of entries in configuration array
 * @retval Error code
 */
int LL_Switch_Deinit(const LL_Switch_InitTypeDef *LL_Switch_InitStruct, int n)
{
34016b78:	b530      	push	{r4, r5, lr}
  int i;
  volatile uint32_t *reg;

  for (i = 0; i < n; i++)
34016b7a:	2400      	movs	r4, #0
34016b7c:	42a1      	cmp	r1, r4
34016b7e:	f101 0301 	add.w	r3, r1, #1
  {
    /* Compute target destination configuration register */
    reg = (uint32_t *)(ATON_STRSWITCH_BASE(0) + ATONN_DSTPORT_ID(LL_Switch_InitStruct[i].dest));

    /* Disable contexts */
    ATON_REG_WRITE(reg, 0);
34016b82:	4625      	mov	r5, r4
34016b84:	bfb8      	it	lt
34016b86:	2301      	movlt	r3, #1
    reg = (uint32_t *)(ATON_STRSWITCH_BASE(0) + ATONN_DSTPORT_ID(LL_Switch_InitStruct[i].dest));
34016b88:	3008      	adds	r0, #8
  for (i = 0; i < n; i++)
34016b8a:	3b01      	subs	r3, #1
34016b8c:	d101      	bne.n	34016b92 <LL_Switch_Deinit+0x1a>
  }

  return 0;
}
34016b8e:	2000      	movs	r0, #0
34016b90:	bd30      	pop	{r4, r5, pc}
    reg = (uint32_t *)(ATON_STRSWITCH_BASE(0) + ATONN_DSTPORT_ID(LL_Switch_InitStruct[i].dest));
34016b92:	0122      	lsls	r2, r4, #4
34016b94:	5882      	ldr	r2, [r0, r2]
  for (i = 0; i < n; i++)
34016b96:	3401      	adds	r4, #1
    reg = (uint32_t *)(ATON_STRSWITCH_BASE(0) + ATONN_DSTPORT_ID(LL_Switch_InitStruct[i].dest));
34016b98:	f102 42b0 	add.w	r2, r2, #1476395008	@ 0x58000000
34016b9c:	f502 2264 	add.w	r2, r2, #933888	@ 0xe4000
    ATON_REG_WRITE(reg, 0);
34016ba0:	6015      	str	r5, [r2, #0]
  for (i = 0; i < n; i++)
34016ba2:	e7f2      	b.n	34016b8a <LL_Switch_Deinit+0x12>

34016ba4 <LL_ATON_EnableClock>:
  return bloblines * 4;
}
#endif // ATON_EPOCHCTRL_NUM

void LL_ATON_EnableClock(unsigned int clock)
{
34016ba4:	b530      	push	{r4, r5, lr}
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 1);
34016ba6:	2401      	movs	r4, #1
34016ba8:	2500      	movs	r5, #0
34016baa:	2301      	movs	r3, #1
34016bac:	ea54 050d 	orrs.w	r5, r4, sp
34016bb0:	4a03      	ldr	r2, [pc, #12]	@ (34016bc0 <LL_ATON_EnableClock+0x1c>)
34016bb2:	4083      	lsls	r3, r0
34016bb4:	6911      	ldr	r1, [r2, #16]
34016bb6:	404b      	eors	r3, r1
34016bb8:	4023      	ands	r3, r4
34016bba:	404b      	eors	r3, r1
34016bbc:	6113      	str	r3, [r2, #16]
#endif
}
34016bbe:	bd30      	pop	{r4, r5, pc}
34016bc0:	580e0000 	.word	0x580e0000

34016bc4 <LL_Streng_TensorInit>:
  if (id >= ATON_STRENG_NUM)
34016bc4:	2809      	cmp	r0, #9
{
34016bc6:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
34016bca:	4604      	mov	r4, r0
34016bcc:	460d      	mov	r5, r1
34016bce:	4616      	mov	r6, r2
  if (id >= ATON_STRENG_NUM)
34016bd0:	dd04      	ble.n	34016bdc <LL_Streng_TensorInit+0x18>
    return LL_ATON_INVALID_ID;
34016bd2:	f04f 30ff 	mov.w	r0, #4294967295
}
34016bd6:	b003      	add	sp, #12
34016bd8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  LL_ATON_EnableClock(ATON_STRENG_CLKB_CLK(id));
34016bdc:	f7ff ffe2 	bl	34016ba4 <LL_ATON_EnableClock>
  if (n != 1)
34016be0:	2e01      	cmp	r6, #1
34016be2:	d1f6      	bne.n	34016bd2 <LL_Streng_TensorInit+0xe>
  if (conf->nbits_in > 24 || conf->nbits_out > 24)
34016be4:	f895 6044 	ldrb.w	r6, [r5, #68]	@ 0x44
34016be8:	2e18      	cmp	r6, #24
34016bea:	d8f2      	bhi.n	34016bd2 <LL_Streng_TensorInit+0xe>
34016bec:	f895 c045 	ldrb.w	ip, [r5, #69]	@ 0x45
34016bf0:	f1bc 0f18 	cmp.w	ip, #24
34016bf4:	d8ed      	bhi.n	34016bd2 <LL_Streng_TensorInit+0xe>
  t = ATON_STRENG_CTRL_SET_DIR(t, (conf->dir != 0));
34016bf6:	7828      	ldrb	r0, [r5, #0]
  t = ATON_STRENG_CTRL_SET_SINGLE(t, conf->frame_tot_cnt == 1);
34016bf8:	f8d5 a040 	ldr.w	sl, [r5, #64]	@ 0x40
  t = ATON_STRENG_CTRL_SET_RAW(t, (conf->raw != 0));
34016bfc:	01c2      	lsls	r2, r0, #7
  t = ATON_STRENG_CTRL_SET_DIR(t, (conf->dir != 0));
34016bfe:	00c3      	lsls	r3, r0, #3
  t = ATON_STRENG_CTRL_SET_RAW(t, (conf->raw != 0));
34016c00:	f402 7180 	and.w	r1, r2, #256	@ 0x100
  t = ATON_STRENG_CTRL_SET_DIR(t, (conf->dir != 0));
34016c04:	f003 0308 	and.w	r3, r3, #8
  t = ATON_STRENG_CTRL_SET_RAW(t, (conf->raw != 0));
34016c08:	430b      	orrs	r3, r1
  t = ATON_STRENG_CTRL_SET_RAW_OUT(t, conf->raw_out);
34016c0a:	f3c0 0180 	ubfx	r1, r0, #2, #1
34016c0e:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
  t = ATON_STRENG_CTRL_SET_NOBLK(t, (conf->noblk != 0));
34016c12:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
34016c16:	431a      	orrs	r2, r3
  t = ATON_STRENG_CTRL_SET_NOINC(t, (conf->noinc == 1));
34016c18:	0843      	lsrs	r3, r0, #1
  t = ATON_STRENG_CTRL_SET_SINGLE(t, conf->frame_tot_cnt == 1);
34016c1a:	f10a 31ff 	add.w	r1, sl, #4294967295
  t = ATON_STRENG_CTRL_SET_NOINC(t, (conf->noinc == 1));
34016c1e:	f003 0310 	and.w	r3, r3, #16
34016c22:	4313      	orrs	r3, r2
  t = ATON_STRENG_CTRL_SET_SINGLE(t, conf->frame_tot_cnt == 1);
34016c24:	424a      	negs	r2, r1
34016c26:	414a      	adcs	r2, r1
34016c28:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
  t = ATON_STRENG_CTRL_SET_CONT(t, conf->continuous == 1);
34016c2c:	0102      	lsls	r2, r0, #4
34016c2e:	f002 0280 	and.w	r2, r2, #128	@ 0x80
  t = ATON_STRENG_CTRL_SET_SIGNEXT(t, conf->align_right == 1 && conf->nbits_unsigned == 0);
34016c32:	f8b5 8000 	ldrh.w	r8, [r5]
  t = ATON_STRENG_CTRL_SET_LSBMODE(t, conf->align_right == 1);
34016c36:	0207      	lsls	r7, r0, #8
  t = ATON_STRENG_CTRL_SET_CONT(t, conf->continuous == 1);
34016c38:	4313      	orrs	r3, r2
  t = ATON_STRENG_CTRL_SET_LSBMODE(t, conf->align_right == 1);
34016c3a:	f407 4780 	and.w	r7, r7, #16384	@ 0x4000
34016c3e:	431f      	orrs	r7, r3
  t = ATON_STRENG_CTRL_SET_SIGNEXT(t, conf->align_right == 1 && conf->nbits_unsigned == 0);
34016c40:	f408 7310 	and.w	r3, r8, #576	@ 0x240
34016c44:	f1a3 0e40 	sub.w	lr, r3, #64	@ 0x40
34016c48:	f1de 0300 	rsbs	r3, lr, #0
34016c4c:	eb43 030e 	adc.w	r3, r3, lr
  io_case += (conf->dir == 0 ? (conf->nbits_in <= conf->nbits_out) : (conf->nbits_in < conf->nbits_out));
34016c50:	f010 0201 	ands.w	r2, r0, #1
  t = ATON_STRENG_CTRL_SET_SIGNEXT(t, conf->align_right == 1 && conf->nbits_unsigned == 0);
34016c54:	ea47 37c3 	orr.w	r7, r7, r3, lsl #15
  int nbits_in = conf->nbits_in;
34016c58:	4631      	mov	r1, r6
  int nbits_out = conf->nbits_out;
34016c5a:	4663      	mov	r3, ip
  io_case += (conf->dir == 0 ? (conf->nbits_in <= conf->nbits_out) : (conf->nbits_in < conf->nbits_out));
34016c5c:	9201      	str	r2, [sp, #4]
34016c5e:	f000 0940 	and.w	r9, r0, #64	@ 0x40
34016c62:	f040 80a9 	bne.w	34016db8 <LL_Streng_TensorInit+0x1f4>
34016c66:	4566      	cmp	r6, ip
34016c68:	bf8c      	ite	hi
34016c6a:	2200      	movhi	r2, #0
34016c6c:	2201      	movls	r2, #1
  switch (io_case)
34016c6e:	2a03      	cmp	r2, #3
34016c70:	f000 80b2 	beq.w	34016dd8 <LL_Streng_TensorInit+0x214>
34016c74:	2a01      	cmp	r2, #1
34016c76:	f000 80aa 	beq.w	34016dce <LL_Streng_TensorInit+0x20a>
    nbits_in = nbits_out;
34016c7a:	4661      	mov	r1, ip
      t_streng_strd = ATON_STRENG_STRD_SET_FGAP(t_streng_strd, (nbits_in - nbits_out));
34016c7c:	eba6 020c 	sub.w	r2, r6, ip
    if (conf->mem_lsb)
34016c80:	0603      	lsls	r3, r0, #24
      t_streng_strd = ATON_STRENG_STRD_SET_FGAP(t_streng_strd, (nbits_in - nbits_out));
34016c82:	bf4b      	itete	mi
34016c84:	0412      	lslmi	r2, r2, #16
      t_streng_strd = ATON_STRENG_STRD_SET_BGAP(t_streng_strd, (nbits_in - nbits_out));
34016c86:	0612      	lslpl	r2, r2, #24
      t_streng_strd = ATON_STRENG_STRD_SET_FGAP(t_streng_strd, (nbits_in - nbits_out));
34016c88:	f402 127c 	andmi.w	r2, r2, #4128768	@ 0x3f0000
      t_streng_strd = ATON_STRENG_STRD_SET_BGAP(t_streng_strd, (nbits_in - nbits_out));
34016c8c:	f002 527c 	andpl.w	r2, r2, #1056964608	@ 0x3f000000
    in_bits[0] = _LL_min(8, nbits_in);
34016c90:	2908      	cmp	r1, #8
34016c92:	468e      	mov	lr, r1
34016c94:	bfa8      	it	ge
34016c96:	f04f 0e08 	movge.w	lr, #8
    in_bits[1] = nbits_in > 8 ? _LL_min(8, nbits_in - 8) : 0;
34016c9a:	2908      	cmp	r1, #8
34016c9c:	f340 8099 	ble.w	34016dd2 <LL_Streng_TensorInit+0x20e>
    in_bits[2] = nbits_in > 16 ? _LL_min(8, nbits_in - 16) : 0;
34016ca0:	2910      	cmp	r1, #16
34016ca2:	bfcb      	itete	gt
34016ca4:	f1a1 0310 	subgt.w	r3, r1, #16
34016ca8:	2300      	movle	r3, #0
    in_bits[1] = nbits_in > 8 ? _LL_min(8, nbits_in - 8) : 0;
34016caa:	2108      	movgt	r1, #8
34016cac:	3908      	suble	r1, #8
    if (conf->align_right)
34016cae:	f009 0bff 	and.w	fp, r9, #255	@ 0xff
34016cb2:	f1b9 0f00 	cmp.w	r9, #0
34016cb6:	d10b      	bne.n	34016cd0 <LL_Streng_TensorInit+0x10c>
      if (nbits_out > 16)
34016cb8:	f1bc 0f10 	cmp.w	ip, #16
34016cbc:	f300 80b2 	bgt.w	34016e24 <LL_Streng_TensorInit+0x260>
      else if (nbits_out > 8)
34016cc0:	f1bc 0f08 	cmp.w	ip, #8
      else if (nbits_in > 8)
34016cc4:	f340 80b2 	ble.w	34016e2c <LL_Streng_TensorInit+0x268>
34016cc8:	4673      	mov	r3, lr
        ch_bits[0] = out_bits[1];
34016cca:	468e      	mov	lr, r1
        ch_bits[1] = out_bits[0];
34016ccc:	4619      	mov	r1, r3
  int ch_bits[3] = {0, 0, 0};
34016cce:	465b      	mov	r3, fp
  t = ATON_STRENG_CTRL_SET_SIZE0(t, ch_bits[0]);
34016cd0:	ea47 470e 	orr.w	r7, r7, lr, lsl #16
  ATON_STRENG_CTRL_SET(id, t);
34016cd4:	f504 24b0 	add.w	r4, r4, #360448	@ 0x58000
  t = ATON_STRENG_CTRL_SET_SIZE1(t, ch_bits[1]);
34016cd8:	ea47 5701 	orr.w	r7, r7, r1, lsl #20
  ATON_STRENG_CTRL_SET(id, t);
34016cdc:	34e5      	adds	r4, #229	@ 0xe5
  t = ATON_STRENG_CTRL_SET_SIZE2(t, ch_bits[2]);
34016cde:	ea47 6703 	orr.w	r7, r7, r3, lsl #24
  ATON_STRENG_CTRL_SET(id, t);
34016ce2:	0324      	lsls	r4, r4, #12
34016ce4:	6027      	str	r7, [r4, #0]
  ATON_REG_WRITE_RELOC(((volatile uint32_t *)(uintptr_t)ATON_STRENG_ADDR_ADDR(id)), conf->addr_base.i,
34016ce6:	e9d5 7e01 	ldrd	r7, lr, [r5, #4]
34016cea:	eb07 030e 	add.w	r3, r7, lr
34016cee:	60a3      	str	r3, [r4, #8]
  if (conf->raw)
34016cf0:	0783      	lsls	r3, r0, #30
    uint32_t line_offset = conf->line_offset == 0 ? conf->fwidth * conf->batch_offset : conf->line_offset;
34016cf2:	6a69      	ldr	r1, [r5, #36]	@ 0x24
  if (conf->raw)
34016cf4:	f140 809d 	bpl.w	34016e32 <LL_Streng_TensorInit+0x26e>
    if (conf->frame_count)
34016cf8:	696b      	ldr	r3, [r5, #20]
34016cfa:	b94b      	cbnz	r3, 34016d10 <LL_Streng_TensorInit+0x14c>
      t = (LL_Streng_len(conf) * 8) / (conf->dir == 0 ? conf->nbits_in : conf->nbits_out);
34016cfc:	f010 0f01 	tst.w	r0, #1
34016d00:	bf18      	it	ne
34016d02:	4666      	movne	r6, ip
    return conf->addr_base.p + conf->offset_limit;
  }

  static inline uint32_t LL_Streng_len(const LL_Streng_TensorInitTypeDef *conf)
  {
    return conf->offset_end - conf->offset_start;
34016d04:	68eb      	ldr	r3, [r5, #12]
34016d06:	eba3 030e 	sub.w	r3, r3, lr
34016d0a:	00db      	lsls	r3, r3, #3
34016d0c:	fbb3 f3f6 	udiv	r3, r3, r6
  uint32_t t_streng_cid_cache = ATON_STRENG_CID_CACHE_DT;
34016d10:	2000      	movs	r0, #0
    ATON_STRENG_FSIZE_SET(id, t);
34016d12:	60e3      	str	r3, [r4, #12]
  ATON_STRENG_FOFFSET_SET(id, conf->frame_offset);
34016d14:	6aab      	ldr	r3, [r5, #40]	@ 0x28
  t = ATON_STRENG_LIMITEN_SET_DOFF_MSB(t, conf->batch_offset >> ATON_STRENG_DEPTH_OFFSET_W);
34016d16:	f36f 010f 	bfc	r1, #0, #16
  ATON_STRENG_FOFFSET_SET(id, conf->frame_offset);
34016d1a:	61a3      	str	r3, [r4, #24]
  ATON_STRENG_FRPTOFF_SET(id, conf->loop_offset);
34016d1c:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
34016d1e:	6223      	str	r3, [r4, #32]
  ATON_STRENG_FRAME_RPT_SET(id, conf->frame_loop_cnt);
34016d20:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
34016d22:	61e3      	str	r3, [r4, #28]
  t = ATON_STRENG_LIMITEN_SET_DOFF_MSB(t, conf->batch_offset >> ATON_STRENG_DEPTH_OFFSET_W);
34016d24:	f041 0306 	orr.w	r3, r1, #6
  ATON_STRENG_LIMITEN_SET(id, t);
34016d28:	6323      	str	r3, [r4, #48]	@ 0x30
  if (/*(conf->dir == 0) && */ (conf->offset_limit != 0x0))
34016d2a:	692b      	ldr	r3, [r5, #16]
34016d2c:	b12b      	cbz	r3, 34016d3a <LL_Streng_TensorInit+0x176>
    ATON_REG_WRITE_RELOC(((volatile uint32_t *)(uintptr_t)ATON_STRENG_LIMITADDR_ADDR(id)), conf->addr_base.i,
34016d2e:	441f      	add	r7, r3
    t = ATON_STRENG_LIMITEN_SET_STOPPREFTC(t, 1);
34016d30:	f041 0107 	orr.w	r1, r1, #7
    ATON_REG_WRITE_RELOC(((volatile uint32_t *)(uintptr_t)ATON_STRENG_LIMITADDR_ADDR(id)), conf->addr_base.i,
34016d34:	3f01      	subs	r7, #1
    ATON_STRENG_LIMITEN_SET(id, t);
34016d36:	6321      	str	r1, [r4, #48]	@ 0x30
    ATON_REG_WRITE_RELOC(((volatile uint32_t *)(uintptr_t)ATON_STRENG_LIMITADDR_ADDR(id)), conf->addr_base.i,
34016d38:	63a7      	str	r7, [r4, #56]	@ 0x38
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_CACHEABLE(t_streng_cid_cache, conf->cacheable);
34016d3a:	7869      	ldrb	r1, [r5, #1]
  if ((conf->dir == 0) && conf->sync_with_other)
34016d3c:	f028 08fe 	bic.w	r8, r8, #254	@ 0xfe
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_ALLOC(t_streng_cid_cache, conf->cache_allocate);
34016d40:	f3c1 1380 	ubfx	r3, r1, #6, #1
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_CACHEABLE(t_streng_cid_cache, conf->cacheable);
34016d44:	f3c1 1640 	ubfx	r6, r1, #5, #1
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_ALLOC(t_streng_cid_cache, conf->cache_allocate);
34016d48:	011b      	lsls	r3, r3, #4
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_LINESIZE(t_streng_cid_cache, conf->cache_linesize);
34016d4a:	ea43 03c6 	orr.w	r3, r3, r6, lsl #3
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_CID(t_streng_cid_cache, conf->bus_cid);
34016d4e:	f3c1 0682 	ubfx	r6, r1, #2, #3
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_LINESIZE(t_streng_cid_cache, conf->cache_linesize);
34016d52:	4333      	orrs	r3, r6
34016d54:	78ae      	ldrb	r6, [r5, #2]
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_PFETCH(t_streng_cid_cache, conf->bus_pfetch);
34016d56:	09c9      	lsrs	r1, r1, #7
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_LINESIZE(t_streng_cid_cache, conf->cache_linesize);
34016d58:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
  if ((conf->dir == 0) && conf->sync_with_other)
34016d5c:	ea4f 58c8 	mov.w	r8, r8, lsl #23
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_LINESIZE(t_streng_cid_cache, conf->cache_linesize);
34016d60:	f006 0103 	and.w	r1, r6, #3
34016d64:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
  if ((conf->dir == 0) && conf->sync_with_other)
34016d68:	ea4f 58d8 	mov.w	r8, r8, lsr #23
  if (conf->dir == 1)
34016d6c:	9901      	ldr	r1, [sp, #4]
  ATON_STRENG_LIMIT_SET(id, conf->frame_tot_cnt);
34016d6e:	f8c4 a034 	str.w	sl, [r4, #52]	@ 0x34
  if ((conf->dir == 0) && conf->sync_with_other)
34016d72:	f5b8 7f80 	cmp.w	r8, #256	@ 0x100
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_LINESIZE(t_streng_cid_cache, conf->cache_linesize);
34016d76:	ea43 0300 	orr.w	r3, r3, r0
  if (conf->dir == 1)
34016d7a:	ea4f 40c1 	mov.w	r0, r1, lsl #19
    t = ATON_STRENG_EVENT_SET_FRMTRG_SRC(t, conf->sync_dma); // Enable synchronizations of frames with other dma
34016d7e:	bf09      	itett	eq
34016d80:	78e9      	ldrbeq	r1, [r5, #3]
  t = ATON_STRENG_EVENT_SET_EN_ILLCFG(t, 1); // Enable Illegal Configuration interrupt
34016d82:	f440 1180 	orrne.w	r1, r0, #1048576	@ 0x100000
    t = ATON_STRENG_EVENT_SET_FRMTRG_SRC(t, conf->sync_dma); // Enable synchronizations of frames with other dma
34016d86:	0609      	lsleq	r1, r1, #24
34016d88:	f001 51f8 	andeq.w	r1, r1, #520093696	@ 0x1f000000
34016d8c:	bf08      	it	eq
34016d8e:	4301      	orreq	r1, r0
  ATON_STRENG_POS_SET(id, t);
34016d90:	f04f 0024 	mov.w	r0, #36	@ 0x24
34016d94:	6260      	str	r0, [r4, #36]	@ 0x24
  ATON_STRENG_STRD_SET(id, t_streng_strd);
34016d96:	6162      	str	r2, [r4, #20]
  ATON_STRENG_CID_CACHE_SET(id, t_streng_cid_cache);
34016d98:	64a3      	str	r3, [r4, #72]	@ 0x48
  t = ATON_STRENG_ENCR_MSB_SET_EN(t, conf->cipher_en);
34016d9a:	f3c6 0380 	ubfx	r3, r6, #2, #1
  t = ATON_STRENG_ENCR_MSB_SET_KEY_SEL(t, conf->key_sel);
34016d9e:	f3c6 06c0 	ubfx	r6, r6, #3, #1
34016da2:	ea4f 3686 	mov.w	r6, r6, lsl #14
    t = ATON_STRENG_EVENT_SET_FRMTRG_SRC(t, conf->sync_dma); // Enable synchronizations of frames with other dma
34016da6:	bf08      	it	eq
34016da8:	f441 0110 	orreq.w	r1, r1, #9437184	@ 0x900000
  t = ATON_STRENG_ENCR_MSB_SET_KEY_SEL(t, conf->key_sel);
34016dac:	ea46 3603 	orr.w	r6, r6, r3, lsl #12
  ATON_STRENG_EVENT_SET(id, t_streng_event);
34016db0:	62a1      	str	r1, [r4, #40]	@ 0x28
  return 0;
34016db2:	2000      	movs	r0, #0
  ATON_STRENG_ENCR_MSB_SET(id, t);
34016db4:	6466      	str	r6, [r4, #68]	@ 0x44
  return 0;
34016db6:	e70e      	b.n	34016bd6 <LL_Streng_TensorInit+0x12>
  int io_case = ((conf->dir != 0) << 1);
34016db8:	0042      	lsls	r2, r0, #1
34016dba:	f002 0202 	and.w	r2, r2, #2
  io_case += (conf->dir == 0 ? (conf->nbits_in <= conf->nbits_out) : (conf->nbits_in < conf->nbits_out));
34016dbe:	4566      	cmp	r6, ip
34016dc0:	ea52 9222 			@ <UNDEFINED> instruction: 0xea529222
  switch (io_case)
34016dc4:	2a02      	cmp	r2, #2
34016dc6:	f47f af52 	bne.w	34016c6e <LL_Streng_TensorInit+0xaa>
34016dca:	2200      	movs	r2, #0
34016dcc:	e00f      	b.n	34016dee <LL_Streng_TensorInit+0x22a>
34016dce:	2200      	movs	r2, #0
34016dd0:	e75e      	b.n	34016c90 <LL_Streng_TensorInit+0xcc>
    in_bits[1] = nbits_in > 8 ? _LL_min(8, nbits_in - 8) : 0;
34016dd2:	2100      	movs	r1, #0
    in_bits[2] = nbits_in > 16 ? _LL_min(8, nbits_in - 16) : 0;
34016dd4:	460b      	mov	r3, r1
34016dd6:	e76a      	b.n	34016cae <LL_Streng_TensorInit+0xea>
    nbits_out = nbits_in;
34016dd8:	4633      	mov	r3, r6
      t_streng_strd = ATON_STRENG_STRD_SET_FGAP(t_streng_strd, (nbits_out - nbits_in));
34016dda:	ebac 0206 	sub.w	r2, ip, r6
    if (conf->mem_lsb)
34016dde:	0601      	lsls	r1, r0, #24
      t_streng_strd = ATON_STRENG_STRD_SET_FGAP(t_streng_strd, (nbits_out - nbits_in));
34016de0:	bf4b      	itete	mi
34016de2:	0412      	lslmi	r2, r2, #16
      t_streng_strd = ATON_STRENG_STRD_SET_BGAP(t_streng_strd, (nbits_out - nbits_in));
34016de4:	0612      	lslpl	r2, r2, #24
      t_streng_strd = ATON_STRENG_STRD_SET_FGAP(t_streng_strd, (nbits_out - nbits_in));
34016de6:	f402 127c 	andmi.w	r2, r2, #4128768	@ 0x3f0000
      t_streng_strd = ATON_STRENG_STRD_SET_BGAP(t_streng_strd, (nbits_out - nbits_in));
34016dea:	f002 527c 	andpl.w	r2, r2, #1056964608	@ 0x3f000000
    out_bits[0] = _LL_min(8, nbits_out);
34016dee:	2b08      	cmp	r3, #8
34016df0:	469e      	mov	lr, r3
34016df2:	bfa8      	it	ge
34016df4:	f04f 0e08 	movge.w	lr, #8
    out_bits[1] = nbits_out > 8 ? _LL_min(8, nbits_out - 8) : 0;
34016df8:	2b08      	cmp	r3, #8
34016dfa:	dd10      	ble.n	34016e1e <LL_Streng_TensorInit+0x25a>
    out_bits[2] = nbits_out > 16 ? _LL_min(8, nbits_out - 16) : 0;
34016dfc:	2b10      	cmp	r3, #16
    out_bits[1] = nbits_out > 8 ? _LL_min(8, nbits_out - 8) : 0;
34016dfe:	bfd5      	itete	le
34016e00:	f1a3 0108 	suble.w	r1, r3, #8
34016e04:	2108      	movgt	r1, #8
    out_bits[2] = nbits_out > 16 ? _LL_min(8, nbits_out - 16) : 0;
34016e06:	2300      	movle	r3, #0
34016e08:	3b10      	subgt	r3, #16
    if (conf->align_right)
34016e0a:	f009 0bff 	and.w	fp, r9, #255	@ 0xff
34016e0e:	f1b9 0f00 	cmp.w	r9, #0
34016e12:	f47f af5d 	bne.w	34016cd0 <LL_Streng_TensorInit+0x10c>
      if (nbits_in > 16)
34016e16:	2e10      	cmp	r6, #16
34016e18:	dc04      	bgt.n	34016e24 <LL_Streng_TensorInit+0x260>
      else if (nbits_in > 8)
34016e1a:	2e08      	cmp	r6, #8
34016e1c:	e752      	b.n	34016cc4 <LL_Streng_TensorInit+0x100>
    out_bits[1] = nbits_out > 8 ? _LL_min(8, nbits_out - 8) : 0;
34016e1e:	2100      	movs	r1, #0
    out_bits[2] = nbits_out > 16 ? _LL_min(8, nbits_out - 16) : 0;
34016e20:	460b      	mov	r3, r1
34016e22:	e7f2      	b.n	34016e0a <LL_Streng_TensorInit+0x246>
34016e24:	46f1      	mov	r9, lr
        ch_bits[0] = out_bits[2];
34016e26:	469e      	mov	lr, r3
        ch_bits[2] = out_bits[0];
34016e28:	464b      	mov	r3, r9
34016e2a:	e751      	b.n	34016cd0 <LL_Streng_TensorInit+0x10c>
  int ch_bits[3] = {0, 0, 0};
34016e2c:	465b      	mov	r3, fp
34016e2e:	4659      	mov	r1, fp
34016e30:	e74e      	b.n	34016cd0 <LL_Streng_TensorInit+0x10c>
    t = ATON_STRENG_FSIZE_SET_HEIGHT(t, conf->fheight);
34016e32:	e9d5 6306 	ldrd	r6, r3, [r5, #24]
    t = ATON_STRENG_FSIZE_SET_WIDTH(t, conf->fwidth);
34016e36:	b2b0      	uxth	r0, r6
    uint32_t line_offset = conf->line_offset == 0 ? conf->fwidth * conf->batch_offset : conf->line_offset;
34016e38:	434e      	muls	r6, r1
    t = ATON_STRENG_FSIZE_SET_HEIGHT(t, conf->fheight);
34016e3a:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
    uint32_t line_offset = conf->line_offset == 0 ? conf->fwidth * conf->batch_offset : conf->line_offset;
34016e3e:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
    ATON_STRENG_FSIZE_SET(id, t);
34016e40:	60e3      	str	r3, [r4, #12]
    uint32_t line_offset = conf->line_offset == 0 ? conf->fwidth * conf->batch_offset : conf->line_offset;
34016e42:	2800      	cmp	r0, #0
34016e44:	bf08      	it	eq
34016e46:	4630      	moveq	r0, r6
    t_streng_strd = ATON_STRENG_STRD_SET_LOFF(t_streng_strd, line_offset);
34016e48:	b283      	uxth	r3, r0
34016e4a:	431a      	orrs	r2, r3
    t = ATON_STRENG_DEPTH_SET_SIZE(t, conf->batch_depth);
34016e4c:	8c2b      	ldrh	r3, [r5, #32]
    t = ATON_STRENG_CID_CACHE_SET_LOFF_MSB(t, (line_offset >> ATON_STRENG_STRD_LOFF_W));
34016e4e:	f36f 000f 	bfc	r0, #0, #16
    t = ATON_STRENG_DEPTH_SET_OFFSET(t, conf->batch_offset);
34016e52:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    ATON_STRENG_DEPTH_SET(id, t);
34016e56:	6123      	str	r3, [r4, #16]
34016e58:	e75c      	b.n	34016d14 <LL_Streng_TensorInit+0x150>
	...

34016e5c <LL_EpochCtrl_Init>:
  if (id >= ATON_EPOCHCTRL_NUM)
34016e5c:	2800      	cmp	r0, #0
{
34016e5e:	b510      	push	{r4, lr}
34016e60:	460c      	mov	r4, r1
  if (id >= ATON_EPOCHCTRL_NUM)
34016e62:	dc0e      	bgt.n	34016e82 <LL_EpochCtrl_Init+0x26>
  LL_ATON_EnableClock(ATON_EPOCHCTRL_CLKB_CLK(id));
34016e64:	3019      	adds	r0, #25
34016e66:	f7ff fe9d 	bl	34016ba4 <LL_ATON_EnableClock>
  t = ATON_EPOCHCTRL_CTRL_SET_SM(t, conf->stepmode);
34016e6a:	7923      	ldrb	r3, [r4, #4]
  ATON_EPOCHCTRL_CTRL_SET(id, t);
34016e6c:	4a08      	ldr	r2, [pc, #32]	@ (34016e90 <LL_EpochCtrl_Init+0x34>)
  t = ATON_EPOCHCTRL_CTRL_SET_SM(t, conf->stepmode);
34016e6e:	f003 0301 	and.w	r3, r3, #1
34016e72:	00db      	lsls	r3, r3, #3
  ATON_EPOCHCTRL_CTRL_SET(id, t);
34016e74:	6013      	str	r3, [r2, #0]
  if (conf->blobaddr & 0x7)
34016e76:	6823      	ldr	r3, [r4, #0]
34016e78:	f013 0007 	ands.w	r0, r3, #7
34016e7c:	d104      	bne.n	34016e88 <LL_EpochCtrl_Init+0x2c>
  ATON_EPOCHCTRL_ADDR_SET(id, conf->blobaddr);
34016e7e:	6093      	str	r3, [r2, #8]
}
34016e80:	bd10      	pop	{r4, pc}
    return LL_ATON_INVALID_ID;
34016e82:	f04f 30ff 	mov.w	r0, #4294967295
34016e86:	e7fb      	b.n	34016e80 <LL_EpochCtrl_Init+0x24>
    return LL_ATON_INVALID_PARAM;
34016e88:	f06f 0001 	mvn.w	r0, #1
34016e8c:	e7f8      	b.n	34016e80 <LL_EpochCtrl_Init+0x24>
34016e8e:	bf00      	nop
34016e90:	580fe000 	.word	0x580fe000

34016e94 <LL_ATON_DisableClock>:

void LL_ATON_DisableClock(unsigned int clock)
{
34016e94:	b530      	push	{r4, r5, lr}
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 0);
34016e96:	2401      	movs	r4, #1
34016e98:	2500      	movs	r5, #0
34016e9a:	ea54 050d 	orrs.w	r5, r4, sp
34016e9e:	4a03      	ldr	r2, [pc, #12]	@ (34016eac <LL_ATON_DisableClock+0x18>)
34016ea0:	6913      	ldr	r3, [r2, #16]
34016ea2:	ea23 0304 	bic.w	r3, r3, r4
34016ea6:	6113      	str	r3, [r2, #16]
#endif
}
34016ea8:	bd30      	pop	{r4, r5, pc}
34016eaa:	bf00      	nop
34016eac:	580e0000 	.word	0x580e0000

34016eb0 <LL_ATON_DisableUnits_Init>:
{
34016eb0:	b570      	push	{r4, r5, r6, lr}
34016eb2:	4605      	mov	r5, r0
  for (i = 0; i < n; i++)
34016eb4:	2400      	movs	r4, #0
    unitId = LL_ATON_DisableUnits_InitStruct[i].unit.unit_num;
34016eb6:	1c86      	adds	r6, r0, #2
  for (i = 0; i < n; i++)
34016eb8:	428c      	cmp	r4, r1
34016eba:	db01      	blt.n	34016ec0 <LL_ATON_DisableUnits_Init+0x10>
  return LL_ATON_OK;
34016ebc:	2000      	movs	r0, #0
}
34016ebe:	bd70      	pop	{r4, r5, r6, pc}
    switch (unitType)
34016ec0:	f815 3024 	ldrb.w	r3, [r5, r4, lsl #2]
    unitId = LL_ATON_DisableUnits_InitStruct[i].unit.unit_num;
34016ec4:	f836 0024 	ldrh.w	r0, [r6, r4, lsl #2]
    switch (unitType)
34016ec8:	2b08      	cmp	r3, #8
34016eca:	d87a      	bhi.n	34016fc2 <LL_ATON_DisableUnits_Init+0x112>
34016ecc:	e8df f003 	tbb	[pc, r3]
34016ed0:	29187905 	.word	0x29187905
34016ed4:	795b4a3a 	.word	0x795b4a3a
34016ed8:	6b          	.byte	0x6b
34016ed9:	00          	.byte	0x00
      ATON_DISABLE_CLR_CONFCLR(STRENG, unitId);
34016eda:	2202      	movs	r2, #2
34016edc:	f500 23b0 	add.w	r3, r0, #360448	@ 0x58000
34016ee0:	33e5      	adds	r3, #229	@ 0xe5
34016ee2:	031b      	lsls	r3, r3, #12
34016ee4:	601a      	str	r2, [r3, #0]
34016ee6:	681a      	ldr	r2, [r3, #0]
34016ee8:	0792      	lsls	r2, r2, #30
34016eea:	d4fc      	bmi.n	34016ee6 <LL_ATON_DisableUnits_Init+0x36>
34016eec:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34016ef0:	601a      	str	r2, [r3, #0]
34016ef2:	681a      	ldr	r2, [r3, #0]
34016ef4:	0052      	lsls	r2, r2, #1
34016ef6:	d4fc      	bmi.n	34016ef2 <LL_ATON_DisableUnits_Init+0x42>
      LL_ATON_DisableClock(ATON_RECBUF_CLKB_CLK(unitId));
34016ef8:	f7ff ffcc 	bl	34016e94 <LL_ATON_DisableClock>
  for (i = 0; i < n; i++)
34016efc:	3401      	adds	r4, #1
34016efe:	e7db      	b.n	34016eb8 <LL_ATON_DisableUnits_Init+0x8>
      ATON_DISABLE_CLR_CONFCLR(CONVACC, unitId);
34016f00:	2202      	movs	r2, #2
34016f02:	f500 23b0 	add.w	r3, r0, #360448	@ 0x58000
34016f06:	33ef      	adds	r3, #239	@ 0xef
34016f08:	031b      	lsls	r3, r3, #12
34016f0a:	601a      	str	r2, [r3, #0]
34016f0c:	681a      	ldr	r2, [r3, #0]
34016f0e:	0792      	lsls	r2, r2, #30
34016f10:	d4fc      	bmi.n	34016f0c <LL_ATON_DisableUnits_Init+0x5c>
34016f12:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34016f16:	601a      	str	r2, [r3, #0]
34016f18:	681a      	ldr	r2, [r3, #0]
34016f1a:	0052      	lsls	r2, r2, #1
34016f1c:	d4fc      	bmi.n	34016f18 <LL_ATON_DisableUnits_Init+0x68>
      LL_ATON_DisableClock(ATON_CONVACC_CLKB_CLK(unitId));
34016f1e:	300a      	adds	r0, #10
34016f20:	e7ea      	b.n	34016ef8 <LL_ATON_DisableUnits_Init+0x48>
      ATON_DISABLE_CLR_CONFCLR(DECUN, unitId);
34016f22:	2202      	movs	r2, #2
34016f24:	f500 23b0 	add.w	r3, r0, #360448	@ 0x58000
34016f28:	33f3      	adds	r3, #243	@ 0xf3
34016f2a:	031b      	lsls	r3, r3, #12
34016f2c:	601a      	str	r2, [r3, #0]
34016f2e:	681a      	ldr	r2, [r3, #0]
34016f30:	0792      	lsls	r2, r2, #30
34016f32:	d4fc      	bmi.n	34016f2e <LL_ATON_DisableUnits_Init+0x7e>
34016f34:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34016f38:	601a      	str	r2, [r3, #0]
34016f3a:	681a      	ldr	r2, [r3, #0]
34016f3c:	0052      	lsls	r2, r2, #1
34016f3e:	d4fc      	bmi.n	34016f3a <LL_ATON_DisableUnits_Init+0x8a>
      LL_ATON_DisableClock(ATON_DECUN_CLKB_CLK(unitId));
34016f40:	300e      	adds	r0, #14
34016f42:	e7d9      	b.n	34016ef8 <LL_ATON_DisableUnits_Init+0x48>
      ATON_DISABLE_CLR_CONFCLR(ACTIV, unitId);
34016f44:	f500 23b0 	add.w	r3, r0, #360448	@ 0x58000
34016f48:	4a1f      	ldr	r2, [pc, #124]	@ (34016fc8 <LL_ATON_DisableUnits_Init+0x118>)
34016f4a:	33f5      	adds	r3, #245	@ 0xf5
34016f4c:	031b      	lsls	r3, r3, #12
34016f4e:	601a      	str	r2, [r3, #0]
34016f50:	681a      	ldr	r2, [r3, #0]
34016f52:	0792      	lsls	r2, r2, #30
34016f54:	d4fc      	bmi.n	34016f50 <LL_ATON_DisableUnits_Init+0xa0>
34016f56:	4a1d      	ldr	r2, [pc, #116]	@ (34016fcc <LL_ATON_DisableUnits_Init+0x11c>)
34016f58:	601a      	str	r2, [r3, #0]
34016f5a:	681a      	ldr	r2, [r3, #0]
34016f5c:	0052      	lsls	r2, r2, #1
34016f5e:	d4fc      	bmi.n	34016f5a <LL_ATON_DisableUnits_Init+0xaa>
      LL_ATON_DisableClock(ATON_ACTIV_CLKB_CLK(unitId));
34016f60:	3010      	adds	r0, #16
34016f62:	e7c9      	b.n	34016ef8 <LL_ATON_DisableUnits_Init+0x48>
      ATON_DISABLE_CLR_CONFCLR(ARITH, unitId);
34016f64:	f500 23b0 	add.w	r3, r0, #360448	@ 0x58000
34016f68:	4a19      	ldr	r2, [pc, #100]	@ (34016fd0 <LL_ATON_DisableUnits_Init+0x120>)
34016f6a:	33f7      	adds	r3, #247	@ 0xf7
34016f6c:	031b      	lsls	r3, r3, #12
34016f6e:	601a      	str	r2, [r3, #0]
34016f70:	681a      	ldr	r2, [r3, #0]
34016f72:	0792      	lsls	r2, r2, #30
34016f74:	d4fc      	bmi.n	34016f70 <LL_ATON_DisableUnits_Init+0xc0>
34016f76:	f04f 4290 	mov.w	r2, #1207959552	@ 0x48000000
34016f7a:	601a      	str	r2, [r3, #0]
34016f7c:	681a      	ldr	r2, [r3, #0]
34016f7e:	0052      	lsls	r2, r2, #1
34016f80:	d4fc      	bmi.n	34016f7c <LL_ATON_DisableUnits_Init+0xcc>
      LL_ATON_DisableClock(ATON_ARITH_CLKB_CLK(unitId));
34016f82:	3012      	adds	r0, #18
34016f84:	e7b8      	b.n	34016ef8 <LL_ATON_DisableUnits_Init+0x48>
      ATON_DISABLE_CLR_CONFCLR(POOL, unitId);
34016f86:	f500 23b0 	add.w	r3, r0, #360448	@ 0x58000
34016f8a:	4a12      	ldr	r2, [pc, #72]	@ (34016fd4 <LL_ATON_DisableUnits_Init+0x124>)
34016f8c:	33fb      	adds	r3, #251	@ 0xfb
34016f8e:	031b      	lsls	r3, r3, #12
34016f90:	601a      	str	r2, [r3, #0]
34016f92:	681a      	ldr	r2, [r3, #0]
34016f94:	0792      	lsls	r2, r2, #30
34016f96:	d4fc      	bmi.n	34016f92 <LL_ATON_DisableUnits_Init+0xe2>
34016f98:	4a0f      	ldr	r2, [pc, #60]	@ (34016fd8 <LL_ATON_DisableUnits_Init+0x128>)
34016f9a:	601a      	str	r2, [r3, #0]
34016f9c:	681a      	ldr	r2, [r3, #0]
34016f9e:	0052      	lsls	r2, r2, #1
34016fa0:	d4fc      	bmi.n	34016f9c <LL_ATON_DisableUnits_Init+0xec>
      LL_ATON_DisableClock(ATON_POOL_CLKB_CLK(unitId));
34016fa2:	3016      	adds	r0, #22
34016fa4:	e7a8      	b.n	34016ef8 <LL_ATON_DisableUnits_Init+0x48>
      ATON_DISABLE_CLR_CONFCLR(RECBUF, unitId);
34016fa6:	2202      	movs	r2, #2
34016fa8:	4b0c      	ldr	r3, [pc, #48]	@ (34016fdc <LL_ATON_DisableUnits_Init+0x12c>)
34016faa:	601a      	str	r2, [r3, #0]
34016fac:	681a      	ldr	r2, [r3, #0]
34016fae:	0792      	lsls	r2, r2, #30
34016fb0:	d4fc      	bmi.n	34016fac <LL_ATON_DisableUnits_Init+0xfc>
34016fb2:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34016fb6:	601a      	str	r2, [r3, #0]
34016fb8:	681a      	ldr	r2, [r3, #0]
34016fba:	0052      	lsls	r2, r2, #1
34016fbc:	d4fc      	bmi.n	34016fb8 <LL_ATON_DisableUnits_Init+0x108>
      LL_ATON_DisableClock(ATON_RECBUF_CLKB_CLK(unitId));
34016fbe:	3018      	adds	r0, #24
34016fc0:	e79a      	b.n	34016ef8 <LL_ATON_DisableUnits_Init+0x48>
    switch (unitType)
34016fc2:	f06f 0001 	mvn.w	r0, #1
34016fc6:	e77a      	b.n	34016ebe <LL_ATON_DisableUnits_Init+0xe>
34016fc8:	00881082 	.word	0x00881082
34016fcc:	40881080 	.word	0x40881080
34016fd0:	08000002 	.word	0x08000002
34016fd4:	00420002 	.word	0x00420002
34016fd8:	40420000 	.word	0x40420000
34016fdc:	580fd000 	.word	0x580fd000

34016fe0 <LL_Buffer_addr_start>:
    return eb->blob_address;
  }

  static inline unsigned char *LL_Buffer_addr_base(const LL_Buffer_InfoTypeDef *buf)
  {
    if (buf->is_user_allocated)
34016fe0:	7d02      	ldrb	r2, [r0, #20]
    {
      unsigned char **tmp = (unsigned char **)buf->addr_base.p;
34016fe2:	6843      	ldr	r3, [r0, #4]
    if (buf->is_user_allocated)
34016fe4:	b102      	cbz	r2, 34016fe8 <LL_Buffer_addr_start+0x8>
      return *tmp;
34016fe6:	681b      	ldr	r3, [r3, #0]
    return buf->addr_base.p;
  }

  static inline unsigned char *LL_Buffer_addr_start(const LL_Buffer_InfoTypeDef *buf)
  {
    return LL_Buffer_addr_base(buf) + buf->offset_start;
34016fe8:	6880      	ldr	r0, [r0, #8]
  }
34016fea:	4418      	add	r0, r3
34016fec:	4770      	bx	lr
	...

34016ff0 <__ll_lib_stop_transfer>:
  LL_Switch_Init_NoReset(switch_init, 1);
  LL_ATON_EnableUnits_Init(dma_units, 2);
}

static inline void __ll_lib_stop_transfer(void)
{
34016ff0:	b508      	push	{r3, lr}
  LL_Switch_Deinit(switch_init, 1);
34016ff2:	2101      	movs	r1, #1
34016ff4:	4804      	ldr	r0, [pc, #16]	@ (34017008 <__ll_lib_stop_transfer+0x18>)
34016ff6:	f7ff fdbf 	bl	34016b78 <LL_Switch_Deinit>
  LL_ATON_DisableUnits_Init(dma_units, 2);
}
34016ffa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  LL_ATON_DisableUnits_Init(dma_units, 2);
34016ffe:	2102      	movs	r1, #2
34017000:	4802      	ldr	r0, [pc, #8]	@ (3401700c <__ll_lib_stop_transfer+0x1c>)
34017002:	f7ff bf55 	b.w	34016eb0 <LL_ATON_DisableUnits_Init>
34017006:	bf00      	nop
34017008:	340b10f4 	.word	0x340b10f4
3401700c:	340b10e4 	.word	0x340b10e4

34017010 <__LL_LIB_DMA_Transfer_End_EpochBlock>:
  __ll_lib_start_transfer(params);
}

static void __LL_LIB_DMA_Transfer_End_EpochBlock(const void *epoch_block)
{
  __ll_lib_stop_transfer();
34017010:	f7ff bfee 	b.w	34016ff0 <__ll_lib_stop_transfer>

34017014 <__LL_ATON_RT_SetWaitMask>:
    nn_instance->exec_state.current_epoch_block = &nn_instance->exec_state.first_epoch_block[index];
  }

  /* set wait mask(s) in interrupt controller */
  static inline void __LL_ATON_RT_SetWaitMask(uint32_t wait_mask)
  {
34017014:	b508      	push	{r3, lr}
#ifndef NDEBUG
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
34017016:	4b07      	ldr	r3, [pc, #28]	@ (34017034 <__LL_ATON_RT_SetWaitMask+0x20>)
34017018:	681b      	ldr	r3, [r3, #0]
3401701a:	b92b      	cbnz	r3, 34017028 <__LL_ATON_RT_SetWaitMask+0x14>
3401701c:	216c      	movs	r1, #108	@ 0x6c
3401701e:	4b06      	ldr	r3, [pc, #24]	@ (34017038 <__LL_ATON_RT_SetWaitMask+0x24>)
34017020:	4a06      	ldr	r2, [pc, #24]	@ (3401703c <__LL_ATON_RT_SetWaitMask+0x28>)
34017022:	4807      	ldr	r0, [pc, #28]	@ (34017040 <__LL_ATON_RT_SetWaitMask+0x2c>)
34017024:	f001 ff1a 	bl	34018e5c <__assert_func>

    extern uint32_t volatile __ll_current_wait_mask;
    __ll_current_wait_mask = wait_mask;
34017028:	4b06      	ldr	r3, [pc, #24]	@ (34017044 <__LL_ATON_RT_SetWaitMask+0x30>)
3401702a:	6018      	str	r0, [r3, #0]

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    wait_mask <<= ATON_STRENG_INT(0);
#ifndef LL_ATON_RT_USE_IRQ_OR_MASK
    /* configure interrupt controller AND mask for epoch block */
    ATON_INTCTRL_STD_INTANDMSK_SET(~wait_mask);
3401702c:	43c0      	mvns	r0, r0
3401702e:	4b06      	ldr	r3, [pc, #24]	@ (34017048 <__LL_ATON_RT_SetWaitMask+0x34>)
34017030:	6258      	str	r0, [r3, #36]	@ 0x24
                                                                // (all other events & errors are enabled)
    val &= ~wait_mask;
    ATON_INTCTRL_STD_INTORMSK_SET(val);
#endif // LL_ATON_RT_USE_IRQ_OR_MASK
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  }
34017032:	bd08      	pop	{r3, pc}
34017034:	340ceee8 	.word	0x340ceee8
34017038:	34021230 	.word	0x34021230
3401703c:	340ae53a 	.word	0x340ae53a
34017040:	3402125a 	.word	0x3402125a
34017044:	340ceee4 	.word	0x340ceee4
34017048:	580e1000 	.word	0x580e1000

3401704c <__ll_lib_strswitch_set_dmas>:
{
3401704c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  switch_init[0].source0 = __atonn_getSrcPortID(STRSWITCH, 0, STRENG, dma_in, 0);
34017050:	2400      	movs	r4, #0
{
34017052:	460d      	mov	r5, r1
34017054:	4606      	mov	r6, r0
34017056:	4617      	mov	r7, r2
  switch_init[0].source0 = __atonn_getSrcPortID(STRSWITCH, 0, STRENG, dma_in, 0);
34017058:	4621      	mov	r1, r4
3401705a:	4622      	mov	r2, r4
3401705c:	b2c3      	uxtb	r3, r0
3401705e:	9400      	str	r4, [sp, #0]
34017060:	4620      	mov	r0, r4
34017062:	f7ff fc11 	bl	34016888 <__atonn_getSrcPortID>
34017066:	f8df 8048 	ldr.w	r8, [pc, #72]	@ 340170b0 <__ll_lib_strswitch_set_dmas+0x64>
  switch_init[0].dest = __atonn_getDstPortID(STRSWITCH, 0, STRENG, dma_out, 0);
3401706a:	4622      	mov	r2, r4
  switch_init[0].source0 = __atonn_getSrcPortID(STRSWITCH, 0, STRENG, dma_in, 0);
3401706c:	f8c8 0000 	str.w	r0, [r8]
  switch_init[0].dest = __atonn_getDstPortID(STRSWITCH, 0, STRENG, dma_out, 0);
34017070:	b2eb      	uxtb	r3, r5
34017072:	4621      	mov	r1, r4
34017074:	4620      	mov	r0, r4
34017076:	9400      	str	r4, [sp, #0]
34017078:	f7ff fc9a 	bl	340169b0 <__atonn_getDstPortID>
  dma_units[1].unit = dma_in_streng;
3401707c:	4b09      	ldr	r3, [pc, #36]	@ (340170a4 <__ll_lib_strswitch_set_dmas+0x58>)
  dma_unit_id[1] = dma_in;
3401707e:	4a0a      	ldr	r2, [pc, #40]	@ (340170a8 <__ll_lib_strswitch_set_dmas+0x5c>)
  dma_units[1].unit = dma_in_streng;
34017080:	711c      	strb	r4, [r3, #4]
  AccelUnits dma_in_streng = {STRENG, dma_in};
34017082:	80de      	strh	r6, [r3, #6]
  dma_units[0].unit = dma_out_streng;
34017084:	701c      	strb	r4, [r3, #0]
  AccelUnits dma_out_streng = {STRENG, dma_out};
34017086:	805d      	strh	r5, [r3, #2]
  uint32_t wait_mask = (0x1 << dma_out);
34017088:	2301      	movs	r3, #1
  dma_unit_id[1] = dma_in;
3401708a:	6056      	str	r6, [r2, #4]
  dma_unit_id[0] = dma_out;
3401708c:	6015      	str	r5, [r2, #0]
  params->g_wait_mask = wait_mask;
3401708e:	4a07      	ldr	r2, [pc, #28]	@ (340170ac <__ll_lib_strswitch_set_dmas+0x60>)
  uint32_t wait_mask = (0x1 << dma_out);
34017090:	40ab      	lsls	r3, r5
  params->g_wait_mask = wait_mask;
34017092:	f8c2 30ac 	str.w	r3, [r2, #172]	@ 0xac
  switch_init[0].dest = __atonn_getDstPortID(STRSWITCH, 0, STRENG, dma_out, 0);
34017096:	f8c8 0008 	str.w	r0, [r8, #8]
  epoch_block_array->wait_mask = wait_mask;
3401709a:	60fb      	str	r3, [r7, #12]
}
3401709c:	b002      	add	sp, #8
3401709e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
340170a2:	bf00      	nop
340170a4:	340b10e4 	.word	0x340b10e4
340170a8:	340b10ec 	.word	0x340b10ec
340170ac:	340ce898 	.word	0x340ce898
340170b0:	340b10f4 	.word	0x340b10f4

340170b4 <LL_ATON_RT_Insert_LibEpochBlockArray>:
  }

  /*** AtoNN API Functions ***/

  static inline void LL_ATON_RT_Insert_LibEpochBlockArray(const LL_ATON_RT_EpochBlockItem_t *new_epoch_block_array)
  {
340170b4:	b508      	push	{r3, lr}
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
340170b6:	4b0d      	ldr	r3, [pc, #52]	@ (340170ec <LL_ATON_RT_Insert_LibEpochBlockArray+0x38>)
340170b8:	681a      	ldr	r2, [r3, #0]
340170ba:	b92a      	cbnz	r2, 340170c8 <LL_ATON_RT_Insert_LibEpochBlockArray+0x14>
340170bc:	21af      	movs	r1, #175	@ 0xaf
340170be:	4b0c      	ldr	r3, [pc, #48]	@ (340170f0 <LL_ATON_RT_Insert_LibEpochBlockArray+0x3c>)
340170c0:	4a0c      	ldr	r2, [pc, #48]	@ (340170f4 <LL_ATON_RT_Insert_LibEpochBlockArray+0x40>)

    // only one saved context at a time allowed!
    LL_ATON_ASSERT(__ll_current_aton_ip_owner->exec_state.next_epoch_block == NULL);
340170c2:	480d      	ldr	r0, [pc, #52]	@ (340170f8 <LL_ATON_RT_Insert_LibEpochBlockArray+0x44>)
340170c4:	f001 feca 	bl	34018e5c <__assert_func>
340170c8:	681a      	ldr	r2, [r3, #0]
340170ca:	68d2      	ldr	r2, [r2, #12]
340170cc:	b11a      	cbz	r2, 340170d6 <LL_ATON_RT_Insert_LibEpochBlockArray+0x22>
340170ce:	21b2      	movs	r1, #178	@ 0xb2
340170d0:	4b0a      	ldr	r3, [pc, #40]	@ (340170fc <LL_ATON_RT_Insert_LibEpochBlockArray+0x48>)
340170d2:	4a08      	ldr	r2, [pc, #32]	@ (340170f4 <LL_ATON_RT_Insert_LibEpochBlockArray+0x40>)
340170d4:	e7f5      	b.n	340170c2 <LL_ATON_RT_Insert_LibEpochBlockArray+0xe>
    LL_ATON_ASSERT(__ll_current_aton_ip_owner->exec_state.saved_current_epoch_block == NULL);
340170d6:	681a      	ldr	r2, [r3, #0]
340170d8:	6912      	ldr	r2, [r2, #16]
340170da:	b11a      	cbz	r2, 340170e4 <LL_ATON_RT_Insert_LibEpochBlockArray+0x30>
340170dc:	21b3      	movs	r1, #179	@ 0xb3
340170de:	4b08      	ldr	r3, [pc, #32]	@ (34017100 <LL_ATON_RT_Insert_LibEpochBlockArray+0x4c>)
340170e0:	4a04      	ldr	r2, [pc, #16]	@ (340170f4 <LL_ATON_RT_Insert_LibEpochBlockArray+0x40>)
340170e2:	e7ee      	b.n	340170c2 <LL_ATON_RT_Insert_LibEpochBlockArray+0xe>

    __ll_current_aton_ip_owner->exec_state.next_epoch_block = new_epoch_block_array;
340170e4:	681b      	ldr	r3, [r3, #0]
340170e6:	60d8      	str	r0, [r3, #12]
  }
340170e8:	bd08      	pop	{r3, pc}
340170ea:	bf00      	nop
340170ec:	340ceee8 	.word	0x340ceee8
340170f0:	34021230 	.word	0x34021230
340170f4:	340ae581 	.word	0x340ae581
340170f8:	3402125a 	.word	0x3402125a
340170fc:	3402130d 	.word	0x3402130d
34017100:	34021354 	.word	0x34021354

34017104 <__ll_lib_prepare_inputs_epoch>:
  LL_ATON_ASSERT(ninputs <= __LL_MAX_TENSORS);
34017104:	2918      	cmp	r1, #24
{
34017106:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34017108:	460d      	mov	r5, r1
3401710a:	4617      	mov	r7, r2
3401710c:	461e      	mov	r6, r3
  LL_ATON_ASSERT(ninputs <= __LL_MAX_TENSORS);
3401710e:	d905      	bls.n	3401711c <__ll_lib_prepare_inputs_epoch+0x18>
34017110:	21e6      	movs	r1, #230	@ 0xe6
34017112:	4b13      	ldr	r3, [pc, #76]	@ (34017160 <__ll_lib_prepare_inputs_epoch+0x5c>)
34017114:	4a13      	ldr	r2, [pc, #76]	@ (34017164 <__ll_lib_prepare_inputs_epoch+0x60>)
34017116:	4814      	ldr	r0, [pc, #80]	@ (34017168 <__ll_lib_prepare_inputs_epoch+0x64>)
34017118:	f001 fea0 	bl	34018e5c <__assert_func>
  memcpy(inputs_copy, inputs, sizeof(LL_LIB_TensorInfo_TypeDef) * ninputs);
3401711c:	2238      	movs	r2, #56	@ 0x38
3401711e:	4b13      	ldr	r3, [pc, #76]	@ (3401716c <__ll_lib_prepare_inputs_epoch+0x68>)
34017120:	434a      	muls	r2, r1
34017122:	4601      	mov	r1, r0
34017124:	4618      	mov	r0, r3
34017126:	f003 fa94 	bl	3401a652 <memcpy>
  params->g_tensors = inputs_copy;
3401712a:	f5a0 7484 	sub.w	r4, r0, #264	@ 0x108
  params->g_dma_in = *dma_in;
3401712e:	2248      	movs	r2, #72	@ 0x48
34017130:	4639      	mov	r1, r7
  params->g_num_tensors = ninputs;
34017132:	e940 5019 	strd	r5, r0, [r0, #-100]	@ 0x64
  params->g_dma_in = *dma_in;
34017136:	4620      	mov	r0, r4
34017138:	f003 fa8b 	bl	3401a652 <memcpy>
  params->g_dma_out = *dma_out;
3401713c:	2248      	movs	r2, #72	@ 0x48
3401713e:	4631      	mov	r1, r6
34017140:	18a0      	adds	r0, r4, r2
34017142:	f003 fa86 	bl	3401a652 <memcpy>
  params->g_dst_o_src = out_start;
34017146:	9b06      	ldr	r3, [sp, #24]
  params->g_size = nbytes_or_line_size;
34017148:	9a07      	ldr	r2, [sp, #28]
  params->g_dst_o_src = out_start;
3401714a:	f8c4 3098 	str.w	r3, [r4, #152]	@ 0x98
  params->g_not_continuous = 0; // signals that destination is not written linearly
3401714e:	2300      	movs	r3, #0
  params->g_idx = 0;
34017150:	e9c4 3224 	strd	r3, r2, [r4, #144]	@ 0x90
  params->g_not_continuous = 0; // signals that destination is not written linearly
34017154:	f8c4 30a0 	str.w	r3, [r4, #160]	@ 0xa0
  params->g_offset_limit = 0;
34017158:	f8c4 309c 	str.w	r3, [r4, #156]	@ 0x9c
}
3401715c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
3401715e:	bf00      	nop
34017160:	340213a4 	.word	0x340213a4
34017164:	340ae5a6 	.word	0x340ae5a6
34017168:	340213b2 	.word	0x340213b2
3401716c:	340ce9a0 	.word	0x340ce9a0

34017170 <__LL_ATON_LIB_DMA_Inputs_Memcpy.part.0>:
 * @param  inputs list of input tensor info structures
 * @param  ninputs number of inputs
 * @param  dst destination address
 * @param  nbytes number of bytes to copy (-1 means: derive from `inputs` structure)
 */
static void __LL_ATON_LIB_DMA_Inputs_Memcpy(const LL_LIB_TensorInfo_TypeDef *inputs, unsigned int ninputs,
34017170:	b573      	push	{r0, r1, r4, r5, r6, lr}
  {
    /* prepare epoch */
    __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_static_const_dma_in, &_static_const_dma_out, dst, nbytes);

    /* configure stream switch */
    __ll_lib_strswitch_set_dmas(dma_in, dma_out, _inputs_memcpy_epoch_block_array);
34017172:	4c0a      	ldr	r4, [pc, #40]	@ (3401719c <__LL_ATON_LIB_DMA_Inputs_Memcpy.part.0+0x2c>)
    __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_static_const_dma_in, &_static_const_dma_out, dst, nbytes);
34017174:	e9cd 2300 	strd	r2, r3, [sp]
static void __LL_ATON_LIB_DMA_Inputs_Memcpy(const LL_LIB_TensorInfo_TypeDef *inputs, unsigned int ninputs,
34017178:	e9dd 5606 	ldrd	r5, r6, [sp, #24]
    __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_static_const_dma_in, &_static_const_dma_out, dst, nbytes);
3401717c:	4b08      	ldr	r3, [pc, #32]	@ (340171a0 <__LL_ATON_LIB_DMA_Inputs_Memcpy.part.0+0x30>)
3401717e:	4a09      	ldr	r2, [pc, #36]	@ (340171a4 <__LL_ATON_LIB_DMA_Inputs_Memcpy.part.0+0x34>)
34017180:	f7ff ffc0 	bl	34017104 <__ll_lib_prepare_inputs_epoch>
    __ll_lib_strswitch_set_dmas(dma_in, dma_out, _inputs_memcpy_epoch_block_array);
34017184:	4628      	mov	r0, r5
34017186:	4622      	mov	r2, r4
34017188:	4631      	mov	r1, r6
3401718a:	f7ff ff5f 	bl	3401704c <__ll_lib_strswitch_set_dmas>

    LL_ATON_RT_Insert_LibEpochBlockArray(_inputs_memcpy_epoch_block_array);
3401718e:	4620      	mov	r0, r4
  }
  else
  {
    /* proceed to next epoch block */
  }
}
34017190:	b002      	add	sp, #8
34017192:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    LL_ATON_RT_Insert_LibEpochBlockArray(_inputs_memcpy_epoch_block_array);
34017196:	f7ff bf8d 	b.w	340170b4 <LL_ATON_RT_Insert_LibEpochBlockArray>
3401719a:	bf00      	nop
3401719c:	340b1094 	.word	0x340b1094
340171a0:	340ae5c4 	.word	0x340ae5c4
340171a4:	340ae60c 	.word	0x340ae60c

340171a8 <__ll_lib_start_transfer.constprop.0>:
static inline void __ll_lib_start_transfer(__ll_lib_params_t *params)
340171a8:	b538      	push	{r3, r4, r5, lr}
  LL_Streng_TensorInit(dma_unit_id[1], &params->g_dma_in, 1);
340171aa:	4d0b      	ldr	r5, [pc, #44]	@ (340171d8 <__ll_lib_start_transfer.constprop.0+0x30>)
340171ac:	4c0b      	ldr	r4, [pc, #44]	@ (340171dc <__ll_lib_start_transfer.constprop.0+0x34>)
340171ae:	4629      	mov	r1, r5
340171b0:	2201      	movs	r2, #1
340171b2:	6860      	ldr	r0, [r4, #4]
340171b4:	f7ff fd06 	bl	34016bc4 <LL_Streng_TensorInit>
  LL_Streng_TensorInit(dma_unit_id[0], &params->g_dma_out, 1);
340171b8:	f105 0148 	add.w	r1, r5, #72	@ 0x48
340171bc:	2201      	movs	r2, #1
340171be:	6820      	ldr	r0, [r4, #0]
340171c0:	f7ff fd00 	bl	34016bc4 <LL_Streng_TensorInit>
  LL_Switch_Init_NoReset(switch_init, 1);
340171c4:	2101      	movs	r1, #1
340171c6:	4806      	ldr	r0, [pc, #24]	@ (340171e0 <__ll_lib_start_transfer.constprop.0+0x38>)
340171c8:	f7ff fc9c 	bl	34016b04 <LL_Switch_Init_NoReset>
}
340171cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  LL_ATON_EnableUnits_Init(dma_units, 2);
340171d0:	2102      	movs	r1, #2
340171d2:	4804      	ldr	r0, [pc, #16]	@ (340171e4 <__ll_lib_start_transfer.constprop.0+0x3c>)
340171d4:	f7ff bb10 	b.w	340167f8 <LL_ATON_EnableUnits_Init>
340171d8:	340ce898 	.word	0x340ce898
340171dc:	340b10ec 	.word	0x340b10ec
340171e0:	340b10f4 	.word	0x340b10f4
340171e4:	340b10e4 	.word	0x340b10e4

340171e8 <__LL_LIB_DMA_Transfer_Start_EpochBlock>:
  __ll_lib_start_transfer(params);
340171e8:	f7ff bfde 	b.w	340171a8 <__ll_lib_start_transfer.constprop.0>

340171ec <LL_ATON_RT_DecCurrEpochBlock.constprop.0>:
  }

  static inline void LL_ATON_RT_DecCurrEpochBlock(uint32_t dec)
  {
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
340171ec:	4a12      	ldr	r2, [pc, #72]	@ (34017238 <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x4c>)
  static inline void LL_ATON_RT_DecCurrEpochBlock(uint32_t dec)
340171ee:	b510      	push	{r4, lr}
    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
340171f0:	6813      	ldr	r3, [r2, #0]
340171f2:	b92b      	cbnz	r3, 34017200 <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x14>
340171f4:	21c9      	movs	r1, #201	@ 0xc9
340171f6:	4b11      	ldr	r3, [pc, #68]	@ (3401723c <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x50>)
340171f8:	4a11      	ldr	r2, [pc, #68]	@ (34017240 <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x54>)
    LL_ATON_ASSERT(_first_epoch_block <= _current_epoch_block); // should never happen
340171fa:	4812      	ldr	r0, [pc, #72]	@ (34017244 <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x58>)
340171fc:	f001 fe2e 	bl	34018e5c <__assert_func>

    uint32_t current_index = __LL_ATON_RT_GetCurrEpochBlockIndex(__ll_current_aton_ip_owner);
34017200:	6811      	ldr	r1, [r2, #0]
    const LL_ATON_RT_EpochBlockItem_t *_current_epoch_block = nn_instance->exec_state.current_epoch_block;
34017202:	684b      	ldr	r3, [r1, #4]
    const LL_ATON_RT_EpochBlockItem_t *_first_epoch_block = nn_instance->exec_state.first_epoch_block;
34017204:	6889      	ldr	r1, [r1, #8]
    LL_ATON_ASSERT(_first_epoch_block <= _current_epoch_block); // should never happen
34017206:	428b      	cmp	r3, r1
34017208:	d203      	bcs.n	34017212 <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x26>
3401720a:	2157      	movs	r1, #87	@ 0x57
3401720c:	4b0e      	ldr	r3, [pc, #56]	@ (34017248 <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x5c>)
3401720e:	4a0f      	ldr	r2, [pc, #60]	@ (3401724c <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x60>)
34017210:	e7f3      	b.n	340171fa <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0xe>
    return (_current_epoch_block - _first_epoch_block);
34017212:	1a5b      	subs	r3, r3, r1
34017214:	4c0e      	ldr	r4, [pc, #56]	@ (34017250 <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x64>)
    LL_ATON_ASSERT((current_index + 1) >= dec); // should never happen
    int32_t new_index = current_index - dec;
    __LL_ATON_RT_SetCurrentEpochBlock(new_index, __ll_current_aton_ip_owner);
34017216:	6811      	ldr	r1, [r2, #0]
    return (_current_epoch_block - _first_epoch_block);
34017218:	109a      	asrs	r2, r3, #2
3401721a:	4362      	muls	r2, r4
    LL_ATON_ASSERT(index < (int32_t)(nn_instance->exec_state.nr_of_epoch_blocks - 1));
3401721c:	6a48      	ldr	r0, [r1, #36]	@ 0x24
    int32_t new_index = current_index - dec;
3401721e:	3a01      	subs	r2, #1
    LL_ATON_ASSERT(index < (int32_t)(nn_instance->exec_state.nr_of_epoch_blocks - 1));
34017220:	3801      	subs	r0, #1
34017222:	4282      	cmp	r2, r0
34017224:	db03      	blt.n	3401722e <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x42>
34017226:	2161      	movs	r1, #97	@ 0x61
34017228:	4b0a      	ldr	r3, [pc, #40]	@ (34017254 <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x68>)
3401722a:	4a0b      	ldr	r2, [pc, #44]	@ (34017258 <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0x6c>)
3401722c:	e7e5      	b.n	340171fa <LL_ATON_RT_DecCurrEpochBlock.constprop.0+0xe>
    nn_instance->exec_state.current_epoch_block = &nn_instance->exec_state.first_epoch_block[index];
3401722e:	688a      	ldr	r2, [r1, #8]
34017230:	3b14      	subs	r3, #20
34017232:	4413      	add	r3, r2
34017234:	604b      	str	r3, [r1, #4]
  }
34017236:	bd10      	pop	{r4, pc}
34017238:	340ceee8 	.word	0x340ceee8
3401723c:	34021230 	.word	0x34021230
34017240:	340ae51d 	.word	0x340ae51d
34017244:	3402125a 	.word	0x3402125a
34017248:	34021461 	.word	0x34021461
3401724c:	340ae4f9 	.word	0x340ae4f9
34017250:	cccccccd 	.word	0xcccccccd
34017254:	3402148c 	.word	0x3402148c
34017258:	340ae4d7 	.word	0x340ae4d7

3401725c <__LL_LIB_Inputs_Batched_Memcpy_End_EpochBlock>:
{
3401725c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  previous_value = eb->wait_mask;
3401725e:	68c4      	ldr	r4, [r0, #12]
{
34017260:	4603      	mov	r3, r0
  eb->wait_mask = wait_mask;
34017262:	2000      	movs	r0, #0
34017264:	60d8      	str	r0, [r3, #12]
  __LL_ATON_RT_SetWaitMask(eb->wait_mask);
34017266:	f7ff fed5 	bl	34017014 <__LL_ATON_RT_SetWaitMask>
  if (__ll_lib_set_wait_mask((LL_ATON_RT_EpochBlockItem_t *)epoch_block, 0))
3401726a:	b10c      	cbz	r4, 34017270 <__LL_LIB_Inputs_Batched_Memcpy_End_EpochBlock+0x14>
    __ll_lib_stop_transfer();
3401726c:	f7ff fec0 	bl	34016ff0 <__ll_lib_stop_transfer>
  LL_LIB_TensorInfo_TypeDef *in = ((LL_LIB_TensorInfo_TypeDef *)params->g_tensors) + params->g_idx;
34017270:	2238      	movs	r2, #56	@ 0x38
34017272:	4b21      	ldr	r3, [pc, #132]	@ (340172f8 <__LL_LIB_Inputs_Batched_Memcpy_End_EpochBlock+0x9c>)
34017274:	f8d3 0090 	ldr.w	r0, [r3, #144]	@ 0x90
34017278:	f8d3 10a8 	ldr.w	r1, [r3, #168]	@ 0xa8
3401727c:	4342      	muls	r2, r0
3401727e:	188e      	adds	r6, r1, r2
  int in_nchannels_old = in->shape[(in_ndims - 4) + TDIM_NCHANNELS];
34017280:	f896 4027 	ldrb.w	r4, [r6, #39]	@ 0x27
  if (params->g_idx < params->g_num_tensors)
34017284:	f8d3 70a4 	ldr.w	r7, [r3, #164]	@ 0xa4
  int in_nchannels_old = in->shape[(in_ndims - 4) + TDIM_NCHANNELS];
34017288:	6af6      	ldr	r6, [r6, #44]	@ 0x2c
  params->g_idx++;
3401728a:	3001      	adds	r0, #1
  int in_nchannels_old = in->shape[(in_ndims - 4) + TDIM_NCHANNELS];
3401728c:	3c01      	subs	r4, #1
  if (params->g_idx < params->g_num_tensors)
3401728e:	42b8      	cmp	r0, r7
  int in_nchannels_old = in->shape[(in_ndims - 4) + TDIM_NCHANNELS];
34017290:	f856 6024 	ldr.w	r6, [r6, r4, lsl #2]
34017294:	ea4f 0584 	mov.w	r5, r4, lsl #2
  params->g_idx++;
34017298:	f8c3 0090 	str.w	r0, [r3, #144]	@ 0x90
  if (params->g_idx < params->g_num_tensors)
3401729c:	d22b      	bcs.n	340172f6 <__LL_LIB_Inputs_Batched_Memcpy_End_EpochBlock+0x9a>
    in = ((LL_LIB_TensorInfo_TypeDef *)params->g_tensors) + params->g_idx;
3401729e:	3238      	adds	r2, #56	@ 0x38
340172a0:	4411      	add	r1, r2
    int in_batch = in->batch;
340172a2:	6988      	ldr	r0, [r1, #24]
    int in_fheight = in->shape[(in_ndims - 4) + TDIM_FHEIGHT];
340172a4:	f8d1 c02c 	ldr.w	ip, [r1, #44]	@ 0x2c
    int in_batch = in->batch;
340172a8:	4607      	mov	r7, r0
    int nbits = in->nbits;
340172aa:	f891 2028 	ldrb.w	r2, [r1, #40]	@ 0x28
    int in_fheight = in->shape[(in_ndims - 4) + TDIM_FHEIGHT];
340172ae:	4465      	add	r5, ip
    int in_fwidth = in->shape[(in_ndims - 4) + TDIM_FWIDTH];
340172b0:	e955 1e02 	ldrd	r1, lr, [r5, #-8]
    int nbytes = (nbits + 7) >> 3;
340172b4:	3207      	adds	r2, #7
    params->g_dst_o_src += in_nchannels_old * nbytes;
340172b6:	f8d3 5098 	ldr.w	r5, [r3, #152]	@ 0x98
    int nbytes = (nbits + 7) >> 3;
340172ba:	10d2      	asrs	r2, r2, #3
    params->g_dst_o_src += in_nchannels_old * nbytes;
340172bc:	fb02 5506 	mla	r5, r2, r6, r5
    int in_nchannels = in->shape[(in_ndims - 4) + TDIM_NCHANNELS];
340172c0:	f85c 4024 	ldr.w	r4, [ip, r4, lsl #2]
    params->g_dma_out.batch_depth = (nbytes == 4) ? (2 * in_batch) : in_batch;  // this must be updated on all inputs
340172c4:	2a04      	cmp	r2, #4
    params->g_dst_o_src += in_nchannels_old * nbytes;
340172c6:	f8c3 5098 	str.w	r5, [r3, #152]	@ 0x98
    params->g_dma_out.batch_depth = (nbytes == 4) ? (2 * in_batch) : in_batch;  // this must be updated on all inputs
340172ca:	ea4f 0540 	mov.w	r5, r0, lsl #1
340172ce:	bf08      	it	eq
340172d0:	4628      	moveq	r0, r5
    params->g_dma_out.frame_loop_cnt = in_nchannels / in_batch;                 // this must be updated on all inputs
340172d2:	fb94 f4f7 	sdiv	r4, r4, r7
    params->g_dma_out.loop_offset = in_fheight * in_fwidth * in_batch * nbytes; // this must be updated on all inputs
340172d6:	fb0e f101 	mul.w	r1, lr, r1
340172da:	4379      	muls	r1, r7
    params->g_dma_out.batch_depth = (nbytes == 4) ? (2 * in_batch) : in_batch;  // this must be updated on all inputs
340172dc:	6698      	str	r0, [r3, #104]	@ 0x68
    params->g_dma_out.frame_offset = in_batch * nbytes;                         // this must be updated on all inputs
340172de:	fb07 f002 	mul.w	r0, r7, r2
    params->g_dma_out.loop_offset = in_fheight * in_fwidth * in_batch * nbytes; // this must be updated on all inputs
340172e2:	434a      	muls	r2, r1
    params->g_dma_out.frame_offset = in_batch * nbytes;                         // this must be updated on all inputs
340172e4:	6718      	str	r0, [r3, #112]	@ 0x70
    params->g_dma_out.frame_loop_cnt = in_nchannels / in_batch;                 // this must be updated on all inputs
340172e6:	67dc      	str	r4, [r3, #124]	@ 0x7c
    params->g_dma_out.frame_tot_cnt = in_nchannels / in_batch;                  // this must be updated on all inputs
340172e8:	f8c3 4088 	str.w	r4, [r3, #136]	@ 0x88
    params->g_dma_out.loop_offset = in_fheight * in_fwidth * in_batch * nbytes; // this must be updated on all inputs
340172ec:	679a      	str	r2, [r3, #120]	@ 0x78
}
340172ee:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    LL_ATON_RT_DecCurrEpochBlock(1);
340172f2:	f7ff bf7b 	b.w	340171ec <LL_ATON_RT_DecCurrEpochBlock.constprop.0>
}
340172f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
340172f8:	340ce898 	.word	0x340ce898

340172fc <__LL_LIB_Inputs_Memcpy_End_EpochBlock>:
{
340172fc:	b510      	push	{r4, lr}
340172fe:	4603      	mov	r3, r0
  previous_value = eb->wait_mask;
34017300:	68c4      	ldr	r4, [r0, #12]
  eb->wait_mask = wait_mask;
34017302:	2000      	movs	r0, #0
34017304:	60d8      	str	r0, [r3, #12]
  __LL_ATON_RT_SetWaitMask(eb->wait_mask);
34017306:	f7ff fe85 	bl	34017014 <__LL_ATON_RT_SetWaitMask>
  if (__ll_lib_set_wait_mask((LL_ATON_RT_EpochBlockItem_t *)epoch_block, 0))
3401730a:	b10c      	cbz	r4, 34017310 <__LL_LIB_Inputs_Memcpy_End_EpochBlock+0x14>
    __ll_lib_stop_transfer();
3401730c:	f7ff fe70 	bl	34016ff0 <__ll_lib_stop_transfer>
  if (params->g_size < 0)
34017310:	4b0e      	ldr	r3, [pc, #56]	@ (3401734c <__LL_LIB_Inputs_Memcpy_End_EpochBlock+0x50>)
    params->g_dst_o_src += LL_Buffer_len(((LL_LIB_TensorInfo_TypeDef *)params->g_tensors) + params->g_idx);
34017312:	e9d3 2024 	ldrd	r2, r0, [r3, #144]	@ 0x90
  if (params->g_size < 0)
34017316:	2800      	cmp	r0, #0
    params->g_dst_o_src += LL_Buffer_len(((LL_LIB_TensorInfo_TypeDef *)params->g_tensors) + params->g_idx);
34017318:	f8d3 1098 	ldr.w	r1, [r3, #152]	@ 0x98
  if (params->g_size < 0)
3401731c:	da07      	bge.n	3401732e <__LL_LIB_Inputs_Memcpy_End_EpochBlock+0x32>
    params->g_dst_o_src += LL_Buffer_len(((LL_LIB_TensorInfo_TypeDef *)params->g_tensors) + params->g_idx);
3401731e:	2438      	movs	r4, #56	@ 0x38
34017320:	f8d3 00a8 	ldr.w	r0, [r3, #168]	@ 0xa8
34017324:	fb04 0002 	mla	r0, r4, r2, r0
    return LL_Buffer_addr_base(buf) + buf->offset_limit;
  }

  static inline uint32_t LL_Buffer_len(const LL_Buffer_InfoTypeDef *buf)
  {
    return buf->offset_end - buf->offset_start;
34017328:	e9d0 0402 	ldrd	r0, r4, [r0, #8]
3401732c:	1a20      	subs	r0, r4, r0
  params->g_idx++;
3401732e:	3201      	adds	r2, #1
    params->g_dst_o_src += (params->g_size);
34017330:	4401      	add	r1, r0
34017332:	f8c3 1098 	str.w	r1, [r3, #152]	@ 0x98
  params->g_idx++;
34017336:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  if (params->g_idx < params->g_num_tensors)
3401733a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3401733e:	429a      	cmp	r2, r3
34017340:	d203      	bcs.n	3401734a <__LL_LIB_Inputs_Memcpy_End_EpochBlock+0x4e>
}
34017342:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LL_ATON_RT_DecCurrEpochBlock(1);
34017346:	f7ff bf51 	b.w	340171ec <LL_ATON_RT_DecCurrEpochBlock.constprop.0>
}
3401734a:	bd10      	pop	{r4, pc}
3401734c:	340ce898 	.word	0x340ce898

34017350 <__LL_LIB_Concat_Case3_End_EpochBlock>:
{
34017350:	b510      	push	{r4, lr}
34017352:	4603      	mov	r3, r0
  previous_value = eb->wait_mask;
34017354:	68c4      	ldr	r4, [r0, #12]
  eb->wait_mask = wait_mask;
34017356:	2000      	movs	r0, #0
34017358:	60d8      	str	r0, [r3, #12]
  __LL_ATON_RT_SetWaitMask(eb->wait_mask);
3401735a:	f7ff fe5b 	bl	34017014 <__LL_ATON_RT_SetWaitMask>
  if (__ll_lib_set_wait_mask((LL_ATON_RT_EpochBlockItem_t *)epoch_block, 0))
3401735e:	b10c      	cbz	r4, 34017364 <__LL_LIB_Concat_Case3_End_EpochBlock+0x14>
    __ll_lib_stop_transfer();
34017360:	f7ff fe46 	bl	34016ff0 <__ll_lib_stop_transfer>
  params->g_idx++;
34017364:	4923      	ldr	r1, [pc, #140]	@ (340173f4 <__LL_LIB_Concat_Case3_End_EpochBlock+0xa4>)
34017366:	f8d1 3090 	ldr.w	r3, [r1, #144]	@ 0x90
  if (params->g_idx < params->special.concat_case3.in_fheight)
3401736a:	f8d1 20b4 	ldr.w	r2, [r1, #180]	@ 0xb4
  params->g_idx++;
3401736e:	3301      	adds	r3, #1
  if (params->g_idx < params->special.concat_case3.in_fheight)
34017370:	4293      	cmp	r3, r2
  params->g_idx++;
34017372:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
  if (params->g_idx < params->special.concat_case3.in_fheight)
34017376:	d211      	bcs.n	3401739c <__LL_LIB_Concat_Case3_End_EpochBlock+0x4c>
    params->g_dst_o_src += params->special.concat_case3.out_line_size;
34017378:	f8d1 3098 	ldr.w	r3, [r1, #152]	@ 0x98
3401737c:	f8d1 20bc 	ldr.w	r2, [r1, #188]	@ 0xbc
34017380:	4413      	add	r3, r2
34017382:	f8c1 3098 	str.w	r3, [r1, #152]	@ 0x98
    params->special.concat_case3.in_curr += params->g_size;
34017386:	f8d1 2094 	ldr.w	r2, [r1, #148]	@ 0x94
3401738a:	f8d1 30c0 	ldr.w	r3, [r1, #192]	@ 0xc0
3401738e:	4413      	add	r3, r2
34017390:	f8c1 30c0 	str.w	r3, [r1, #192]	@ 0xc0
}
34017394:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      LL_ATON_RT_DecCurrEpochBlock(1);
34017398:	f7ff bf28 	b.w	340171ec <LL_ATON_RT_DecCurrEpochBlock.constprop.0>
    params->special.concat_case3.outer_idx++;
3401739c:	f8d1 30b0 	ldr.w	r3, [r1, #176]	@ 0xb0
    if (params->special.concat_case3.outer_idx < params->g_num_tensors)
340173a0:	f8d1 20a4 	ldr.w	r2, [r1, #164]	@ 0xa4
    params->special.concat_case3.outer_idx++;
340173a4:	3301      	adds	r3, #1
    if (params->special.concat_case3.outer_idx < params->g_num_tensors)
340173a6:	4293      	cmp	r3, r2
    params->special.concat_case3.outer_idx++;
340173a8:	f8c1 30b0 	str.w	r3, [r1, #176]	@ 0xb0
    if (params->special.concat_case3.outer_idx < params->g_num_tensors)
340173ac:	d221      	bcs.n	340173f2 <__LL_LIB_Concat_Case3_End_EpochBlock+0xa2>
      int in_ndims = ((LL_LIB_TensorInfo_TypeDef *)params->g_tensors)[params->special.concat_case3.outer_idx].ndims;
340173ae:	2238      	movs	r2, #56	@ 0x38
340173b0:	f8d1 00a8 	ldr.w	r0, [r1, #168]	@ 0xa8
340173b4:	fb02 0003 	mla	r0, r2, r3, r0
                                  .shape[(in_ndims - 4) + TDIM_NCHANNELS];
340173b8:	f890 2027 	ldrb.w	r2, [r0, #39]	@ 0x27
340173bc:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
340173be:	3a01      	subs	r2, #1
                         .shape[(in_ndims - 4) + TDIM_FWIDTH];
340173c0:	eb04 0382 	add.w	r3, r4, r2, lsl #2
          pix_size * ((LL_LIB_TensorInfo_TypeDef *)params->g_tensors)[params->special.concat_case3.outer_idx]
340173c4:	f853 3c04 	ldr.w	r3, [r3, #-4]
340173c8:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
340173cc:	4353      	muls	r3, r2
340173ce:	f8d1 20b8 	ldr.w	r2, [r1, #184]	@ 0xb8
340173d2:	4353      	muls	r3, r2
      params->g_dst_o_src += params->g_size;
340173d4:	f8d1 2098 	ldr.w	r2, [r1, #152]	@ 0x98
      params->g_size =
340173d8:	f8c1 3094 	str.w	r3, [r1, #148]	@ 0x94
      params->g_dst_o_src += params->g_size;
340173dc:	441a      	add	r2, r3
340173de:	f8c1 2098 	str.w	r2, [r1, #152]	@ 0x98
      params->special.concat_case3.in_curr = LL_Buffer_addr_start(((LL_LIB_TensorInfo_TypeDef *)params->g_tensors) +
340173e2:	f7ff fdfd 	bl	34016fe0 <LL_Buffer_addr_start>
      params->g_idx = 0;
340173e6:	2300      	movs	r3, #0
      params->special.concat_case3.in_curr = LL_Buffer_addr_start(((LL_LIB_TensorInfo_TypeDef *)params->g_tensors) +
340173e8:	f8c1 00c0 	str.w	r0, [r1, #192]	@ 0xc0
      params->g_idx = 0;
340173ec:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
340173f0:	e7d0      	b.n	34017394 <__LL_LIB_Concat_Case3_End_EpochBlock+0x44>
}
340173f2:	bd10      	pop	{r4, pc}
340173f4:	340ce898 	.word	0x340ce898

340173f8 <__ll_lib_memcpy_prolog>:
  if (n < __LL_DMA_MIN_BUFF_LEN)
340173f8:	2a27      	cmp	r2, #39	@ 0x27
{
340173fa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
340173fc:	4613      	mov	r3, r2
  int prolog_len = (n % 3);
340173fe:	bf81      	itttt	hi
34017400:	2303      	movhi	r3, #3
34017402:	fbb2 f3f3 	udivhi	r3, r2, r3
34017406:	eb03 0343 	addhi.w	r3, r3, r3, lsl #1
3401740a:	1ad3      	subhi	r3, r2, r3
3401740c:	2b00      	cmp	r3, #0
3401740e:	f103 0401 	add.w	r4, r3, #1
34017412:	bfb8      	it	lt
34017414:	2401      	movlt	r4, #1
{
34017416:	4605      	mov	r5, r0
  uint8_t *_dst_orig = *dst;
34017418:	6800      	ldr	r0, [r0, #0]
  for (i = 0; i < prolog_len; i++)
3401741a:	3c01      	subs	r4, #1
3401741c:	d106      	bne.n	3401742c <__ll_lib_memcpy_prolog+0x34>
  n -= prolog_len;
3401741e:	1ad4      	subs	r4, r2, r3
  if (prolog_len > 0)
34017420:	b113      	cbz	r3, 34017428 <__ll_lib_memcpy_prolog+0x30>
   *       filled
   */
  static inline void LL_ATON_Cache_MCU_Clean_Invalidate_Range(uintptr_t virtual_addr, uint32_t size)
  {
    LL_ATON_OSAL_LOCK_MCU_CACHE();
    mcu_cache_clean_invalidate_range(virtual_addr, virtual_addr + size);
34017422:	18c1      	adds	r1, r0, r3
34017424:	f7eb fc4a 	bl	34002cbc <mcu_cache_clean_invalidate_range>
}
34017428:	4620      	mov	r0, r4
3401742a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    **_dst = **_src;
3401742c:	680f      	ldr	r7, [r1, #0]
3401742e:	682e      	ldr	r6, [r5, #0]
34017430:	783f      	ldrb	r7, [r7, #0]
34017432:	7037      	strb	r7, [r6, #0]
    (*_dst)++;
34017434:	682e      	ldr	r6, [r5, #0]
34017436:	3601      	adds	r6, #1
34017438:	602e      	str	r6, [r5, #0]
    (*_src)++;
3401743a:	680e      	ldr	r6, [r1, #0]
3401743c:	3601      	adds	r6, #1
3401743e:	600e      	str	r6, [r1, #0]
  for (i = 0; i < prolog_len; i++)
34017440:	e7eb      	b.n	3401741a <__ll_lib_memcpy_prolog+0x22>
	...

34017444 <__ll_lib_inputs_memcpy_start>:
{
34017444:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t *_dst = (uint8_t *)params->g_dst_o_src;
34017446:	4c1e      	ldr	r4, [pc, #120]	@ (340174c0 <__ll_lib_inputs_memcpy_start+0x7c>)
{
34017448:	4605      	mov	r5, r0
  if (params->g_size < 0)
3401744a:	f8d4 0094 	ldr.w	r0, [r4, #148]	@ 0x94
  uint8_t *_dst = (uint8_t *)params->g_dst_o_src;
3401744e:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
  if (params->g_size < 0)
34017452:	2800      	cmp	r0, #0
{
34017454:	9101      	str	r1, [sp, #4]
  uint8_t *_dst = (uint8_t *)params->g_dst_o_src;
34017456:	9303      	str	r3, [sp, #12]
  if (params->g_size < 0)
34017458:	da09      	bge.n	3401746e <__ll_lib_inputs_memcpy_start+0x2a>
    n = LL_Buffer_len(((LL_LIB_TensorInfo_TypeDef *)params->g_tensors) + params->g_idx);
3401745a:	2138      	movs	r1, #56	@ 0x38
3401745c:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
34017460:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
34017464:	fb01 3302 	mla	r3, r1, r2, r3
34017468:	e9d3 0202 	ldrd	r0, r2, [r3, #8]
3401746c:	1a10      	subs	r0, r2, r0
  if (params->g_not_continuous == 0)
3401746e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
34017472:	b923      	cbnz	r3, 3401747e <__ll_lib_inputs_memcpy_start+0x3a>
    n = __ll_lib_memcpy_prolog((void **)&_dst, (void **)&_src, n);
34017474:	4602      	mov	r2, r0
34017476:	a901      	add	r1, sp, #4
34017478:	a803      	add	r0, sp, #12
3401747a:	f7ff ffbd 	bl	340173f8 <__ll_lib_memcpy_prolog>
  if (n > 0)
3401747e:	b1d0      	cbz	r0, 340174b6 <__ll_lib_inputs_memcpy_start+0x72>
    params->g_dma_in.offset_limit = ((LL_LIB_TensorInfo_TypeDef *)params->g_tensors)[params->g_idx].offset_limit;
34017480:	2638      	movs	r6, #56	@ 0x38
    params->g_dma_in.offset_start = 0;
34017482:	2200      	movs	r2, #0
    params->g_dma_in.addr_base.p = _src;
34017484:	9b01      	ldr	r3, [sp, #4]
    params->g_dma_in.offset_limit = ((LL_LIB_TensorInfo_TypeDef *)params->g_tensors)[params->g_idx].offset_limit;
34017486:	f8d4 1090 	ldr.w	r1, [r4, #144]	@ 0x90
    params->g_dma_in.addr_base.p = _src;
3401748a:	6063      	str	r3, [r4, #4]
    params->g_dma_in.offset_limit = ((LL_LIB_TensorInfo_TypeDef *)params->g_tensors)[params->g_idx].offset_limit;
3401748c:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
    params->g_dma_in.offset_end = n; // not used for batched output version g_not_continuous == 1
34017490:	e9c4 2002 	strd	r2, r0, [r4, #8]
    params->g_dma_in.offset_limit = ((LL_LIB_TensorInfo_TypeDef *)params->g_tensors)[params->g_idx].offset_limit;
34017494:	fb06 3301 	mla	r3, r6, r1, r3
34017498:	691b      	ldr	r3, [r3, #16]
    params->g_dma_out.offset_end = n; // not used for batched input version g_not_continuous == 1
3401749a:	6560      	str	r0, [r4, #84]	@ 0x54
    params->g_dma_in.offset_limit = ((LL_LIB_TensorInfo_TypeDef *)params->g_tensors)[params->g_idx].offset_limit;
3401749c:	6123      	str	r3, [r4, #16]
    __ll_lib_set_wait_mask((LL_ATON_RT_EpochBlockItem_t *)epoch_block, params->g_wait_mask);
3401749e:	f8d4 00ac 	ldr.w	r0, [r4, #172]	@ 0xac
    params->g_dma_out.addr_base.p = _dst;
340174a2:	9b03      	ldr	r3, [sp, #12]
    params->g_dma_out.offset_start = 0;
340174a4:	e9c4 3213 	strd	r3, r2, [r4, #76]	@ 0x4c
  eb->wait_mask = wait_mask;
340174a8:	60e8      	str	r0, [r5, #12]
  __LL_ATON_RT_SetWaitMask(eb->wait_mask);
340174aa:	f7ff fdb3 	bl	34017014 <__LL_ATON_RT_SetWaitMask>
    __ll_lib_start_transfer(params);
340174ae:	f7ff fe7b 	bl	340171a8 <__ll_lib_start_transfer.constprop.0>
}
340174b2:	b004      	add	sp, #16
340174b4:	bd70      	pop	{r4, r5, r6, pc}
  eb->wait_mask = wait_mask;
340174b6:	60e8      	str	r0, [r5, #12]
  __LL_ATON_RT_SetWaitMask(eb->wait_mask);
340174b8:	f7ff fdac 	bl	34017014 <__LL_ATON_RT_SetWaitMask>
}
340174bc:	e7f9      	b.n	340174b2 <__ll_lib_inputs_memcpy_start+0x6e>
340174be:	bf00      	nop
340174c0:	340ce898 	.word	0x340ce898

340174c4 <__LL_LIB_Concat_Case3_Start_EpochBlock>:
{
340174c4:	b508      	push	{r3, lr}
  LL_ATON_ASSERT((params->special.concat_case3.outer_idx < params->g_num_tensors) &&
340174c6:	4b0d      	ldr	r3, [pc, #52]	@ (340174fc <__LL_LIB_Concat_Case3_Start_EpochBlock+0x38>)
340174c8:	f8d3 10b0 	ldr.w	r1, [r3, #176]	@ 0xb0
340174cc:	f8d3 20a4 	ldr.w	r2, [r3, #164]	@ 0xa4
340174d0:	4291      	cmp	r1, r2
340174d2:	d205      	bcs.n	340174e0 <__LL_LIB_Concat_Case3_Start_EpochBlock+0x1c>
340174d4:	f8d3 1090 	ldr.w	r1, [r3, #144]	@ 0x90
340174d8:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
340174dc:	4291      	cmp	r1, r2
340174de:	d306      	bcc.n	340174ee <__LL_LIB_Concat_Case3_Start_EpochBlock+0x2a>
340174e0:	f240 1193 	movw	r1, #403	@ 0x193
340174e4:	4b06      	ldr	r3, [pc, #24]	@ (34017500 <__LL_LIB_Concat_Case3_Start_EpochBlock+0x3c>)
340174e6:	4a07      	ldr	r2, [pc, #28]	@ (34017504 <__LL_LIB_Concat_Case3_Start_EpochBlock+0x40>)
340174e8:	4807      	ldr	r0, [pc, #28]	@ (34017508 <__LL_LIB_Concat_Case3_Start_EpochBlock+0x44>)
340174ea:	f001 fcb7 	bl	34018e5c <__assert_func>
  __ll_lib_inputs_memcpy_start(epoch_block, (uint8_t *)params->special.concat_case3.in_curr);
340174ee:	f8d3 10c0 	ldr.w	r1, [r3, #192]	@ 0xc0
}
340174f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  __ll_lib_inputs_memcpy_start(epoch_block, (uint8_t *)params->special.concat_case3.in_curr);
340174f6:	f7ff bfa5 	b.w	34017444 <__ll_lib_inputs_memcpy_start>
340174fa:	bf00      	nop
340174fc:	340ce898 	.word	0x340ce898
34017500:	340214ce 	.word	0x340214ce
34017504:	340ae4b0 	.word	0x340ae4b0
34017508:	340213b2 	.word	0x340213b2

3401750c <__LL_LIB_Inputs_Memcpy_Start_EpochBlock>:
  LL_ATON_ASSERT(params->g_idx < params->g_num_tensors); // must be checked before
3401750c:	4b0e      	ldr	r3, [pc, #56]	@ (34017548 <__LL_LIB_Inputs_Memcpy_Start_EpochBlock+0x3c>)
{
3401750e:	b510      	push	{r4, lr}
  LL_ATON_ASSERT(params->g_idx < params->g_num_tensors); // must be checked before
34017510:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34017514:	f8d3 10a4 	ldr.w	r1, [r3, #164]	@ 0xa4
{
34017518:	4604      	mov	r4, r0
  LL_ATON_ASSERT(params->g_idx < params->g_num_tensors); // must be checked before
3401751a:	428a      	cmp	r2, r1
3401751c:	d306      	bcc.n	3401752c <__LL_LIB_Inputs_Memcpy_Start_EpochBlock+0x20>
3401751e:	f240 11cb 	movw	r1, #459	@ 0x1cb
34017522:	4b0a      	ldr	r3, [pc, #40]	@ (3401754c <__LL_LIB_Inputs_Memcpy_Start_EpochBlock+0x40>)
34017524:	4a0a      	ldr	r2, [pc, #40]	@ (34017550 <__LL_LIB_Inputs_Memcpy_Start_EpochBlock+0x44>)
34017526:	480b      	ldr	r0, [pc, #44]	@ (34017554 <__LL_LIB_Inputs_Memcpy_Start_EpochBlock+0x48>)
34017528:	f001 fc98 	bl	34018e5c <__assert_func>
  uint8_t *src = (uint8_t *)LL_Buffer_addr_start(((LL_LIB_TensorInfo_TypeDef *)params->g_tensors) + params->g_idx);
3401752c:	2038      	movs	r0, #56	@ 0x38
3401752e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34017532:	fb00 3002 	mla	r0, r0, r2, r3
34017536:	f7ff fd53 	bl	34016fe0 <LL_Buffer_addr_start>
3401753a:	4601      	mov	r1, r0
  __ll_lib_inputs_memcpy_start(epoch_block, src);
3401753c:	4620      	mov	r0, r4
}
3401753e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __ll_lib_inputs_memcpy_start(epoch_block, src);
34017542:	f7ff bf7f 	b.w	34017444 <__ll_lib_inputs_memcpy_start>
34017546:	bf00      	nop
34017548:	340ce898 	.word	0x340ce898
3401754c:	3402154c 	.word	0x3402154c
34017550:	340ae488 	.word	0x340ae488
34017554:	340213b2 	.word	0x340213b2

34017558 <__LL_LIB_Inputs_Batched_Memcpy_Start_EpochBlock>:
  LL_ATON_ASSERT(params->g_idx < params->g_num_tensors); // must be checked before
34017558:	4b0f      	ldr	r3, [pc, #60]	@ (34017598 <__LL_LIB_Inputs_Batched_Memcpy_Start_EpochBlock+0x40>)
{
3401755a:	b510      	push	{r4, lr}
  LL_ATON_ASSERT(params->g_idx < params->g_num_tensors); // must be checked before
3401755c:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34017560:	f8d3 10a4 	ldr.w	r1, [r3, #164]	@ 0xa4
{
34017564:	4604      	mov	r4, r0
  LL_ATON_ASSERT(params->g_idx < params->g_num_tensors); // must be checked before
34017566:	428a      	cmp	r2, r1
34017568:	d306      	bcc.n	34017578 <__LL_LIB_Inputs_Batched_Memcpy_Start_EpochBlock+0x20>
3401756a:	f44f 71f9 	mov.w	r1, #498	@ 0x1f2
3401756e:	4b0b      	ldr	r3, [pc, #44]	@ (3401759c <__LL_LIB_Inputs_Batched_Memcpy_Start_EpochBlock+0x44>)
34017570:	4a0b      	ldr	r2, [pc, #44]	@ (340175a0 <__LL_LIB_Inputs_Batched_Memcpy_Start_EpochBlock+0x48>)
34017572:	480c      	ldr	r0, [pc, #48]	@ (340175a4 <__LL_LIB_Inputs_Batched_Memcpy_Start_EpochBlock+0x4c>)
34017574:	f001 fc72 	bl	34018e5c <__assert_func>
  params->g_not_continuous =
34017578:	2101      	movs	r1, #1
  uint8_t *src = (uint8_t *)LL_Buffer_addr_start(((LL_LIB_TensorInfo_TypeDef *)params->g_tensors) + params->g_idx);
3401757a:	2038      	movs	r0, #56	@ 0x38
  params->g_not_continuous =
3401757c:	f8c3 10a0 	str.w	r1, [r3, #160]	@ 0xa0
  uint8_t *src = (uint8_t *)LL_Buffer_addr_start(((LL_LIB_TensorInfo_TypeDef *)params->g_tensors) + params->g_idx);
34017580:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34017584:	fb00 3002 	mla	r0, r0, r2, r3
34017588:	f7ff fd2a 	bl	34016fe0 <LL_Buffer_addr_start>
3401758c:	4601      	mov	r1, r0
  __ll_lib_inputs_memcpy_start(epoch_block, src);
3401758e:	4620      	mov	r0, r4
}
34017590:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __ll_lib_inputs_memcpy_start(epoch_block, src);
34017594:	f7ff bf56 	b.w	34017444 <__ll_lib_inputs_memcpy_start>
34017598:	340ce898 	.word	0x340ce898
3401759c:	3402154c 	.word	0x3402154c
340175a0:	340ae458 	.word	0x340ae458
340175a4:	340213b2 	.word	0x340213b2

340175a8 <__ll_lib_error>:
{
340175a8:	b410      	push	{r4}
340175aa:	460c      	mov	r4, r1
340175ac:	3801      	subs	r0, #1
340175ae:	280f      	cmp	r0, #15
340175b0:	bf98      	it	ls
340175b2:	4b06      	ldrls	r3, [pc, #24]	@ (340175cc <__ll_lib_error+0x24>)
340175b4:	4611      	mov	r1, r2
340175b6:	bf98      	it	ls
340175b8:	f853 3020 	ldrls.w	r3, [r3, r0, lsl #2]
  LL_ATON_PRINTF("%s line %d LL_LIB Error: %s\n", func, line, errs);
340175bc:	4622      	mov	r2, r4
  switch (err_code)
340175be:	bf88      	it	hi
340175c0:	4b03      	ldrhi	r3, [pc, #12]	@ (340175d0 <__ll_lib_error+0x28>)
  LL_ATON_PRINTF("%s line %d LL_LIB Error: %s\n", func, line, errs);
340175c2:	4804      	ldr	r0, [pc, #16]	@ (340175d4 <__ll_lib_error+0x2c>)
}
340175c4:	f85d 4b04 	ldr.w	r4, [sp], #4
  LL_ATON_PRINTF("%s line %d LL_LIB Error: %s\n", func, line, errs);
340175c8:	f002 bbd8 	b.w	34019d7c <iprintf>
340175cc:	340ae418 	.word	0x340ae418
340175d0:	34021572 	.word	0x34021572
340175d4:	3402157a 	.word	0x3402157a

340175d8 <LL_ATON_LIB_DMA_RowToImage>:
 *
 */
int LL_ATON_LIB_DMA_RowToImage(const LL_LIB_TensorInfo_TypeDef *inputs, unsigned int ninputs,
                               const LL_LIB_TensorInfo_TypeDef *output, unsigned blocksize_h, unsigned blocksize_w,
                               unsigned stride_h, unsigned stride_w, int dma_in, int dma_out)
{
340175d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340175dc:	4690      	mov	r8, r2
340175de:	4604      	mov	r4, r0
340175e0:	469a      	mov	sl, r3
  int in_batches = inputs[0].shape[TDIM_NKERNELS];
340175e2:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
{
340175e4:	b0ab      	sub	sp, #172	@ 0xac
  int in_fwidth = inputs[0].shape[TDIM_FWIDTH];
  int in_fheight = inputs[0].shape[TDIM_FHEIGHT];
340175e6:	e9d3 2701 	ldrd	r2, r7, [r3, #4]
340175ea:	9202      	str	r2, [sp, #8]
  int in_nchannels = inputs[0].shape[TDIM_NCHANNELS];
  int out_batches = output->shape[TDIM_NKERNELS];
340175ec:	f8d8 202c 	ldr.w	r2, [r8, #44]	@ 0x2c
  int in_batches = inputs[0].shape[TDIM_NKERNELS];
340175f0:	681e      	ldr	r6, [r3, #0]
  int in_nchannels = inputs[0].shape[TDIM_NCHANNELS];
340175f2:	68d8      	ldr	r0, [r3, #12]
  int out_batches = output->shape[TDIM_NKERNELS];
340175f4:	6813      	ldr	r3, [r2, #0]
  int out_fwidth = output->shape[TDIM_FWIDTH];
  int out_fheight = output->shape[TDIM_FHEIGHT];
  int out_nchannels = output->shape[TDIM_NCHANNELS];
340175f6:	f8d2 900c 	ldr.w	r9, [r2, #12]
  int out_batches = output->shape[TDIM_NKERNELS];
340175fa:	9304      	str	r3, [sp, #16]
  int out_fwidth = output->shape[TDIM_FWIDTH];
340175fc:	6893      	ldr	r3, [r2, #8]
  int nbits = inputs[0].nbits;
340175fe:	f894 c028 	ldrb.w	ip, [r4, #40]	@ 0x28
  int out_fwidth = output->shape[TDIM_FWIDTH];
34017602:	9303      	str	r3, [sp, #12]
  int out_fheight = output->shape[TDIM_FHEIGHT];
34017604:	6853      	ldr	r3, [r2, #4]
  unsigned nbits_unsigned = inputs[0].Qunsigned;
34017606:	f894 2026 	ldrb.w	r2, [r4, #38]	@ 0x26
  int nbytes = (nbits + 7) >> 3;
3401760a:	f10c 0507 	add.w	r5, ip, #7
  unsigned nbits_unsigned = inputs[0].Qunsigned;
3401760e:	9205      	str	r2, [sp, #20]
  uint32_t in_bytes_size = in_fwidth * in_fheight * in_nchannels * in_batches * nbytes;
34017610:	9a02      	ldr	r2, [sp, #8]
  int nbytes = (nbits + 7) >> 3;
34017612:	10ed      	asrs	r5, r5, #3
  uint32_t in_bytes_size = in_fwidth * in_fheight * in_nchannels * in_batches * nbytes;
34017614:	437a      	muls	r2, r7
34017616:	4342      	muls	r2, r0
34017618:	4372      	muls	r2, r6
  /*
LL_ATON_PRINTF("in: b=%d w=%d g=%d c=%d\n",in_batches,in_fwidth,in_fheight,in_nchannels);
LL_ATON_PRINTF("out: b=%d w=%d g=%d c=%d ndims=%d\n",out_batches,out_fwidth,out_fheight,out_nchannels,output->ndims);
   */

  if (ninputs != 1)
3401761a:	2901      	cmp	r1, #1
  uint32_t in_bytes_size = in_fwidth * in_fheight * in_nchannels * in_batches * nbytes;
3401761c:	fb05 fb02 	mul.w	fp, r5, r2
  if (ninputs != 1)
34017620:	d00a      	beq.n	34017638 <LL_ATON_LIB_DMA_RowToImage+0x60>
    __LL_LIB_ERROR(_ERR_NINPUTS, LL_ATON_INVALID_PARAM);
34017622:	f44f 61dc 	mov.w	r1, #1760	@ 0x6e0
34017626:	2001      	movs	r0, #1
34017628:	4a62      	ldr	r2, [pc, #392]	@ (340177b4 <LL_ATON_LIB_DMA_RowToImage+0x1dc>)

  if (nbits != output->nbits)
    __LL_LIB_ERROR(_ERR_NBITS, LL_ATON_INVALID_PARAM);
3401762a:	f7ff ffbd 	bl	340175a8 <__ll_lib_error>
    __LL_LIB_ERROR(_ERR_NINPUTS, LL_ATON_INVALID_PARAM);
3401762e:	f06f 0001 	mvn.w	r0, #1

  /* start epoch block sequence */
  LL_ATON_RT_Insert_LibEpochBlockArray(_dma_ri2ir_epoch_block_array);

  return LL_ATON_OK;
}
34017632:	b02b      	add	sp, #172	@ 0xac
34017634:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (nbits != output->nbits)
34017638:	f898 2028 	ldrb.w	r2, [r8, #40]	@ 0x28
3401763c:	4562      	cmp	r2, ip
3401763e:	d004      	beq.n	3401764a <LL_ATON_LIB_DMA_RowToImage+0x72>
    __LL_LIB_ERROR(_ERR_NBITS, LL_ATON_INVALID_PARAM);
34017640:	f240 61e3 	movw	r1, #1763	@ 0x6e3
34017644:	2006      	movs	r0, #6
34017646:	4a5b      	ldr	r2, [pc, #364]	@ (340177b4 <LL_ATON_LIB_DMA_RowToImage+0x1dc>)
34017648:	e7ef      	b.n	3401762a <LL_ATON_LIB_DMA_RowToImage+0x52>
  if ((output->ndims < 1) || (output->ndims > 4))
3401764a:	f898 2027 	ldrb.w	r2, [r8, #39]	@ 0x27
3401764e:	3a01      	subs	r2, #1
34017650:	2a03      	cmp	r2, #3
34017652:	d904      	bls.n	3401765e <LL_ATON_LIB_DMA_RowToImage+0x86>
    __LL_LIB_ERROR(_ERR_SHAPE_OUT, LL_ATON_INVALID_PARAM);
34017654:	f240 61e6 	movw	r1, #1766	@ 0x6e6
34017658:	200b      	movs	r0, #11
3401765a:	4a56      	ldr	r2, [pc, #344]	@ (340177b4 <LL_ATON_LIB_DMA_RowToImage+0x1dc>)
3401765c:	e7e5      	b.n	3401762a <LL_ATON_LIB_DMA_RowToImage+0x52>
  if ((inputs[0].ndims < 1) || (inputs[0].ndims > 4))
3401765e:	f894 2027 	ldrb.w	r2, [r4, #39]	@ 0x27
34017662:	3a01      	subs	r2, #1
34017664:	2a03      	cmp	r2, #3
34017666:	d904      	bls.n	34017672 <LL_ATON_LIB_DMA_RowToImage+0x9a>
    __LL_LIB_ERROR(_ERR_SHAPE_IN, LL_ATON_INVALID_PARAM);
34017668:	f240 61e9 	movw	r1, #1769	@ 0x6e9
3401766c:	200a      	movs	r0, #10
3401766e:	4a51      	ldr	r2, [pc, #324]	@ (340177b4 <LL_ATON_LIB_DMA_RowToImage+0x1dc>)
34017670:	e7db      	b.n	3401762a <LL_ATON_LIB_DMA_RowToImage+0x52>
  if (in_batches != out_batches || in_nchannels != out_nchannels * (blocksize_h * blocksize_w) ||
34017672:	9a04      	ldr	r2, [sp, #16]
34017674:	4296      	cmp	r6, r2
34017676:	d124      	bne.n	340176c2 <LL_ATON_LIB_DMA_RowToImage+0xea>
34017678:	9a34      	ldr	r2, [sp, #208]	@ 0xd0
3401767a:	fb02 f20a 	mul.w	r2, r2, sl
3401767e:	fb09 f202 	mul.w	r2, r9, r2
34017682:	4290      	cmp	r0, r2
34017684:	d11d      	bne.n	340176c2 <LL_ATON_LIB_DMA_RowToImage+0xea>
34017686:	9a03      	ldr	r2, [sp, #12]
34017688:	9934      	ldr	r1, [sp, #208]	@ 0xd0
3401768a:	428a      	cmp	r2, r1
3401768c:	d319      	bcc.n	340176c2 <LL_ATON_LIB_DMA_RowToImage+0xea>
      (out_fwidth < blocksize_w) || (out_fheight < blocksize_h) || ((out_fwidth - blocksize_w) % stride_w) ||
3401768e:	4553      	cmp	r3, sl
34017690:	d317      	bcc.n	340176c2 <LL_ATON_LIB_DMA_RowToImage+0xea>
34017692:	1a52      	subs	r2, r2, r1
34017694:	9936      	ldr	r1, [sp, #216]	@ 0xd8
34017696:	9836      	ldr	r0, [sp, #216]	@ 0xd8
34017698:	fbb2 f1f1 	udiv	r1, r2, r1
3401769c:	fb00 2211 	mls	r2, r0, r1, r2
340176a0:	b97a      	cbnz	r2, 340176c2 <LL_ATON_LIB_DMA_RowToImage+0xea>
      ((out_fheight - blocksize_h) % stride_h) || (in_fwidth != (((out_fwidth - blocksize_w) / stride_w) + 1)) ||
340176a2:	9a35      	ldr	r2, [sp, #212]	@ 0xd4
340176a4:	eba3 030a 	sub.w	r3, r3, sl
340176a8:	fbb3 f2f2 	udiv	r2, r3, r2
340176ac:	9835      	ldr	r0, [sp, #212]	@ 0xd4
340176ae:	fb00 3312 	mls	r3, r0, r2, r3
      (out_fwidth < blocksize_w) || (out_fheight < blocksize_h) || ((out_fwidth - blocksize_w) % stride_w) ||
340176b2:	b933      	cbnz	r3, 340176c2 <LL_ATON_LIB_DMA_RowToImage+0xea>
      ((out_fheight - blocksize_h) % stride_h) || (in_fwidth != (((out_fwidth - blocksize_w) / stride_w) + 1)) ||
340176b4:	3101      	adds	r1, #1
340176b6:	428f      	cmp	r7, r1
340176b8:	d103      	bne.n	340176c2 <LL_ATON_LIB_DMA_RowToImage+0xea>
340176ba:	9b02      	ldr	r3, [sp, #8]
      (in_fheight != (((out_fheight - blocksize_h) / stride_h) + 1)))
340176bc:	3201      	adds	r2, #1
      ((out_fheight - blocksize_h) % stride_h) || (in_fwidth != (((out_fwidth - blocksize_w) / stride_w) + 1)) ||
340176be:	4293      	cmp	r3, r2
340176c0:	d004      	beq.n	340176cc <LL_ATON_LIB_DMA_RowToImage+0xf4>
    __LL_LIB_ERROR(_ERR_SHAPE, LL_ATON_INVALID_PARAM);
340176c2:	f240 61ef 	movw	r1, #1775	@ 0x6ef
340176c6:	2009      	movs	r0, #9
340176c8:	4a3a      	ldr	r2, [pc, #232]	@ (340177b4 <LL_ATON_LIB_DMA_RowToImage+0x1dc>)
340176ca:	e7ae      	b.n	3401762a <LL_ATON_LIB_DMA_RowToImage+0x52>
  LL_Streng_TensorInitTypeDef _dma_in = {
340176cc:	2248      	movs	r2, #72	@ 0x48
340176ce:	2100      	movs	r1, #0
340176d0:	a806      	add	r0, sp, #24
340176d2:	f002 fd27 	bl	3401a124 <memset>
340176d6:	2302      	movs	r3, #2
340176d8:	f04f 0200 	mov.w	r2, #0
340176dc:	f88d 3018 	strb.w	r3, [sp, #24]
340176e0:	9b05      	ldr	r3, [sp, #20]
340176e2:	2d04      	cmp	r5, #4
340176e4:	f003 0301 	and.w	r3, r3, #1
340176e8:	f363 0241 	bfi	r2, r3, #1, #1
340176ec:	f88d 2019 	strb.w	r2, [sp, #25]
340176f0:	6862      	ldr	r2, [r4, #4]
340176f2:	ea4f 06c5 	mov.w	r6, r5, lsl #3
340176f6:	9207      	str	r2, [sp, #28]
      .offset_start = inputs[0].offset_start,
340176f8:	68a2      	ldr	r2, [r4, #8]
  LL_Streng_TensorInitTypeDef _dma_in = {
340176fa:	b2f6      	uxtb	r6, r6
340176fc:	9208      	str	r2, [sp, #32]
340176fe:	bf08      	it	eq
34017700:	2610      	moveq	r6, #16
      .offset_end = inputs[0].offset_start + in_bytes_size,
34017702:	445a      	add	r2, fp
  LL_Streng_TensorInitTypeDef _dma_in = {
34017704:	f04f 0b01 	mov.w	fp, #1
34017708:	9209      	str	r2, [sp, #36]	@ 0x24
3401770a:	6922      	ldr	r2, [r4, #16]
  LL_Streng_TensorInitTypeDef _dma_out = {
3401770c:	2100      	movs	r1, #0
  LL_Streng_TensorInitTypeDef _dma_in = {
3401770e:	920a      	str	r2, [sp, #40]	@ 0x28
  LL_Streng_TensorInitTypeDef _dma_out = {
34017710:	a818      	add	r0, sp, #96	@ 0x60
34017712:	2248      	movs	r2, #72	@ 0x48
  LL_Streng_TensorInitTypeDef _dma_in = {
34017714:	9305      	str	r3, [sp, #20]
34017716:	f8cd b058 	str.w	fp, [sp, #88]	@ 0x58
3401771a:	f88d 605c 	strb.w	r6, [sp, #92]	@ 0x5c
3401771e:	f88d 605d 	strb.w	r6, [sp, #93]	@ 0x5d
  LL_Streng_TensorInitTypeDef _dma_out = {
34017722:	f002 fcff 	bl	3401a124 <memset>
34017726:	f04f 0200 	mov.w	r2, #0
3401772a:	9b05      	ldr	r3, [sp, #20]
      .batch_depth = (nbytes == 4) ? (2 * out_nchannels) : out_nchannels,
3401772c:	2d04      	cmp	r5, #4
  LL_Streng_TensorInitTypeDef _dma_out = {
3401772e:	f363 0241 	bfi	r2, r3, #1, #1
34017732:	f8d8 3004 	ldr.w	r3, [r8, #4]
34017736:	f88d 2061 	strb.w	r2, [sp, #97]	@ 0x61
3401773a:	9319      	str	r3, [sp, #100]	@ 0x64
3401773c:	f8d8 3008 	ldr.w	r3, [r8, #8]
  __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out,
34017740:	4659      	mov	r1, fp
  LL_Streng_TensorInitTypeDef _dma_out = {
34017742:	931a      	str	r3, [sp, #104]	@ 0x68
34017744:	9b34      	ldr	r3, [sp, #208]	@ 0xd0
  __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out,
34017746:	4620      	mov	r0, r4
  LL_Streng_TensorInitTypeDef _dma_out = {
34017748:	e9cd 3a1e 	strd	r3, sl, [sp, #120]	@ 0x78
      .batch_depth = (nbytes == 4) ? (2 * out_nchannels) : out_nchannels,
3401774c:	fa09 f30b 	lsl.w	r3, r9, fp
34017750:	bf18      	it	ne
34017752:	464b      	movne	r3, r9
  LL_Streng_TensorInitTypeDef _dma_out = {
34017754:	9320      	str	r3, [sp, #128]	@ 0x80
      .batch_offset = out_nchannels * nbytes,
34017756:	fb05 f309 	mul.w	r3, r5, r9
  LL_Streng_TensorInitTypeDef _dma_out = {
3401775a:	9321      	str	r3, [sp, #132]	@ 0x84
      .frame_offset = stride_w * out_nchannels * nbytes,
3401775c:	9b36      	ldr	r3, [sp, #216]	@ 0xd8
  LL_Streng_TensorInitTypeDef _dma_out = {
3401775e:	f88d b060 	strb.w	fp, [sp, #96]	@ 0x60
      .frame_offset = stride_w * out_nchannels * nbytes,
34017762:	fb03 f309 	mul.w	r3, r3, r9
34017766:	436b      	muls	r3, r5
  LL_Streng_TensorInitTypeDef _dma_out = {
34017768:	9322      	str	r3, [sp, #136]	@ 0x88
      .line_offset = out_fwidth * out_nchannels * nbytes,
3401776a:	9b03      	ldr	r3, [sp, #12]
3401776c:	f88d 60a4 	strb.w	r6, [sp, #164]	@ 0xa4
34017770:	fb09 f303 	mul.w	r3, r9, r3
34017774:	fb05 f203 	mul.w	r2, r5, r3
  LL_Streng_TensorInitTypeDef _dma_out = {
34017778:	9223      	str	r2, [sp, #140]	@ 0x8c
      .loop_offset = stride_h * out_fwidth * out_nchannels * nbytes,
3401777a:	9a35      	ldr	r2, [sp, #212]	@ 0xd4
  LL_Streng_TensorInitTypeDef _dma_out = {
3401777c:	f88d 60a5 	strb.w	r6, [sp, #165]	@ 0xa5
      .loop_offset = stride_h * out_fwidth * out_nchannels * nbytes,
34017780:	4353      	muls	r3, r2
34017782:	436b      	muls	r3, r5
  __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out,
34017784:	2500      	movs	r5, #0
  LL_Streng_TensorInitTypeDef _dma_out = {
34017786:	e9cd 3724 	strd	r3, r7, [sp, #144]	@ 0x90
          out_batches * (((out_fheight - blocksize_h) / stride_h) + 1) * (((out_fwidth - blocksize_w) / stride_w) + 1),
3401778a:	9b02      	ldr	r3, [sp, #8]
  __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out,
3401778c:	aa06      	add	r2, sp, #24
          out_batches * (((out_fheight - blocksize_h) / stride_h) + 1) * (((out_fwidth - blocksize_w) / stride_w) + 1),
3401778e:	435f      	muls	r7, r3
34017790:	9b04      	ldr	r3, [sp, #16]
  __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out,
34017792:	e9cd 5500 	strd	r5, r5, [sp]
          out_batches * (((out_fheight - blocksize_h) / stride_h) + 1) * (((out_fwidth - blocksize_w) / stride_w) + 1),
34017796:	435f      	muls	r7, r3
  __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out,
34017798:	ab18      	add	r3, sp, #96	@ 0x60
  LL_Streng_TensorInitTypeDef _dma_out = {
3401779a:	9728      	str	r7, [sp, #160]	@ 0xa0
  __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out,
3401779c:	f7ff fcb2 	bl	34017104 <__ll_lib_prepare_inputs_epoch>
  __ll_lib_strswitch_set_dmas(dma_in, dma_out, _dma_ri2ir_epoch_block_array);
340177a0:	e9dd 0137 	ldrd	r0, r1, [sp, #220]	@ 0xdc
340177a4:	4a04      	ldr	r2, [pc, #16]	@ (340177b8 <LL_ATON_LIB_DMA_RowToImage+0x1e0>)
340177a6:	f7ff fc51 	bl	3401704c <__ll_lib_strswitch_set_dmas>
  LL_ATON_RT_Insert_LibEpochBlockArray(_dma_ri2ir_epoch_block_array);
340177aa:	4803      	ldr	r0, [pc, #12]	@ (340177b8 <LL_ATON_LIB_DMA_RowToImage+0x1e0>)
340177ac:	f7ff fc82 	bl	340170b4 <LL_ATON_RT_Insert_LibEpochBlockArray>
  return LL_ATON_OK;
340177b0:	4628      	mov	r0, r5
340177b2:	e73e      	b.n	34017632 <LL_ATON_LIB_DMA_RowToImage+0x5a>
340177b4:	340ae566 	.word	0x340ae566
340177b8:	340b1044 	.word	0x340b1044

340177bc <LL_ATON_LIB_DMA_DepthToSpace>:
 *
 */
int LL_ATON_LIB_DMA_DepthToSpace(const LL_LIB_TensorInfo_TypeDef *inputs, unsigned int ninputs,
                                 const LL_LIB_TensorInfo_TypeDef *output, unsigned blocksize_h, unsigned blocksize_w,
                                 int dma_in, int dma_out)
{
340177bc:	b530      	push	{r4, r5, lr}
340177be:	b087      	sub	sp, #28
  return LL_ATON_LIB_DMA_RowToImage(inputs, ninputs, output, blocksize_h, blocksize_w, blocksize_h, blocksize_w, dma_in,
340177c0:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
{
340177c2:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
  return LL_ATON_LIB_DMA_RowToImage(inputs, ninputs, output, blocksize_h, blocksize_w, blocksize_h, blocksize_w, dma_in,
340177c4:	9504      	str	r5, [sp, #16]
340177c6:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
340177c8:	e9cd 4300 	strd	r4, r3, [sp]
340177cc:	e9cd 4502 	strd	r4, r5, [sp, #8]
340177d0:	f7ff ff02 	bl	340175d8 <LL_ATON_LIB_DMA_RowToImage>
                                    dma_out);
}
340177d4:	b007      	add	sp, #28
340177d6:	bd30      	pop	{r4, r5, pc}

340177d8 <LL_ATON_LIB_Concat>:
 * @param  axis for concatenation
 * @retval Error code
 */
int LL_ATON_LIB_Concat(const LL_Buffer_InfoTypeDef *inputs, unsigned int ninputs, const LL_Buffer_InfoTypeDef *output,
                       unsigned int axis, int dma_in, int dma_out)
{
340177d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340177dc:	b0bb      	sub	sp, #236	@ 0xec
340177de:	4605      	mov	r5, r0
340177e0:	4617      	mov	r7, r2
  int i, k;

  // LL_ATON_PRINTF("Concat ------ axis=%d\n", axis);
  if (ninputs == 0)
340177e2:	460e      	mov	r6, r1
{
340177e4:	9305      	str	r3, [sp, #20]
  if (ninputs == 0)
340177e6:	b951      	cbnz	r1, 340177fe <LL_ATON_LIB_Concat+0x26>
    __LL_LIB_ERROR(_ERR_NINPUTS, LL_ATON_INVALID_PARAM);
340177e8:	f44f 61fa 	mov.w	r1, #2000	@ 0x7d0
340177ec:	2001      	movs	r0, #1
340177ee:	4a98      	ldr	r2, [pc, #608]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)

  int in_ndims = inputs[0].ndims;

  if (in_ndims < 4)
    __LL_LIB_ERROR(_ERR_SHAPE, LL_ATON_INVALID_PARAM);
340177f0:	f7ff feda 	bl	340175a8 <__ll_lib_error>
    __LL_LIB_ERROR(_ERR_NINPUTS, LL_ATON_INVALID_PARAM);
340177f4:	f06f 0001 	mvn.w	r0, #1
    }
    start += copy_val;
  }

  return LL_ATON_OK;
}
340177f8:	b03b      	add	sp, #236	@ 0xec
340177fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  int in_ndims = inputs[0].ndims;
340177fe:	f890 4027 	ldrb.w	r4, [r0, #39]	@ 0x27
  if (in_ndims < 4)
34017802:	2c03      	cmp	r4, #3
34017804:	dc04      	bgt.n	34017810 <LL_ATON_LIB_Concat+0x38>
    __LL_LIB_ERROR(_ERR_SHAPE, LL_ATON_INVALID_PARAM);
34017806:	f240 71d5 	movw	r1, #2005	@ 0x7d5
3401780a:	4a91      	ldr	r2, [pc, #580]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
3401780c:	2009      	movs	r0, #9
3401780e:	e7ef      	b.n	340177f0 <LL_ATON_LIB_Concat+0x18>
  int in_batch = inputs[0].batch;
34017810:	6983      	ldr	r3, [r0, #24]
  int in_fheight = inputs[0].shape[(in_ndims - 4) + TDIM_FHEIGHT];
34017812:	f8d0 802c 	ldr.w	r8, [r0, #44]	@ 0x2c
  int in_batch = inputs[0].batch;
34017816:	9302      	str	r3, [sp, #8]
  int in_fheight = inputs[0].shape[(in_ndims - 4) + TDIM_FHEIGHT];
34017818:	1ee3      	subs	r3, r4, #3
3401781a:	009a      	lsls	r2, r3, #2
3401781c:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
  int out_fwidth = output->shape[(in_ndims - 4) + TDIM_FWIDTH];
34017820:	f8d7 b02c 	ldr.w	fp, [r7, #44]	@ 0x2c
  int in_fheight = inputs[0].shape[(in_ndims - 4) + TDIM_FHEIGHT];
34017824:	9306      	str	r3, [sp, #24]
  int in_nchannels = inputs[0].shape[(in_ndims - 4) + TDIM_NCHANNELS];
34017826:	4613      	mov	r3, r2
34017828:	3308      	adds	r3, #8
3401782a:	9307      	str	r3, [sp, #28]
3401782c:	f858 3003 	ldr.w	r3, [r8, r3]
  int axis_lut[] = {TDIM_NKERNELS, TDIM_NCHANNELS, TDIM_FHEIGHT, TDIM_FWIDTH}; // 0, 3, 1, 2
34017830:	f10d 0c48 	add.w	ip, sp, #72	@ 0x48
  int in_nchannels = inputs[0].shape[(in_ndims - 4) + TDIM_NCHANNELS];
34017834:	9303      	str	r3, [sp, #12]
  int out_batch = output->batch;
34017836:	69bb      	ldr	r3, [r7, #24]
  int in_fheight = inputs[0].shape[(in_ndims - 4) + TDIM_FHEIGHT];
34017838:	920c      	str	r2, [sp, #48]	@ 0x30
  int out_batch = output->batch;
3401783a:	9308      	str	r3, [sp, #32]
  int out_fwidth = output->shape[(in_ndims - 4) + TDIM_FWIDTH];
3401783c:	4613      	mov	r3, r2
3401783e:	3304      	adds	r3, #4
34017840:	930d      	str	r3, [sp, #52]	@ 0x34
34017842:	f85b 3003 	ldr.w	r3, [fp, r3]
34017846:	9311      	str	r3, [sp, #68]	@ 0x44
  int out_nchannels = output->shape[(in_ndims - 4) + TDIM_NCHANNELS];
34017848:	9b07      	ldr	r3, [sp, #28]
3401784a:	f85b 3003 	ldr.w	r3, [fp, r3]
3401784e:	930f      	str	r3, [sp, #60]	@ 0x3c
  int axis_lut[] = {TDIM_NKERNELS, TDIM_NCHANNELS, TDIM_FHEIGHT, TDIM_FWIDTH}; // 0, 3, 1, 2
34017850:	4b80      	ldr	r3, [pc, #512]	@ (34017a54 <LL_ATON_LIB_Concat+0x27c>)
34017852:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
34017854:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  if (output->ndims != in_ndims)
34017858:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401785c:	429c      	cmp	r4, r3
3401785e:	9309      	str	r3, [sp, #36]	@ 0x24
34017860:	d003      	beq.n	3401786a <LL_ATON_LIB_Concat+0x92>
    __LL_LIB_ERROR(_ERR_SHAPE, LL_ATON_INVALID_PARAM);
34017862:	f240 71ee 	movw	r1, #2030	@ 0x7ee
34017866:	4a7a      	ldr	r2, [pc, #488]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
34017868:	e7d0      	b.n	3401780c <LL_ATON_LIB_Concat+0x34>
  int nbits = inputs[0].nbits;
3401786a:	f895 3028 	ldrb.w	r3, [r5, #40]	@ 0x28
3401786e:	9304      	str	r3, [sp, #16]
  if (nbits & 0x7)
34017870:	075b      	lsls	r3, r3, #29
34017872:	d004      	beq.n	3401787e <LL_ATON_LIB_Concat+0xa6>
    __LL_LIB_ERROR(_ERR_FRACTIONAL, LL_ATON_INVALID_PARAM); // for now can't handle fractional bytes
34017874:	f240 71fa 	movw	r1, #2042	@ 0x7fa
34017878:	2004      	movs	r0, #4
3401787a:	4a75      	ldr	r2, [pc, #468]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
3401787c:	e7b8      	b.n	340177f0 <LL_ATON_LIB_Concat+0x18>
  int atonn_axis = LUT_AXIS(axis);
3401787e:	9b05      	ldr	r3, [sp, #20]
34017880:	1f22      	subs	r2, r4, #4
34017882:	429a      	cmp	r2, r3
34017884:	d807      	bhi.n	34017896 <LL_ATON_LIB_Concat+0xbe>
34017886:	3304      	adds	r3, #4
34017888:	1b1b      	subs	r3, r3, r4
3401788a:	a93a      	add	r1, sp, #232	@ 0xe8
3401788c:	eb01 0383 	add.w	r3, r1, r3, lsl #2
34017890:	f853 3ca0 	ldr.w	r3, [r3, #-160]
34017894:	4413      	add	r3, r2
  int tot_axis_dim = 0;
34017896:	f04f 0c00 	mov.w	ip, #0
    tot_axis_dim += inputs[i].shape[atonn_axis];
3401789a:	009a      	lsls	r2, r3, #2
3401789c:	920e      	str	r2, [sp, #56]	@ 0x38
  for (i = 0; i < ninputs; i++)
3401789e:	46e6      	mov	lr, ip
    tot_axis_dim += inputs[i].shape[atonn_axis];
340178a0:	462a      	mov	r2, r5
340178a2:	950a      	str	r5, [sp, #40]	@ 0x28
  int tot_size = 0;
340178a4:	f8cd c02c 	str.w	ip, [sp, #44]	@ 0x2c
    tot_size += LL_Buffer_len(inputs + i);
340178a8:	68d1      	ldr	r1, [r2, #12]
340178aa:	980b      	ldr	r0, [sp, #44]	@ 0x2c
    if (!(((inputs[i].shape[(in_ndims - 4) + TDIM_NCHANNELS] == inputs[i].batch) && in_canonical) ||
340178ac:	f8d2 902c 	ldr.w	r9, [r2, #44]	@ 0x2c
    tot_size += LL_Buffer_len(inputs + i);
340178b0:	4408      	add	r0, r1
340178b2:	4601      	mov	r1, r0
340178b4:	6890      	ldr	r0, [r2, #8]
    if (!(((inputs[i].shape[(in_ndims - 4) + TDIM_NCHANNELS] == inputs[i].batch) && in_canonical) ||
340178b6:	f8d2 a018 	ldr.w	sl, [r2, #24]
    tot_size += LL_Buffer_len(inputs + i);
340178ba:	1a09      	subs	r1, r1, r0
340178bc:	910b      	str	r1, [sp, #44]	@ 0x2c
    if (!(((inputs[i].shape[(in_ndims - 4) + TDIM_NCHANNELS] == inputs[i].batch) && in_canonical) ||
340178be:	9907      	ldr	r1, [sp, #28]
340178c0:	f859 1001 	ldr.w	r1, [r9, r1]
340178c4:	4551      	cmp	r1, sl
340178c6:	d103      	bne.n	340178d0 <LL_ATON_LIB_Concat+0xf8>
340178c8:	e9dd 1002 	ldrd	r1, r0, [sp, #8]
340178cc:	4281      	cmp	r1, r0
340178ce:	d007      	beq.n	340178e0 <LL_ATON_LIB_Concat+0x108>
340178d0:	9902      	ldr	r1, [sp, #8]
340178d2:	4551      	cmp	r1, sl
340178d4:	d004      	beq.n	340178e0 <LL_ATON_LIB_Concat+0x108>
      __LL_LIB_ERROR(_ERR_SHAPE_IN, LL_ATON_INVALID_PARAM);
340178d6:	f640 0108 	movw	r1, #2056	@ 0x808
340178da:	4a5d      	ldr	r2, [pc, #372]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
      __LL_LIB_ERROR(_ERR_SHAPE_IN, LL_ATON_INVALID_PARAM);
340178dc:	200a      	movs	r0, #10
340178de:	e787      	b.n	340177f0 <LL_ATON_LIB_Concat+0x18>
    if (inputs[i].ndims != in_ndims)
340178e0:	f892 1027 	ldrb.w	r1, [r2, #39]	@ 0x27
340178e4:	42a1      	cmp	r1, r4
340178e6:	d003      	beq.n	340178f0 <LL_ATON_LIB_Concat+0x118>
      __LL_LIB_ERROR(_ERR_SHAPE_IN, LL_ATON_INVALID_PARAM);
340178e8:	f640 010b 	movw	r1, #2059	@ 0x80b
340178ec:	4a58      	ldr	r2, [pc, #352]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
340178ee:	e7f5      	b.n	340178dc <LL_ATON_LIB_Concat+0x104>
    if (inputs[i].nbits != nbits)
340178f0:	f892 1028 	ldrb.w	r1, [r2, #40]	@ 0x28
340178f4:	9804      	ldr	r0, [sp, #16]
340178f6:	4281      	cmp	r1, r0
340178f8:	d004      	beq.n	34017904 <LL_ATON_LIB_Concat+0x12c>
      __LL_LIB_ERROR(_ERR_NBITS_IN, LL_ATON_INVALID_PARAM);
340178fa:	f640 010d 	movw	r1, #2061	@ 0x80d
340178fe:	2007      	movs	r0, #7
34017900:	4a53      	ldr	r2, [pc, #332]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
34017902:	e775      	b.n	340177f0 <LL_ATON_LIB_Concat+0x18>
    for (k = 0; k < in_ndims; k++)
34017904:	f04f 0a00 	mov.w	sl, #0
    tot_axis_dim += inputs[i].shape[atonn_axis];
34017908:	990e      	ldr	r1, [sp, #56]	@ 0x38
3401790a:	4554      	cmp	r4, sl
3401790c:	f859 1001 	ldr.w	r1, [r9, r1]
34017910:	448c      	add	ip, r1
    for (k = 0; k < in_ndims; k++)
34017912:	bf14      	ite	ne
34017914:	4621      	movne	r1, r4
34017916:	2101      	moveq	r1, #1
34017918:	9110      	str	r1, [sp, #64]	@ 0x40
      if (k != atonn_axis && inputs[0].shape[k] != inputs[i].shape[k])
3401791a:	4553      	cmp	r3, sl
3401791c:	d009      	beq.n	34017932 <LL_ATON_LIB_Concat+0x15a>
3401791e:	f858 002a 	ldr.w	r0, [r8, sl, lsl #2]
34017922:	f859 102a 	ldr.w	r1, [r9, sl, lsl #2]
34017926:	4288      	cmp	r0, r1
34017928:	d003      	beq.n	34017932 <LL_ATON_LIB_Concat+0x15a>
        __LL_LIB_ERROR(_ERR_SHAPE_IN, LL_ATON_INVALID_PARAM);
3401792a:	f640 0114 	movw	r1, #2068	@ 0x814
3401792e:	4a48      	ldr	r2, [pc, #288]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
34017930:	e7d4      	b.n	340178dc <LL_ATON_LIB_Concat+0x104>
    for (k = 0; k < in_ndims; k++)
34017932:	9910      	ldr	r1, [sp, #64]	@ 0x40
34017934:	f10a 0a01 	add.w	sl, sl, #1
34017938:	3901      	subs	r1, #1
3401793a:	9110      	str	r1, [sp, #64]	@ 0x40
3401793c:	d1ed      	bne.n	3401791a <LL_ATON_LIB_Concat+0x142>
  for (i = 0; i < ninputs; i++)
3401793e:	f10e 0e01 	add.w	lr, lr, #1
34017942:	45b6      	cmp	lr, r6
34017944:	f102 0238 	add.w	r2, r2, #56	@ 0x38
34017948:	d1ae      	bne.n	340178a8 <LL_ATON_LIB_Concat+0xd0>
  for (k = 0; k < in_ndims; k++)
3401794a:	2000      	movs	r0, #0
3401794c:	4284      	cmp	r4, r0
3401794e:	bf14      	ite	ne
34017950:	46a6      	movne	lr, r4
34017952:	f04f 0e01 	moveq.w	lr, #1
    if (k != atonn_axis && output->shape[k] != inputs[0].shape[k])
34017956:	4283      	cmp	r3, r0
34017958:	d009      	beq.n	3401796e <LL_ATON_LIB_Concat+0x196>
3401795a:	f85b 1020 	ldr.w	r1, [fp, r0, lsl #2]
3401795e:	f858 2020 	ldr.w	r2, [r8, r0, lsl #2]
34017962:	4291      	cmp	r1, r2
34017964:	d003      	beq.n	3401796e <LL_ATON_LIB_Concat+0x196>
      __LL_LIB_ERROR(_ERR_SHAPE, LL_ATON_INVALID_PARAM);
34017966:	f640 011d 	movw	r1, #2077	@ 0x81d
3401796a:	4a39      	ldr	r2, [pc, #228]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
3401796c:	e74e      	b.n	3401780c <LL_ATON_LIB_Concat+0x34>
  for (k = 0; k < in_ndims; k++)
3401796e:	f1be 0e01 	subs.w	lr, lr, #1
34017972:	f100 0001 	add.w	r0, r0, #1
34017976:	d1ee      	bne.n	34017956 <LL_ATON_LIB_Concat+0x17e>
  if (output->shape[atonn_axis] != tot_axis_dim)
34017978:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
3401797a:	f85b 0002 	ldr.w	r0, [fp, r2]
3401797e:	4584      	cmp	ip, r0
34017980:	d004      	beq.n	3401798c <LL_ATON_LIB_Concat+0x1b4>
    __LL_LIB_ERROR(_ERR_AXIS, LL_ATON_INVALID_PARAM);
34017982:	f640 0122 	movw	r1, #2082	@ 0x822
34017986:	2003      	movs	r0, #3
34017988:	4a31      	ldr	r2, [pc, #196]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
3401798a:	e731      	b.n	340177f0 <LL_ATON_LIB_Concat+0x18>
  if (nbits != output->nbits) // perhaps this could be relaxed later on FIXME !!!
3401798c:	f897 2028 	ldrb.w	r2, [r7, #40]	@ 0x28
34017990:	9904      	ldr	r1, [sp, #16]
34017992:	428a      	cmp	r2, r1
34017994:	d004      	beq.n	340179a0 <LL_ATON_LIB_Concat+0x1c8>
    __LL_LIB_ERROR(_ERR_NBITS, LL_ATON_INVALID_PARAM);
34017996:	f640 0127 	movw	r1, #2087	@ 0x827
3401799a:	2006      	movs	r0, #6
3401799c:	4a2c      	ldr	r2, [pc, #176]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
3401799e:	e727      	b.n	340177f0 <LL_ATON_LIB_Concat+0x18>
340179a0:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
340179a4:	1a52      	subs	r2, r2, r1
  if (tot_size > LL_Buffer_len(output))
340179a6:	990b      	ldr	r1, [sp, #44]	@ 0x2c
340179a8:	4291      	cmp	r1, r2
340179aa:	d822      	bhi.n	340179f2 <LL_ATON_LIB_Concat+0x21a>
  int axis_is_leftmost = 1;
340179ac:	f04f 0c01 	mov.w	ip, #1
340179b0:	4659      	mov	r1, fp
340179b2:	9a05      	ldr	r2, [sp, #20]
340179b4:	f022 4240 	bic.w	r2, r2, #32####MQTT_PASS####5472	@ 0xc0000000
340179b8:	4462      	add	r2, ip
  for (i = 0; i < axis; i++)
340179ba:	3a01      	subs	r2, #1
340179bc:	d11e      	bne.n	340179fc <LL_ATON_LIB_Concat+0x224>
  int nbytes = (inputs[0].nbits + 7) >> 3;
340179be:	9a04      	ldr	r2, [sp, #16]
340179c0:	1dd1      	adds	r1, r2, #7
  if (nbits > 24) // assumes that inputs & output have the same number of bits (`nbits`), see above `__LL_LIB_ERROR`s
340179c2:	2a18      	cmp	r2, #24
  int nbytes = (inputs[0].nbits + 7) >> 3;
340179c4:	ea4f 09e1 	mov.w	r9, r1, asr #3
  if (nbits > 24) // assumes that inputs & output have the same number of bits (`nbits`), see above `__LL_LIB_ERROR`s
340179c8:	f300 80f5 	bgt.w	34017bb6 <LL_ATON_LIB_Concat+0x3de>
  if (axis_is_leftmost)
340179cc:	f1bc 0f00 	cmp.w	ip, #0
340179d0:	f000 80f1 	beq.w	34017bb6 <LL_ATON_LIB_Concat+0x3de>
    switch ((in_ndims - 1) - axis) // count from right CHW, W=0,H=1,C=2, anything else >= 3
340179d4:	9b05      	ldr	r3, [sp, #20]
340179d6:	1ae4      	subs	r4, r4, r3
340179d8:	3c01      	subs	r4, #1
340179da:	f000 80b1 	beq.w	34017b40 <LL_ATON_LIB_Concat+0x368>
340179de:	2c02      	cmp	r4, #2
340179e0:	d026      	beq.n	34017a30 <LL_ATON_LIB_Concat+0x258>
      if (in_batch != out_batch)
340179e2:	9b02      	ldr	r3, [sp, #8]
340179e4:	9a08      	ldr	r2, [sp, #32]
340179e6:	4293      	cmp	r3, r2
340179e8:	d012      	beq.n	34017a10 <LL_ATON_LIB_Concat+0x238>
        __LL_LIB_ERROR(_ERR_SHAPE, LL_ATON_INVALID_PARAM);
340179ea:	f640 0144 	movw	r1, #2116	@ 0x844
340179ee:	4a18      	ldr	r2, [pc, #96]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
340179f0:	e70c      	b.n	3401780c <LL_ATON_LIB_Concat+0x34>
    __LL_LIB_ERROR(_ERR_BUFFER, LL_ATON_INVALID_PARAM);
340179f2:	f640 012c 	movw	r1, #2092	@ 0x82c
340179f6:	200c      	movs	r0, #12
340179f8:	4a15      	ldr	r2, [pc, #84]	@ (34017a50 <LL_ATON_LIB_Concat+0x278>)
340179fa:	e6f9      	b.n	340177f0 <LL_ATON_LIB_Concat+0x18>
    axis_is_leftmost &= (output->shape[i] == 1);
340179fc:	f851 eb04 	ldr.w	lr, [r1], #4
34017a00:	f1be 0f01 	cmp.w	lr, #1
34017a04:	bf14      	ite	ne
34017a06:	f04f 0c00 	movne.w	ip, #0
34017a0a:	f00c 0c01 	andeq.w	ip, ip, #1
  for (i = 0; i < axis; i++)
34017a0e:	e7d4      	b.n	340179ba <LL_ATON_LIB_Concat+0x1e2>
      __LL_ATON_LIB_DMA_Inputs_Memcpy(inputs, ninputs, LL_Buffer_addr_start(output), -1, dma_in, dma_out);
34017a10:	4638      	mov	r0, r7
34017a12:	f7ff fae5 	bl	34016fe0 <LL_Buffer_addr_start>
34017a16:	9b45      	ldr	r3, [sp, #276]	@ 0x114
34017a18:	4602      	mov	r2, r0
  if (ninputs > 0)
34017a1a:	9301      	str	r3, [sp, #4]
34017a1c:	9b44      	ldr	r3, [sp, #272]	@ 0x110
34017a1e:	9300      	str	r3, [sp, #0]
34017a20:	f04f 33ff 	mov.w	r3, #4294967295
34017a24:	4631      	mov	r1, r6
34017a26:	4628      	mov	r0, r5
34017a28:	f7ff fba2 	bl	34017170 <__LL_ATON_LIB_DMA_Inputs_Memcpy.part.0>
      return LL_ATON_OK;
34017a2c:	2000      	movs	r0, #0
34017a2e:	e6e3      	b.n	340177f8 <LL_ATON_LIB_Concat+0x20>
      __LL_ATON_LIB_DMA_Inputs_Memcpy(inputs, ninputs, LL_Buffer_addr_start(output), -1, dma_in, dma_out);
34017a30:	4638      	mov	r0, r7
34017a32:	f7ff fad5 	bl	34016fe0 <LL_Buffer_addr_start>
      if (in_batch == out_batch)
34017a36:	9b02      	ldr	r3, [sp, #8]
34017a38:	9a08      	ldr	r2, [sp, #32]
      __LL_ATON_LIB_DMA_Inputs_Memcpy(inputs, ninputs, LL_Buffer_addr_start(output), -1, dma_in, dma_out);
34017a3a:	4681      	mov	r9, r0
      if (in_batch == out_batch)
34017a3c:	4293      	cmp	r3, r2
34017a3e:	d10b      	bne.n	34017a58 <LL_ATON_LIB_Concat+0x280>
  if (ninputs > 0)
34017a40:	9b45      	ldr	r3, [sp, #276]	@ 0x114
34017a42:	4602      	mov	r2, r0
34017a44:	9301      	str	r3, [sp, #4]
34017a46:	9b44      	ldr	r3, [sp, #272]	@ 0x110
34017a48:	9300      	str	r3, [sp, #0]
34017a4a:	f04f 33ff 	mov.w	r3, #4294967295
34017a4e:	e7e9      	b.n	34017a24 <LL_ATON_LIB_Concat+0x24c>
34017a50:	340ae553 	.word	0x340ae553
34017a54:	3401d3b8 	.word	0x3401d3b8
  uint32_t in_fwidth = inputs[0].shape[(in_ndims - 4) + TDIM_FWIDTH];
34017a58:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
    out_nchannels += inputs[i].shape[(in_ndims - 4) + TDIM_NCHANNELS];
34017a5a:	46b6      	mov	lr, r6
  uint32_t in_fwidth = inputs[0].shape[(in_ndims - 4) + TDIM_FWIDTH];
34017a5c:	f858 b003 	ldr.w	fp, [r8, r3]
  uint32_t in_bytes_size = in_fwidth * in_fheight * in_nchannels * in_nkernels * nbytes;
34017a60:	9b06      	ldr	r3, [sp, #24]
    out_nchannels += inputs[i].shape[(in_ndims - 4) + TDIM_NCHANNELS];
34017a62:	f04f 0c38 	mov.w	ip, #56	@ 0x38
  uint32_t in_bytes_size = in_fwidth * in_fheight * in_nchannels * in_nkernels * nbytes;
34017a66:	fb0b fa03 	mul.w	sl, fp, r3
  uint32_t in_nkernels = inputs[0].shape[(in_ndims - 4) + TDIM_NKERNELS];
34017a6a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
  uint32_t nbytes = (nbits + 7) >> 3;
34017a6c:	08cf      	lsrs	r7, r1, #3
  uint32_t in_nkernels = inputs[0].shape[(in_ndims - 4) + TDIM_NKERNELS];
34017a6e:	4443      	add	r3, r8
  uint32_t in_bytes_size = in_fwidth * in_fheight * in_nchannels * in_nkernels * nbytes;
34017a70:	f853 4c04 	ldr.w	r4, [r3, #-4]
34017a74:	9b03      	ldr	r3, [sp, #12]
    out_nchannels += inputs[i].shape[(in_ndims - 4) + TDIM_NCHANNELS];
34017a76:	f105 012c 	add.w	r1, r5, #44	@ 0x2c
  uint32_t in_bytes_size = in_fwidth * in_fheight * in_nchannels * in_nkernels * nbytes;
34017a7a:	435c      	muls	r4, r3
  for (i = 0; i < ninputs; i++)
34017a7c:	2300      	movs	r3, #0
34017a7e:	429e      	cmp	r6, r3
34017a80:	bf14      	ite	ne
34017a82:	46b6      	movne	lr, r6
34017a84:	f04f 0e01 	moveq.w	lr, #1
  uint32_t out_nchannels = 0;
34017a88:	4698      	mov	r8, r3
34017a8a:	f04e e001 	dls	lr, lr
  uint32_t in_bytes_size = in_fwidth * in_fheight * in_nchannels * in_nkernels * nbytes;
34017a8e:	437c      	muls	r4, r7
34017a90:	fb0a f404 	mul.w	r4, sl, r4
    out_nchannels += inputs[i].shape[(in_ndims - 4) + TDIM_NCHANNELS];
34017a94:	fb0c f203 	mul.w	r2, ip, r3
34017a98:	9807      	ldr	r0, [sp, #28]
34017a9a:	588a      	ldr	r2, [r1, r2]
  for (i = 0; i < ninputs; i++)
34017a9c:	3301      	adds	r3, #1
    out_nchannels += inputs[i].shape[(in_ndims - 4) + TDIM_NCHANNELS];
34017a9e:	5812      	ldr	r2, [r2, r0]
34017aa0:	4490      	add	r8, r2
  for (i = 0; i < ninputs; i++)
34017aa2:	f00f c809 	le	lr, 34017a94 <LL_ATON_LIB_Concat+0x2bc>
  LL_Streng_TensorInitTypeDef _dma_in = {
34017aa6:	2248      	movs	r2, #72	@ 0x48
34017aa8:	2100      	movs	r1, #0
34017aaa:	a816      	add	r0, sp, #88	@ 0x58
34017aac:	f002 fb3a 	bl	3401a124 <memset>
34017ab0:	2302      	movs	r3, #2
34017ab2:	f88d 3058 	strb.w	r3, [sp, #88]	@ 0x58
34017ab6:	686b      	ldr	r3, [r5, #4]
  LL_Streng_TensorInitTypeDef _dma_out = {
34017ab8:	2248      	movs	r2, #72	@ 0x48
  LL_Streng_TensorInitTypeDef _dma_in = {
34017aba:	9317      	str	r3, [sp, #92]	@ 0x5c
      .offset_start = inputs[0].offset_start,               // this must be updated on all inputs
34017abc:	68ab      	ldr	r3, [r5, #8]
  LL_Streng_TensorInitTypeDef _dma_out = {
34017abe:	2100      	movs	r1, #0
      .offset_end = inputs[0].offset_start + in_bytes_size, // this must be updated on all inputs
34017ac0:	441c      	add	r4, r3
  LL_Streng_TensorInitTypeDef _dma_in = {
34017ac2:	9318      	str	r3, [sp, #96]	@ 0x60
34017ac4:	2301      	movs	r3, #1
34017ac6:	9419      	str	r4, [sp, #100]	@ 0x64
34017ac8:	00fc      	lsls	r4, r7, #3
34017aca:	b2e4      	uxtb	r4, r4
  LL_Streng_TensorInitTypeDef _dma_out = {
34017acc:	a828      	add	r0, sp, #160	@ 0xa0
  LL_Streng_TensorInitTypeDef _dma_in = {
34017ace:	9326      	str	r3, [sp, #152]	@ 0x98
34017ad0:	f88d 409c 	strb.w	r4, [sp, #156]	@ 0x9c
34017ad4:	f88d 409d 	strb.w	r4, [sp, #157]	@ 0x9d
  LL_Streng_TensorInitTypeDef _dma_out = {
34017ad8:	f002 fb24 	bl	3401a124 <memset>
34017adc:	2301      	movs	r3, #1
34017ade:	f88d 30a0 	strb.w	r3, [sp, #160]	@ 0xa0
34017ae2:	9b06      	ldr	r3, [sp, #24]
    __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out, dst, -1);
34017ae4:	4628      	mov	r0, r5
  LL_Streng_TensorInitTypeDef _dma_out = {
34017ae6:	932f      	str	r3, [sp, #188]	@ 0xbc
34017ae8:	9b02      	ldr	r3, [sp, #8]
34017aea:	f8cd 90a4 	str.w	r9, [sp, #164]	@ 0xa4
34017aee:	9330      	str	r3, [sp, #192]	@ 0xc0
      .batch_offset = out_nchannels * nbytes,
34017af0:	fb08 f307 	mul.w	r3, r8, r7
  LL_Streng_TensorInitTypeDef _dma_out = {
34017af4:	9331      	str	r3, [sp, #196]	@ 0xc4
      .frame_offset = in_batch * nbytes, // this must be updated on all inputs
34017af6:	9b02      	ldr	r3, [sp, #8]
  LL_Streng_TensorInitTypeDef _dma_out = {
34017af8:	f8cd b0b8 	str.w	fp, [sp, #184]	@ 0xb8
      .frame_offset = in_batch * nbytes, // this must be updated on all inputs
34017afc:	fb07 f103 	mul.w	r1, r7, r3
      .frame_loop_cnt = in_nchannels / in_batch,                 // this must be updated on all inputs
34017b00:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34017b04:	fbb3 f3f2 	udiv	r3, r3, r2
  LL_Streng_TensorInitTypeDef _dma_out = {
34017b08:	9335      	str	r3, [sp, #212]	@ 0xd4
34017b0a:	9338      	str	r3, [sp, #224]	@ 0xe0
    __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out, dst, -1);
34017b0c:	f04f 33ff 	mov.w	r3, #4294967295
  LL_Streng_TensorInitTypeDef _dma_out = {
34017b10:	9132      	str	r1, [sp, #200]	@ 0xc8
      .loop_offset = in_fheight * in_fwidth * in_batch * nbytes, // this must be updated on all inputs
34017b12:	fb01 f10a 	mul.w	r1, r1, sl
    __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out, dst, -1);
34017b16:	e9cd 9300 	strd	r9, r3, [sp]
  LL_Streng_TensorInitTypeDef _dma_out = {
34017b1a:	9134      	str	r1, [sp, #208]	@ 0xd0
    __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out, dst, -1);
34017b1c:	ab28      	add	r3, sp, #160	@ 0xa0
34017b1e:	4631      	mov	r1, r6
34017b20:	aa16      	add	r2, sp, #88	@ 0x58
  LL_Streng_TensorInitTypeDef _dma_out = {
34017b22:	f88d 40e4 	strb.w	r4, [sp, #228]	@ 0xe4
34017b26:	f88d 40e5 	strb.w	r4, [sp, #229]	@ 0xe5
    __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_dma_in, &_dma_out, dst, -1);
34017b2a:	f7ff faeb 	bl	34017104 <__ll_lib_prepare_inputs_epoch>
    __ll_lib_strswitch_set_dmas(dma_in, dma_out, _inputs_batched_memcpy_epoch_block_array);
34017b2e:	e9dd 0144 	ldrd	r0, r1, [sp, #272]	@ 0x110
34017b32:	4a48      	ldr	r2, [pc, #288]	@ (34017c54 <LL_ATON_LIB_Concat+0x47c>)
34017b34:	f7ff fa8a 	bl	3401704c <__ll_lib_strswitch_set_dmas>
    LL_ATON_RT_Insert_LibEpochBlockArray(_inputs_batched_memcpy_epoch_block_array);
34017b38:	4846      	ldr	r0, [pc, #280]	@ (34017c54 <LL_ATON_LIB_Concat+0x47c>)
          LL_ATON_RT_Insert_LibEpochBlockArray(_concat_case3_epoch_block_array);
34017b3a:	f7ff fabb 	bl	340170b4 <LL_ATON_RT_Insert_LibEpochBlockArray>
34017b3e:	e775      	b.n	34017a2c <LL_ATON_LIB_Concat+0x254>
      if (in_batch != out_batch)
34017b40:	9b02      	ldr	r3, [sp, #8]
34017b42:	9a08      	ldr	r2, [sp, #32]
34017b44:	4293      	cmp	r3, r2
34017b46:	d003      	beq.n	34017b50 <LL_ATON_LIB_Concat+0x378>
        __LL_LIB_ERROR(_ERR_SHAPE, LL_ATON_INVALID_PARAM);
34017b48:	f640 0165 	movw	r1, #2149	@ 0x865
34017b4c:	4a42      	ldr	r2, [pc, #264]	@ (34017c58 <LL_ATON_LIB_Concat+0x480>)
34017b4e:	e65d      	b.n	3401780c <LL_ATON_LIB_Concat+0x34>
      unsigned int out_pix_size = nbytes * out_nchannels;
34017b50:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
      unsigned char *out_start = LL_Buffer_addr_start(output);
34017b52:	4638      	mov	r0, r7
      unsigned int out_pix_size = nbytes * out_nchannels;
34017b54:	fb09 f103 	mul.w	r1, r9, r3
      unsigned int out_line_size = out_pix_size * out_fwidth;
34017b58:	9b11      	ldr	r3, [sp, #68]	@ 0x44
34017b5a:	4359      	muls	r1, r3
      unsigned char *out_start = LL_Buffer_addr_start(output);
34017b5c:	f7ff fa40 	bl	34016fe0 <LL_Buffer_addr_start>
        unsigned int line_size = pix_size * inputs[0].shape[(in_ndims - 4) + TDIM_FWIDTH];
34017b60:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
      unsigned char *out_start = LL_Buffer_addr_start(output);
34017b62:	4607      	mov	r7, r0
        unsigned int line_size = pix_size * inputs[0].shape[(in_ndims - 4) + TDIM_FWIDTH];
34017b64:	f858 a003 	ldr.w	sl, [r8, r3]
        params->special.concat_case3.outer_idx = 0;
34017b68:	f8df 80fc 	ldr.w	r8, [pc, #252]	@ 34017c68 <LL_ATON_LIB_Concat+0x490>
        params->special.concat_case3.in_fheight = in_fheight;
34017b6c:	9b06      	ldr	r3, [sp, #24]
        params->special.concat_case3.in_curr = LL_Buffer_addr_start((LL_LIB_TensorInfo_TypeDef *)params->g_tensors);
34017b6e:	f8d8 00a8 	ldr.w	r0, [r8, #168]	@ 0xa8
        params->special.concat_case3.nbytes = nbytes;
34017b72:	e9c8 392d 	strd	r3, r9, [r8, #180]	@ 0xb4
        params->special.concat_case3.outer_idx = 0;
34017b76:	f8c8 40b0 	str.w	r4, [r8, #176]	@ 0xb0
        params->special.concat_case3.out_line_size = out_line_size;
34017b7a:	f8c8 10bc 	str.w	r1, [r8, #188]	@ 0xbc
        params->special.concat_case3.in_curr = LL_Buffer_addr_start((LL_LIB_TensorInfo_TypeDef *)params->g_tensors);
34017b7e:	f7ff fa2f 	bl	34016fe0 <LL_Buffer_addr_start>
        if ((ninputs > 0) && (in_fheight > 0))
34017b82:	9b06      	ldr	r3, [sp, #24]
        params->special.concat_case3.in_curr = LL_Buffer_addr_start((LL_LIB_TensorInfo_TypeDef *)params->g_tensors);
34017b84:	f8c8 00c0 	str.w	r0, [r8, #192]	@ 0xc0
        if ((ninputs > 0) && (in_fheight > 0))
34017b88:	2b00      	cmp	r3, #0
34017b8a:	f77f af4f 	ble.w	34017a2c <LL_ATON_LIB_Concat+0x254>
        unsigned int line_size = pix_size * inputs[0].shape[(in_ndims - 4) + TDIM_FWIDTH];
34017b8e:	9b03      	ldr	r3, [sp, #12]
          __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_static_const_dma_in, &_static_const_dma_out,
34017b90:	4631      	mov	r1, r6
        unsigned int line_size = pix_size * inputs[0].shape[(in_ndims - 4) + TDIM_FWIDTH];
34017b92:	fb0a fa03 	mul.w	sl, sl, r3
34017b96:	fb09 f30a 	mul.w	r3, r9, sl
          __ll_lib_prepare_inputs_epoch(inputs, ninputs, &_static_const_dma_in, &_static_const_dma_out,
34017b9a:	4628      	mov	r0, r5
34017b9c:	e9cd 7300 	strd	r7, r3, [sp]
34017ba0:	4a2e      	ldr	r2, [pc, #184]	@ (34017c5c <LL_ATON_LIB_Concat+0x484>)
34017ba2:	4b2f      	ldr	r3, [pc, #188]	@ (34017c60 <LL_ATON_LIB_Concat+0x488>)
34017ba4:	f7ff faae 	bl	34017104 <__ll_lib_prepare_inputs_epoch>
          __ll_lib_strswitch_set_dmas(dma_in, dma_out, _concat_case3_epoch_block_array);
34017ba8:	e9dd 0144 	ldrd	r0, r1, [sp, #272]	@ 0x110
34017bac:	4a2d      	ldr	r2, [pc, #180]	@ (34017c64 <LL_ATON_LIB_Concat+0x48c>)
34017bae:	f7ff fa4d 	bl	3401704c <__ll_lib_strswitch_set_dmas>
          LL_ATON_RT_Insert_LibEpochBlockArray(_concat_case3_epoch_block_array);
34017bb2:	482c      	ldr	r0, [pc, #176]	@ (34017c64 <LL_ATON_LIB_Concat+0x48c>)
34017bb4:	e7c1      	b.n	34017b3a <LL_ATON_LIB_Concat+0x362>
  if (in_canonical == 0)
34017bb6:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
34017bba:	428a      	cmp	r2, r1
34017bbc:	d003      	beq.n	34017bc6 <LL_ATON_LIB_Concat+0x3ee>
    __LL_LIB_ERROR(_ERR_SHAPE_IN, LL_ATON_INVALID_PARAM);
34017bbe:	f640 01bd 	movw	r1, #2237	@ 0x8bd
34017bc2:	4a25      	ldr	r2, [pc, #148]	@ (34017c58 <LL_ATON_LIB_Concat+0x480>)
34017bc4:	e68a      	b.n	340178dc <LL_ATON_LIB_Concat+0x104>
  if (out_canonical == 0)
34017bc6:	9a08      	ldr	r2, [sp, #32]
34017bc8:	990f      	ldr	r1, [sp, #60]	@ 0x3c
34017bca:	428a      	cmp	r2, r1
34017bcc:	d004      	beq.n	34017bd8 <LL_ATON_LIB_Concat+0x400>
    __LL_LIB_ERROR(_ERR_SHAPE_OUT, LL_ATON_INVALID_PARAM);
34017bce:	f640 01bf 	movw	r1, #2239	@ 0x8bf
34017bd2:	200b      	movs	r0, #11
34017bd4:	4a20      	ldr	r2, [pc, #128]	@ (34017c58 <LL_ATON_LIB_Concat+0x480>)
34017bd6:	e60b      	b.n	340177f0 <LL_ATON_LIB_Concat+0x18>
  uint32_t jump_base = 1;
34017bd8:	2401      	movs	r4, #1
34017bda:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34017bdc:	1919      	adds	r1, r3, r4
34017bde:	4291      	cmp	r1, r2
34017be0:	eba2 0303 	sub.w	r3, r2, r3
34017be4:	bfd4      	ite	le
34017be6:	461d      	movle	r5, r3
34017be8:	4625      	movgt	r5, r4
  for (i = atonn_axis + 1; i < output->ndims; i++)
34017bea:	3d01      	subs	r5, #1
34017bec:	d11a      	bne.n	34017c24 <LL_ATON_LIB_Concat+0x44c>
  jump_base *= nbytes;
34017bee:	fb04 f909 	mul.w	r9, r4, r9
  uint32_t start = 0;
34017bf2:	2400      	movs	r4, #0
  for (i = 0; i < ninputs; i++)
34017bf4:	46a2      	mov	sl, r4
  uint32_t jump = jump_base * output->shape[atonn_axis];
34017bf6:	fb09 f300 	mul.w	r3, r9, r0
34017bfa:	9303      	str	r3, [sp, #12]
    for (dst = start; dst < stop; dst += jump, src += copy_val)
34017bfc:	46a0      	mov	r8, r4
    int src = 0;
34017bfe:	2500      	movs	r5, #0
    uint32_t copy_val = inputs[i].shape[atonn_axis] * jump_base;
34017c00:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34017c02:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
34017c04:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34017c06:	589a      	ldr	r2, [r3, r2]
34017c08:	fb02 fb09 	mul.w	fp, r2, r9
    for (dst = start; dst < stop; dst += jump, src += copy_val)
34017c0c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
34017c0e:	4543      	cmp	r3, r8
34017c10:	d80d      	bhi.n	34017c2e <LL_ATON_LIB_Concat+0x456>
  for (i = 0; i < ninputs; i++)
34017c12:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34017c14:	f10a 0a01 	add.w	sl, sl, #1
34017c18:	3338      	adds	r3, #56	@ 0x38
34017c1a:	45b2      	cmp	sl, r6
    start += copy_val;
34017c1c:	445c      	add	r4, fp
  for (i = 0; i < ninputs; i++)
34017c1e:	930a      	str	r3, [sp, #40]	@ 0x28
34017c20:	d3ec      	bcc.n	34017bfc <LL_ATON_LIB_Concat+0x424>
34017c22:	e703      	b.n	34017a2c <LL_ATON_LIB_Concat+0x254>
    jump_base *= output->shape[i];
34017c24:	f85b 2021 	ldr.w	r2, [fp, r1, lsl #2]
  for (i = atonn_axis + 1; i < output->ndims; i++)
34017c28:	3101      	adds	r1, #1
    jump_base *= output->shape[i];
34017c2a:	4354      	muls	r4, r2
  for (i = atonn_axis + 1; i < output->ndims; i++)
34017c2c:	e7dd      	b.n	34017bea <LL_ATON_LIB_Concat+0x412>
      memcpy(LL_Buffer_addr_start(output) + dst, LL_Buffer_addr_start(inputs + i) + src, copy_val);
34017c2e:	4638      	mov	r0, r7
34017c30:	f7ff f9d6 	bl	34016fe0 <LL_Buffer_addr_start>
34017c34:	eb00 0308 	add.w	r3, r0, r8
34017c38:	980a      	ldr	r0, [sp, #40]	@ 0x28
34017c3a:	9302      	str	r3, [sp, #8]
34017c3c:	f7ff f9d0 	bl	34016fe0 <LL_Buffer_addr_start>
34017c40:	465a      	mov	r2, fp
34017c42:	1941      	adds	r1, r0, r5
34017c44:	9802      	ldr	r0, [sp, #8]
34017c46:	f002 fd04 	bl	3401a652 <memcpy>
    for (dst = start; dst < stop; dst += jump, src += copy_val)
34017c4a:	9b03      	ldr	r3, [sp, #12]
34017c4c:	445d      	add	r5, fp
34017c4e:	4498      	add	r8, r3
34017c50:	e7dc      	b.n	34017c0c <LL_ATON_LIB_Concat+0x434>
34017c52:	bf00      	nop
34017c54:	340b106c 	.word	0x340b106c
34017c58:	340ae553 	.word	0x340ae553
34017c5c:	340ae60c 	.word	0x340ae60c
34017c60:	340ae5c4 	.word	0x340ae5c4
34017c64:	340b10bc 	.word	0x340b10bc
34017c68:	340ce898 	.word	0x340ce898

34017c6c <__LL_ATON_RT_Init_Network>:
                          // wait for
  }
}

static inline void __LL_ATON_RT_Init_Network(NN_Instance_TypeDef *nn_instance)
{
34017c6c:	b510      	push	{r4, lr}
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
34017c6e:	4604      	mov	r4, r0
34017c70:	b310      	cbz	r0, 34017cb8 <__LL_ATON_RT_Init_Network+0x4c>
  {
    return;
  }

  /** Exit if `nn_instance->network` is equal to NULL **/
  if (nn_instance->network == NULL)
34017c72:	6803      	ldr	r3, [r0, #0]
34017c74:	b303      	cbz	r3, 34017cb8 <__LL_ATON_RT_Init_Network+0x4c>
  else
  {
    eb_list = nn_instance->network->epoch_block_items();
  }
#else
  const LL_ATON_RT_EpochBlockItem_t *eb_list = nn_instance->network->epoch_block_items();
34017c76:	69db      	ldr	r3, [r3, #28]
34017c78:	4798      	blx	r3
#endif
  nn_instance->exec_state.current_epoch_block = eb_list;
  nn_instance->exec_state.first_epoch_block = eb_list;
  nn_instance->exec_state.next_epoch_block = NULL;
34017c7a:	2300      	movs	r3, #0
  nn_instance->exec_state.current_epoch_block = eb_list;
34017c7c:	6060      	str	r0, [r4, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
34017c7e:	60a0      	str	r0, [r4, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
34017c80:	60e3      	str	r3, [r4, #12]

  /* set saved context */
  nn_instance->exec_state.saved_current_epoch_block = NULL;
34017c82:	6123      	str	r3, [r4, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
34017c84:	6163      	str	r3, [r4, #20]
#ifndef NDEBUG
  nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.current_epoch_block);
34017c86:	6863      	ldr	r3, [r4, #4]
  if (list != NULL)
34017c88:	b9a3      	cbnz	r3, 34017cb4 <__LL_ATON_RT_Init_Network+0x48>
  int i = 0;
34017c8a:	461a      	mov	r2, r3
  nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.current_epoch_block);
34017c8c:	6262      	str	r2, [r4, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
34017c8e:	2200      	movs	r2, #0
  nn_instance->exec_state.triggered_events = 0x0;
  nn_instance->exec_state.current_epoch_block_started = false;
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  /** Call epoch callback with callback type `LL_ATON_RT_Callbacktype_NN_Init` and network instance **/
  if (nn_instance->exec_state.epoch_callback_function != NULL)
34017c90:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
34017c92:	62a2      	str	r2, [r4, #40]	@ 0x28
  nn_instance->exec_state.inference_started = false;
34017c94:	7622      	strb	r2, [r4, #24]
  nn_instance->exec_state.triggered_events = 0x0;
34017c96:	61e2      	str	r2, [r4, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
34017c98:	f884 2020 	strb.w	r2, [r4, #32]
  if (nn_instance->exec_state.epoch_callback_function != NULL)
34017c9c:	b163      	cbz	r3, 34017cb8 <__LL_ATON_RT_Init_Network+0x4c>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_Init, nn_instance, NULL);
34017c9e:	4621      	mov	r1, r4
  }
}
34017ca0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_Init, nn_instance, NULL);
34017ca4:	2004      	movs	r0, #4
34017ca6:	4718      	bx	r3
      list++;
34017ca8:	3314      	adds	r3, #20
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
34017caa:	3201      	adds	r2, #1
34017cac:	8a19      	ldrh	r1, [r3, #16]
34017cae:	0709      	lsls	r1, r1, #28
34017cb0:	d5fa      	bpl.n	34017ca8 <__LL_ATON_RT_Init_Network+0x3c>
34017cb2:	e7eb      	b.n	34017c8c <__LL_ATON_RT_Init_Network+0x20>
34017cb4:	2201      	movs	r2, #1
34017cb6:	e7f9      	b.n	34017cac <__LL_ATON_RT_Init_Network+0x40>
}
34017cb8:	bd10      	pop	{r4, pc}
	...

34017cbc <__ll_clear_aton_owner>:
  {
34017cbc:	b508      	push	{r3, lr}
    LL_ATON_ASSERT(current_owner == __ll_current_aton_ip_owner);
34017cbe:	4b09      	ldr	r3, [pc, #36]	@ (34017ce4 <__ll_clear_aton_owner+0x28>)
34017cc0:	681a      	ldr	r2, [r3, #0]
34017cc2:	4282      	cmp	r2, r0
34017cc4:	d005      	beq.n	34017cd2 <__ll_clear_aton_owner+0x16>
34017cc6:	2139      	movs	r1, #57	@ 0x39
34017cc8:	4b07      	ldr	r3, [pc, #28]	@ (34017ce8 <__ll_clear_aton_owner+0x2c>)
34017cca:	4a08      	ldr	r2, [pc, #32]	@ (34017cec <__ll_clear_aton_owner+0x30>)
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
34017ccc:	4808      	ldr	r0, [pc, #32]	@ (34017cf0 <__ll_clear_aton_owner+0x34>)
34017cce:	f001 f8c5 	bl	34018e5c <__assert_func>
34017cd2:	4a08      	ldr	r2, [pc, #32]	@ (34017cf4 <__ll_clear_aton_owner+0x38>)
34017cd4:	6812      	ldr	r2, [r2, #0]
34017cd6:	b11a      	cbz	r2, 34017ce0 <__ll_clear_aton_owner+0x24>
34017cd8:	213d      	movs	r1, #61	@ 0x3d
34017cda:	4b07      	ldr	r3, [pc, #28]	@ (34017cf8 <__ll_clear_aton_owner+0x3c>)
34017cdc:	4a03      	ldr	r2, [pc, #12]	@ (34017cec <__ll_clear_aton_owner+0x30>)
34017cde:	e7f5      	b.n	34017ccc <__ll_clear_aton_owner+0x10>
    __ll_current_aton_ip_owner = NULL;
34017ce0:	601a      	str	r2, [r3, #0]
  }
34017ce2:	bd08      	pop	{r3, pc}
34017ce4:	340ceee8 	.word	0x340ceee8
34017ce8:	340217b2 	.word	0x340217b2
34017cec:	340ae7a2 	.word	0x340ae7a2
34017cf0:	3402125a 	.word	0x3402125a
34017cf4:	340ceee4 	.word	0x340ceee4
34017cf8:	340217de 	.word	0x340217de

34017cfc <__LL_ATON_RT_SetWaitMask>:
  {
34017cfc:	b508      	push	{r3, lr}
    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
34017cfe:	4b07      	ldr	r3, [pc, #28]	@ (34017d1c <__LL_ATON_RT_SetWaitMask+0x20>)
34017d00:	681b      	ldr	r3, [r3, #0]
34017d02:	b92b      	cbnz	r3, 34017d10 <__LL_ATON_RT_SetWaitMask+0x14>
34017d04:	216c      	movs	r1, #108	@ 0x6c
34017d06:	4b06      	ldr	r3, [pc, #24]	@ (34017d20 <__LL_ATON_RT_SetWaitMask+0x24>)
34017d08:	4a06      	ldr	r2, [pc, #24]	@ (34017d24 <__LL_ATON_RT_SetWaitMask+0x28>)
34017d0a:	4807      	ldr	r0, [pc, #28]	@ (34017d28 <__LL_ATON_RT_SetWaitMask+0x2c>)
34017d0c:	f001 f8a6 	bl	34018e5c <__assert_func>
    __ll_current_wait_mask = wait_mask;
34017d10:	4b06      	ldr	r3, [pc, #24]	@ (34017d2c <__LL_ATON_RT_SetWaitMask+0x30>)
34017d12:	6018      	str	r0, [r3, #0]
    ATON_INTCTRL_STD_INTANDMSK_SET(~wait_mask);
34017d14:	43c0      	mvns	r0, r0
34017d16:	4b06      	ldr	r3, [pc, #24]	@ (34017d30 <__LL_ATON_RT_SetWaitMask+0x34>)
34017d18:	6258      	str	r0, [r3, #36]	@ 0x24
  }
34017d1a:	bd08      	pop	{r3, pc}
34017d1c:	340ceee8 	.word	0x340ceee8
34017d20:	34021230 	.word	0x34021230
34017d24:	340ae6f5 	.word	0x340ae6f5
34017d28:	3402125a 	.word	0x3402125a
34017d2c:	340ceee4 	.word	0x340ceee4
34017d30:	580e1000 	.word	0x580e1000

34017d34 <EpochBlock_EpochControllerUnit>:
  {
34017d34:	b508      	push	{r3, lr}
    LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
34017d36:	8a03      	ldrh	r3, [r0, #16]
34017d38:	075b      	lsls	r3, r3, #29
34017d3a:	d406      	bmi.n	34017d4a <EpochBlock_EpochControllerUnit+0x16>
34017d3c:	f240 11d5 	movw	r1, #469	@ 0x1d5
34017d40:	4b03      	ldr	r3, [pc, #12]	@ (34017d50 <EpochBlock_EpochControllerUnit+0x1c>)
34017d42:	4a04      	ldr	r2, [pc, #16]	@ (34017d54 <EpochBlock_EpochControllerUnit+0x20>)
34017d44:	4804      	ldr	r0, [pc, #16]	@ (34017d58 <EpochBlock_EpochControllerUnit+0x24>)
34017d46:	f001 f889 	bl	34018e5c <__assert_func>
  }
34017d4a:	68c0      	ldr	r0, [r0, #12]
34017d4c:	bd08      	pop	{r3, pc}
34017d4e:	bf00      	nop
34017d50:	340217fa 	.word	0x340217fa
34017d54:	340ae6d6 	.word	0x340ae6d6
34017d58:	34021815 	.word	0x34021815

34017d5c <__LL_ATON_RT_ExecEndEpochBlock>:
  if (nn_instance->exec_state.epoch_callback_function != NULL)
34017d5c:	6acb      	ldr	r3, [r1, #44]	@ 0x2c
{
34017d5e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34017d62:	4605      	mov	r5, r0
34017d64:	460c      	mov	r4, r1
  if (nn_instance->exec_state.epoch_callback_function != NULL)
34017d66:	b113      	cbz	r3, 34017d6e <__LL_ATON_RT_ExecEndEpochBlock+0x12>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_END, nn_instance, eb);
34017d68:	4602      	mov	r2, r0
34017d6a:	2002      	movs	r0, #2
34017d6c:	4798      	blx	r3
  if (EpochBlock_IsEpochBlob(eb))
34017d6e:	8a2b      	ldrh	r3, [r5, #16]
34017d70:	0758      	lsls	r0, r3, #29
34017d72:	d518      	bpl.n	34017da6 <__LL_ATON_RT_ExecEndEpochBlock+0x4a>
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
34017d74:	4628      	mov	r0, r5
34017d76:	f7ff ffdd 	bl	34017d34 <EpochBlock_EpochControllerUnit>
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
34017d7a:	b128      	cbz	r0, 34017d88 <__LL_ATON_RT_ExecEndEpochBlock+0x2c>
34017d7c:	21c2      	movs	r1, #194	@ 0xc2
34017d7e:	4b25      	ldr	r3, [pc, #148]	@ (34017e14 <__LL_ATON_RT_ExecEndEpochBlock+0xb8>)
34017d80:	4a25      	ldr	r2, [pc, #148]	@ (34017e18 <__LL_ATON_RT_ExecEndEpochBlock+0xbc>)
    LL_ATON_ASSERT(nn_instance == __ll_current_aton_ip_owner);
34017d82:	4826      	ldr	r0, [pc, #152]	@ (34017e1c <__LL_ATON_RT_ExecEndEpochBlock+0xc0>)
34017d84:	f001 f86a 	bl	34018e5c <__assert_func>
    ATON_DISABLE_CLR_CONFCLR(EPOCHCTRL, ecId);
34017d88:	2202      	movs	r2, #2
34017d8a:	4b25      	ldr	r3, [pc, #148]	@ (34017e20 <__LL_ATON_RT_ExecEndEpochBlock+0xc4>)
34017d8c:	601a      	str	r2, [r3, #0]
34017d8e:	681a      	ldr	r2, [r3, #0]
34017d90:	0791      	lsls	r1, r2, #30
34017d92:	d4fc      	bmi.n	34017d8e <__LL_ATON_RT_ExecEndEpochBlock+0x32>
34017d94:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34017d98:	601a      	str	r2, [r3, #0]
34017d9a:	681a      	ldr	r2, [r3, #0]
34017d9c:	0052      	lsls	r2, r2, #1
34017d9e:	d4fc      	bmi.n	34017d9a <__LL_ATON_RT_ExecEndEpochBlock+0x3e>
    LL_ATON_DisableClock(ATON_EPOCHCTRL_CLKB_CLK(ecId));
34017da0:	2019      	movs	r0, #25
34017da2:	f7ff f877 	bl	34016e94 <LL_ATON_DisableClock>
  if (eb->end_epoch_block != NULL)
34017da6:	686b      	ldr	r3, [r5, #4]
34017da8:	b10b      	cbz	r3, 34017dae <__LL_ATON_RT_ExecEndEpochBlock+0x52>
    eb->end_epoch_block((const void *)eb);
34017daa:	4628      	mov	r0, r5
34017dac:	4798      	blx	r3
    return ((eb->flags & EpochBlock_Flags_pure_hw) != 0);
34017dae:	8a2e      	ldrh	r6, [r5, #16]
  if (EpochBlock_IsEpochPureHW(eb) ||
34017db0:	f016 0f90 	tst.w	r6, #144	@ 0x90
34017db4:	f006 07c0 	and.w	r7, r6, #192	@ 0xc0
34017db8:	d108      	bne.n	34017dcc <__LL_ATON_RT_ExecEndEpochBlock+0x70>
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
34017dba:	bb0f      	cbnz	r7, 34017e00 <__LL_ATON_RT_ExecEndEpochBlock+0xa4>
  LL_ATON_ASSERT(EpochBlock_IsEpochInternal(eb) || EpochBlock_IsEpochHybrid(eb) ||
34017dbc:	4b19      	ldr	r3, [pc, #100]	@ (34017e24 <__LL_ATON_RT_ExecEndEpochBlock+0xc8>)
34017dbe:	681b      	ldr	r3, [r3, #0]
34017dc0:	42a3      	cmp	r3, r4
34017dc2:	d115      	bne.n	34017df0 <__LL_ATON_RT_ExecEndEpochBlock+0x94>
34017dc4:	21ed      	movs	r1, #237	@ 0xed
34017dc6:	4b18      	ldr	r3, [pc, #96]	@ (34017e28 <__LL_ATON_RT_ExecEndEpochBlock+0xcc>)
34017dc8:	4a13      	ldr	r2, [pc, #76]	@ (34017e18 <__LL_ATON_RT_ExecEndEpochBlock+0xbc>)
34017dca:	e7da      	b.n	34017d82 <__LL_ATON_RT_ExecEndEpochBlock+0x26>
    LL_ATON_ASSERT(nn_instance == __ll_current_aton_ip_owner);
34017dcc:	4b15      	ldr	r3, [pc, #84]	@ (34017e24 <__LL_ATON_RT_ExecEndEpochBlock+0xc8>)
34017dce:	681b      	ldr	r3, [r3, #0]
34017dd0:	42a3      	cmp	r3, r4
34017dd2:	d003      	beq.n	34017ddc <__LL_ATON_RT_ExecEndEpochBlock+0x80>
34017dd4:	21e1      	movs	r1, #225	@ 0xe1
34017dd6:	4b15      	ldr	r3, [pc, #84]	@ (34017e2c <__LL_ATON_RT_ExecEndEpochBlock+0xd0>)
34017dd8:	4a0f      	ldr	r2, [pc, #60]	@ (34017e18 <__LL_ATON_RT_ExecEndEpochBlock+0xbc>)
34017dda:	e7d2      	b.n	34017d82 <__LL_ATON_RT_ExecEndEpochBlock+0x26>
    __LL_ATON_RT_SetWaitMask(0);
34017ddc:	2000      	movs	r0, #0
34017dde:	f7ff ff8d 	bl	34017cfc <__LL_ATON_RT_SetWaitMask>
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
34017de2:	06f3      	lsls	r3, r6, #27
34017de4:	d5e9      	bpl.n	34017dba <__LL_ATON_RT_ExecEndEpochBlock+0x5e>
    __ll_clear_aton_owner(nn_instance);
34017de6:	4620      	mov	r0, r4
34017de8:	f7ff ff68 	bl	34017cbc <__ll_clear_aton_owner>
  LL_ATON_ASSERT(EpochBlock_IsEpochInternal(eb) || EpochBlock_IsEpochHybrid(eb) ||
34017dec:	2f00      	cmp	r7, #0
34017dee:	d0e5      	beq.n	34017dbc <__LL_ATON_RT_ExecEndEpochBlock+0x60>
  if (nn_instance->exec_state.epoch_callback_function != NULL)
34017df0:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34017df2:	b163      	cbz	r3, 34017e0e <__LL_ATON_RT_ExecEndEpochBlock+0xb2>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_END, nn_instance, eb);
34017df4:	462a      	mov	r2, r5
34017df6:	4621      	mov	r1, r4
}
34017df8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_END, nn_instance, eb);
34017dfc:	2003      	movs	r0, #3
34017dfe:	4718      	bx	r3
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
34017e00:	6923      	ldr	r3, [r4, #16]
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
34017e02:	2b00      	cmp	r3, #0
34017e04:	d1f4      	bne.n	34017df0 <__LL_ATON_RT_ExecEndEpochBlock+0x94>
                                       (nn_instance->exec_state.next_epoch_block ==
34017e06:	68e3      	ldr	r3, [r4, #12]
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
34017e08:	2b00      	cmp	r3, #0
34017e0a:	d1f1      	bne.n	34017df0 <__LL_ATON_RT_ExecEndEpochBlock+0x94>
34017e0c:	e7eb      	b.n	34017de6 <__LL_ATON_RT_ExecEndEpochBlock+0x8a>
}
34017e0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34017e12:	bf00      	nop
34017e14:	340218cd 	.word	0x340218cd
34017e18:	340ae6b7 	.word	0x340ae6b7
34017e1c:	340218d6 	.word	0x340218d6
34017e20:	580fe000 	.word	0x580fe000
34017e24:	340ceee8 	.word	0x340ceee8
34017e28:	340219b3 	.word	0x340219b3
34017e2c:	34021989 	.word	0x34021989

34017e30 <__LL_ATON_RT_DetermineNextEpochBlock>:
{
34017e30:	b508      	push	{r3, lr}
  LL_ATON_ASSERT(nn_instance != NULL);
34017e32:	b928      	cbnz	r0, 34017e40 <__LL_ATON_RT_DetermineNextEpochBlock+0x10>
34017e34:	21f8      	movs	r1, #248	@ 0xf8
34017e36:	4b1a      	ldr	r3, [pc, #104]	@ (34017ea0 <__LL_ATON_RT_DetermineNextEpochBlock+0x70>)
34017e38:	4a1a      	ldr	r2, [pc, #104]	@ (34017ea4 <__LL_ATON_RT_DetermineNextEpochBlock+0x74>)
  LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
34017e3a:	481b      	ldr	r0, [pc, #108]	@ (34017ea8 <__LL_ATON_RT_DetermineNextEpochBlock+0x78>)
34017e3c:	f001 f80e 	bl	34018e5c <__assert_func>
34017e40:	69c3      	ldr	r3, [r0, #28]
34017e42:	b11b      	cbz	r3, 34017e4c <__LL_ATON_RT_DetermineNextEpochBlock+0x1c>
34017e44:	21fa      	movs	r1, #250	@ 0xfa
34017e46:	4b19      	ldr	r3, [pc, #100]	@ (34017eac <__LL_ATON_RT_DetermineNextEpochBlock+0x7c>)
34017e48:	4a16      	ldr	r2, [pc, #88]	@ (34017ea4 <__LL_ATON_RT_DetermineNextEpochBlock+0x74>)
34017e4a:	e7f6      	b.n	34017e3a <__LL_ATON_RT_DetermineNextEpochBlock+0xa>
  if ((nn_instance->exec_state.next_epoch_block != NULL))
34017e4c:	68c3      	ldr	r3, [r0, #12]
34017e4e:	b313      	cbz	r3, 34017e96 <__LL_ATON_RT_DetermineNextEpochBlock+0x66>
    LL_ATON_ASSERT(nn_instance->exec_state.saved_current_epoch_block == NULL);
34017e50:	6903      	ldr	r3, [r0, #16]
34017e52:	b123      	cbz	r3, 34017e5e <__LL_ATON_RT_DetermineNextEpochBlock+0x2e>
34017e54:	f44f 7181 	mov.w	r1, #258	@ 0x102
34017e58:	4b15      	ldr	r3, [pc, #84]	@ (34017eb0 <__LL_ATON_RT_DetermineNextEpochBlock+0x80>)
34017e5a:	4a12      	ldr	r2, [pc, #72]	@ (34017ea4 <__LL_ATON_RT_DetermineNextEpochBlock+0x74>)
34017e5c:	e7ed      	b.n	34017e3a <__LL_ATON_RT_DetermineNextEpochBlock+0xa>
    nn_instance->exec_state.saved_current_epoch_block = nn_instance->exec_state.current_epoch_block;
34017e5e:	6843      	ldr	r3, [r0, #4]
34017e60:	6103      	str	r3, [r0, #16]
    nn_instance->exec_state.saved_first_epoch_block = nn_instance->exec_state.first_epoch_block;
34017e62:	6883      	ldr	r3, [r0, #8]
34017e64:	6143      	str	r3, [r0, #20]
    nn_instance->exec_state.saved_nr_of_epoch_blocks = nn_instance->exec_state.nr_of_epoch_blocks;
34017e66:	6a43      	ldr	r3, [r0, #36]	@ 0x24
34017e68:	6283      	str	r3, [r0, #40]	@ 0x28
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.next_epoch_block;
34017e6a:	68c3      	ldr	r3, [r0, #12]
34017e6c:	6043      	str	r3, [r0, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.next_epoch_block;
34017e6e:	68c3      	ldr	r3, [r0, #12]
34017e70:	6083      	str	r3, [r0, #8]
    nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.first_epoch_block);
34017e72:	6883      	ldr	r3, [r0, #8]
  if (list != NULL)
34017e74:	b96b      	cbnz	r3, 34017e92 <__LL_ATON_RT_DetermineNextEpochBlock+0x62>
  int i = 0;
34017e76:	461a      	mov	r2, r3
    nn_instance->exec_state.next_epoch_block = NULL;
34017e78:	2300      	movs	r3, #0
    nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.first_epoch_block);
34017e7a:	6242      	str	r2, [r0, #36]	@ 0x24
    nn_instance->exec_state.next_epoch_block = NULL;
34017e7c:	60c3      	str	r3, [r0, #12]
  nn_instance->exec_state.current_epoch_block_started = false;
34017e7e:	2300      	movs	r3, #0
34017e80:	f880 3020 	strb.w	r3, [r0, #32]
}
34017e84:	bd08      	pop	{r3, pc}
      list++;
34017e86:	3314      	adds	r3, #20
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
34017e88:	3201      	adds	r2, #1
34017e8a:	8a19      	ldrh	r1, [r3, #16]
34017e8c:	0709      	lsls	r1, r1, #28
34017e8e:	d5fa      	bpl.n	34017e86 <__LL_ATON_RT_DetermineNextEpochBlock+0x56>
34017e90:	e7f2      	b.n	34017e78 <__LL_ATON_RT_DetermineNextEpochBlock+0x48>
34017e92:	2201      	movs	r2, #1
34017e94:	e7f9      	b.n	34017e8a <__LL_ATON_RT_DetermineNextEpochBlock+0x5a>
    nn_instance->exec_state.current_epoch_block++;
34017e96:	6843      	ldr	r3, [r0, #4]
34017e98:	3314      	adds	r3, #20
34017e9a:	6043      	str	r3, [r0, #4]
34017e9c:	e7ef      	b.n	34017e7e <__LL_ATON_RT_DetermineNextEpochBlock+0x4e>
34017e9e:	bf00      	nop
34017ea0:	34021a21 	.word	0x34021a21
34017ea4:	340ae692 	.word	0x340ae692
34017ea8:	340218d6 	.word	0x340218d6
34017eac:	34021a3c 	.word	0x34021a3c
34017eb0:	34021a6c 	.word	0x34021a6c

34017eb4 <dump_dma_state>:
LL_ATON_WEAK void dump_dma_state(void){};
34017eb4:	4770      	bx	lr
	...

34017eb8 <__LL_ATON_RT_IrqErr>:
#if (ATON_INT_NR > 32)
static void __LL_ATON_RT_IrqErr(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static void __LL_ATON_RT_IrqErr(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
34017eb8:	b538      	push	{r3, r4, r5, lr}
  extern void dump_dma_state(void);
  int32_t i;

  if (!irqs)
34017eba:	4604      	mov	r4, r0
34017ebc:	2800      	cmp	r0, #0
34017ebe:	d05b      	beq.n	34017f78 <__LL_ATON_RT_IrqErr+0xc0>
    return;

#ifdef ATON_STRENG_NUM
  /* Streaming Engine Error interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRENG_ERR_INT_MASK, ATON_STRENG_NUM))
34017ec0:	4b2e      	ldr	r3, [pc, #184]	@ (34017f7c <__LL_ATON_RT_IrqErr+0xc4>)
34017ec2:	4003      	ands	r3, r0
34017ec4:	d007      	beq.n	34017ed6 <__LL_ATON_RT_IrqErr+0x1e>

    masked_irqs = (irqs & ATON_INT_GET_MASK(ATON_STRENG_ERR_INT_MASK, ATON_STRENG_NUM));

    // assumes that stream engine interrupts are assigned in the order of their engine number and to consecutive bits
    // within the `INTREG` register
    uint32_t streaming_engine_nr = (uint32_t)(masked_irqs & (-masked_irqs));
34017ec6:	4259      	negs	r1, r3
34017ec8:	4019      	ands	r1, r3
    streaming_engine_nr -= ATON_STRENG_INT(0);

#ifndef NDEBUG
    uint32_t streng_err = ATON_STRENG_IRQ_GET(streaming_engine_nr);
34017eca:	4b2d      	ldr	r3, [pc, #180]	@ (34017f80 <__LL_ATON_RT_IrqErr+0xc8>)
34017ecc:	030a      	lsls	r2, r1, #12
34017ece:	58d2      	ldr	r2, [r2, r3]
    LL_ATON_PRINTF("Streaming engine #%" PRIu32 " error interrupt: 0x%" PRIx32 "\n", streaming_engine_nr, streng_err);
34017ed0:	482c      	ldr	r0, [pc, #176]	@ (34017f84 <__LL_ATON_RT_IrqErr+0xcc>)
34017ed2:	f001 ff53 	bl	34019d7c <iprintf>
#endif // NDEBUG
  }
  /* Streaming Engine interrupts */
  if (irqs & ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0))
34017ed6:	f3c4 0309 	ubfx	r3, r4, #0, #10
34017eda:	b113      	cbz	r3, 34017ee2 <__LL_ATON_RT_IrqErr+0x2a>
  {
    LL_ATON_PRINTF("Streaming engine completion interrupt\n");
34017edc:	482a      	ldr	r0, [pc, #168]	@ (34017f88 <__LL_ATON_RT_IrqErr+0xd0>)
34017ede:	f001 ffb5 	bl	34019e4c <puts>
  }
#endif // ATON_STRENG_NUM

#ifdef ATON_CONVACC_NUM
  /* Convolutional accelerators interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_CONVACC_INT_MASK, ATON_CONVACC_NUM))
34017ee2:	f414 0f70 	tst.w	r4, #15728640	@ 0xf00000
34017ee6:	d002      	beq.n	34017eee <__LL_ATON_RT_IrqErr+0x36>
  {
    LL_ATON_PRINTF("Convolutional accelerator interrupt\n");
34017ee8:	4828      	ldr	r0, [pc, #160]	@ (34017f8c <__LL_ATON_RT_IrqErr+0xd4>)
34017eea:	f001 ffaf 	bl	34019e4c <puts>
  }
#endif // ATON_CONVACC_NUM

#if defined(ATON_RECBUF_NUM)
  /* Reconfigurable buffer interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_RECBUF_INT_MASK, ATON_RECBUF_NUM))
34017eee:	01e5      	lsls	r5, r4, #7
34017ef0:	d502      	bpl.n	34017ef8 <__LL_ATON_RT_IrqErr+0x40>
  {
    LL_ATON_PRINTF("Reconfigurable buffer interrupt\n");
34017ef2:	4827      	ldr	r0, [pc, #156]	@ (34017f90 <__LL_ATON_RT_IrqErr+0xd8>)
34017ef4:	f001 ffaa 	bl	34019e4c <puts>
  }
#endif // ATON_RECBUF_NUM

#ifdef ATON_BUSIF_NUM
  /* Bus interface interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_BUSIF_INT_MASK, ATON_BUSIF_NUM))
34017ef8:	f014 6fc0 	tst.w	r4, #100663296	@ 0x6000000
34017efc:	d00e      	beq.n	34017f1c <__LL_ATON_RT_IrqErr+0x64>
  {
    LL_ATON_PRINTF("Bus interface interrupt\n");
34017efe:	4825      	ldr	r0, [pc, #148]	@ (34017f94 <__LL_ATON_RT_IrqErr+0xdc>)
34017f00:	f001 ffa4 	bl	34019e4c <puts>

    /* Report offending stream engine */
    for (i = 0; i < ATON_BUSIF_NUM; i++)
      LL_ATON_PRINTF("BUSIF%" PRId32 " ERR: 0x%" PRIx32 "\n", i, ATON_BUSIF_ERR_GET(i));
34017f04:	4b24      	ldr	r3, [pc, #144]	@ (34017f98 <__LL_ATON_RT_IrqErr+0xe0>)
34017f06:	2100      	movs	r1, #0
34017f08:	691a      	ldr	r2, [r3, #16]
34017f0a:	4824      	ldr	r0, [pc, #144]	@ (34017f9c <__LL_ATON_RT_IrqErr+0xe4>)
34017f0c:	f001 ff36 	bl	34019d7c <iprintf>
34017f10:	4b23      	ldr	r3, [pc, #140]	@ (34017fa0 <__LL_ATON_RT_IrqErr+0xe8>)
34017f12:	2101      	movs	r1, #1
34017f14:	691a      	ldr	r2, [r3, #16]
34017f16:	4821      	ldr	r0, [pc, #132]	@ (34017f9c <__LL_ATON_RT_IrqErr+0xe4>)
34017f18:	f001 ff30 	bl	34019d7c <iprintf>
  }
#endif // ATON_BUSIF_NUM

#if defined(ATON_STRSWITCH_NUM)
  /* Stream switch interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRSWITCH_INT_MASK, ATON_STRSWITCH_NUM))
34017f1c:	0120      	lsls	r0, r4, #4
34017f1e:	d502      	bpl.n	34017f26 <__LL_ATON_RT_IrqErr+0x6e>
  {
    LL_ATON_PRINTF("Stream switch interrupt\n");
34017f20:	4820      	ldr	r0, [pc, #128]	@ (34017fa4 <__LL_ATON_RT_IrqErr+0xec>)
34017f22:	f001 ff93 	bl	34019e4c <puts>
  }
#endif // ATON_STRSWITCH_NUM

#if defined(ATON_EPOCHCTRL_NUM)
  /* Epoch Controller interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_ERR_INT_MASK, ATON_EPOCHCTRL_NUM))
34017f26:	0061      	lsls	r1, r4, #1
34017f28:	d50c      	bpl.n	34017f44 <__LL_ATON_RT_IrqErr+0x8c>
  {
    LL_ATON_PRINTF("Epoch Controller ERROR interrupt: EC_IRQ = 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_IRQ_GET(0));
34017f2a:	4d1f      	ldr	r5, [pc, #124]	@ (34017fa8 <__LL_ATON_RT_IrqErr+0xf0>)
34017f2c:	481f      	ldr	r0, [pc, #124]	@ (34017fac <__LL_ATON_RT_IrqErr+0xf4>)
34017f2e:	68e9      	ldr	r1, [r5, #12]
34017f30:	f001 ff24 	bl	34019d7c <iprintf>
    LL_ATON_PRINTF("Epoch Controller opcode counter: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_BC_GET(0));
34017f34:	6a29      	ldr	r1, [r5, #32]
34017f36:	481e      	ldr	r0, [pc, #120]	@ (34017fb0 <__LL_ATON_RT_IrqErr+0xf8>)
34017f38:	f001 ff20 	bl	34019d7c <iprintf>
    LL_ATON_PRINTF("Epoch Controller label: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_LABEL_GET(0));
34017f3c:	69e9      	ldr	r1, [r5, #28]
34017f3e:	481d      	ldr	r0, [pc, #116]	@ (34017fb4 <__LL_ATON_RT_IrqErr+0xfc>)
34017f40:	f001 ff1c 	bl	34019d7c <iprintf>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_NOACK_INT_MASK, ATON_EPOCHCTRL_NUM))
34017f44:	00a2      	lsls	r2, r4, #2
34017f46:	d502      	bpl.n	34017f4e <__LL_ATON_RT_IrqErr+0x96>
  {
    LL_ATON_PRINTF("Epoch Controller NOACK interrupt\n");
34017f48:	481b      	ldr	r0, [pc, #108]	@ (34017fb8 <__LL_ATON_RT_IrqErr+0x100>)
34017f4a:	f001 ff7f 	bl	34019e4c <puts>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ATON_EPOCHCTRL_NUM))
34017f4e:	00e3      	lsls	r3, r4, #3
34017f50:	d502      	bpl.n	34017f58 <__LL_ATON_RT_IrqErr+0xa0>
  {
    LL_ATON_PRINTF("Epoch Controller interrupt\n");
34017f52:	481a      	ldr	r0, [pc, #104]	@ (34017fbc <__LL_ATON_RT_IrqErr+0x104>)
34017f54:	f001 ff7a 	bl	34019e4c <puts>
  }
#endif // ATON_EPOCHCTRL_NUM

  /* default error handling */
  dump_dma_state();
34017f58:	f7ff ffac 	bl	34017eb4 <dump_dma_state>
  IRQ_ERR_MSG(); // just for debug
34017f5c:	4622      	mov	r2, r4
34017f5e:	2300      	movs	r3, #0
34017f60:	f240 3153 	movw	r1, #851	@ 0x353
34017f64:	4816      	ldr	r0, [pc, #88]	@ (34017fc0 <__LL_ATON_RT_IrqErr+0x108>)
34017f66:	f001 ff09 	bl	34019d7c <iprintf>
#if (ATON_PLAT_HAS_FFLUSH)
  LL_ATON_FFLUSH(stdout);
#endif
  LL_ATON_ASSERT(false); // may never happen
34017f6a:	f240 3157 	movw	r1, #855	@ 0x357
34017f6e:	4b15      	ldr	r3, [pc, #84]	@ (34017fc4 <__LL_ATON_RT_IrqErr+0x10c>)
34017f70:	4a15      	ldr	r2, [pc, #84]	@ (34017fc8 <__LL_ATON_RT_IrqErr+0x110>)
34017f72:	4816      	ldr	r0, [pc, #88]	@ (34017fcc <__LL_ATON_RT_IrqErr+0x114>)
34017f74:	f000 ff72 	bl	34018e5c <__assert_func>
  // All of the above not handled interrupts should be changed in a way that allows both a return from
  // this IRQ handler (w/o immediate re-entry) and to return control back to the user's main loop e.g. by using an
  // internal flag/variable to signal the error, then performing a `LL_ATON_RT_RuntimeDeInit()`, and returning with a
  // respective (new) return value (of type `LL_ATON_RT_RetValues_t`), reporting about the error, from the latest
  // call to `LL_ATON_RT_RunEpochBlock()`
}
34017f78:	bd38      	pop	{r3, r4, r5, pc}
34017f7a:	bf00      	nop
34017f7c:	000ffc00 	.word	0x000ffc00
34017f80:	580e503c 	.word	0x580e503c
34017f84:	34021aad 	.word	0x34021aad
34017f88:	34021adb 	.word	0x34021adb
34017f8c:	34021b01 	.word	0x34021b01
34017f90:	34021b25 	.word	0x34021b25
34017f94:	34021b45 	.word	0x34021b45
34017f98:	580e2000 	.word	0x580e2000
34017f9c:	34021b5d 	.word	0x34021b5d
34017fa0:	580e3000 	.word	0x580e3000
34017fa4:	34021b72 	.word	0x34021b72
34017fa8:	580fe000 	.word	0x580fe000
34017fac:	34021b8a 	.word	0x34021b8a
34017fb0:	34021bbe 	.word	0x34021bbe
34017fb4:	34021be8 	.word	0x34021be8
34017fb8:	34021c09 	.word	0x34021c09
34017fbc:	34021c2a 	.word	0x34021c2a
34017fc0:	34021c45 	.word	0x34021c45
34017fc4:	340217f8 	.word	0x340217f8
34017fc8:	340ae66e 	.word	0x340ae66e
34017fcc:	340218d6 	.word	0x340218d6

34017fd0 <LL_ATON_RT_Init_Network>:
{
34017fd0:	b510      	push	{r4, lr}
  if (nn_instance == NULL)
34017fd2:	4604      	mov	r4, r0
34017fd4:	b1b0      	cbz	r0, 34018004 <LL_ATON_RT_Init_Network+0x34>
  if (nn_instance->network == NULL)
34017fd6:	6803      	ldr	r3, [r0, #0]
34017fd8:	b1a3      	cbz	r3, 34018004 <LL_ATON_RT_Init_Network+0x34>
  LL_ATON_ASSERT(nn_instance->network->ec_network_init != NULL);
34017fda:	685b      	ldr	r3, [r3, #4]
34017fdc:	b933      	cbnz	r3, 34017fec <LL_ATON_RT_Init_Network+0x1c>
34017fde:	f240 11af 	movw	r1, #431	@ 0x1af
34017fe2:	4b09      	ldr	r3, [pc, #36]	@ (34018008 <LL_ATON_RT_Init_Network+0x38>)
34017fe4:	4a09      	ldr	r2, [pc, #36]	@ (3401800c <LL_ATON_RT_Init_Network+0x3c>)
  LL_ATON_ASSERT(ret == true);
34017fe6:	480a      	ldr	r0, [pc, #40]	@ (34018010 <LL_ATON_RT_Init_Network+0x40>)
34017fe8:	f000 ff38 	bl	34018e5c <__assert_func>
  bool ret = nn_instance->network->ec_network_init();
34017fec:	4798      	blx	r3
  LL_ATON_ASSERT(ret == true);
34017fee:	b920      	cbnz	r0, 34017ffa <LL_ATON_RT_Init_Network+0x2a>
34017ff0:	f44f 71d9 	mov.w	r1, #434	@ 0x1b2
34017ff4:	4b07      	ldr	r3, [pc, #28]	@ (34018014 <LL_ATON_RT_Init_Network+0x44>)
34017ff6:	4a05      	ldr	r2, [pc, #20]	@ (3401800c <LL_ATON_RT_Init_Network+0x3c>)
34017ff8:	e7f5      	b.n	34017fe6 <LL_ATON_RT_Init_Network+0x16>
  __LL_ATON_RT_Init_Network(nn_instance);
34017ffa:	4620      	mov	r0, r4
}
34017ffc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __LL_ATON_RT_Init_Network(nn_instance);
34018000:	f7ff be34 	b.w	34017c6c <__LL_ATON_RT_Init_Network>
}
34018004:	bd10      	pop	{r4, pc}
34018006:	bf00      	nop
34018008:	34021c6c 	.word	0x34021c6c
3401800c:	340ae7b8 	.word	0x340ae7b8
34018010:	340218d6 	.word	0x340218d6
34018014:	34021ca1 	.word	0x34021ca1

34018018 <LL_ATON_RT_DeInit_Network>:
{
34018018:	b510      	push	{r4, lr}
  if (nn_instance == NULL)
3401801a:	4604      	mov	r4, r0
3401801c:	b1b8      	cbz	r0, 3401804e <LL_ATON_RT_DeInit_Network+0x36>
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401801e:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
34018020:	b11b      	cbz	r3, 3401802a <LL_ATON_RT_DeInit_Network+0x12>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_DeInit, nn_instance, NULL);
34018022:	4601      	mov	r1, r0
34018024:	2200      	movs	r2, #0
34018026:	2005      	movs	r0, #5
34018028:	4798      	blx	r3
  if (nn_instance == __ll_current_aton_ip_owner)
3401802a:	4b09      	ldr	r3, [pc, #36]	@ (34018050 <LL_ATON_RT_DeInit_Network+0x38>)
3401802c:	681b      	ldr	r3, [r3, #0]
3401802e:	42a3      	cmp	r3, r4
34018030:	d102      	bne.n	34018038 <LL_ATON_RT_DeInit_Network+0x20>
    __ll_clear_aton_owner(nn_instance);
34018032:	4620      	mov	r0, r4
34018034:	f7ff fe42 	bl	34017cbc <__ll_clear_aton_owner>
  nn_instance->exec_state.current_epoch_block = eb_list;
34018038:	2300      	movs	r3, #0
3401803a:	6063      	str	r3, [r4, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
3401803c:	60a3      	str	r3, [r4, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
3401803e:	60e3      	str	r3, [r4, #12]
  nn_instance->exec_state.saved_current_epoch_block = NULL;
34018040:	6123      	str	r3, [r4, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
34018042:	6163      	str	r3, [r4, #20]
  nn_instance->exec_state.nr_of_epoch_blocks = 0;
34018044:	6263      	str	r3, [r4, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
34018046:	62a3      	str	r3, [r4, #40]	@ 0x28
  nn_instance->exec_state.triggered_events = 0x0;
34018048:	61e3      	str	r3, [r4, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
3401804a:	f884 3020 	strb.w	r3, [r4, #32]
}
3401804e:	bd10      	pop	{r4, pc}
34018050:	340ceee8 	.word	0x340ceee8

34018054 <LL_ATON_RT_Reset_Network>:
{
34018054:	b510      	push	{r4, lr}
34018056:	4604      	mov	r4, r0
  LL_ATON_RT_DeInit_Network(nn_instance);
34018058:	f7ff ffde 	bl	34018018 <LL_ATON_RT_DeInit_Network>
  __LL_ATON_RT_Init_Network(nn_instance);
3401805c:	4620      	mov	r0, r4
}
3401805e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __LL_ATON_RT_Init_Network(nn_instance);
34018062:	f7ff be03 	b.w	34017c6c <__LL_ATON_RT_Init_Network>
	...

34018068 <LL_ATON_RT_RuntimeInit>:
{
34018068:	b510      	push	{r4, lr}
  LL_ATON_Init();
3401806a:	f7fe f929 	bl	340162c0 <LL_ATON_Init>
    ATON_DISABLE_CLR_CONFCLR(INTCTRL, 0);
3401806e:	2202      	movs	r2, #2
34018070:	4b1f      	ldr	r3, [pc, #124]	@ (340180f0 <LL_ATON_RT_RuntimeInit+0x88>)
34018072:	601a      	str	r2, [r3, #0]
34018074:	681a      	ldr	r2, [r3, #0]
34018076:	0791      	lsls	r1, r2, #30
34018078:	d4fc      	bmi.n	34018074 <LL_ATON_RT_RuntimeInit+0xc>
3401807a:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
3401807e:	601a      	str	r2, [r3, #0]
34018080:	681a      	ldr	r2, [r3, #0]
34018082:	0052      	lsls	r2, r2, #1
34018084:	d4fc      	bmi.n	34018080 <LL_ATON_RT_RuntimeInit+0x18>
    ATON_INTCTRL_STD_INTORMSK_SET(ATON_STRENG_INT_MASK(
34018086:	f240 32ff 	movw	r2, #1023	@ 0x3ff
3401808a:	615a      	str	r2, [r3, #20]
    ATON_INTCTRL_STD_INTANDMSK_SET(0xFFFFFFFF); // AND-mask: disable all events & errors
3401808c:	f04f 32ff 	mov.w	r2, #4294967295
34018090:	625a      	str	r2, [r3, #36]	@ 0x24
    ATON_ENABLE(INTCTRL, 0);
34018092:	681a      	ldr	r2, [r3, #0]
34018094:	f042 0201 	orr.w	r2, r2, #1
34018098:	601a      	str	r2, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
3401809a:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
3401809e:	4b15      	ldr	r3, [pc, #84]	@ (340180f4 <LL_ATON_RT_RuntimeInit+0x8c>)
340180a0:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
340180a4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340180a8:	f3bf 8f6f 	isb	sy
340180ac:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
340180b0:	f8c3 1084 	str.w	r1, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
340180b4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340180b8:	f3bf 8f6f 	isb	sy
340180bc:	f44f 0100 	mov.w	r1, #8388608	@ 0x800000
340180c0:	f8c3 1084 	str.w	r1, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
340180c4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340180c8:	f3bf 8f6f 	isb	sy
340180cc:	f04f 7180 	mov.w	r1, #16777216	@ 0x1000000
340180d0:	f8c3 1084 	str.w	r1, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
340180d4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340180d8:	f3bf 8f6f 	isb	sy
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
340180dc:	605a      	str	r2, [r3, #4]
  if (ll_aton_init_deinit_trace)
340180de:	4b06      	ldr	r3, [pc, #24]	@ (340180f8 <LL_ATON_RT_RuntimeInit+0x90>)
340180e0:	681b      	ldr	r3, [r3, #0]
340180e2:	b11b      	cbz	r3, 340180ec <LL_ATON_RT_RuntimeInit+0x84>
}
340180e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ll_aton_init_deinit_trace(LL_ATON_RT_Callbacktype_RT_Init);
340180e8:	2006      	movs	r0, #6
340180ea:	4718      	bx	r3
}
340180ec:	bd10      	pop	{r4, pc}
340180ee:	bf00      	nop
340180f0:	580e1000 	.word	0x580e1000
340180f4:	e000e100 	.word	0xe000e100
340180f8:	340ceee0 	.word	0x340ceee0

340180fc <LL_ATON_RT_RunEpochBlock>:
{
340180fc:	b573      	push	{r0, r1, r4, r5, r6, lr}
  LL_ATON_ASSERT(nn_instance != NULL);
340180fe:	4604      	mov	r4, r0
34018100:	b930      	cbnz	r0, 34018110 <LL_ATON_RT_RunEpochBlock+0x14>
34018102:	f240 2149 	movw	r1, #585	@ 0x249
34018106:	4b8c      	ldr	r3, [pc, #560]	@ (34018338 <LL_ATON_RT_RunEpochBlock+0x23c>)
34018108:	4a8c      	ldr	r2, [pc, #560]	@ (3401833c <LL_ATON_RT_RunEpochBlock+0x240>)
  LL_ATON_ASSERT(nn_instance->exec_state.current_epoch_block != NULL); // should never happen
3401810a:	488d      	ldr	r0, [pc, #564]	@ (34018340 <LL_ATON_RT_RunEpochBlock+0x244>)
3401810c:	f000 fea6 	bl	34018e5c <__assert_func>
34018110:	6843      	ldr	r3, [r0, #4]
34018112:	b923      	cbnz	r3, 3401811e <LL_ATON_RT_RunEpochBlock+0x22>
34018114:	f44f 7113 	mov.w	r1, #588	@ 0x24c
34018118:	4b8a      	ldr	r3, [pc, #552]	@ (34018344 <LL_ATON_RT_RunEpochBlock+0x248>)
3401811a:	4a88      	ldr	r2, [pc, #544]	@ (3401833c <LL_ATON_RT_RunEpochBlock+0x240>)
3401811c:	e7f5      	b.n	3401810a <LL_ATON_RT_RunEpochBlock+0xe>
  if (nn_instance->exec_state.inference_started == false)
3401811e:	7e03      	ldrb	r3, [r0, #24]
34018120:	b98b      	cbnz	r3, 34018146 <LL_ATON_RT_RunEpochBlock+0x4a>
    LL_ATON_ASSERT((nn_instance->network != NULL) && (nn_instance->network->ec_inference_init != NULL));
34018122:	6803      	ldr	r3, [r0, #0]
34018124:	b10b      	cbz	r3, 3401812a <LL_ATON_RT_RunEpochBlock+0x2e>
34018126:	689b      	ldr	r3, [r3, #8]
34018128:	b923      	cbnz	r3, 34018134 <LL_ATON_RT_RunEpochBlock+0x38>
3401812a:	f240 215e 	movw	r1, #606	@ 0x25e
3401812e:	4b86      	ldr	r3, [pc, #536]	@ (34018348 <LL_ATON_RT_RunEpochBlock+0x24c>)
34018130:	4a82      	ldr	r2, [pc, #520]	@ (3401833c <LL_ATON_RT_RunEpochBlock+0x240>)
34018132:	e7ea      	b.n	3401810a <LL_ATON_RT_RunEpochBlock+0xe>
    bool ret = nn_instance->network->ec_inference_init();
34018134:	4798      	blx	r3
    LL_ATON_ASSERT(ret == true);
34018136:	b920      	cbnz	r0, 34018142 <LL_ATON_RT_RunEpochBlock+0x46>
34018138:	f240 2162 	movw	r1, #610	@ 0x262
3401813c:	4b83      	ldr	r3, [pc, #524]	@ (3401834c <LL_ATON_RT_RunEpochBlock+0x250>)
3401813e:	4a7f      	ldr	r2, [pc, #508]	@ (3401833c <LL_ATON_RT_RunEpochBlock+0x240>)
34018140:	e7e3      	b.n	3401810a <LL_ATON_RT_RunEpochBlock+0xe>
    nn_instance->exec_state.inference_started = true;
34018142:	2301      	movs	r3, #1
34018144:	7623      	strb	r3, [r4, #24]
    uint32_t _wait_mask = __LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block);
34018146:	6860      	ldr	r0, [r4, #4]
  if (EpochBlock_IsEpochBlob(eb))
34018148:	8a03      	ldrh	r3, [r0, #16]
3401814a:	075a      	lsls	r2, r3, #29
3401814c:	d512      	bpl.n	34018174 <LL_ATON_RT_RunEpochBlock+0x78>
    return (1 << EpochBlock_EpochControllerUnit(eb));
3401814e:	f7ff fdf1 	bl	34017d34 <EpochBlock_EpochControllerUnit>
34018152:	2301      	movs	r3, #1
34018154:	fa03 f000 	lsl.w	r0, r3, r0
    if (nn_instance->exec_state.current_epoch_block_started && (_wait_mask != 0))
34018158:	f894 3020 	ldrb.w	r3, [r4, #32]
3401815c:	f003 06ff 	and.w	r6, r3, #255	@ 0xff
34018160:	b343      	cbz	r3, 340181b4 <LL_ATON_RT_RunEpochBlock+0xb8>
34018162:	2800      	cmp	r0, #0
34018164:	d036      	beq.n	340181d4 <LL_ATON_RT_RunEpochBlock+0xd8>
      if ((nn_instance->exec_state.triggered_events & _wait_mask) == _wait_mask)
34018166:	69e3      	ldr	r3, [r4, #28]
34018168:	ea30 0303 	bics.w	r3, r0, r3
3401816c:	d004      	beq.n	34018178 <LL_ATON_RT_RunEpochBlock+0x7c>
        return LL_ATON_RT_WFE;
3401816e:	2001      	movs	r0, #1
}
34018170:	b002      	add	sp, #8
34018172:	bd70      	pop	{r4, r5, r6, pc}
    return eb->wait_mask; // in case of "normal" epoch block `wait_mask` contains bitmask of (output) stream engines to
34018174:	68c0      	ldr	r0, [r0, #12]
34018176:	e7ef      	b.n	34018158 <LL_ATON_RT_RunEpochBlock+0x5c>
        LL_ATON_ASSERT(__ll_current_aton_ip_owner ==
34018178:	4b75      	ldr	r3, [pc, #468]	@ (34018350 <LL_ATON_RT_RunEpochBlock+0x254>)
3401817a:	681b      	ldr	r3, [r3, #0]
3401817c:	42a3      	cmp	r3, r4
3401817e:	d004      	beq.n	3401818a <LL_ATON_RT_RunEpochBlock+0x8e>
34018180:	f240 217a 	movw	r1, #634	@ 0x27a
34018184:	4b73      	ldr	r3, [pc, #460]	@ (34018354 <LL_ATON_RT_RunEpochBlock+0x258>)
34018186:	4a6d      	ldr	r2, [pc, #436]	@ (3401833c <LL_ATON_RT_RunEpochBlock+0x240>)
34018188:	e7bf      	b.n	3401810a <LL_ATON_RT_RunEpochBlock+0xe>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
3401818a:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
3401818e:	4a72      	ldr	r2, [pc, #456]	@ (34018358 <LL_ATON_RT_RunEpochBlock+0x25c>)
34018190:	f8c2 1084 	str.w	r1, [r2, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34018194:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34018198:	f3bf 8f6f 	isb	sy
        nn_instance->exec_state.triggered_events &= ~_wait_mask;
3401819c:	69e3      	ldr	r3, [r4, #28]
3401819e:	ea23 0300 	bic.w	r3, r3, r0
340181a2:	61e3      	str	r3, [r4, #28]
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
340181a4:	6051      	str	r1, [r2, #4]
        __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
340181a6:	6860      	ldr	r0, [r4, #4]
340181a8:	4621      	mov	r1, r4
340181aa:	f7ff fdd7 	bl	34017d5c <__LL_ATON_RT_ExecEndEpochBlock>
        __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
340181ae:	4620      	mov	r0, r4
340181b0:	f7ff fe3e 	bl	34017e30 <__LL_ATON_RT_DetermineNextEpochBlock>
    if (EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block))
340181b4:	6863      	ldr	r3, [r4, #4]
340181b6:	8a1b      	ldrh	r3, [r3, #16]
340181b8:	071b      	lsls	r3, r3, #28
340181ba:	d534      	bpl.n	34018226 <LL_ATON_RT_RunEpochBlock+0x12a>
      if (nn_instance->exec_state.saved_current_epoch_block != NULL)
340181bc:	6923      	ldr	r3, [r4, #16]
340181be:	2b00      	cmp	r3, #0
340181c0:	f000 80b7 	beq.w	34018332 <LL_ATON_RT_RunEpochBlock+0x236>
    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
340181c4:	4b62      	ldr	r3, [pc, #392]	@ (34018350 <LL_ATON_RT_RunEpochBlock+0x254>)
340181c6:	681a      	ldr	r2, [r3, #0]
340181c8:	b932      	cbnz	r2, 340181d8 <LL_ATON_RT_RunEpochBlock+0xdc>
340181ca:	218e      	movs	r1, #142	@ 0x8e
340181cc:	4b63      	ldr	r3, [pc, #396]	@ (3401835c <LL_ATON_RT_RunEpochBlock+0x260>)
340181ce:	4a64      	ldr	r2, [pc, #400]	@ (34018360 <LL_ATON_RT_RunEpochBlock+0x264>)
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
340181d0:	4864      	ldr	r0, [pc, #400]	@ (34018364 <LL_ATON_RT_RunEpochBlock+0x268>)
340181d2:	e79b      	b.n	3401810c <LL_ATON_RT_RunEpochBlock+0x10>
  bool this_run_executed_end_epoch = false;
340181d4:	4606      	mov	r6, r0
340181d6:	e7ed      	b.n	340181b4 <LL_ATON_RT_RunEpochBlock+0xb8>
    LL_ATON_ASSERT(unlock ? EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block)
340181d8:	6862      	ldr	r2, [r4, #4]
340181da:	8a12      	ldrh	r2, [r2, #16]
340181dc:	0716      	lsls	r6, r2, #28
340181de:	d403      	bmi.n	340181e8 <LL_ATON_RT_RunEpochBlock+0xec>
340181e0:	218f      	movs	r1, #143	@ 0x8f
340181e2:	4b61      	ldr	r3, [pc, #388]	@ (34018368 <LL_ATON_RT_RunEpochBlock+0x26c>)
340181e4:	4a5e      	ldr	r2, [pc, #376]	@ (34018360 <LL_ATON_RT_RunEpochBlock+0x264>)
340181e6:	e7f3      	b.n	340181d0 <LL_ATON_RT_RunEpochBlock+0xd4>
    LL_ATON_ASSERT(EpochBlock_IsEpochHybrid(nn_instance->exec_state.saved_current_epoch_block));
340181e8:	6922      	ldr	r2, [r4, #16]
340181ea:	8a12      	ldrh	r2, [r2, #16]
340181ec:	0655      	lsls	r5, r2, #25
340181ee:	d403      	bmi.n	340181f8 <LL_ATON_RT_RunEpochBlock+0xfc>
340181f0:	2191      	movs	r1, #145	@ 0x91
340181f2:	4b5e      	ldr	r3, [pc, #376]	@ (3401836c <LL_ATON_RT_RunEpochBlock+0x270>)
340181f4:	4a5a      	ldr	r2, [pc, #360]	@ (34018360 <LL_ATON_RT_RunEpochBlock+0x264>)
340181f6:	e7eb      	b.n	340181d0 <LL_ATON_RT_RunEpochBlock+0xd4>
      __ll_clear_aton_owner(__ll_current_aton_ip_owner);
340181f8:	6818      	ldr	r0, [r3, #0]
340181fa:	f7ff fd5f 	bl	34017cbc <__ll_clear_aton_owner>
    LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
340181fe:	68e3      	ldr	r3, [r4, #12]
34018200:	b11b      	cbz	r3, 3401820a <LL_ATON_RT_RunEpochBlock+0x10e>
34018202:	219a      	movs	r1, #154	@ 0x9a
34018204:	4b5a      	ldr	r3, [pc, #360]	@ (34018370 <LL_ATON_RT_RunEpochBlock+0x274>)
34018206:	4a56      	ldr	r2, [pc, #344]	@ (34018360 <LL_ATON_RT_RunEpochBlock+0x264>)
34018208:	e7e2      	b.n	340181d0 <LL_ATON_RT_RunEpochBlock+0xd4>
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.saved_current_epoch_block;
3401820a:	6922      	ldr	r2, [r4, #16]
3401820c:	6062      	str	r2, [r4, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.saved_first_epoch_block;
3401820e:	6962      	ldr	r2, [r4, #20]
34018210:	60a2      	str	r2, [r4, #8]
    nn_instance->exec_state.nr_of_epoch_blocks = nn_instance->exec_state.saved_nr_of_epoch_blocks;
34018212:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
34018214:	6262      	str	r2, [r4, #36]	@ 0x24
    nn_instance->exec_state.saved_current_epoch_block = NULL;
34018216:	6123      	str	r3, [r4, #16]
    nn_instance->exec_state.saved_first_epoch_block = NULL;
34018218:	6163      	str	r3, [r4, #20]
    nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401821a:	62a3      	str	r3, [r4, #40]	@ 0x28
        nn_instance->exec_state.current_epoch_block++;
3401821c:	6863      	ldr	r3, [r4, #4]
3401821e:	3314      	adds	r3, #20
34018220:	6063      	str	r3, [r4, #4]
        return LL_ATON_RT_NO_WFE;
34018222:	2000      	movs	r0, #0
34018224:	e7a4      	b.n	34018170 <LL_ATON_RT_RunEpochBlock+0x74>
    if (this_run_executed_end_epoch)
34018226:	2e00      	cmp	r6, #0
34018228:	d1fb      	bne.n	34018222 <LL_ATON_RT_RunEpochBlock+0x126>
    if (!nn_instance->exec_state.current_epoch_block_started)
3401822a:	f894 3020 	ldrb.w	r3, [r4, #32]
3401822e:	2b00      	cmp	r3, #0
34018230:	d169      	bne.n	34018306 <LL_ATON_RT_RunEpochBlock+0x20a>
      nn_instance->exec_state.current_epoch_block_started = true;
34018232:	2301      	movs	r3, #1
34018234:	f884 3020 	strb.w	r3, [r4, #32]
      __LL_ATON_RT_ExecStartEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
34018238:	6865      	ldr	r5, [r4, #4]
  LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
3401823a:	68e3      	ldr	r3, [r4, #12]
3401823c:	b11b      	cbz	r3, 34018246 <LL_ATON_RT_RunEpochBlock+0x14a>
3401823e:	2161      	movs	r1, #97	@ 0x61
34018240:	4b4b      	ldr	r3, [pc, #300]	@ (34018370 <LL_ATON_RT_RunEpochBlock+0x274>)
34018242:	4a4c      	ldr	r2, [pc, #304]	@ (34018374 <LL_ATON_RT_RunEpochBlock+0x278>)
34018244:	e761      	b.n	3401810a <LL_ATON_RT_RunEpochBlock+0xe>
  if (nn_instance->exec_state.epoch_callback_function != NULL)
34018246:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34018248:	b11b      	cbz	r3, 34018252 <LL_ATON_RT_RunEpochBlock+0x156>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_START, nn_instance, eb);
3401824a:	462a      	mov	r2, r5
3401824c:	4621      	mov	r1, r4
3401824e:	4630      	mov	r0, r6
34018250:	4798      	blx	r3
    return ((eb->flags & EpochBlock_Flags_epoch_start) != 0);
34018252:	8a2b      	ldrh	r3, [r5, #16]
  if (EpochBlock_IsEpochStart(eb))
34018254:	07d8      	lsls	r0, r3, #31
34018256:	d505      	bpl.n	34018264 <LL_ATON_RT_RunEpochBlock+0x168>
    LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
34018258:	69e2      	ldr	r2, [r4, #28]
3401825a:	b11a      	cbz	r2, 34018264 <LL_ATON_RT_RunEpochBlock+0x168>
3401825c:	214d      	movs	r1, #77	@ 0x4d
3401825e:	4b46      	ldr	r3, [pc, #280]	@ (34018378 <LL_ATON_RT_RunEpochBlock+0x27c>)
34018260:	4a46      	ldr	r2, [pc, #280]	@ (3401837c <LL_ATON_RT_RunEpochBlock+0x280>)
34018262:	e7b5      	b.n	340181d0 <LL_ATON_RT_RunEpochBlock+0xd4>
  if (EpochBlock_IsEpochPureHW(eb) ||
34018264:	f013 0f50 	tst.w	r3, #80	@ 0x50
34018268:	d015      	beq.n	34018296 <LL_ATON_RT_RunEpochBlock+0x19a>
    LL_ATON_ASSERT(new_owner != __ll_current_aton_ip_owner);
3401826a:	4a39      	ldr	r2, [pc, #228]	@ (34018350 <LL_ATON_RT_RunEpochBlock+0x254>)
3401826c:	6811      	ldr	r1, [r2, #0]
3401826e:	428c      	cmp	r4, r1
34018270:	d103      	bne.n	3401827a <LL_ATON_RT_RunEpochBlock+0x17e>
34018272:	2128      	movs	r1, #40	@ 0x28
34018274:	4b42      	ldr	r3, [pc, #264]	@ (34018380 <LL_ATON_RT_RunEpochBlock+0x284>)
34018276:	4a43      	ldr	r2, [pc, #268]	@ (34018384 <LL_ATON_RT_RunEpochBlock+0x288>)
34018278:	e7aa      	b.n	340181d0 <LL_ATON_RT_RunEpochBlock+0xd4>
    LL_ATON_ASSERT(__ll_current_aton_ip_owner == NULL);
3401827a:	6811      	ldr	r1, [r2, #0]
3401827c:	b119      	cbz	r1, 34018286 <LL_ATON_RT_RunEpochBlock+0x18a>
3401827e:	212c      	movs	r1, #44	@ 0x2c
34018280:	4b41      	ldr	r3, [pc, #260]	@ (34018388 <LL_ATON_RT_RunEpochBlock+0x28c>)
34018282:	4a40      	ldr	r2, [pc, #256]	@ (34018384 <LL_ATON_RT_RunEpochBlock+0x288>)
34018284:	e7a4      	b.n	340181d0 <LL_ATON_RT_RunEpochBlock+0xd4>
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
34018286:	4941      	ldr	r1, [pc, #260]	@ (3401838c <LL_ATON_RT_RunEpochBlock+0x290>)
34018288:	6809      	ldr	r1, [r1, #0]
3401828a:	b119      	cbz	r1, 34018294 <LL_ATON_RT_RunEpochBlock+0x198>
3401828c:	2130      	movs	r1, #48	@ 0x30
3401828e:	4b40      	ldr	r3, [pc, #256]	@ (34018390 <LL_ATON_RT_RunEpochBlock+0x294>)
34018290:	4a3c      	ldr	r2, [pc, #240]	@ (34018384 <LL_ATON_RT_RunEpochBlock+0x288>)
34018292:	e79d      	b.n	340181d0 <LL_ATON_RT_RunEpochBlock+0xd4>
    __ll_current_aton_ip_owner = new_owner;
34018294:	6014      	str	r4, [r2, #0]
  if (!EpochBlock_IsEpochBlob(eb))
34018296:	0759      	lsls	r1, r3, #29
34018298:	d41c      	bmi.n	340182d4 <LL_ATON_RT_RunEpochBlock+0x1d8>
    if (EpochBlock_IsEpochPureHW(eb) || EpochBlock_IsEpochInternal(eb))
3401829a:	f013 0f90 	tst.w	r3, #144	@ 0x90
3401829e:	d00a      	beq.n	340182b6 <LL_ATON_RT_RunEpochBlock+0x1ba>
      LL_ATON_ASSERT(__ll_current_aton_ip_owner == nn_instance);
340182a0:	4b2b      	ldr	r3, [pc, #172]	@ (34018350 <LL_ATON_RT_RunEpochBlock+0x254>)
340182a2:	681b      	ldr	r3, [r3, #0]
340182a4:	429c      	cmp	r4, r3
340182a6:	d003      	beq.n	340182b0 <LL_ATON_RT_RunEpochBlock+0x1b4>
340182a8:	2178      	movs	r1, #120	@ 0x78
340182aa:	4b2a      	ldr	r3, [pc, #168]	@ (34018354 <LL_ATON_RT_RunEpochBlock+0x258>)
340182ac:	4a31      	ldr	r2, [pc, #196]	@ (34018374 <LL_ATON_RT_RunEpochBlock+0x278>)
340182ae:	e72c      	b.n	3401810a <LL_ATON_RT_RunEpochBlock+0xe>
      __LL_ATON_RT_SetWaitMask(eb->wait_mask);
340182b0:	68e8      	ldr	r0, [r5, #12]
    __LL_ATON_RT_SetWaitMask(ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0));
340182b2:	f7ff fd23 	bl	34017cfc <__LL_ATON_RT_SetWaitMask>
  if (eb->start_epoch_block != NULL)
340182b6:	682b      	ldr	r3, [r5, #0]
340182b8:	b10b      	cbz	r3, 340182be <LL_ATON_RT_RunEpochBlock+0x1c2>
    eb->start_epoch_block((const void *)eb);
340182ba:	4628      	mov	r0, r5
340182bc:	4798      	blx	r3
  if (EpochBlock_IsEpochBlob(eb))
340182be:	8a2b      	ldrh	r3, [r5, #16]
340182c0:	075a      	lsls	r2, r3, #29
340182c2:	d51a      	bpl.n	340182fa <LL_ATON_RT_RunEpochBlock+0x1fe>
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
340182c4:	4628      	mov	r0, r5
340182c6:	f7ff fd35 	bl	34017d34 <EpochBlock_EpochControllerUnit>
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
340182ca:	b130      	cbz	r0, 340182da <LL_ATON_RT_RunEpochBlock+0x1de>
340182cc:	21a4      	movs	r1, #164	@ 0xa4
340182ce:	4b31      	ldr	r3, [pc, #196]	@ (34018394 <LL_ATON_RT_RunEpochBlock+0x298>)
340182d0:	4a28      	ldr	r2, [pc, #160]	@ (34018374 <LL_ATON_RT_RunEpochBlock+0x278>)
340182d2:	e71a      	b.n	3401810a <LL_ATON_RT_RunEpochBlock+0xe>
    __LL_ATON_RT_SetWaitMask(ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0));
340182d4:	f240 30ff 	movw	r0, #1023	@ 0x3ff
340182d8:	e7eb      	b.n	340182b2 <LL_ATON_RT_RunEpochBlock+0x1b6>
    conf.stepmode = 0;
340182da:	f89d 2004 	ldrb.w	r2, [sp, #4]
    conf.blobaddr = EpochBlock_EpochBlobAddr(eb);
340182de:	68ab      	ldr	r3, [r5, #8]
    conf.stepmode = 0;
340182e0:	f360 0200 	bfi	r2, r0, #0, #1
    LL_EpochCtrl_Init(ecId, &conf);
340182e4:	4669      	mov	r1, sp
    conf.stepmode = 0;
340182e6:	f88d 2004 	strb.w	r2, [sp, #4]
    conf.blobaddr = EpochBlock_EpochBlobAddr(eb);
340182ea:	9300      	str	r3, [sp, #0]
    LL_EpochCtrl_Init(ecId, &conf);
340182ec:	f7fe fdb6 	bl	34016e5c <LL_EpochCtrl_Init>
    ATON_ENABLE(EPOCHCTRL, ecId);
340182f0:	4a29      	ldr	r2, [pc, #164]	@ (34018398 <LL_ATON_RT_RunEpochBlock+0x29c>)
340182f2:	6813      	ldr	r3, [r2, #0]
340182f4:	f043 0301 	orr.w	r3, r3, #1
340182f8:	6013      	str	r3, [r2, #0]
  if (nn_instance->exec_state.epoch_callback_function != NULL)
340182fa:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
340182fc:	b11b      	cbz	r3, 34018306 <LL_ATON_RT_RunEpochBlock+0x20a>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_START, nn_instance, eb);
340182fe:	462a      	mov	r2, r5
34018300:	4621      	mov	r1, r4
34018302:	2001      	movs	r0, #1
34018304:	4798      	blx	r3
    if (__LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block) == 0x0)
34018306:	6860      	ldr	r0, [r4, #4]
  if (EpochBlock_IsEpochBlob(eb))
34018308:	8a03      	ldrh	r3, [r0, #16]
3401830a:	075b      	lsls	r3, r3, #29
3401830c:	d50f      	bpl.n	3401832e <LL_ATON_RT_RunEpochBlock+0x232>
    return (1 << EpochBlock_EpochControllerUnit(eb));
3401830e:	f7ff fd11 	bl	34017d34 <EpochBlock_EpochControllerUnit>
34018312:	2301      	movs	r3, #1
34018314:	fa03 f000 	lsl.w	r0, r3, r0
    if (__LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block) == 0x0)
34018318:	2800      	cmp	r0, #0
3401831a:	f47f af28 	bne.w	3401816e <LL_ATON_RT_RunEpochBlock+0x72>
      __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
3401831e:	6860      	ldr	r0, [r4, #4]
34018320:	4621      	mov	r1, r4
34018322:	f7ff fd1b 	bl	34017d5c <__LL_ATON_RT_ExecEndEpochBlock>
      __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
34018326:	4620      	mov	r0, r4
34018328:	f7ff fd82 	bl	34017e30 <__LL_ATON_RT_DetermineNextEpochBlock>
      return LL_ATON_RT_NO_WFE;
3401832c:	e779      	b.n	34018222 <LL_ATON_RT_RunEpochBlock+0x126>
    return eb->wait_mask; // in case of "normal" epoch block `wait_mask` contains bitmask of (output) stream engines to
3401832e:	68c0      	ldr	r0, [r0, #12]
34018330:	e7f2      	b.n	34018318 <LL_ATON_RT_RunEpochBlock+0x21c>
        return LL_ATON_RT_DONE;
34018332:	2002      	movs	r0, #2
34018334:	e71c      	b.n	34018170 <LL_ATON_RT_RunEpochBlock+0x74>
34018336:	bf00      	nop
34018338:	34021a21 	.word	0x34021a21
3401833c:	340ae789 	.word	0x340ae789
34018340:	340218d6 	.word	0x340218d6
34018344:	34021caa 	.word	0x34021caa
34018348:	34021ce5 	.word	0x34021ce5
3401834c:	34021ca1 	.word	0x34021ca1
34018350:	340ceee8 	.word	0x340ceee8
34018354:	34021d47 	.word	0x34021d47
34018358:	e000e100 	.word	0xe000e100
3401835c:	34021230 	.word	0x34021230
34018360:	340ae762 	.word	0x340ae762
34018364:	3402125a 	.word	0x3402125a
34018368:	34021d71 	.word	0x34021d71
3401836c:	34021e0d 	.word	0x34021e0d
34018370:	34021e59 	.word	0x34021e59
34018374:	340ae741 	.word	0x340ae741
34018378:	34021a3c 	.word	0x34021a3c
3401837c:	340ae722 	.word	0x340ae722
34018380:	34021e91 	.word	0x34021e91
34018384:	340ae70e 	.word	0x340ae70e
34018388:	34021eb9 	.word	0x34021eb9
3401838c:	340ceee4 	.word	0x340ceee4
34018390:	340217de 	.word	0x340217de
34018394:	340218cd 	.word	0x340218cd
34018398:	580fe000 	.word	0x580fe000

3401839c <NPU0_IRQHandler>:
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

/* ATON ISR
 * ll_aton routes all interrupts to `ATON_STD_IRQ_LINE` interrupt line */
void ATON_STD_IRQHandler(void)
{
3401839c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if (ATON_INT_NR > 32)
  uint32_t irqs_l = ATON_INTCTRL_INTREG_GET(0);
  uint32_t irqs_h = ATON_INTCTRL_INTREG_H_GET(0);
  uint64_t irqs = irqs_l | (irqs_h << 32);
#else  //(ATON_INT_NR <= 32)
  uint32_t irqs = ATON_INTCTRL_INTREG_GET(0);
3401839e:	4b38      	ldr	r3, [pc, #224]	@ (34018480 <NPU0_IRQHandler+0xe4>)
#endif //(ATON_INT_NR <= 32)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  if (__ll_current_aton_ip_owner != NULL)
340183a0:	4c38      	ldr	r4, [pc, #224]	@ (34018484 <NPU0_IRQHandler+0xe8>)
  uint32_t irqs = ATON_INTCTRL_INTREG_GET(0);
340183a2:	689d      	ldr	r5, [r3, #8]
  if (__ll_current_aton_ip_owner != NULL)
340183a4:	6823      	ldr	r3, [r4, #0]
340183a6:	b343      	cbz	r3, 340183fa <NPU0_IRQHandler+0x5e>
  {
    LL_ATON_ASSERT(__ll_current_aton_ip_owner->exec_state.current_epoch_block != NULL);
340183a8:	6823      	ldr	r3, [r4, #0]
340183aa:	685b      	ldr	r3, [r3, #4]
340183ac:	b933      	cbnz	r3, 340183bc <NPU0_IRQHandler+0x20>
340183ae:	f240 31ba 	movw	r1, #954	@ 0x3ba
340183b2:	4b35      	ldr	r3, [pc, #212]	@ (34018488 <NPU0_IRQHandler+0xec>)
340183b4:	4a35      	ldr	r2, [pc, #212]	@ (3401848c <NPU0_IRQHandler+0xf0>)
    }
    else // epoch blob handling based on epoch controller
    {
#if defined(ATON_EPOCHCTRL_NUM)
      uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
      LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
340183b6:	4836      	ldr	r0, [pc, #216]	@ (34018490 <NPU0_IRQHandler+0xf4>)
340183b8:	f000 fd50 	bl	34018e5c <__assert_func>
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
340183bc:	6823      	ldr	r3, [r4, #0]
                                    .current_epoch_block)) // standard epoch block handling based on streaming engines
340183be:	685b      	ldr	r3, [r3, #4]
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
340183c0:	8a1b      	ldrh	r3, [r3, #16]
340183c2:	075b      	lsls	r3, r3, #29
340183c4:	d40c      	bmi.n	340183e0 <NPU0_IRQHandler+0x44>
      __LL_ATON_RT_IrqErr(
340183c6:	f425 707f 	bic.w	r0, r5, #1020	@ 0x3fc
340183ca:	f020 0003 	bic.w	r0, r0, #3
#endif                                      // !ATON_EPOCHCTRL_NUM
    }
  }
  else // `__ll_current_aton_ip_owner == NULL`
  {
    __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
340183ce:	f7ff fd73 	bl	34017eb8 <__LL_ATON_RT_IrqErr>
#else  // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)
  __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
340183d2:	6823      	ldr	r3, [r4, #0]
340183d4:	b99b      	cbnz	r3, 340183fe <NPU0_IRQHandler+0x62>
340183d6:	f240 31db 	movw	r1, #987	@ 0x3db
340183da:	4b2e      	ldr	r3, [pc, #184]	@ (34018494 <NPU0_IRQHandler+0xf8>)
340183dc:	4a2b      	ldr	r2, [pc, #172]	@ (3401848c <NPU0_IRQHandler+0xf0>)
340183de:	e7ea      	b.n	340183b6 <NPU0_IRQHandler+0x1a>
      uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
340183e0:	6823      	ldr	r3, [r4, #0]
340183e2:	6858      	ldr	r0, [r3, #4]
340183e4:	f7ff fca6 	bl	34017d34 <EpochBlock_EpochControllerUnit>
      LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
340183e8:	b120      	cbz	r0, 340183f4 <NPU0_IRQHandler+0x58>
340183ea:	f240 31c7 	movw	r1, #967	@ 0x3c7
340183ee:	4b2a      	ldr	r3, [pc, #168]	@ (34018498 <NPU0_IRQHandler+0xfc>)
340183f0:	4a26      	ldr	r2, [pc, #152]	@ (3401848c <NPU0_IRQHandler+0xf0>)
340183f2:	e7e0      	b.n	340183b6 <NPU0_IRQHandler+0x1a>
      __LL_ATON_RT_IrqErr(
340183f4:	f025 5080 	bic.w	r0, r5, #268435456	@ 0x10000000
340183f8:	e7e9      	b.n	340183ce <NPU0_IRQHandler+0x32>
    __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
340183fa:	4628      	mov	r0, r5
340183fc:	e7e7      	b.n	340183ce <NPU0_IRQHandler+0x32>

  if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state.current_epoch_block))
340183fe:	6823      	ldr	r3, [r4, #0]
34018400:	685b      	ldr	r3, [r3, #4]
34018402:	8a1b      	ldrh	r3, [r3, #16]
34018404:	f013 0304 	ands.w	r3, r3, #4
34018408:	d123      	bne.n	34018452 <NPU0_IRQHandler+0xb6>
      __ll_current_aton_ip_owner->exec_state.current_epoch_block
3401840a:	6822      	ldr	r2, [r4, #0]
3401840c:	6852      	ldr	r2, [r2, #4]
  wait_irqs =
3401840e:	68d2      	ldr	r2, [r2, #12]
  if (wait_irqs)
34018410:	402a      	ands	r2, r5
34018412:	d017      	beq.n	34018444 <NPU0_IRQHandler+0xa8>
        _tmp_triggered_events |= (1 << i);
34018414:	f04f 0c01 	mov.w	ip, #1
34018418:	200a      	movs	r0, #10
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
3401841a:	6821      	ldr	r1, [r4, #0]
        uint32_t strengIrqs = ATON_STRENG_IRQ_GET(i);
3401841c:	4e1f      	ldr	r6, [pc, #124]	@ (3401849c <NPU0_IRQHandler+0x100>)
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
3401841e:	69c9      	ldr	r1, [r1, #28]
      if ((wait_irqs >> i) & 1)
34018420:	fa22 f703 	lsr.w	r7, r2, r3
34018424:	07ff      	lsls	r7, r7, #31
34018426:	d507      	bpl.n	34018438 <NPU0_IRQHandler+0x9c>
        uint32_t strengIrqs = ATON_STRENG_IRQ_GET(i);
34018428:	031f      	lsls	r7, r3, #12
3401842a:	f857 e006 	ldr.w	lr, [r7, r6]
        ATON_STRENG_IRQ_SET(
3401842e:	f847 e006 	str.w	lr, [r7, r6]
        _tmp_triggered_events |= (1 << i);
34018432:	fa0c f703 	lsl.w	r7, ip, r3
34018436:	4339      	orrs	r1, r7
    for (i = 0; i < ATON_STRENG_NUM; i++)
34018438:	3801      	subs	r0, #1
3401843a:	f103 0301 	add.w	r3, r3, #1
3401843e:	d1ef      	bne.n	34018420 <NPU0_IRQHandler+0x84>
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
34018440:	6823      	ldr	r3, [r4, #0]
34018442:	61d9      	str	r1, [r3, #28]
  __ASM volatile ("dsb 0xF":::"memory");
34018444:	f3bf 8f4f 	dsb	sy
   */
#if (ATON_INT_NR > 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs_l);
  ATON_INTCTRL_INTCLR_H_SET(0, irqs_h);
#else  //(ATON_INT_NR <= 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs);
34018448:	4b0d      	ldr	r3, [pc, #52]	@ (34018480 <NPU0_IRQHandler+0xe4>)
3401844a:	611d      	str	r5, [r3, #16]
3401844c:	f3bf 8f4f 	dsb	sy
  LL_ATON_OSAL_SIGNAL_EVENT();

#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  return;
}
34018450:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
34018452:	6823      	ldr	r3, [r4, #0]
34018454:	6858      	ldr	r0, [r3, #4]
34018456:	f7ff fc6d 	bl	34017d34 <EpochBlock_EpochControllerUnit>
  LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401845a:	b120      	cbz	r0, 34018466 <NPU0_IRQHandler+0xca>
3401845c:	f240 319a 	movw	r1, #922	@ 0x39a
34018460:	4b0d      	ldr	r3, [pc, #52]	@ (34018498 <NPU0_IRQHandler+0xfc>)
34018462:	4a0f      	ldr	r2, [pc, #60]	@ (340184a0 <NPU0_IRQHandler+0x104>)
34018464:	e7a7      	b.n	340183b6 <NPU0_IRQHandler+0x1a>
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ecId))
34018466:	00eb      	lsls	r3, r5, #3
34018468:	d5ec      	bpl.n	34018444 <NPU0_IRQHandler+0xa8>
    uint32_t ecIrqs = ATON_EPOCHCTRL_IRQ_GET(ecId);
3401846a:	4b0e      	ldr	r3, [pc, #56]	@ (340184a4 <NPU0_IRQHandler+0x108>)
3401846c:	68da      	ldr	r2, [r3, #12]
    ATON_EPOCHCTRL_IRQ_SET(ecId, ecIrqs);
3401846e:	60da      	str	r2, [r3, #12]
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
34018470:	6823      	ldr	r3, [r4, #0]
34018472:	69db      	ldr	r3, [r3, #28]
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
34018474:	6822      	ldr	r2, [r4, #0]
    _tmp_triggered_events |= (1 << ecId);
34018476:	f043 0301 	orr.w	r3, r3, #1
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
3401847a:	61d3      	str	r3, [r2, #28]
3401847c:	e7e2      	b.n	34018444 <NPU0_IRQHandler+0xa8>
3401847e:	bf00      	nop
34018480:	580e1000 	.word	0x580e1000
34018484:	340ceee8 	.word	0x340ceee8
34018488:	34021ee3 	.word	0x34021ee3
3401848c:	340ae682 	.word	0x340ae682
34018490:	340218d6 	.word	0x340218d6
34018494:	34021230 	.word	0x34021230
34018498:	340218cd 	.word	0x340218cd
3401849c:	580e503c 	.word	0x580e503c
340184a0:	340ae654 	.word	0x340ae654
340184a4:	580fe000 	.word	0x580fe000

340184a8 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
340184a8:	480f      	ldr	r0, [pc, #60]	@ (340184e8 <LoopForever+0x4>)
  msr   MSPLIM, r0
340184aa:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
340184ae:	480f      	ldr	r0, [pc, #60]	@ (340184ec <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
340184b0:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
340184b2:	f7ec fb07 	bl	34004ac4 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
340184b6:	480e      	ldr	r0, [pc, #56]	@ (340184f0 <LoopForever+0xc>)
  ldr r1, =_edata
340184b8:	490e      	ldr	r1, [pc, #56]	@ (340184f4 <LoopForever+0x10>)
  ldr r2, =_sidata
340184ba:	4a0f      	ldr	r2, [pc, #60]	@ (340184f8 <LoopForever+0x14>)
  movs r3, #0
340184bc:	2300      	movs	r3, #0
  b LoopCopyDataInit
340184be:	e002      	b.n	340184c6 <LoopCopyDataInit>

340184c0 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
340184c0:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
340184c2:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
340184c4:	3304      	adds	r3, #4

340184c6 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
340184c6:	18c4      	adds	r4, r0, r3
  cmp r4, r1
340184c8:	428c      	cmp	r4, r1
  bcc CopyDataInit
340184ca:	d3f9      	bcc.n	340184c0 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
340184cc:	4a0b      	ldr	r2, [pc, #44]	@ (340184fc <LoopForever+0x18>)
  ldr r4, =_ebss
340184ce:	4c0c      	ldr	r4, [pc, #48]	@ (34018500 <LoopForever+0x1c>)
  movs r3, #0
340184d0:	2300      	movs	r3, #0
  b LoopFillZerobss
340184d2:	e001      	b.n	340184d8 <LoopFillZerobss>

340184d4 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
340184d4:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
340184d6:	3204      	adds	r2, #4

340184d8 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
340184d8:	42a2      	cmp	r2, r4
  bcc FillZerobss
340184da:	d3fb      	bcc.n	340184d4 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
340184dc:	f002 f87c 	bl	3401a5d8 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
340184e0:	f7ea f85a 	bl	34002598 <main>

340184e4 <LoopForever>:

LoopForever:
  b LoopForever
340184e4:	e7fe      	b.n	340184e4 <LoopForever>
340184e6:	0000      	.short	0x0000
  ldr   r0, =_sstack
340184e8:	340fc000 	.word	0x340fc000
  ldr   r0, =_estack
340184ec:	34100000 	.word	0x34100000
  ldr r0, =_sdata
340184f0:	340b0ee4 	.word	0x340b0ee4
  ldr r1, =_edata
340184f4:	340b12cc 	.word	0x340b12cc
  ldr r2, =_sidata
340184f8:	340b0ee4 	.word	0x340b0ee4
  ldr r2, =_sbss
340184fc:	340b12d0 	.word	0x340b12d0
  ldr r4, =_ebss
34018500:	340cf03c 	.word	0x340cf03c

34018504 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
34018504:	e7fe      	b.n	34018504 <ADC1_2_IRQHandler>
	...

34018508 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
34018508:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
3401850a:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3401850c:	e852 3f00 	ldrex	r3, [r2]
34018510:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34018514:	e842 3100 	strex	r1, r3, [r2]
   return(result);
34018518:	6802      	ldr	r2, [r0, #0]
3401851a:	2900      	cmp	r1, #0
3401851c:	d1f5      	bne.n	3401850a <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
3401851e:	4c0f      	ldr	r4, [pc, #60]	@ (3401855c <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34018520:	f102 0308 	add.w	r3, r2, #8
34018524:	e853 3f00 	ldrex	r3, [r3]
34018528:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3401852a:	f102 0c08 	add.w	ip, r2, #8
3401852e:	e84c 3100 	strex	r1, r3, [ip]
34018532:	2900      	cmp	r1, #0
34018534:	d1f4      	bne.n	34018520 <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
34018536:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
34018538:	2b01      	cmp	r3, #1
3401853a:	d107      	bne.n	3401854c <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3401853c:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
34018540:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34018544:	e842 3100 	strex	r1, r3, [r2]
34018548:	2900      	cmp	r1, #0
3401854a:	d1f7      	bne.n	3401853c <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
3401854c:	2320      	movs	r3, #32
3401854e:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
34018552:	2300      	movs	r3, #0
34018554:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
34018556:	6743      	str	r3, [r0, #116]	@ 0x74
}
34018558:	bd10      	pop	{r4, pc}
3401855a:	bf00      	nop
3401855c:	effffffe 	.word	0xeffffffe

34018560 <HAL_UART_MspInit>:
}
34018560:	4770      	bx	lr
	...

34018564 <UART_SetConfig>:
{
34018564:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
34018566:	6842      	ldr	r2, [r0, #4]
34018568:	4bb0      	ldr	r3, [pc, #704]	@ (3401882c <UART_SetConfig+0x2c8>)
{
3401856a:	4604      	mov	r4, r0
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
3401856c:	429a      	cmp	r2, r3
3401856e:	d904      	bls.n	3401857a <UART_SetConfig+0x16>
34018570:	f44f 6145 	mov.w	r1, #3152	@ 0xc50
34018574:	48ae      	ldr	r0, [pc, #696]	@ (34018830 <UART_SetConfig+0x2cc>)
34018576:	f7ea fb4b 	bl	34002c10 <assert_failed>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
3401857a:	68a3      	ldr	r3, [r4, #8]
3401857c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34018580:	d007      	beq.n	34018592 <UART_SetConfig+0x2e>
34018582:	f433 5380 	bics.w	r3, r3, #4096	@ 0x1000
34018586:	d004      	beq.n	34018592 <UART_SetConfig+0x2e>
34018588:	f640 4151 	movw	r1, #3153	@ 0xc51
3401858c:	48a8      	ldr	r0, [pc, #672]	@ (34018830 <UART_SetConfig+0x2cc>)
3401858e:	f7ea fb3f 	bl	34002c10 <assert_failed>
  if (UART_INSTANCE_LOWPOWER(huart))
34018592:	6822      	ldr	r2, [r4, #0]
34018594:	49a7      	ldr	r1, [pc, #668]	@ (34018834 <UART_SetConfig+0x2d0>)
    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
34018596:	68e3      	ldr	r3, [r4, #12]
  if (UART_INSTANCE_LOWPOWER(huart))
34018598:	428a      	cmp	r2, r1
3401859a:	d004      	beq.n	340185a6 <UART_SetConfig+0x42>
3401859c:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
340185a0:	428a      	cmp	r2, r1
340185a2:	f040 80af 	bne.w	34018704 <UART_SetConfig+0x1a0>
    assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));
340185a6:	f433 5300 	bics.w	r3, r3, #8192	@ 0x2000
340185aa:	d004      	beq.n	340185b6 <UART_SetConfig+0x52>
340185ac:	f640 4154 	movw	r1, #3156	@ 0xc54
    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
340185b0:	489f      	ldr	r0, [pc, #636]	@ (34018830 <UART_SetConfig+0x2cc>)
340185b2:	f7ea fb2d 	bl	34002c10 <assert_failed>
  assert_param(IS_UART_PARITY(huart->Init.Parity));
340185b6:	6923      	ldr	r3, [r4, #16]
340185b8:	f433 6280 	bics.w	r2, r3, #1024	@ 0x400
340185bc:	d007      	beq.n	340185ce <UART_SetConfig+0x6a>
340185be:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
340185c2:	d004      	beq.n	340185ce <UART_SetConfig+0x6a>
340185c4:	f640 415c 	movw	r1, #3164	@ 0xc5c
340185c8:	4899      	ldr	r0, [pc, #612]	@ (34018830 <UART_SetConfig+0x2cc>)
340185ca:	f7ea fb21 	bl	34002c10 <assert_failed>
  assert_param(IS_UART_MODE(huart->Init.Mode));
340185ce:	6963      	ldr	r3, [r4, #20]
340185d0:	f033 020c 	bics.w	r2, r3, #12
340185d4:	d100      	bne.n	340185d8 <UART_SetConfig+0x74>
340185d6:	b923      	cbnz	r3, 340185e2 <UART_SetConfig+0x7e>
340185d8:	f640 415d 	movw	r1, #3165	@ 0xc5d
340185dc:	4894      	ldr	r0, [pc, #592]	@ (34018830 <UART_SetConfig+0x2cc>)
340185de:	f7ea fb17 	bl	34002c10 <assert_failed>
  assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
340185e2:	69a3      	ldr	r3, [r4, #24]
340185e4:	f433 7340 	bics.w	r3, r3, #768	@ 0x300
340185e8:	d004      	beq.n	340185f4 <UART_SetConfig+0x90>
340185ea:	f640 415e 	movw	r1, #3166	@ 0xc5e
340185ee:	4890      	ldr	r0, [pc, #576]	@ (34018830 <UART_SetConfig+0x2cc>)
340185f0:	f7ea fb0e 	bl	34002c10 <assert_failed>
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
340185f4:	69e3      	ldr	r3, [r4, #28]
340185f6:	f433 4300 	bics.w	r3, r3, #32768	@ 0x8000
340185fa:	d004      	beq.n	34018606 <UART_SetConfig+0xa2>
340185fc:	f640 415f 	movw	r1, #3167	@ 0xc5f
34018600:	488b      	ldr	r0, [pc, #556]	@ (34018830 <UART_SetConfig+0x2cc>)
34018602:	f7ea fb05 	bl	34002c10 <assert_failed>
  assert_param(IS_UART_PRESCALER(huart->Init.ClockPrescaler));
34018606:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34018608:	2b0b      	cmp	r3, #11
3401860a:	d904      	bls.n	34018616 <UART_SetConfig+0xb2>
3401860c:	f44f 6146 	mov.w	r1, #3168	@ 0xc60
34018610:	4887      	ldr	r0, [pc, #540]	@ (34018830 <UART_SetConfig+0x2cc>)
34018612:	f7ea fafd 	bl	34002c10 <assert_failed>
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
34018616:	6921      	ldr	r1, [r4, #16]
34018618:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3401861a:	6823      	ldr	r3, [r4, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
3401861c:	430a      	orrs	r2, r1
3401861e:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
34018620:	6818      	ldr	r0, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
34018622:	69e5      	ldr	r5, [r4, #28]
34018624:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
34018626:	4984      	ldr	r1, [pc, #528]	@ (34018838 <UART_SetConfig+0x2d4>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
34018628:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3401862a:	4001      	ands	r1, r0
3401862c:	430a      	orrs	r2, r1
3401862e:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
34018630:	685a      	ldr	r2, [r3, #4]
34018632:	68e1      	ldr	r1, [r4, #12]
34018634:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
34018638:	430a      	orrs	r2, r1
3401863a:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
3401863c:	4a7d      	ldr	r2, [pc, #500]	@ (34018834 <UART_SetConfig+0x2d0>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
3401863e:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
34018640:	4293      	cmp	r3, r2
34018642:	d005      	beq.n	34018650 <UART_SetConfig+0xec>
34018644:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018648:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
3401864a:	bf1c      	itt	ne
3401864c:	6a22      	ldrne	r2, [r4, #32]
3401864e:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
34018650:	689a      	ldr	r2, [r3, #8]
34018652:	f022 426e 	bic.w	r2, r2, #3992977408	@ 0xee000000
34018656:	f422 6230 	bic.w	r2, r2, #2816	@ 0xb00
3401865a:	430a      	orrs	r2, r1
3401865c:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
3401865e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34018660:	6a61      	ldr	r1, [r4, #36]	@ 0x24
34018662:	f022 020f 	bic.w	r2, r2, #15
34018666:	430a      	orrs	r2, r1
34018668:	62da      	str	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
3401866a:	4a74      	ldr	r2, [pc, #464]	@ (3401883c <UART_SetConfig+0x2d8>)
3401866c:	4293      	cmp	r3, r2
3401866e:	d07a      	beq.n	34018766 <UART_SetConfig+0x202>
34018670:	4a73      	ldr	r2, [pc, #460]	@ (34018840 <UART_SetConfig+0x2dc>)
34018672:	4293      	cmp	r3, r2
34018674:	f000 809c 	beq.w	340187b0 <UART_SetConfig+0x24c>
34018678:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3401867c:	4293      	cmp	r3, r2
3401867e:	f000 809b 	beq.w	340187b8 <UART_SetConfig+0x254>
34018682:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
34018686:	4293      	cmp	r3, r2
34018688:	f000 809a 	beq.w	340187c0 <UART_SetConfig+0x25c>
3401868c:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
34018690:	f000 809a 	beq.w	340187c8 <UART_SetConfig+0x264>
34018694:	4a6b      	ldr	r2, [pc, #428]	@ (34018844 <UART_SetConfig+0x2e0>)
34018696:	4293      	cmp	r3, r2
34018698:	f000 809a 	beq.w	340187d0 <UART_SetConfig+0x26c>
3401869c:	4a6a      	ldr	r2, [pc, #424]	@ (34018848 <UART_SetConfig+0x2e4>)
3401869e:	4293      	cmp	r3, r2
340186a0:	f000 809a 	beq.w	340187d8 <UART_SetConfig+0x274>
340186a4:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
340186a8:	4293      	cmp	r3, r2
340186aa:	f000 8099 	beq.w	340187e0 <UART_SetConfig+0x27c>
340186ae:	4a67      	ldr	r2, [pc, #412]	@ (3401884c <UART_SetConfig+0x2e8>)
340186b0:	4293      	cmp	r3, r2
340186b2:	f000 8099 	beq.w	340187e8 <UART_SetConfig+0x284>
340186b6:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
340186ba:	4293      	cmp	r3, r2
340186bc:	f000 8098 	beq.w	340187f0 <UART_SetConfig+0x28c>
340186c0:	4a5c      	ldr	r2, [pc, #368]	@ (34018834 <UART_SetConfig+0x2d0>)
340186c2:	4293      	cmp	r3, r2
340186c4:	d02e      	beq.n	34018724 <UART_SetConfig+0x1c0>
  if (UART_INSTANCE_LOWPOWER(huart))
340186c6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340186ca:	4293      	cmp	r3, r2
340186cc:	f04f 0000 	mov.w	r0, #0
340186d0:	f04f 0100 	mov.w	r1, #0
340186d4:	d14a      	bne.n	3401876c <UART_SetConfig+0x208>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
340186d6:	f7f6 fb4d 	bl	3400ed74 <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
340186da:	2800      	cmp	r0, #0
340186dc:	d041      	beq.n	34018762 <UART_SetConfig+0x1fe>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
340186de:	6a61      	ldr	r1, [r4, #36]	@ 0x24
340186e0:	4a5b      	ldr	r2, [pc, #364]	@ (34018850 <UART_SetConfig+0x2ec>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
340186e2:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
340186e4:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
340186e8:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
340186ec:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
340186f0:	4299      	cmp	r1, r3
340186f2:	d91b      	bls.n	3401872c <UART_SetConfig+0x1c8>
        ret = HAL_ERROR;
340186f4:	2001      	movs	r0, #1
  huart->NbRxDataToProcess = 1;
340186f6:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
340186fa:	66a3      	str	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
340186fc:	2300      	movs	r3, #0
  huart->TxISR = NULL;
340186fe:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
}
34018702:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
34018704:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
34018708:	d004      	beq.n	34018714 <UART_SetConfig+0x1b0>
3401870a:	f640 4158 	movw	r1, #3160	@ 0xc58
3401870e:	4848      	ldr	r0, [pc, #288]	@ (34018830 <UART_SetConfig+0x2cc>)
34018710:	f7ea fa7e 	bl	34002c10 <assert_failed>
    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
34018714:	6a23      	ldr	r3, [r4, #32]
34018716:	f433 6300 	bics.w	r3, r3, #2048	@ 0x800
3401871a:	f43f af4c 	beq.w	340185b6 <UART_SetConfig+0x52>
3401871e:	f640 4159 	movw	r1, #3161	@ 0xc59
34018722:	e745      	b.n	340185b0 <UART_SetConfig+0x4c>
  UART_GETCLOCKSOURCE(huart, clocksource);
34018724:	f44f 0000 	mov.w	r0, #8388608	@ 0x800000
34018728:	2100      	movs	r1, #0
3401872a:	e7d4      	b.n	340186d6 <UART_SetConfig+0x172>
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3401872c:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
34018730:	d8e0      	bhi.n	340186f4 <UART_SetConfig+0x190>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
34018732:	2300      	movs	r3, #0
34018734:	4619      	mov	r1, r3
34018736:	f7e9 f859 	bl	340017ec <__aeabi_uldivmod>
3401873a:	4606      	mov	r6, r0
3401873c:	460f      	mov	r7, r1
3401873e:	ea56 270f 	orrs.w	r7, r6, pc, lsl #8
34018742:	0868      	lsrs	r0, r5, #1
34018744:	1830      	adds	r0, r6, r0
34018746:	462a      	mov	r2, r5
34018748:	f04f 0300 	mov.w	r3, #0
3401874c:	f147 0100 	adc.w	r1, r7, #0
34018750:	f7e9 f84c 	bl	340017ec <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
34018754:	4b3f      	ldr	r3, [pc, #252]	@ (34018854 <UART_SetConfig+0x2f0>)
34018756:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
3401875a:	429a      	cmp	r2, r3
3401875c:	d8ca      	bhi.n	340186f4 <UART_SetConfig+0x190>
          huart->Instance->BRR = usartdiv;
3401875e:	6823      	ldr	r3, [r4, #0]
34018760:	60d8      	str	r0, [r3, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
34018762:	2000      	movs	r0, #0
34018764:	e7c7      	b.n	340186f6 <UART_SetConfig+0x192>
  UART_GETCLOCKSOURCE(huart, clocksource);
34018766:	2000      	movs	r0, #0
34018768:	f44f 7180 	mov.w	r1, #256	@ 0x100
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
3401876c:	f5b5 4f00 	cmp.w	r5, #32768	@ 0x8000
34018770:	d142      	bne.n	340187f8 <UART_SetConfig+0x294>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
34018772:	f7f6 faff 	bl	3400ed74 <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
34018776:	2800      	cmp	r0, #0
34018778:	d0f3      	beq.n	34018762 <UART_SetConfig+0x1fe>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3401877a:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3401877c:	4b34      	ldr	r3, [pc, #208]	@ (34018850 <UART_SetConfig+0x2ec>)
3401877e:	6862      	ldr	r2, [r4, #4]
34018780:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
34018784:	fbb0 f0f3 	udiv	r0, r0, r3
34018788:	0853      	lsrs	r3, r2, #1
3401878a:	eb03 0340 	add.w	r3, r3, r0, lsl #1
3401878e:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
34018792:	f64f 72ef 	movw	r2, #65519	@ 0xffef
34018796:	f1a3 0110 	sub.w	r1, r3, #16
3401879a:	4291      	cmp	r1, r2
3401879c:	d8aa      	bhi.n	340186f4 <UART_SetConfig+0x190>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
3401879e:	f023 020f 	bic.w	r2, r3, #15
        huart->Instance->BRR = brrtemp;
340187a2:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
340187a4:	b292      	uxth	r2, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
340187a6:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
340187aa:	4313      	orrs	r3, r2
340187ac:	60cb      	str	r3, [r1, #12]
340187ae:	e7d8      	b.n	34018762 <UART_SetConfig+0x1fe>
  UART_GETCLOCKSOURCE(huart, clocksource);
340187b0:	2000      	movs	r0, #0
340187b2:	f44f 7100 	mov.w	r1, #512	@ 0x200
340187b6:	e7d9      	b.n	3401876c <UART_SetConfig+0x208>
340187b8:	2000      	movs	r0, #0
340187ba:	f44f 6180 	mov.w	r1, #1024	@ 0x400
340187be:	e7d5      	b.n	3401876c <UART_SetConfig+0x208>
340187c0:	2000      	movs	r0, #0
340187c2:	f44f 6100 	mov.w	r1, #2048	@ 0x800
340187c6:	e7d1      	b.n	3401876c <UART_SetConfig+0x208>
340187c8:	2000      	movs	r0, #0
340187ca:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
340187ce:	e7cd      	b.n	3401876c <UART_SetConfig+0x208>
340187d0:	2000      	movs	r0, #0
340187d2:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
340187d6:	e7c9      	b.n	3401876c <UART_SetConfig+0x208>
340187d8:	2000      	movs	r0, #0
340187da:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
340187de:	e7c5      	b.n	3401876c <UART_SetConfig+0x208>
340187e0:	2000      	movs	r0, #0
340187e2:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
340187e6:	e7c1      	b.n	3401876c <UART_SetConfig+0x208>
340187e8:	2000      	movs	r0, #0
340187ea:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
340187ee:	e7bd      	b.n	3401876c <UART_SetConfig+0x208>
340187f0:	2000      	movs	r0, #0
340187f2:	f44f 3100 	mov.w	r1, #131072	@ 0x20000
340187f6:	e7b9      	b.n	3401876c <UART_SetConfig+0x208>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
340187f8:	f7f6 fabc 	bl	3400ed74 <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
340187fc:	2800      	cmp	r0, #0
340187fe:	d0b0      	beq.n	34018762 <UART_SetConfig+0x1fe>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
34018800:	6a61      	ldr	r1, [r4, #36]	@ 0x24
34018802:	4b13      	ldr	r3, [pc, #76]	@ (34018850 <UART_SetConfig+0x2ec>)
34018804:	6862      	ldr	r2, [r4, #4]
34018806:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
3401880a:	fbb0 f3f3 	udiv	r3, r0, r3
3401880e:	eb03 0352 	add.w	r3, r3, r2, lsr #1
34018812:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
34018816:	f64f 72ef 	movw	r2, #65519	@ 0xffef
3401881a:	f1a3 0110 	sub.w	r1, r3, #16
3401881e:	4291      	cmp	r1, r2
34018820:	f63f af68 	bhi.w	340186f4 <UART_SetConfig+0x190>
        huart->Instance->BRR = (uint16_t)usartdiv;
34018824:	6822      	ldr	r2, [r4, #0]
34018826:	60d3      	str	r3, [r2, #12]
34018828:	e79b      	b.n	34018762 <UART_SetConfig+0x1fe>
3401882a:	bf00      	nop
3401882c:	00bebc1f 	.word	0x00bebc1f
34018830:	34021f2d 	.word	0x34021f2d
34018834:	56000c00 	.word	0x56000c00
34018838:	cfff69f3 	.word	0xcfff69f3
3401883c:	52001000 	.word	0x52001000
34018840:	50004400 	.word	0x50004400
34018844:	52001400 	.word	0x52001400
34018848:	50007800 	.word	0x50007800
3401884c:	52001800 	.word	0x52001800
34018850:	340ae7d0 	.word	0x340ae7d0
34018854:	000ffcff 	.word	0x000ffcff

34018858 <UART_AdvFeatureConfig>:
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
34018858:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
3401885a:	b510      	push	{r4, lr}
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
3401885c:	2bff      	cmp	r3, #255	@ 0xff
{
3401885e:	4604      	mov	r4, r0
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
34018860:	d904      	bls.n	3401886c <UART_AdvFeatureConfig+0x14>
34018862:	f640 41e5 	movw	r1, #3301	@ 0xce5
34018866:	487e      	ldr	r0, [pc, #504]	@ (34018a60 <UART_AdvFeatureConfig+0x208>)
34018868:	f7ea f9d2 	bl	34002c10 <assert_failed>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
3401886c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3401886e:	0718      	lsls	r0, r3, #28
34018870:	d50f      	bpl.n	34018892 <UART_AdvFeatureConfig+0x3a>
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
34018872:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
34018874:	f433 4300 	bics.w	r3, r3, #32768	@ 0x8000
34018878:	d004      	beq.n	34018884 <UART_AdvFeatureConfig+0x2c>
3401887a:	f640 41ea 	movw	r1, #3306	@ 0xcea
3401887e:	4878      	ldr	r0, [pc, #480]	@ (34018a60 <UART_AdvFeatureConfig+0x208>)
34018880:	f7ea f9c6 	bl	34002c10 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
34018884:	6822      	ldr	r2, [r4, #0]
34018886:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
34018888:	6853      	ldr	r3, [r2, #4]
3401888a:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3401888e:	430b      	orrs	r3, r1
34018890:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
34018892:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34018894:	07d9      	lsls	r1, r3, #31
34018896:	d50f      	bpl.n	340188b8 <UART_AdvFeatureConfig+0x60>
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
34018898:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3401889a:	f433 3300 	bics.w	r3, r3, #131072	@ 0x20000
3401889e:	d004      	beq.n	340188aa <UART_AdvFeatureConfig+0x52>
340188a0:	f640 41f1 	movw	r1, #3313	@ 0xcf1
340188a4:	486e      	ldr	r0, [pc, #440]	@ (34018a60 <UART_AdvFeatureConfig+0x208>)
340188a6:	f7ea f9b3 	bl	34002c10 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
340188aa:	6822      	ldr	r2, [r4, #0]
340188ac:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
340188ae:	6853      	ldr	r3, [r2, #4]
340188b0:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
340188b4:	430b      	orrs	r3, r1
340188b6:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
340188b8:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
340188ba:	079a      	lsls	r2, r3, #30
340188bc:	d50f      	bpl.n	340188de <UART_AdvFeatureConfig+0x86>
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
340188be:	6b23      	ldr	r3, [r4, #48]	@ 0x30
340188c0:	f433 3380 	bics.w	r3, r3, #65536	@ 0x10000
340188c4:	d004      	beq.n	340188d0 <UART_AdvFeatureConfig+0x78>
340188c6:	f640 41f8 	movw	r1, #3320	@ 0xcf8
340188ca:	4865      	ldr	r0, [pc, #404]	@ (34018a60 <UART_AdvFeatureConfig+0x208>)
340188cc:	f7ea f9a0 	bl	34002c10 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
340188d0:	6822      	ldr	r2, [r4, #0]
340188d2:	6b21      	ldr	r1, [r4, #48]	@ 0x30
340188d4:	6853      	ldr	r3, [r2, #4]
340188d6:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
340188da:	430b      	orrs	r3, r1
340188dc:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
340188de:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
340188e0:	075b      	lsls	r3, r3, #29
340188e2:	d50f      	bpl.n	34018904 <UART_AdvFeatureConfig+0xac>
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
340188e4:	6b63      	ldr	r3, [r4, #52]	@ 0x34
340188e6:	f433 2380 	bics.w	r3, r3, #262144	@ 0x40000
340188ea:	d004      	beq.n	340188f6 <UART_AdvFeatureConfig+0x9e>
340188ec:	f640 41ff 	movw	r1, #3327	@ 0xcff
340188f0:	485b      	ldr	r0, [pc, #364]	@ (34018a60 <UART_AdvFeatureConfig+0x208>)
340188f2:	f7ea f98d 	bl	34002c10 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
340188f6:	6822      	ldr	r2, [r4, #0]
340188f8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
340188fa:	6853      	ldr	r3, [r2, #4]
340188fc:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
34018900:	430b      	orrs	r3, r1
34018902:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
34018904:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34018906:	06d8      	lsls	r0, r3, #27
34018908:	d50f      	bpl.n	3401892a <UART_AdvFeatureConfig+0xd2>
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
3401890a:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3401890c:	f433 5380 	bics.w	r3, r3, #4096	@ 0x1000
34018910:	d004      	beq.n	3401891c <UART_AdvFeatureConfig+0xc4>
34018912:	f640 5106 	movw	r1, #3334	@ 0xd06
34018916:	4852      	ldr	r0, [pc, #328]	@ (34018a60 <UART_AdvFeatureConfig+0x208>)
34018918:	f7ea f97a 	bl	34002c10 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
3401891c:	6822      	ldr	r2, [r4, #0]
3401891e:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
34018920:	6893      	ldr	r3, [r2, #8]
34018922:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
34018926:	430b      	orrs	r3, r1
34018928:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
3401892a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3401892c:	0699      	lsls	r1, r3, #26
3401892e:	d50f      	bpl.n	34018950 <UART_AdvFeatureConfig+0xf8>
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
34018930:	6c23      	ldr	r3, [r4, #64]	@ 0x40
34018932:	f433 5300 	bics.w	r3, r3, #8192	@ 0x2000
34018936:	d004      	beq.n	34018942 <UART_AdvFeatureConfig+0xea>
34018938:	f640 510e 	movw	r1, #3342	@ 0xd0e
3401893c:	4848      	ldr	r0, [pc, #288]	@ (34018a60 <UART_AdvFeatureConfig+0x208>)
3401893e:	f7ea f967 	bl	34002c10 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
34018942:	6822      	ldr	r2, [r4, #0]
34018944:	6c21      	ldr	r1, [r4, #64]	@ 0x40
34018946:	6893      	ldr	r3, [r2, #8]
34018948:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
3401894c:	430b      	orrs	r3, r1
3401894e:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
34018950:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34018952:	065a      	lsls	r2, r3, #25
34018954:	d56f      	bpl.n	34018a36 <UART_AdvFeatureConfig+0x1de>
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
34018956:	6823      	ldr	r3, [r4, #0]
34018958:	4a42      	ldr	r2, [pc, #264]	@ (34018a64 <UART_AdvFeatureConfig+0x20c>)
3401895a:	4293      	cmp	r3, r2
3401895c:	d047      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
3401895e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018962:	4293      	cmp	r3, r2
34018964:	d043      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
34018966:	4a40      	ldr	r2, [pc, #256]	@ (34018a68 <UART_AdvFeatureConfig+0x210>)
34018968:	4293      	cmp	r3, r2
3401896a:	d040      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
3401896c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018970:	4293      	cmp	r3, r2
34018972:	d03c      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
34018974:	4a3d      	ldr	r2, [pc, #244]	@ (34018a6c <UART_AdvFeatureConfig+0x214>)
34018976:	4293      	cmp	r3, r2
34018978:	d039      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
3401897a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3401897e:	4293      	cmp	r3, r2
34018980:	d035      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
34018982:	4a3b      	ldr	r2, [pc, #236]	@ (34018a70 <UART_AdvFeatureConfig+0x218>)
34018984:	4293      	cmp	r3, r2
34018986:	d032      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
34018988:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3401898c:	4293      	cmp	r3, r2
3401898e:	d02e      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
34018990:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
34018994:	d02b      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
34018996:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3401899a:	4293      	cmp	r3, r2
3401899c:	d027      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
3401899e:	4a35      	ldr	r2, [pc, #212]	@ (34018a74 <UART_AdvFeatureConfig+0x21c>)
340189a0:	4293      	cmp	r3, r2
340189a2:	d024      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
340189a4:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340189a8:	4293      	cmp	r3, r2
340189aa:	d020      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
340189ac:	4a32      	ldr	r2, [pc, #200]	@ (34018a78 <UART_AdvFeatureConfig+0x220>)
340189ae:	4293      	cmp	r3, r2
340189b0:	d01d      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
340189b2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340189b6:	4293      	cmp	r3, r2
340189b8:	d019      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
340189ba:	4a30      	ldr	r2, [pc, #192]	@ (34018a7c <UART_AdvFeatureConfig+0x224>)
340189bc:	4293      	cmp	r3, r2
340189be:	d016      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
340189c0:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340189c4:	4293      	cmp	r3, r2
340189c6:	d012      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
340189c8:	4a2d      	ldr	r2, [pc, #180]	@ (34018a80 <UART_AdvFeatureConfig+0x228>)
340189ca:	4293      	cmp	r3, r2
340189cc:	d00f      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
340189ce:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340189d2:	4293      	cmp	r3, r2
340189d4:	d00b      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
340189d6:	4a2b      	ldr	r2, [pc, #172]	@ (34018a84 <UART_AdvFeatureConfig+0x22c>)
340189d8:	4293      	cmp	r3, r2
340189da:	d008      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
340189dc:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340189e0:	4293      	cmp	r3, r2
340189e2:	d004      	beq.n	340189ee <UART_AdvFeatureConfig+0x196>
340189e4:	f640 5116 	movw	r1, #3350	@ 0xd16
340189e8:	481d      	ldr	r0, [pc, #116]	@ (34018a60 <UART_AdvFeatureConfig+0x208>)
340189ea:	f7ea f911 	bl	34002c10 <assert_failed>
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
340189ee:	6c63      	ldr	r3, [r4, #68]	@ 0x44
340189f0:	f433 1380 	bics.w	r3, r3, #1048576	@ 0x100000
340189f4:	d004      	beq.n	34018a00 <UART_AdvFeatureConfig+0x1a8>
340189f6:	f640 5117 	movw	r1, #3351	@ 0xd17
340189fa:	4819      	ldr	r0, [pc, #100]	@ (34018a60 <UART_AdvFeatureConfig+0x208>)
340189fc:	f7ea f908 	bl	34002c10 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
34018a00:	6821      	ldr	r1, [r4, #0]
34018a02:	6c62      	ldr	r2, [r4, #68]	@ 0x44
34018a04:	684b      	ldr	r3, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
34018a06:	f5b2 1f80 	cmp.w	r2, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
34018a0a:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
34018a0e:	ea43 0302 	orr.w	r3, r3, r2
34018a12:	604b      	str	r3, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
34018a14:	d10f      	bne.n	34018a36 <UART_AdvFeatureConfig+0x1de>
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
34018a16:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
34018a18:	f433 03c0 	bics.w	r3, r3, #6291456	@ 0x600000
34018a1c:	d004      	beq.n	34018a28 <UART_AdvFeatureConfig+0x1d0>
34018a1e:	f640 511c 	movw	r1, #3356	@ 0xd1c
34018a22:	480f      	ldr	r0, [pc, #60]	@ (34018a60 <UART_AdvFeatureConfig+0x208>)
34018a24:	f7ea f8f4 	bl	34002c10 <assert_failed>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
34018a28:	6822      	ldr	r2, [r4, #0]
34018a2a:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
34018a2c:	6853      	ldr	r3, [r2, #4]
34018a2e:	f423 03c0 	bic.w	r3, r3, #6291456	@ 0x600000
34018a32:	430b      	orrs	r3, r1
34018a34:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
34018a36:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34018a38:	061b      	lsls	r3, r3, #24
34018a3a:	d50f      	bpl.n	34018a5c <UART_AdvFeatureConfig+0x204>
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
34018a3c:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
34018a3e:	f433 2300 	bics.w	r3, r3, #524288	@ 0x80000
34018a42:	d004      	beq.n	34018a4e <UART_AdvFeatureConfig+0x1f6>
34018a44:	f640 5124 	movw	r1, #3364	@ 0xd24
34018a48:	4805      	ldr	r0, [pc, #20]	@ (34018a60 <UART_AdvFeatureConfig+0x208>)
34018a4a:	f7ea f8e1 	bl	34002c10 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
34018a4e:	6822      	ldr	r2, [r4, #0]
34018a50:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
34018a52:	6853      	ldr	r3, [r2, #4]
34018a54:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
34018a58:	430b      	orrs	r3, r1
34018a5a:	6053      	str	r3, [r2, #4]
}
34018a5c:	bd10      	pop	{r4, pc}
34018a5e:	bf00      	nop
34018a60:	34021f2d 	.word	0x34021f2d
34018a64:	52001000 	.word	0x52001000
34018a68:	50004400 	.word	0x50004400
34018a6c:	50004800 	.word	0x50004800
34018a70:	50004c00 	.word	0x50004c00
34018a74:	52001400 	.word	0x52001400
34018a78:	50007800 	.word	0x50007800
34018a7c:	50007c00 	.word	0x50007c00
34018a80:	52001800 	.word	0x52001800
34018a84:	52001c00 	.word	0x52001c00

34018a88 <UART_WaitOnFlagUntilTimeout>:
{
34018a88:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34018a8c:	4604      	mov	r4, r0
34018a8e:	460d      	mov	r5, r1
34018a90:	4617      	mov	r7, r2
34018a92:	4698      	mov	r8, r3
34018a94:	f8dd 9020 	ldr.w	r9, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
34018a98:	6822      	ldr	r2, [r4, #0]
34018a9a:	69d3      	ldr	r3, [r2, #28]
34018a9c:	ea35 0303 	bics.w	r3, r5, r3
34018aa0:	bf0c      	ite	eq
34018aa2:	2301      	moveq	r3, #1
34018aa4:	2300      	movne	r3, #0
34018aa6:	42bb      	cmp	r3, r7
34018aa8:	d001      	beq.n	34018aae <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
34018aaa:	2000      	movs	r0, #0
34018aac:	e022      	b.n	34018af4 <UART_WaitOnFlagUntilTimeout+0x6c>
    if (Timeout != HAL_MAX_DELAY)
34018aae:	f1b9 3fff 	cmp.w	r9, #4294967295
34018ab2:	d0f2      	beq.n	34018a9a <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34018ab4:	f7ec f9e2 	bl	34004e7c <HAL_GetTick>
34018ab8:	eba0 0008 	sub.w	r0, r0, r8
34018abc:	4548      	cmp	r0, r9
34018abe:	d829      	bhi.n	34018b14 <UART_WaitOnFlagUntilTimeout+0x8c>
34018ac0:	f1b9 0f00 	cmp.w	r9, #0
34018ac4:	d026      	beq.n	34018b14 <UART_WaitOnFlagUntilTimeout+0x8c>
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
34018ac6:	6821      	ldr	r1, [r4, #0]
34018ac8:	680b      	ldr	r3, [r1, #0]
34018aca:	075a      	lsls	r2, r3, #29
34018acc:	d5e4      	bpl.n	34018a98 <UART_WaitOnFlagUntilTimeout+0x10>
34018ace:	2d80      	cmp	r5, #128	@ 0x80
34018ad0:	d0e2      	beq.n	34018a98 <UART_WaitOnFlagUntilTimeout+0x10>
34018ad2:	2d40      	cmp	r5, #64	@ 0x40
34018ad4:	d0e0      	beq.n	34018a98 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
34018ad6:	69ce      	ldr	r6, [r1, #28]
34018ad8:	f016 0608 	ands.w	r6, r6, #8
34018adc:	d00c      	beq.n	34018af8 <UART_WaitOnFlagUntilTimeout+0x70>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
34018ade:	2508      	movs	r5, #8
          UART_EndRxTransfer(huart);
34018ae0:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
34018ae2:	620d      	str	r5, [r1, #32]
          UART_EndRxTransfer(huart);
34018ae4:	f7ff fd10 	bl	34018508 <UART_EndRxTransfer>
          __HAL_UNLOCK(huart);
34018ae8:	2300      	movs	r3, #0
          return HAL_ERROR;
34018aea:	2001      	movs	r0, #1
          huart->ErrorCode = HAL_UART_ERROR_ORE;
34018aec:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
          __HAL_UNLOCK(huart);
34018af0:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
34018af4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
34018af8:	69cb      	ldr	r3, [r1, #28]
34018afa:	051b      	lsls	r3, r3, #20
34018afc:	d5cc      	bpl.n	34018a98 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
34018afe:	f44f 6300 	mov.w	r3, #2048	@ 0x800
          UART_EndRxTransfer(huart);
34018b02:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
34018b04:	620b      	str	r3, [r1, #32]
          UART_EndRxTransfer(huart);
34018b06:	f7ff fcff 	bl	34018508 <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
34018b0a:	2320      	movs	r3, #32
          __HAL_UNLOCK(huart);
34018b0c:	f884 6084 	strb.w	r6, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
34018b10:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        return HAL_TIMEOUT;
34018b14:	2003      	movs	r0, #3
34018b16:	e7ed      	b.n	34018af4 <UART_WaitOnFlagUntilTimeout+0x6c>

34018b18 <HAL_UART_Transmit>:
{
34018b18:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
34018b1c:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
34018b1e:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
34018b22:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
34018b24:	2b20      	cmp	r3, #32
{
34018b26:	460d      	mov	r5, r1
34018b28:	4616      	mov	r6, r2
  if (huart->gState == HAL_UART_STATE_READY)
34018b2a:	d148      	bne.n	34018bbe <HAL_UART_Transmit+0xa6>
    if ((pData == NULL) || (Size == 0U))
34018b2c:	2900      	cmp	r1, #0
34018b2e:	d048      	beq.n	34018bc2 <HAL_UART_Transmit+0xaa>
34018b30:	2a00      	cmp	r2, #0
34018b32:	d046      	beq.n	34018bc2 <HAL_UART_Transmit+0xaa>
    huart->gState = HAL_UART_STATE_BUSY_TX;
34018b34:	2321      	movs	r3, #33	@ 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
34018b36:	f04f 0900 	mov.w	r9, #0
34018b3a:	f8c0 9090 	str.w	r9, [r0, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
34018b3e:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    tickstart = HAL_GetTick();
34018b42:	f7ec f99b 	bl	34004e7c <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
34018b46:	68a3      	ldr	r3, [r4, #8]
    huart->TxXferSize  = Size;
34018b48:	f8a4 6054 	strh.w	r6, [r4, #84]	@ 0x54
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
34018b4c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->TxXferCount = Size;
34018b50:	f8a4 6056 	strh.w	r6, [r4, #86]	@ 0x56
    tickstart = HAL_GetTick();
34018b54:	4607      	mov	r7, r0
      pdata16bits = NULL;
34018b56:	464e      	mov	r6, r9
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
34018b58:	d103      	bne.n	34018b62 <HAL_UART_Transmit+0x4a>
34018b5a:	6923      	ldr	r3, [r4, #16]
34018b5c:	b90b      	cbnz	r3, 34018b62 <HAL_UART_Transmit+0x4a>
      pdata16bits = (const uint16_t *) pData;
34018b5e:	462e      	mov	r6, r5
      pdata8bits  = NULL;
34018b60:	461d      	mov	r5, r3
    while (huart->TxXferCount > 0U)
34018b62:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
34018b66:	463b      	mov	r3, r7
    while (huart->TxXferCount > 0U)
34018b68:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
34018b6a:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
34018b6e:	b942      	cbnz	r2, 34018b82 <HAL_UART_Transmit+0x6a>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
34018b70:	2140      	movs	r1, #64	@ 0x40
34018b72:	4620      	mov	r0, r4
34018b74:	f7ff ff88 	bl	34018a88 <UART_WaitOnFlagUntilTimeout>
34018b78:	2320      	movs	r3, #32
34018b7a:	b948      	cbnz	r0, 34018b90 <HAL_UART_Transmit+0x78>
    huart->gState = HAL_UART_STATE_READY;
34018b7c:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    return HAL_OK;
34018b80:	e009      	b.n	34018b96 <HAL_UART_Transmit+0x7e>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
34018b82:	2200      	movs	r2, #0
34018b84:	2180      	movs	r1, #128	@ 0x80
34018b86:	4620      	mov	r0, r4
34018b88:	f7ff ff7e 	bl	34018a88 <UART_WaitOnFlagUntilTimeout>
34018b8c:	b130      	cbz	r0, 34018b9c <HAL_UART_Transmit+0x84>
        huart->gState = HAL_UART_STATE_READY;
34018b8e:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
34018b90:	2003      	movs	r0, #3
        huart->gState = HAL_UART_STATE_READY;
34018b92:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
}
34018b96:	b003      	add	sp, #12
34018b98:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
34018b9c:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
34018b9e:	b95d      	cbnz	r5, 34018bb8 <HAL_UART_Transmit+0xa0>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
34018ba0:	f836 3b02 	ldrh.w	r3, [r6], #2
34018ba4:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
34018ba8:	6293      	str	r3, [r2, #40]	@ 0x28
      huart->TxXferCount--;
34018baa:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
34018bae:	3a01      	subs	r2, #1
34018bb0:	b292      	uxth	r2, r2
34018bb2:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
34018bb6:	e7d4      	b.n	34018b62 <HAL_UART_Transmit+0x4a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
34018bb8:	f815 3b01 	ldrb.w	r3, [r5], #1
34018bbc:	e7f4      	b.n	34018ba8 <HAL_UART_Transmit+0x90>
    return HAL_BUSY;
34018bbe:	2002      	movs	r0, #2
34018bc0:	e7e9      	b.n	34018b96 <HAL_UART_Transmit+0x7e>
      return  HAL_ERROR;
34018bc2:	2001      	movs	r0, #1
34018bc4:	e7e7      	b.n	34018b96 <HAL_UART_Transmit+0x7e>

34018bc6 <UART_CheckIdleState>:
{
34018bc6:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
34018bc8:	2600      	movs	r6, #0
{
34018bca:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
34018bcc:	f8c0 6090 	str.w	r6, [r0, #144]	@ 0x90
  tickstart = HAL_GetTick();
34018bd0:	f7ec f954 	bl	34004e7c <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
34018bd4:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
34018bd6:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
34018bd8:	681b      	ldr	r3, [r3, #0]
34018bda:	071a      	lsls	r2, r3, #28
34018bdc:	d51c      	bpl.n	34018c18 <UART_CheckIdleState+0x52>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
34018bde:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
34018be2:	4632      	mov	r2, r6
34018be4:	9300      	str	r3, [sp, #0]
34018be6:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
34018bea:	4603      	mov	r3, r0
34018bec:	4620      	mov	r0, r4
34018bee:	f7ff ff4b 	bl	34018a88 <UART_WaitOnFlagUntilTimeout>
34018bf2:	b188      	cbz	r0, 34018c18 <UART_CheckIdleState+0x52>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
34018bf4:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34018bf6:	e852 3f00 	ldrex	r3, [r2]
34018bfa:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34018bfe:	e842 3100 	strex	r1, r3, [r2]
34018c02:	2900      	cmp	r1, #0
34018c04:	d1f6      	bne.n	34018bf4 <UART_CheckIdleState+0x2e>
      huart->gState = HAL_UART_STATE_READY;
34018c06:	2320      	movs	r3, #32
34018c08:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
34018c0c:	2003      	movs	r0, #3
      __HAL_UNLOCK(huart);
34018c0e:	2300      	movs	r3, #0
34018c10:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
34018c14:	b002      	add	sp, #8
34018c16:	bd70      	pop	{r4, r5, r6, pc}
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
34018c18:	6823      	ldr	r3, [r4, #0]
34018c1a:	681b      	ldr	r3, [r3, #0]
34018c1c:	075b      	lsls	r3, r3, #29
34018c1e:	d524      	bpl.n	34018c6a <UART_CheckIdleState+0xa4>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
34018c20:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
34018c24:	2200      	movs	r2, #0
34018c26:	9300      	str	r3, [sp, #0]
34018c28:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
34018c2c:	462b      	mov	r3, r5
34018c2e:	4620      	mov	r0, r4
34018c30:	f7ff ff2a 	bl	34018a88 <UART_WaitOnFlagUntilTimeout>
34018c34:	b1c8      	cbz	r0, 34018c6a <UART_CheckIdleState+0xa4>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
34018c36:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34018c38:	e852 3f00 	ldrex	r3, [r2]
34018c3c:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34018c40:	e842 3100 	strex	r1, r3, [r2]
   return(result);
34018c44:	6822      	ldr	r2, [r4, #0]
34018c46:	2900      	cmp	r1, #0
34018c48:	d1f5      	bne.n	34018c36 <UART_CheckIdleState+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34018c4a:	f102 0308 	add.w	r3, r2, #8
34018c4e:	e853 3f00 	ldrex	r3, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
34018c52:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34018c56:	f102 0008 	add.w	r0, r2, #8
34018c5a:	e840 3100 	strex	r1, r3, [r0]
34018c5e:	2900      	cmp	r1, #0
34018c60:	d1f3      	bne.n	34018c4a <UART_CheckIdleState+0x84>
      huart->RxState = HAL_UART_STATE_READY;
34018c62:	2320      	movs	r3, #32
34018c64:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      return HAL_TIMEOUT;
34018c68:	e7d0      	b.n	34018c0c <UART_CheckIdleState+0x46>
  huart->gState = HAL_UART_STATE_READY;
34018c6a:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
34018c6c:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
34018c6e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
34018c72:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
34018c76:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
34018c78:	6720      	str	r0, [r4, #112]	@ 0x70
  return HAL_OK;
34018c7a:	e7c8      	b.n	34018c0e <UART_CheckIdleState+0x48>

34018c7c <HAL_UART_Init>:
{
34018c7c:	b510      	push	{r4, lr}
  if (huart == NULL)
34018c7e:	4604      	mov	r4, r0
34018c80:	2800      	cmp	r0, #0
34018c82:	f000 80d0 	beq.w	34018e26 <HAL_UART_Init+0x1aa>
  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
34018c86:	6981      	ldr	r1, [r0, #24]
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
34018c88:	6803      	ldr	r3, [r0, #0]
34018c8a:	4a68      	ldr	r2, [pc, #416]	@ (34018e2c <HAL_UART_Init+0x1b0>)
  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
34018c8c:	2900      	cmp	r1, #0
34018c8e:	d07c      	beq.n	34018d8a <HAL_UART_Init+0x10e>
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
34018c90:	4293      	cmp	r3, r2
34018c92:	d04e      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018c94:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018c98:	4293      	cmp	r3, r2
34018c9a:	d04a      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018c9c:	4a64      	ldr	r2, [pc, #400]	@ (34018e30 <HAL_UART_Init+0x1b4>)
34018c9e:	4293      	cmp	r3, r2
34018ca0:	d047      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018ca2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018ca6:	4293      	cmp	r3, r2
34018ca8:	d043      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018caa:	4a62      	ldr	r2, [pc, #392]	@ (34018e34 <HAL_UART_Init+0x1b8>)
34018cac:	4293      	cmp	r3, r2
34018cae:	d040      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018cb0:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018cb4:	4293      	cmp	r3, r2
34018cb6:	d03c      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018cb8:	4a5f      	ldr	r2, [pc, #380]	@ (34018e38 <HAL_UART_Init+0x1bc>)
34018cba:	4293      	cmp	r3, r2
34018cbc:	d039      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018cbe:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018cc2:	4293      	cmp	r3, r2
34018cc4:	d035      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018cc6:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
34018cca:	d032      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018ccc:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
34018cd0:	4293      	cmp	r3, r2
34018cd2:	d02e      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018cd4:	4a59      	ldr	r2, [pc, #356]	@ (34018e3c <HAL_UART_Init+0x1c0>)
34018cd6:	4293      	cmp	r3, r2
34018cd8:	d02b      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018cda:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018cde:	4293      	cmp	r3, r2
34018ce0:	d027      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018ce2:	4a57      	ldr	r2, [pc, #348]	@ (34018e40 <HAL_UART_Init+0x1c4>)
34018ce4:	4293      	cmp	r3, r2
34018ce6:	d024      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018ce8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018cec:	4293      	cmp	r3, r2
34018cee:	d020      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018cf0:	4a54      	ldr	r2, [pc, #336]	@ (34018e44 <HAL_UART_Init+0x1c8>)
34018cf2:	4293      	cmp	r3, r2
34018cf4:	d01d      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018cf6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018cfa:	4293      	cmp	r3, r2
34018cfc:	d019      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018cfe:	4a52      	ldr	r2, [pc, #328]	@ (34018e48 <HAL_UART_Init+0x1cc>)
34018d00:	4293      	cmp	r3, r2
34018d02:	d016      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018d04:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018d08:	4293      	cmp	r3, r2
34018d0a:	d012      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018d0c:	4a4f      	ldr	r2, [pc, #316]	@ (34018e4c <HAL_UART_Init+0x1d0>)
34018d0e:	4293      	cmp	r3, r2
34018d10:	d00f      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018d12:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018d16:	4293      	cmp	r3, r2
34018d18:	d00b      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018d1a:	4a4d      	ldr	r2, [pc, #308]	@ (34018e50 <HAL_UART_Init+0x1d4>)
34018d1c:	4293      	cmp	r3, r2
34018d1e:	d008      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018d20:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018d24:	4293      	cmp	r3, r2
34018d26:	d004      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018d28:	f44f 71a0 	mov.w	r1, #320	@ 0x140
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
34018d2c:	4849      	ldr	r0, [pc, #292]	@ (34018e54 <HAL_UART_Init+0x1d8>)
34018d2e:	f7e9 ff6f 	bl	34002c10 <assert_failed>
  if (huart->gState == HAL_UART_STATE_RESET)
34018d32:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
34018d36:	b923      	cbnz	r3, 34018d42 <HAL_UART_Init+0xc6>
    HAL_UART_MspInit(huart);
34018d38:	4620      	mov	r0, r4
    huart->Lock = HAL_UNLOCKED;
34018d3a:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
    HAL_UART_MspInit(huart);
34018d3e:	f7ff fc0f 	bl	34018560 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
34018d42:	2324      	movs	r3, #36	@ 0x24
  __HAL_UART_DISABLE(huart);
34018d44:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
34018d46:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
34018d4a:	6813      	ldr	r3, [r2, #0]
34018d4c:	f023 0301 	bic.w	r3, r3, #1
34018d50:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
34018d52:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34018d54:	b113      	cbz	r3, 34018d5c <HAL_UART_Init+0xe0>
    UART_AdvFeatureConfig(huart);
34018d56:	4620      	mov	r0, r4
34018d58:	f7ff fd7e 	bl	34018858 <UART_AdvFeatureConfig>
  if (UART_SetConfig(huart) == HAL_ERROR)
34018d5c:	4620      	mov	r0, r4
34018d5e:	f7ff fc01 	bl	34018564 <UART_SetConfig>
34018d62:	2801      	cmp	r0, #1
34018d64:	d05f      	beq.n	34018e26 <HAL_UART_Init+0x1aa>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
34018d66:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
34018d68:	4620      	mov	r0, r4
}
34018d6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
34018d6e:	685a      	ldr	r2, [r3, #4]
34018d70:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
34018d74:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
34018d76:	689a      	ldr	r2, [r3, #8]
34018d78:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
34018d7c:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
34018d7e:	681a      	ldr	r2, [r3, #0]
34018d80:	f042 0201 	orr.w	r2, r2, #1
34018d84:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
34018d86:	f7ff bf1e 	b.w	34018bc6 <UART_CheckIdleState>
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
34018d8a:	4293      	cmp	r3, r2
34018d8c:	d0d1      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018d8e:	4a32      	ldr	r2, [pc, #200]	@ (34018e58 <HAL_UART_Init+0x1dc>)
34018d90:	4293      	cmp	r3, r2
34018d92:	d0ce      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018d94:	4a26      	ldr	r2, [pc, #152]	@ (34018e30 <HAL_UART_Init+0x1b4>)
34018d96:	4293      	cmp	r3, r2
34018d98:	d0cb      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018d9a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018d9e:	4293      	cmp	r3, r2
34018da0:	d0c7      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018da2:	4a24      	ldr	r2, [pc, #144]	@ (34018e34 <HAL_UART_Init+0x1b8>)
34018da4:	4293      	cmp	r3, r2
34018da6:	d0c4      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018da8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018dac:	4293      	cmp	r3, r2
34018dae:	d0c0      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018db0:	4a21      	ldr	r2, [pc, #132]	@ (34018e38 <HAL_UART_Init+0x1bc>)
34018db2:	4293      	cmp	r3, r2
34018db4:	d0bd      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018db6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018dba:	4293      	cmp	r3, r2
34018dbc:	d0b9      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018dbe:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
34018dc2:	d0b6      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018dc4:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
34018dc8:	4293      	cmp	r3, r2
34018dca:	d0b2      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018dcc:	4a1b      	ldr	r2, [pc, #108]	@ (34018e3c <HAL_UART_Init+0x1c0>)
34018dce:	4293      	cmp	r3, r2
34018dd0:	d0af      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018dd2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018dd6:	4293      	cmp	r3, r2
34018dd8:	d0ab      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018dda:	4a19      	ldr	r2, [pc, #100]	@ (34018e40 <HAL_UART_Init+0x1c4>)
34018ddc:	4293      	cmp	r3, r2
34018dde:	d0a8      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018de0:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018de4:	4293      	cmp	r3, r2
34018de6:	d0a4      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018de8:	4a16      	ldr	r2, [pc, #88]	@ (34018e44 <HAL_UART_Init+0x1c8>)
34018dea:	4293      	cmp	r3, r2
34018dec:	d0a1      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018dee:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018df2:	4293      	cmp	r3, r2
34018df4:	d09d      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018df6:	4a14      	ldr	r2, [pc, #80]	@ (34018e48 <HAL_UART_Init+0x1cc>)
34018df8:	4293      	cmp	r3, r2
34018dfa:	d09a      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018dfc:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018e00:	4293      	cmp	r3, r2
34018e02:	d096      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018e04:	4a11      	ldr	r2, [pc, #68]	@ (34018e4c <HAL_UART_Init+0x1d0>)
34018e06:	4293      	cmp	r3, r2
34018e08:	d093      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018e0a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018e0e:	4293      	cmp	r3, r2
34018e10:	d08f      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018e12:	4a0f      	ldr	r2, [pc, #60]	@ (34018e50 <HAL_UART_Init+0x1d4>)
34018e14:	4293      	cmp	r3, r2
34018e16:	d08c      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018e18:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34018e1c:	4293      	cmp	r3, r2
34018e1e:	d088      	beq.n	34018d32 <HAL_UART_Init+0xb6>
34018e20:	f240 1145 	movw	r1, #325	@ 0x145
34018e24:	e782      	b.n	34018d2c <HAL_UART_Init+0xb0>
}
34018e26:	2001      	movs	r0, #1
34018e28:	bd10      	pop	{r4, pc}
34018e2a:	bf00      	nop
34018e2c:	52001000 	.word	0x52001000
34018e30:	50004400 	.word	0x50004400
34018e34:	50004800 	.word	0x50004800
34018e38:	50004c00 	.word	0x50004c00
34018e3c:	52001400 	.word	0x52001400
34018e40:	50007800 	.word	0x50007800
34018e44:	50007c00 	.word	0x50007c00
34018e48:	52001800 	.word	0x52001800
34018e4c:	52001c00 	.word	0x52001c00
34018e50:	56000c00 	.word	0x56000c00
34018e54:	34021f2d 	.word	0x34021f2d
34018e58:	42001000 	.word	0x42001000

34018e5c <__assert_func>:
34018e5c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
34018e5e:	4614      	mov	r4, r2
34018e60:	461a      	mov	r2, r3
34018e62:	4b09      	ldr	r3, [pc, #36]	@ (34018e88 <__assert_func+0x2c>)
34018e64:	4605      	mov	r5, r0
34018e66:	681b      	ldr	r3, [r3, #0]
34018e68:	68d8      	ldr	r0, [r3, #12]
34018e6a:	b14c      	cbz	r4, 34018e80 <__assert_func+0x24>
34018e6c:	4b07      	ldr	r3, [pc, #28]	@ (34018e8c <__assert_func+0x30>)
34018e6e:	9100      	str	r1, [sp, #0]
34018e70:	4907      	ldr	r1, [pc, #28]	@ (34018e90 <__assert_func+0x34>)
34018e72:	e9cd 3401 	strd	r3, r4, [sp, #4]
34018e76:	462b      	mov	r3, r5
34018e78:	f000 ff50 	bl	34019d1c <fiprintf>
34018e7c:	f001 fbf6 	bl	3401a66c <abort>
34018e80:	4b04      	ldr	r3, [pc, #16]	@ (34018e94 <__assert_func+0x38>)
34018e82:	461c      	mov	r4, r3
34018e84:	e7f3      	b.n	34018e6e <__assert_func+0x12>
34018e86:	bf00      	nop
34018e88:	340b1110 	.word	0x340b1110
34018e8c:	340225ea 	.word	0x340225ea
34018e90:	340225f7 	.word	0x340225f7
34018e94:	3402118e 	.word	0x3402118e

34018e98 <malloc>:
34018e98:	4b02      	ldr	r3, [pc, #8]	@ (34018ea4 <malloc+0xc>)
34018e9a:	4601      	mov	r1, r0
34018e9c:	6818      	ldr	r0, [r3, #0]
34018e9e:	f000 b825 	b.w	34018eec <_malloc_r>
34018ea2:	bf00      	nop
34018ea4:	340b1110 	.word	0x340b1110

34018ea8 <sbrk_aligned>:
34018ea8:	b570      	push	{r4, r5, r6, lr}
34018eaa:	4e0f      	ldr	r6, [pc, #60]	@ (34018ee8 <sbrk_aligned+0x40>)
34018eac:	460c      	mov	r4, r1
34018eae:	4605      	mov	r5, r0
34018eb0:	6831      	ldr	r1, [r6, #0]
34018eb2:	b911      	cbnz	r1, 34018eba <sbrk_aligned+0x12>
34018eb4:	f001 fb68 	bl	3401a588 <_sbrk_r>
34018eb8:	6030      	str	r0, [r6, #0]
34018eba:	4621      	mov	r1, r4
34018ebc:	4628      	mov	r0, r5
34018ebe:	f001 fb63 	bl	3401a588 <_sbrk_r>
34018ec2:	1c43      	adds	r3, r0, #1
34018ec4:	d103      	bne.n	34018ece <sbrk_aligned+0x26>
34018ec6:	f04f 34ff 	mov.w	r4, #4294967295
34018eca:	4620      	mov	r0, r4
34018ecc:	bd70      	pop	{r4, r5, r6, pc}
34018ece:	1cc4      	adds	r4, r0, #3
34018ed0:	f024 0403 	bic.w	r4, r4, #3
34018ed4:	42a0      	cmp	r0, r4
34018ed6:	d0f8      	beq.n	34018eca <sbrk_aligned+0x22>
34018ed8:	1a21      	subs	r1, r4, r0
34018eda:	4628      	mov	r0, r5
34018edc:	f001 fb54 	bl	3401a588 <_sbrk_r>
34018ee0:	3001      	adds	r0, #1
34018ee2:	d1f2      	bne.n	34018eca <sbrk_aligned+0x22>
34018ee4:	e7ef      	b.n	34018ec6 <sbrk_aligned+0x1e>
34018ee6:	bf00      	nop
34018ee8:	340ceeec 	.word	0x340ceeec

34018eec <_malloc_r>:
34018eec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34018ef0:	1ccd      	adds	r5, r1, #3
34018ef2:	4606      	mov	r6, r0
34018ef4:	f025 0503 	bic.w	r5, r5, #3
34018ef8:	3508      	adds	r5, #8
34018efa:	2d0c      	cmp	r5, #12
34018efc:	bf38      	it	cc
34018efe:	250c      	movcc	r5, #12
34018f00:	2d00      	cmp	r5, #0
34018f02:	db01      	blt.n	34018f08 <_malloc_r+0x1c>
34018f04:	42a9      	cmp	r1, r5
34018f06:	d904      	bls.n	34018f12 <_malloc_r+0x26>
34018f08:	230c      	movs	r3, #12
34018f0a:	6033      	str	r3, [r6, #0]
34018f0c:	2000      	movs	r0, #0
34018f0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
34018f12:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 34018fe8 <_malloc_r+0xfc>
34018f16:	f000 f869 	bl	34018fec <__malloc_lock>
34018f1a:	f8d8 3000 	ldr.w	r3, [r8]
34018f1e:	461c      	mov	r4, r3
34018f20:	bb44      	cbnz	r4, 34018f74 <_malloc_r+0x88>
34018f22:	4629      	mov	r1, r5
34018f24:	4630      	mov	r0, r6
34018f26:	f7ff ffbf 	bl	34018ea8 <sbrk_aligned>
34018f2a:	1c43      	adds	r3, r0, #1
34018f2c:	4604      	mov	r4, r0
34018f2e:	d158      	bne.n	34018fe2 <_malloc_r+0xf6>
34018f30:	f8d8 4000 	ldr.w	r4, [r8]
34018f34:	4627      	mov	r7, r4
34018f36:	2f00      	cmp	r7, #0
34018f38:	d143      	bne.n	34018fc2 <_malloc_r+0xd6>
34018f3a:	2c00      	cmp	r4, #0
34018f3c:	d04b      	beq.n	34018fd6 <_malloc_r+0xea>
34018f3e:	6823      	ldr	r3, [r4, #0]
34018f40:	4639      	mov	r1, r7
34018f42:	4630      	mov	r0, r6
34018f44:	eb04 0903 	add.w	r9, r4, r3
34018f48:	f001 fb1e 	bl	3401a588 <_sbrk_r>
34018f4c:	4581      	cmp	r9, r0
34018f4e:	d142      	bne.n	34018fd6 <_malloc_r+0xea>
34018f50:	6821      	ldr	r1, [r4, #0]
34018f52:	4630      	mov	r0, r6
34018f54:	1a6d      	subs	r5, r5, r1
34018f56:	4629      	mov	r1, r5
34018f58:	f7ff ffa6 	bl	34018ea8 <sbrk_aligned>
34018f5c:	3001      	adds	r0, #1
34018f5e:	d03a      	beq.n	34018fd6 <_malloc_r+0xea>
34018f60:	6823      	ldr	r3, [r4, #0]
34018f62:	442b      	add	r3, r5
34018f64:	6023      	str	r3, [r4, #0]
34018f66:	f8d8 3000 	ldr.w	r3, [r8]
34018f6a:	685a      	ldr	r2, [r3, #4]
34018f6c:	bb62      	cbnz	r2, 34018fc8 <_malloc_r+0xdc>
34018f6e:	f8c8 7000 	str.w	r7, [r8]
34018f72:	e00f      	b.n	34018f94 <_malloc_r+0xa8>
34018f74:	6822      	ldr	r2, [r4, #0]
34018f76:	1b52      	subs	r2, r2, r5
34018f78:	d420      	bmi.n	34018fbc <_malloc_r+0xd0>
34018f7a:	2a0b      	cmp	r2, #11
34018f7c:	d917      	bls.n	34018fae <_malloc_r+0xc2>
34018f7e:	1961      	adds	r1, r4, r5
34018f80:	42a3      	cmp	r3, r4
34018f82:	6025      	str	r5, [r4, #0]
34018f84:	bf18      	it	ne
34018f86:	6059      	strne	r1, [r3, #4]
34018f88:	6863      	ldr	r3, [r4, #4]
34018f8a:	bf08      	it	eq
34018f8c:	f8c8 1000 	streq.w	r1, [r8]
34018f90:	5162      	str	r2, [r4, r5]
34018f92:	604b      	str	r3, [r1, #4]
34018f94:	4630      	mov	r0, r6
34018f96:	f000 f82f 	bl	34018ff8 <__malloc_unlock>
34018f9a:	f104 000b 	add.w	r0, r4, #11
34018f9e:	1d23      	adds	r3, r4, #4
34018fa0:	f020 0007 	bic.w	r0, r0, #7
34018fa4:	1ac2      	subs	r2, r0, r3
34018fa6:	bf1c      	itt	ne
34018fa8:	1a1b      	subne	r3, r3, r0
34018faa:	50a3      	strne	r3, [r4, r2]
34018fac:	e7af      	b.n	34018f0e <_malloc_r+0x22>
34018fae:	6862      	ldr	r2, [r4, #4]
34018fb0:	42a3      	cmp	r3, r4
34018fb2:	bf0c      	ite	eq
34018fb4:	f8c8 2000 	streq.w	r2, [r8]
34018fb8:	605a      	strne	r2, [r3, #4]
34018fba:	e7eb      	b.n	34018f94 <_malloc_r+0xa8>
34018fbc:	4623      	mov	r3, r4
34018fbe:	6864      	ldr	r4, [r4, #4]
34018fc0:	e7ae      	b.n	34018f20 <_malloc_r+0x34>
34018fc2:	463c      	mov	r4, r7
34018fc4:	687f      	ldr	r7, [r7, #4]
34018fc6:	e7b6      	b.n	34018f36 <_malloc_r+0x4a>
34018fc8:	461a      	mov	r2, r3
34018fca:	685b      	ldr	r3, [r3, #4]
34018fcc:	42a3      	cmp	r3, r4
34018fce:	d1fb      	bne.n	34018fc8 <_malloc_r+0xdc>
34018fd0:	2300      	movs	r3, #0
34018fd2:	6053      	str	r3, [r2, #4]
34018fd4:	e7de      	b.n	34018f94 <_malloc_r+0xa8>
34018fd6:	230c      	movs	r3, #12
34018fd8:	4630      	mov	r0, r6
34018fda:	6033      	str	r3, [r6, #0]
34018fdc:	f000 f80c 	bl	34018ff8 <__malloc_unlock>
34018fe0:	e794      	b.n	34018f0c <_malloc_r+0x20>
34018fe2:	6005      	str	r5, [r0, #0]
34018fe4:	e7d6      	b.n	34018f94 <_malloc_r+0xa8>
34018fe6:	bf00      	nop
34018fe8:	340ceef0 	.word	0x340ceef0

34018fec <__malloc_lock>:
34018fec:	4801      	ldr	r0, [pc, #4]	@ (34018ff4 <__malloc_lock+0x8>)
34018fee:	f001 bb18 	b.w	3401a622 <__retarget_lock_acquire_recursive>
34018ff2:	bf00      	nop
34018ff4:	340cf034 	.word	0x340cf034

34018ff8 <__malloc_unlock>:
34018ff8:	4801      	ldr	r0, [pc, #4]	@ (34019000 <__malloc_unlock+0x8>)
34018ffa:	f001 bb13 	b.w	3401a624 <__retarget_lock_release_recursive>
34018ffe:	bf00      	nop
34019000:	340cf034 	.word	0x340cf034

34019004 <_realloc_r>:
34019004:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34019008:	4607      	mov	r7, r0
3401900a:	4614      	mov	r4, r2
3401900c:	460d      	mov	r5, r1
3401900e:	b921      	cbnz	r1, 3401901a <_realloc_r+0x16>
34019010:	4611      	mov	r1, r2
34019012:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
34019016:	f7ff bf69 	b.w	34018eec <_malloc_r>
3401901a:	b92a      	cbnz	r2, 34019028 <_realloc_r+0x24>
3401901c:	4625      	mov	r5, r4
3401901e:	f002 f919 	bl	3401b254 <_free_r>
34019022:	4628      	mov	r0, r5
34019024:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34019028:	f002 fce0 	bl	3401b9ec <_malloc_usable_size_r>
3401902c:	4284      	cmp	r4, r0
3401902e:	4606      	mov	r6, r0
34019030:	d802      	bhi.n	34019038 <_realloc_r+0x34>
34019032:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
34019036:	d8f4      	bhi.n	34019022 <_realloc_r+0x1e>
34019038:	4621      	mov	r1, r4
3401903a:	4638      	mov	r0, r7
3401903c:	f7ff ff56 	bl	34018eec <_malloc_r>
34019040:	4680      	mov	r8, r0
34019042:	b908      	cbnz	r0, 34019048 <_realloc_r+0x44>
34019044:	4645      	mov	r5, r8
34019046:	e7ec      	b.n	34019022 <_realloc_r+0x1e>
34019048:	42b4      	cmp	r4, r6
3401904a:	4622      	mov	r2, r4
3401904c:	4629      	mov	r1, r5
3401904e:	bf28      	it	cs
34019050:	4632      	movcs	r2, r6
34019052:	f001 fafe 	bl	3401a652 <memcpy>
34019056:	4629      	mov	r1, r5
34019058:	4638      	mov	r0, r7
3401905a:	f002 f8fb 	bl	3401b254 <_free_r>
3401905e:	e7f1      	b.n	34019044 <_realloc_r+0x40>

34019060 <swapfunc>:
34019060:	2b02      	cmp	r3, #2
34019062:	b510      	push	{r4, lr}
34019064:	d00a      	beq.n	3401907c <swapfunc+0x1c>
34019066:	0892      	lsrs	r2, r2, #2
34019068:	3a01      	subs	r2, #1
3401906a:	6803      	ldr	r3, [r0, #0]
3401906c:	680c      	ldr	r4, [r1, #0]
3401906e:	2a00      	cmp	r2, #0
34019070:	f840 4b04 	str.w	r4, [r0], #4
34019074:	f841 3b04 	str.w	r3, [r1], #4
34019078:	dcf6      	bgt.n	34019068 <swapfunc+0x8>
3401907a:	bd10      	pop	{r4, pc}
3401907c:	4402      	add	r2, r0
3401907e:	7803      	ldrb	r3, [r0, #0]
34019080:	780c      	ldrb	r4, [r1, #0]
34019082:	f800 4b01 	strb.w	r4, [r0], #1
34019086:	f801 3b01 	strb.w	r3, [r1], #1
3401908a:	1a13      	subs	r3, r2, r0
3401908c:	2b00      	cmp	r3, #0
3401908e:	dcf6      	bgt.n	3401907e <swapfunc+0x1e>
34019090:	e7f3      	b.n	3401907a <swapfunc+0x1a>

34019092 <med3.constprop.0>:
34019092:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34019094:	460f      	mov	r7, r1
34019096:	4616      	mov	r6, r2
34019098:	4604      	mov	r4, r0
3401909a:	461d      	mov	r5, r3
3401909c:	4798      	blx	r3
3401909e:	2800      	cmp	r0, #0
340190a0:	4631      	mov	r1, r6
340190a2:	4638      	mov	r0, r7
340190a4:	da0c      	bge.n	340190c0 <med3.constprop.0+0x2e>
340190a6:	47a8      	blx	r5
340190a8:	2800      	cmp	r0, #0
340190aa:	da02      	bge.n	340190b2 <med3.constprop.0+0x20>
340190ac:	463c      	mov	r4, r7
340190ae:	4620      	mov	r0, r4
340190b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
340190b2:	4631      	mov	r1, r6
340190b4:	4620      	mov	r0, r4
340190b6:	47a8      	blx	r5
340190b8:	2800      	cmp	r0, #0
340190ba:	daf8      	bge.n	340190ae <med3.constprop.0+0x1c>
340190bc:	4634      	mov	r4, r6
340190be:	e7f6      	b.n	340190ae <med3.constprop.0+0x1c>
340190c0:	47a8      	blx	r5
340190c2:	2800      	cmp	r0, #0
340190c4:	dcf2      	bgt.n	340190ac <med3.constprop.0+0x1a>
340190c6:	4631      	mov	r1, r6
340190c8:	4620      	mov	r0, r4
340190ca:	47a8      	blx	r5
340190cc:	2800      	cmp	r0, #0
340190ce:	daf5      	bge.n	340190bc <med3.constprop.0+0x2a>
340190d0:	e7ed      	b.n	340190ae <med3.constprop.0+0x1c>

340190d2 <qsort>:
340190d2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340190d6:	b095      	sub	sp, #84	@ 0x54
340190d8:	4607      	mov	r7, r0
340190da:	4615      	mov	r5, r2
340190dc:	9300      	str	r3, [sp, #0]
340190de:	ea40 0302 	orr.w	r3, r0, r2
340190e2:	079b      	lsls	r3, r3, #30
340190e4:	d119      	bne.n	3401911a <qsort+0x48>
340190e6:	f1b2 0804 	subs.w	r8, r2, #4
340190ea:	bf18      	it	ne
340190ec:	f04f 0801 	movne.w	r8, #1
340190f0:	2300      	movs	r3, #0
340190f2:	9301      	str	r3, [sp, #4]
340190f4:	fb05 f401 	mul.w	r4, r5, r1
340190f8:	2906      	cmp	r1, #6
340190fa:	eb07 0b05 	add.w	fp, r7, r5
340190fe:	eb07 0304 	add.w	r3, r7, r4
34019102:	9302      	str	r3, [sp, #8]
34019104:	d828      	bhi.n	34019158 <qsort+0x86>
34019106:	9b02      	ldr	r3, [sp, #8]
34019108:	459b      	cmp	fp, r3
3401910a:	d310      	bcc.n	3401912e <qsort+0x5c>
3401910c:	9b01      	ldr	r3, [sp, #4]
3401910e:	2b00      	cmp	r3, #0
34019110:	f040 8117 	bne.w	34019342 <qsort+0x270>
34019114:	b015      	add	sp, #84	@ 0x54
34019116:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401911a:	f04f 0802 	mov.w	r8, #2
3401911e:	e7e7      	b.n	340190f0 <qsort+0x1e>
34019120:	4643      	mov	r3, r8
34019122:	462a      	mov	r2, r5
34019124:	4631      	mov	r1, r6
34019126:	4620      	mov	r0, r4
34019128:	f7ff ff9a 	bl	34019060 <swapfunc>
3401912c:	e00f      	b.n	3401914e <qsort+0x7c>
3401912e:	465c      	mov	r4, fp
34019130:	e00e      	b.n	34019150 <qsort+0x7e>
34019132:	1b66      	subs	r6, r4, r5
34019134:	4621      	mov	r1, r4
34019136:	9b00      	ldr	r3, [sp, #0]
34019138:	4630      	mov	r0, r6
3401913a:	4798      	blx	r3
3401913c:	2800      	cmp	r0, #0
3401913e:	dd09      	ble.n	34019154 <qsort+0x82>
34019140:	f1b8 0f00 	cmp.w	r8, #0
34019144:	d1ec      	bne.n	34019120 <qsort+0x4e>
34019146:	6823      	ldr	r3, [r4, #0]
34019148:	6832      	ldr	r2, [r6, #0]
3401914a:	6022      	str	r2, [r4, #0]
3401914c:	6033      	str	r3, [r6, #0]
3401914e:	4634      	mov	r4, r6
34019150:	42a7      	cmp	r7, r4
34019152:	d3ee      	bcc.n	34019132 <qsort+0x60>
34019154:	44ab      	add	fp, r5
34019156:	e7d6      	b.n	34019106 <qsort+0x34>
34019158:	ea4f 0951 	mov.w	r9, r1, lsr #1
3401915c:	1b64      	subs	r4, r4, r5
3401915e:	2907      	cmp	r1, #7
34019160:	fb05 7909 	mla	r9, r5, r9, r7
34019164:	443c      	add	r4, r7
34019166:	d021      	beq.n	340191ac <qsort+0xda>
34019168:	2928      	cmp	r1, #40	@ 0x28
3401916a:	d944      	bls.n	340191f6 <qsort+0x124>
3401916c:	08ce      	lsrs	r6, r1, #3
3401916e:	9b00      	ldr	r3, [sp, #0]
34019170:	4638      	mov	r0, r7
34019172:	436e      	muls	r6, r5
34019174:	eb07 0246 	add.w	r2, r7, r6, lsl #1
34019178:	19b9      	adds	r1, r7, r6
3401917a:	f7ff ff8a 	bl	34019092 <med3.constprop.0>
3401917e:	4649      	mov	r1, r9
34019180:	eb09 0206 	add.w	r2, r9, r6
34019184:	9b00      	ldr	r3, [sp, #0]
34019186:	4682      	mov	sl, r0
34019188:	1b88      	subs	r0, r1, r6
3401918a:	f7ff ff82 	bl	34019092 <med3.constprop.0>
3401918e:	4622      	mov	r2, r4
34019190:	4681      	mov	r9, r0
34019192:	9b00      	ldr	r3, [sp, #0]
34019194:	1ba1      	subs	r1, r4, r6
34019196:	eba4 0046 	sub.w	r0, r4, r6, lsl #1
3401919a:	f7ff ff7a 	bl	34019092 <med3.constprop.0>
3401919e:	4602      	mov	r2, r0
340191a0:	4649      	mov	r1, r9
340191a2:	9b00      	ldr	r3, [sp, #0]
340191a4:	4650      	mov	r0, sl
340191a6:	f7ff ff74 	bl	34019092 <med3.constprop.0>
340191aa:	4681      	mov	r9, r0
340191ac:	f1b8 0f00 	cmp.w	r8, #0
340191b0:	d124      	bne.n	340191fc <qsort+0x12a>
340191b2:	683b      	ldr	r3, [r7, #0]
340191b4:	f8d9 2000 	ldr.w	r2, [r9]
340191b8:	603a      	str	r2, [r7, #0]
340191ba:	f8c9 3000 	str.w	r3, [r9]
340191be:	46d9      	mov	r9, fp
340191c0:	46a2      	mov	sl, r4
340191c2:	465e      	mov	r6, fp
340191c4:	2300      	movs	r3, #0
340191c6:	45a1      	cmp	r9, r4
340191c8:	d836      	bhi.n	34019238 <qsort+0x166>
340191ca:	9303      	str	r3, [sp, #12]
340191cc:	4639      	mov	r1, r7
340191ce:	9b00      	ldr	r3, [sp, #0]
340191d0:	4648      	mov	r0, r9
340191d2:	4798      	blx	r3
340191d4:	2800      	cmp	r0, #0
340191d6:	9b03      	ldr	r3, [sp, #12]
340191d8:	dc2c      	bgt.n	34019234 <qsort+0x162>
340191da:	d10a      	bne.n	340191f2 <qsort+0x120>
340191dc:	f1b8 0f00 	cmp.w	r8, #0
340191e0:	d113      	bne.n	3401920a <qsort+0x138>
340191e2:	6833      	ldr	r3, [r6, #0]
340191e4:	f8d9 2000 	ldr.w	r2, [r9]
340191e8:	6032      	str	r2, [r6, #0]
340191ea:	f8c9 3000 	str.w	r3, [r9]
340191ee:	442e      	add	r6, r5
340191f0:	2301      	movs	r3, #1
340191f2:	44a9      	add	r9, r5
340191f4:	e7e7      	b.n	340191c6 <qsort+0xf4>
340191f6:	4622      	mov	r2, r4
340191f8:	46ba      	mov	sl, r7
340191fa:	e7d1      	b.n	340191a0 <qsort+0xce>
340191fc:	4643      	mov	r3, r8
340191fe:	462a      	mov	r2, r5
34019200:	4649      	mov	r1, r9
34019202:	4638      	mov	r0, r7
34019204:	f7ff ff2c 	bl	34019060 <swapfunc>
34019208:	e7d9      	b.n	340191be <qsort+0xec>
3401920a:	4643      	mov	r3, r8
3401920c:	462a      	mov	r2, r5
3401920e:	4649      	mov	r1, r9
34019210:	4630      	mov	r0, r6
34019212:	f7ff ff25 	bl	34019060 <swapfunc>
34019216:	e7ea      	b.n	340191ee <qsort+0x11c>
34019218:	d10b      	bne.n	34019232 <qsort+0x160>
3401921a:	f1b8 0f00 	cmp.w	r8, #0
3401921e:	d113      	bne.n	34019248 <qsort+0x176>
34019220:	6823      	ldr	r3, [r4, #0]
34019222:	f8da 2000 	ldr.w	r2, [sl]
34019226:	6022      	str	r2, [r4, #0]
34019228:	f8ca 3000 	str.w	r3, [sl]
3401922c:	ebaa 0a05 	sub.w	sl, sl, r5
34019230:	2301      	movs	r3, #1
34019232:	1b64      	subs	r4, r4, r5
34019234:	45a1      	cmp	r9, r4
34019236:	d90e      	bls.n	34019256 <qsort+0x184>
34019238:	2b00      	cmp	r3, #0
3401923a:	d140      	bne.n	340192be <qsort+0x1ec>
3401923c:	9b02      	ldr	r3, [sp, #8]
3401923e:	459b      	cmp	fp, r3
34019240:	f4bf af64 	bcs.w	3401910c <qsort+0x3a>
34019244:	465c      	mov	r4, fp
34019246:	e036      	b.n	340192b6 <qsort+0x1e4>
34019248:	4643      	mov	r3, r8
3401924a:	462a      	mov	r2, r5
3401924c:	4651      	mov	r1, sl
3401924e:	4620      	mov	r0, r4
34019250:	f7ff ff06 	bl	34019060 <swapfunc>
34019254:	e7ea      	b.n	3401922c <qsort+0x15a>
34019256:	9303      	str	r3, [sp, #12]
34019258:	4639      	mov	r1, r7
3401925a:	9b00      	ldr	r3, [sp, #0]
3401925c:	4620      	mov	r0, r4
3401925e:	4798      	blx	r3
34019260:	2800      	cmp	r0, #0
34019262:	9b03      	ldr	r3, [sp, #12]
34019264:	dad8      	bge.n	34019218 <qsort+0x146>
34019266:	f1b8 0f00 	cmp.w	r8, #0
3401926a:	d107      	bne.n	3401927c <qsort+0x1aa>
3401926c:	f8d9 3000 	ldr.w	r3, [r9]
34019270:	6822      	ldr	r2, [r4, #0]
34019272:	f8c9 2000 	str.w	r2, [r9]
34019276:	6023      	str	r3, [r4, #0]
34019278:	1b64      	subs	r4, r4, r5
3401927a:	e7b9      	b.n	340191f0 <qsort+0x11e>
3401927c:	4643      	mov	r3, r8
3401927e:	462a      	mov	r2, r5
34019280:	4621      	mov	r1, r4
34019282:	4648      	mov	r0, r9
34019284:	f7ff feec 	bl	34019060 <swapfunc>
34019288:	e7f6      	b.n	34019278 <qsort+0x1a6>
3401928a:	4643      	mov	r3, r8
3401928c:	462a      	mov	r2, r5
3401928e:	4631      	mov	r1, r6
34019290:	4620      	mov	r0, r4
34019292:	f7ff fee5 	bl	34019060 <swapfunc>
34019296:	e00d      	b.n	340192b4 <qsort+0x1e2>
34019298:	1b66      	subs	r6, r4, r5
3401929a:	4621      	mov	r1, r4
3401929c:	9b00      	ldr	r3, [sp, #0]
3401929e:	4630      	mov	r0, r6
340192a0:	4798      	blx	r3
340192a2:	2800      	cmp	r0, #0
340192a4:	dd09      	ble.n	340192ba <qsort+0x1e8>
340192a6:	f1b8 0f00 	cmp.w	r8, #0
340192aa:	d1ee      	bne.n	3401928a <qsort+0x1b8>
340192ac:	6823      	ldr	r3, [r4, #0]
340192ae:	6832      	ldr	r2, [r6, #0]
340192b0:	6022      	str	r2, [r4, #0]
340192b2:	6033      	str	r3, [r6, #0]
340192b4:	4634      	mov	r4, r6
340192b6:	42a7      	cmp	r7, r4
340192b8:	d3ee      	bcc.n	34019298 <qsort+0x1c6>
340192ba:	44ab      	add	fp, r5
340192bc:	e7be      	b.n	3401923c <qsort+0x16a>
340192be:	eba9 0b06 	sub.w	fp, r9, r6
340192c2:	1bf2      	subs	r2, r6, r7
340192c4:	455a      	cmp	r2, fp
340192c6:	bfa8      	it	ge
340192c8:	465a      	movge	r2, fp
340192ca:	b12a      	cbz	r2, 340192d8 <qsort+0x206>
340192cc:	4643      	mov	r3, r8
340192ce:	eba9 0102 	sub.w	r1, r9, r2
340192d2:	4638      	mov	r0, r7
340192d4:	f7ff fec4 	bl	34019060 <swapfunc>
340192d8:	9b02      	ldr	r3, [sp, #8]
340192da:	ebaa 0404 	sub.w	r4, sl, r4
340192de:	eba3 020a 	sub.w	r2, r3, sl
340192e2:	1b52      	subs	r2, r2, r5
340192e4:	42a2      	cmp	r2, r4
340192e6:	bf28      	it	cs
340192e8:	4622      	movcs	r2, r4
340192ea:	b12a      	cbz	r2, 340192f8 <qsort+0x226>
340192ec:	9902      	ldr	r1, [sp, #8]
340192ee:	4643      	mov	r3, r8
340192f0:	4648      	mov	r0, r9
340192f2:	1a89      	subs	r1, r1, r2
340192f4:	f7ff feb4 	bl	34019060 <swapfunc>
340192f8:	9b02      	ldr	r3, [sp, #8]
340192fa:	455c      	cmp	r4, fp
340192fc:	eba3 0604 	sub.w	r6, r3, r4
34019300:	d805      	bhi.n	3401930e <qsort+0x23c>
34019302:	4623      	mov	r3, r4
34019304:	465c      	mov	r4, fp
34019306:	469b      	mov	fp, r3
34019308:	4633      	mov	r3, r6
3401930a:	463e      	mov	r6, r7
3401930c:	461f      	mov	r7, r3
3401930e:	45ab      	cmp	fp, r5
34019310:	d920      	bls.n	34019354 <qsort+0x282>
34019312:	9b01      	ldr	r3, [sp, #4]
34019314:	2b07      	cmp	r3, #7
34019316:	fbbb f1f5 	udiv	r1, fp, r5
3401931a:	d80b      	bhi.n	34019334 <qsort+0x262>
3401931c:	aa14      	add	r2, sp, #80	@ 0x50
3401931e:	fbb4 f4f5 	udiv	r4, r4, r5
34019322:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
34019326:	f843 6c40 	str.w	r6, [r3, #-64]
3401932a:	f843 4c3c 	str.w	r4, [r3, #-60]
3401932e:	9b01      	ldr	r3, [sp, #4]
34019330:	3301      	adds	r3, #1
34019332:	e6de      	b.n	340190f2 <qsort+0x20>
34019334:	9b00      	ldr	r3, [sp, #0]
34019336:	462a      	mov	r2, r5
34019338:	4638      	mov	r0, r7
3401933a:	f7ff feca 	bl	340190d2 <qsort>
3401933e:	42ac      	cmp	r4, r5
34019340:	d80b      	bhi.n	3401935a <qsort+0x288>
34019342:	9b01      	ldr	r3, [sp, #4]
34019344:	aa14      	add	r2, sp, #80	@ 0x50
34019346:	3b01      	subs	r3, #1
34019348:	9301      	str	r3, [sp, #4]
3401934a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
3401934e:	e953 7110 	ldrd	r7, r1, [r3, #-64]	@ 0x40
34019352:	e6cf      	b.n	340190f4 <qsort+0x22>
34019354:	42ac      	cmp	r4, r5
34019356:	f67f aed9 	bls.w	3401910c <qsort+0x3a>
3401935a:	4637      	mov	r7, r6
3401935c:	fbb4 f1f5 	udiv	r1, r4, r5
34019360:	e6c8      	b.n	340190f4 <qsort+0x22>

34019362 <__cvt>:
34019362:	b5f0      	push	{r4, r5, r6, r7, lr}
34019364:	ed2d 8b02 	vpush	{d8}
34019368:	eeb0 8b40 	vmov.f64	d8, d0
3401936c:	b085      	sub	sp, #20
3401936e:	4617      	mov	r7, r2
34019370:	460c      	mov	r4, r1
34019372:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
34019374:	ee18 2a90 	vmov	r2, s17
34019378:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
3401937a:	f025 0520 	bic.w	r5, r5, #32
3401937e:	2a00      	cmp	r2, #0
34019380:	bfb6      	itet	lt
34019382:	222d      	movlt	r2, #45	@ 0x2d
34019384:	2200      	movge	r2, #0
34019386:	eeb1 8b40 	vneglt.f64	d8, d0
3401938a:	2d46      	cmp	r5, #70	@ 0x46
3401938c:	701a      	strb	r2, [r3, #0]
3401938e:	d004      	beq.n	3401939a <__cvt+0x38>
34019390:	2d45      	cmp	r5, #69	@ 0x45
34019392:	d100      	bne.n	34019396 <__cvt+0x34>
34019394:	3401      	adds	r4, #1
34019396:	2102      	movs	r1, #2
34019398:	e000      	b.n	3401939c <__cvt+0x3a>
3401939a:	2103      	movs	r1, #3
3401939c:	ab03      	add	r3, sp, #12
3401939e:	eeb0 0b48 	vmov.f64	d0, d8
340193a2:	4622      	mov	r2, r4
340193a4:	9301      	str	r3, [sp, #4]
340193a6:	ab02      	add	r3, sp, #8
340193a8:	9300      	str	r3, [sp, #0]
340193aa:	4633      	mov	r3, r6
340193ac:	f001 f9f4 	bl	3401a798 <_dtoa_r>
340193b0:	2d47      	cmp	r5, #71	@ 0x47
340193b2:	d114      	bne.n	340193de <__cvt+0x7c>
340193b4:	07fb      	lsls	r3, r7, #31
340193b6:	d50a      	bpl.n	340193ce <__cvt+0x6c>
340193b8:	1902      	adds	r2, r0, r4
340193ba:	eeb5 8b40 	vcmp.f64	d8, #0.0
340193be:	2130      	movs	r1, #48	@ 0x30
340193c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340193c4:	bf08      	it	eq
340193c6:	9203      	streq	r2, [sp, #12]
340193c8:	9b03      	ldr	r3, [sp, #12]
340193ca:	4293      	cmp	r3, r2
340193cc:	d319      	bcc.n	34019402 <__cvt+0xa0>
340193ce:	9b03      	ldr	r3, [sp, #12]
340193d0:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
340193d2:	1a1b      	subs	r3, r3, r0
340193d4:	6013      	str	r3, [r2, #0]
340193d6:	b005      	add	sp, #20
340193d8:	ecbd 8b02 	vpop	{d8}
340193dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
340193de:	2d46      	cmp	r5, #70	@ 0x46
340193e0:	eb00 0204 	add.w	r2, r0, r4
340193e4:	d1e9      	bne.n	340193ba <__cvt+0x58>
340193e6:	7803      	ldrb	r3, [r0, #0]
340193e8:	2b30      	cmp	r3, #48	@ 0x30
340193ea:	d107      	bne.n	340193fc <__cvt+0x9a>
340193ec:	eeb5 8b40 	vcmp.f64	d8, #0.0
340193f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340193f4:	bf1c      	itt	ne
340193f6:	f1c4 0401 	rsbne	r4, r4, #1
340193fa:	6034      	strne	r4, [r6, #0]
340193fc:	6833      	ldr	r3, [r6, #0]
340193fe:	441a      	add	r2, r3
34019400:	e7db      	b.n	340193ba <__cvt+0x58>
34019402:	1c5c      	adds	r4, r3, #1
34019404:	9403      	str	r4, [sp, #12]
34019406:	7019      	strb	r1, [r3, #0]
34019408:	e7de      	b.n	340193c8 <__cvt+0x66>

3401940a <__exponent>:
3401940a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3401940c:	2900      	cmp	r1, #0
3401940e:	7002      	strb	r2, [r0, #0]
34019410:	bfba      	itte	lt
34019412:	4249      	neglt	r1, r1
34019414:	232d      	movlt	r3, #45	@ 0x2d
34019416:	232b      	movge	r3, #43	@ 0x2b
34019418:	2909      	cmp	r1, #9
3401941a:	7043      	strb	r3, [r0, #1]
3401941c:	dd28      	ble.n	34019470 <__exponent+0x66>
3401941e:	f10d 0307 	add.w	r3, sp, #7
34019422:	270a      	movs	r7, #10
34019424:	461d      	mov	r5, r3
34019426:	461a      	mov	r2, r3
34019428:	3b01      	subs	r3, #1
3401942a:	fbb1 f6f7 	udiv	r6, r1, r7
3401942e:	fb07 1416 	mls	r4, r7, r6, r1
34019432:	3430      	adds	r4, #48	@ 0x30
34019434:	f802 4c01 	strb.w	r4, [r2, #-1]
34019438:	460c      	mov	r4, r1
3401943a:	4631      	mov	r1, r6
3401943c:	2c63      	cmp	r4, #99	@ 0x63
3401943e:	dcf2      	bgt.n	34019426 <__exponent+0x1c>
34019440:	3130      	adds	r1, #48	@ 0x30
34019442:	1e94      	subs	r4, r2, #2
34019444:	f803 1c01 	strb.w	r1, [r3, #-1]
34019448:	1c41      	adds	r1, r0, #1
3401944a:	4623      	mov	r3, r4
3401944c:	42ab      	cmp	r3, r5
3401944e:	d30a      	bcc.n	34019466 <__exponent+0x5c>
34019450:	f10d 0309 	add.w	r3, sp, #9
34019454:	1a9b      	subs	r3, r3, r2
34019456:	42ac      	cmp	r4, r5
34019458:	bf88      	it	hi
3401945a:	2300      	movhi	r3, #0
3401945c:	3302      	adds	r3, #2
3401945e:	4403      	add	r3, r0
34019460:	1a18      	subs	r0, r3, r0
34019462:	b003      	add	sp, #12
34019464:	bdf0      	pop	{r4, r5, r6, r7, pc}
34019466:	f813 6b01 	ldrb.w	r6, [r3], #1
3401946a:	f801 6f01 	strb.w	r6, [r1, #1]!
3401946e:	e7ed      	b.n	3401944c <__exponent+0x42>
34019470:	2330      	movs	r3, #48	@ 0x30
34019472:	3130      	adds	r1, #48	@ 0x30
34019474:	7083      	strb	r3, [r0, #2]
34019476:	1d03      	adds	r3, r0, #4
34019478:	70c1      	strb	r1, [r0, #3]
3401947a:	e7f1      	b.n	34019460 <__exponent+0x56>
3401947c:	0000      	movs	r0, r0
	...

34019480 <_printf_float>:
34019480:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34019484:	b08d      	sub	sp, #52	@ 0x34
34019486:	460c      	mov	r4, r1
34019488:	4616      	mov	r6, r2
3401948a:	461f      	mov	r7, r3
3401948c:	f8dd 8058 	ldr.w	r8, [sp, #88]	@ 0x58
34019490:	4605      	mov	r5, r0
34019492:	f001 f841 	bl	3401a518 <_localeconv_r>
34019496:	f8d0 b000 	ldr.w	fp, [r0]
3401949a:	4658      	mov	r0, fp
3401949c:	f7e8 f94e 	bl	3400173c <strlen>
340194a0:	2300      	movs	r3, #0
340194a2:	f894 9018 	ldrb.w	r9, [r4, #24]
340194a6:	930a      	str	r3, [sp, #40]	@ 0x28
340194a8:	f8d8 3000 	ldr.w	r3, [r8]
340194ac:	6822      	ldr	r2, [r4, #0]
340194ae:	3307      	adds	r3, #7
340194b0:	9005      	str	r0, [sp, #20]
340194b2:	f023 0307 	bic.w	r3, r3, #7
340194b6:	f103 0108 	add.w	r1, r3, #8
340194ba:	f8c8 1000 	str.w	r1, [r8]
340194be:	ed93 0b00 	vldr	d0, [r3]
340194c2:	ed9f 6b97 	vldr	d6, [pc, #604]	@ 34019720 <_printf_float+0x2a0>
340194c6:	eeb0 7bc0 	vabs.f64	d7, d0
340194ca:	ed84 0b12 	vstr	d0, [r4, #72]	@ 0x48
340194ce:	eeb4 7b46 	vcmp.f64	d7, d6
340194d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340194d6:	dd24      	ble.n	34019522 <_printf_float+0xa2>
340194d8:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
340194dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340194e0:	d502      	bpl.n	340194e8 <_printf_float+0x68>
340194e2:	232d      	movs	r3, #45	@ 0x2d
340194e4:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
340194e8:	498f      	ldr	r1, [pc, #572]	@ (34019728 <_printf_float+0x2a8>)
340194ea:	4b90      	ldr	r3, [pc, #576]	@ (3401972c <_printf_float+0x2ac>)
340194ec:	f1b9 0f47 	cmp.w	r9, #71	@ 0x47
340194f0:	bf8c      	ite	hi
340194f2:	4688      	movhi	r8, r1
340194f4:	4698      	movls	r8, r3
340194f6:	f022 0204 	bic.w	r2, r2, #4
340194fa:	2303      	movs	r3, #3
340194fc:	f04f 0a00 	mov.w	sl, #0
34019500:	6022      	str	r2, [r4, #0]
34019502:	6123      	str	r3, [r4, #16]
34019504:	4633      	mov	r3, r6
34019506:	aa0b      	add	r2, sp, #44	@ 0x2c
34019508:	4621      	mov	r1, r4
3401950a:	4628      	mov	r0, r5
3401950c:	9700      	str	r7, [sp, #0]
3401950e:	f000 f9d1 	bl	340198b4 <_printf_common>
34019512:	3001      	adds	r0, #1
34019514:	f040 8089 	bne.w	3401962a <_printf_float+0x1aa>
34019518:	f04f 30ff 	mov.w	r0, #4294967295
3401951c:	b00d      	add	sp, #52	@ 0x34
3401951e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34019522:	eeb4 0b40 	vcmp.f64	d0, d0
34019526:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401952a:	d709      	bvc.n	34019540 <_printf_float+0xc0>
3401952c:	ee10 3a90 	vmov	r3, s1
34019530:	497f      	ldr	r1, [pc, #508]	@ (34019730 <_printf_float+0x2b0>)
34019532:	2b00      	cmp	r3, #0
34019534:	bfbc      	itt	lt
34019536:	232d      	movlt	r3, #45	@ 0x2d
34019538:	f884 3043 	strblt.w	r3, [r4, #67]	@ 0x43
3401953c:	4b7d      	ldr	r3, [pc, #500]	@ (34019734 <_printf_float+0x2b4>)
3401953e:	e7d5      	b.n	340194ec <_printf_float+0x6c>
34019540:	6863      	ldr	r3, [r4, #4]
34019542:	f009 0adf 	and.w	sl, r9, #223	@ 0xdf
34019546:	1c59      	adds	r1, r3, #1
34019548:	d139      	bne.n	340195be <_printf_float+0x13e>
3401954a:	2306      	movs	r3, #6
3401954c:	6063      	str	r3, [r4, #4]
3401954e:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
34019552:	2300      	movs	r3, #0
34019554:	4628      	mov	r0, r5
34019556:	6022      	str	r2, [r4, #0]
34019558:	9303      	str	r3, [sp, #12]
3401955a:	ab0a      	add	r3, sp, #40	@ 0x28
3401955c:	e9cd 9301 	strd	r9, r3, [sp, #4]
34019560:	ab09      	add	r3, sp, #36	@ 0x24
34019562:	9300      	str	r3, [sp, #0]
34019564:	f10d 0323 	add.w	r3, sp, #35	@ 0x23
34019568:	6861      	ldr	r1, [r4, #4]
3401956a:	f7ff fefa 	bl	34019362 <__cvt>
3401956e:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
34019572:	4680      	mov	r8, r0
34019574:	9909      	ldr	r1, [sp, #36]	@ 0x24
34019576:	d129      	bne.n	340195cc <_printf_float+0x14c>
34019578:	1cc8      	adds	r0, r1, #3
3401957a:	db02      	blt.n	34019582 <_printf_float+0x102>
3401957c:	6863      	ldr	r3, [r4, #4]
3401957e:	4299      	cmp	r1, r3
34019580:	dd41      	ble.n	34019606 <_printf_float+0x186>
34019582:	f1a9 0902 	sub.w	r9, r9, #2
34019586:	fa5f f989 	uxtb.w	r9, r9
3401958a:	3901      	subs	r1, #1
3401958c:	464a      	mov	r2, r9
3401958e:	f104 0050 	add.w	r0, r4, #80	@ 0x50
34019592:	9109      	str	r1, [sp, #36]	@ 0x24
34019594:	f7ff ff39 	bl	3401940a <__exponent>
34019598:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
3401959a:	4682      	mov	sl, r0
3401959c:	1813      	adds	r3, r2, r0
3401959e:	2a01      	cmp	r2, #1
340195a0:	6123      	str	r3, [r4, #16]
340195a2:	dc02      	bgt.n	340195aa <_printf_float+0x12a>
340195a4:	6822      	ldr	r2, [r4, #0]
340195a6:	07d2      	lsls	r2, r2, #31
340195a8:	d501      	bpl.n	340195ae <_printf_float+0x12e>
340195aa:	3301      	adds	r3, #1
340195ac:	6123      	str	r3, [r4, #16]
340195ae:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
340195b2:	2b00      	cmp	r3, #0
340195b4:	d0a6      	beq.n	34019504 <_printf_float+0x84>
340195b6:	232d      	movs	r3, #45	@ 0x2d
340195b8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
340195bc:	e7a2      	b.n	34019504 <_printf_float+0x84>
340195be:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
340195c2:	d1c4      	bne.n	3401954e <_printf_float+0xce>
340195c4:	2b00      	cmp	r3, #0
340195c6:	d1c2      	bne.n	3401954e <_printf_float+0xce>
340195c8:	2301      	movs	r3, #1
340195ca:	e7bf      	b.n	3401954c <_printf_float+0xcc>
340195cc:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
340195d0:	d9db      	bls.n	3401958a <_printf_float+0x10a>
340195d2:	f1b9 0f66 	cmp.w	r9, #102	@ 0x66
340195d6:	d118      	bne.n	3401960a <_printf_float+0x18a>
340195d8:	2900      	cmp	r1, #0
340195da:	6863      	ldr	r3, [r4, #4]
340195dc:	dd0b      	ble.n	340195f6 <_printf_float+0x176>
340195de:	6121      	str	r1, [r4, #16]
340195e0:	b913      	cbnz	r3, 340195e8 <_printf_float+0x168>
340195e2:	6822      	ldr	r2, [r4, #0]
340195e4:	07d0      	lsls	r0, r2, #31
340195e6:	d502      	bpl.n	340195ee <_printf_float+0x16e>
340195e8:	3301      	adds	r3, #1
340195ea:	440b      	add	r3, r1
340195ec:	6123      	str	r3, [r4, #16]
340195ee:	f04f 0a00 	mov.w	sl, #0
340195f2:	65a1      	str	r1, [r4, #88]	@ 0x58
340195f4:	e7db      	b.n	340195ae <_printf_float+0x12e>
340195f6:	b913      	cbnz	r3, 340195fe <_printf_float+0x17e>
340195f8:	6822      	ldr	r2, [r4, #0]
340195fa:	07d2      	lsls	r2, r2, #31
340195fc:	d501      	bpl.n	34019602 <_printf_float+0x182>
340195fe:	3302      	adds	r3, #2
34019600:	e7f4      	b.n	340195ec <_printf_float+0x16c>
34019602:	2301      	movs	r3, #1
34019604:	e7f2      	b.n	340195ec <_printf_float+0x16c>
34019606:	f04f 0967 	mov.w	r9, #103	@ 0x67
3401960a:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3401960c:	4299      	cmp	r1, r3
3401960e:	db05      	blt.n	3401961c <_printf_float+0x19c>
34019610:	6823      	ldr	r3, [r4, #0]
34019612:	6121      	str	r1, [r4, #16]
34019614:	07d8      	lsls	r0, r3, #31
34019616:	d5ea      	bpl.n	340195ee <_printf_float+0x16e>
34019618:	1c4b      	adds	r3, r1, #1
3401961a:	e7e7      	b.n	340195ec <_printf_float+0x16c>
3401961c:	2900      	cmp	r1, #0
3401961e:	bfd4      	ite	le
34019620:	f1c1 0202 	rsble	r2, r1, #2
34019624:	2201      	movgt	r2, #1
34019626:	4413      	add	r3, r2
34019628:	e7e0      	b.n	340195ec <_printf_float+0x16c>
3401962a:	6823      	ldr	r3, [r4, #0]
3401962c:	055a      	lsls	r2, r3, #21
3401962e:	d407      	bmi.n	34019640 <_printf_float+0x1c0>
34019630:	6923      	ldr	r3, [r4, #16]
34019632:	4642      	mov	r2, r8
34019634:	4631      	mov	r1, r6
34019636:	4628      	mov	r0, r5
34019638:	47b8      	blx	r7
3401963a:	3001      	adds	r0, #1
3401963c:	d12a      	bne.n	34019694 <_printf_float+0x214>
3401963e:	e76b      	b.n	34019518 <_printf_float+0x98>
34019640:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
34019644:	f240 80e0 	bls.w	34019808 <_printf_float+0x388>
34019648:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
3401964c:	eeb5 7b40 	vcmp.f64	d7, #0.0
34019650:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019654:	d133      	bne.n	340196be <_printf_float+0x23e>
34019656:	2301      	movs	r3, #1
34019658:	4a37      	ldr	r2, [pc, #220]	@ (34019738 <_printf_float+0x2b8>)
3401965a:	4631      	mov	r1, r6
3401965c:	4628      	mov	r0, r5
3401965e:	47b8      	blx	r7
34019660:	3001      	adds	r0, #1
34019662:	f43f af59 	beq.w	34019518 <_printf_float+0x98>
34019666:	e9dd 3809 	ldrd	r3, r8, [sp, #36]	@ 0x24
3401966a:	4543      	cmp	r3, r8
3401966c:	db02      	blt.n	34019674 <_printf_float+0x1f4>
3401966e:	6823      	ldr	r3, [r4, #0]
34019670:	07d8      	lsls	r0, r3, #31
34019672:	d50f      	bpl.n	34019694 <_printf_float+0x214>
34019674:	9b05      	ldr	r3, [sp, #20]
34019676:	465a      	mov	r2, fp
34019678:	4631      	mov	r1, r6
3401967a:	4628      	mov	r0, r5
3401967c:	47b8      	blx	r7
3401967e:	3001      	adds	r0, #1
34019680:	f43f af4a 	beq.w	34019518 <_printf_float+0x98>
34019684:	f04f 0900 	mov.w	r9, #0
34019688:	f108 38ff 	add.w	r8, r8, #4294967295
3401968c:	f104 0a1a 	add.w	sl, r4, #26
34019690:	45c8      	cmp	r8, r9
34019692:	dc09      	bgt.n	340196a8 <_printf_float+0x228>
34019694:	6823      	ldr	r3, [r4, #0]
34019696:	079b      	lsls	r3, r3, #30
34019698:	f100 8107 	bmi.w	340198aa <_printf_float+0x42a>
3401969c:	68e0      	ldr	r0, [r4, #12]
3401969e:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
340196a0:	4298      	cmp	r0, r3
340196a2:	bfb8      	it	lt
340196a4:	4618      	movlt	r0, r3
340196a6:	e739      	b.n	3401951c <_printf_float+0x9c>
340196a8:	2301      	movs	r3, #1
340196aa:	4652      	mov	r2, sl
340196ac:	4631      	mov	r1, r6
340196ae:	4628      	mov	r0, r5
340196b0:	47b8      	blx	r7
340196b2:	3001      	adds	r0, #1
340196b4:	f43f af30 	beq.w	34019518 <_printf_float+0x98>
340196b8:	f109 0901 	add.w	r9, r9, #1
340196bc:	e7e8      	b.n	34019690 <_printf_float+0x210>
340196be:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340196c0:	2b00      	cmp	r3, #0
340196c2:	dc3b      	bgt.n	3401973c <_printf_float+0x2bc>
340196c4:	2301      	movs	r3, #1
340196c6:	4a1c      	ldr	r2, [pc, #112]	@ (34019738 <_printf_float+0x2b8>)
340196c8:	4631      	mov	r1, r6
340196ca:	4628      	mov	r0, r5
340196cc:	47b8      	blx	r7
340196ce:	3001      	adds	r0, #1
340196d0:	f43f af22 	beq.w	34019518 <_printf_float+0x98>
340196d4:	e9dd 3909 	ldrd	r3, r9, [sp, #36]	@ 0x24
340196d8:	ea59 0303 	orrs.w	r3, r9, r3
340196dc:	d102      	bne.n	340196e4 <_printf_float+0x264>
340196de:	6823      	ldr	r3, [r4, #0]
340196e0:	07d9      	lsls	r1, r3, #31
340196e2:	d5d7      	bpl.n	34019694 <_printf_float+0x214>
340196e4:	9b05      	ldr	r3, [sp, #20]
340196e6:	465a      	mov	r2, fp
340196e8:	4631      	mov	r1, r6
340196ea:	4628      	mov	r0, r5
340196ec:	47b8      	blx	r7
340196ee:	3001      	adds	r0, #1
340196f0:	f43f af12 	beq.w	34019518 <_printf_float+0x98>
340196f4:	f04f 0a00 	mov.w	sl, #0
340196f8:	f104 0b1a 	add.w	fp, r4, #26
340196fc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340196fe:	425b      	negs	r3, r3
34019700:	4553      	cmp	r3, sl
34019702:	dc01      	bgt.n	34019708 <_printf_float+0x288>
34019704:	464b      	mov	r3, r9
34019706:	e794      	b.n	34019632 <_printf_float+0x1b2>
34019708:	2301      	movs	r3, #1
3401970a:	465a      	mov	r2, fp
3401970c:	4631      	mov	r1, r6
3401970e:	4628      	mov	r0, r5
34019710:	47b8      	blx	r7
34019712:	3001      	adds	r0, #1
34019714:	f43f af00 	beq.w	34019518 <_printf_float+0x98>
34019718:	f10a 0a01 	add.w	sl, sl, #1
3401971c:	e7ee      	b.n	340196fc <_printf_float+0x27c>
3401971e:	bf00      	nop
34019720:	ffffffff 	.word	0xffffffff
34019724:	7fefffff 	.word	0x7fefffff
34019728:	3402262a 	.word	0x3402262a
3401972c:	34022626 	.word	0x34022626
34019730:	34022632 	.word	0x34022632
34019734:	3402262e 	.word	0x3402262e
34019738:	340217f8 	.word	0x340217f8
3401973c:	6da3      	ldr	r3, [r4, #88]	@ 0x58
3401973e:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
34019742:	4553      	cmp	r3, sl
34019744:	bfa8      	it	ge
34019746:	4653      	movge	r3, sl
34019748:	2b00      	cmp	r3, #0
3401974a:	4699      	mov	r9, r3
3401974c:	dc37      	bgt.n	340197be <_printf_float+0x33e>
3401974e:	2300      	movs	r3, #0
34019750:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
34019754:	f104 021a 	add.w	r2, r4, #26
34019758:	9307      	str	r3, [sp, #28]
3401975a:	6da3      	ldr	r3, [r4, #88]	@ 0x58
3401975c:	9907      	ldr	r1, [sp, #28]
3401975e:	9306      	str	r3, [sp, #24]
34019760:	eba3 0309 	sub.w	r3, r3, r9
34019764:	428b      	cmp	r3, r1
34019766:	dc31      	bgt.n	340197cc <_printf_float+0x34c>
34019768:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401976a:	459a      	cmp	sl, r3
3401976c:	dc3b      	bgt.n	340197e6 <_printf_float+0x366>
3401976e:	6823      	ldr	r3, [r4, #0]
34019770:	07da      	lsls	r2, r3, #31
34019772:	d438      	bmi.n	340197e6 <_printf_float+0x366>
34019774:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34019776:	ebaa 0903 	sub.w	r9, sl, r3
3401977a:	9b06      	ldr	r3, [sp, #24]
3401977c:	ebaa 0303 	sub.w	r3, sl, r3
34019780:	4599      	cmp	r9, r3
34019782:	bfa8      	it	ge
34019784:	4699      	movge	r9, r3
34019786:	f1b9 0f00 	cmp.w	r9, #0
3401978a:	dc34      	bgt.n	340197f6 <_printf_float+0x376>
3401978c:	f04f 0800 	mov.w	r8, #0
34019790:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
34019794:	f104 0b1a 	add.w	fp, r4, #26
34019798:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401979a:	ebaa 0303 	sub.w	r3, sl, r3
3401979e:	eba3 0309 	sub.w	r3, r3, r9
340197a2:	4543      	cmp	r3, r8
340197a4:	f77f af76 	ble.w	34019694 <_printf_float+0x214>
340197a8:	2301      	movs	r3, #1
340197aa:	465a      	mov	r2, fp
340197ac:	4631      	mov	r1, r6
340197ae:	4628      	mov	r0, r5
340197b0:	47b8      	blx	r7
340197b2:	3001      	adds	r0, #1
340197b4:	f43f aeb0 	beq.w	34019518 <_printf_float+0x98>
340197b8:	f108 0801 	add.w	r8, r8, #1
340197bc:	e7ec      	b.n	34019798 <_printf_float+0x318>
340197be:	4642      	mov	r2, r8
340197c0:	4631      	mov	r1, r6
340197c2:	4628      	mov	r0, r5
340197c4:	47b8      	blx	r7
340197c6:	3001      	adds	r0, #1
340197c8:	d1c1      	bne.n	3401974e <_printf_float+0x2ce>
340197ca:	e6a5      	b.n	34019518 <_printf_float+0x98>
340197cc:	2301      	movs	r3, #1
340197ce:	4631      	mov	r1, r6
340197d0:	4628      	mov	r0, r5
340197d2:	9206      	str	r2, [sp, #24]
340197d4:	47b8      	blx	r7
340197d6:	3001      	adds	r0, #1
340197d8:	f43f ae9e 	beq.w	34019518 <_printf_float+0x98>
340197dc:	9b07      	ldr	r3, [sp, #28]
340197de:	9a06      	ldr	r2, [sp, #24]
340197e0:	3301      	adds	r3, #1
340197e2:	9307      	str	r3, [sp, #28]
340197e4:	e7b9      	b.n	3401975a <_printf_float+0x2da>
340197e6:	9b05      	ldr	r3, [sp, #20]
340197e8:	465a      	mov	r2, fp
340197ea:	4631      	mov	r1, r6
340197ec:	4628      	mov	r0, r5
340197ee:	47b8      	blx	r7
340197f0:	3001      	adds	r0, #1
340197f2:	d1bf      	bne.n	34019774 <_printf_float+0x2f4>
340197f4:	e690      	b.n	34019518 <_printf_float+0x98>
340197f6:	9a06      	ldr	r2, [sp, #24]
340197f8:	464b      	mov	r3, r9
340197fa:	4631      	mov	r1, r6
340197fc:	4628      	mov	r0, r5
340197fe:	4442      	add	r2, r8
34019800:	47b8      	blx	r7
34019802:	3001      	adds	r0, #1
34019804:	d1c2      	bne.n	3401978c <_printf_float+0x30c>
34019806:	e687      	b.n	34019518 <_printf_float+0x98>
34019808:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
3401980c:	f1b9 0f01 	cmp.w	r9, #1
34019810:	dc01      	bgt.n	34019816 <_printf_float+0x396>
34019812:	07db      	lsls	r3, r3, #31
34019814:	d536      	bpl.n	34019884 <_printf_float+0x404>
34019816:	2301      	movs	r3, #1
34019818:	4642      	mov	r2, r8
3401981a:	4631      	mov	r1, r6
3401981c:	4628      	mov	r0, r5
3401981e:	47b8      	blx	r7
34019820:	3001      	adds	r0, #1
34019822:	f43f ae79 	beq.w	34019518 <_printf_float+0x98>
34019826:	9b05      	ldr	r3, [sp, #20]
34019828:	465a      	mov	r2, fp
3401982a:	4631      	mov	r1, r6
3401982c:	4628      	mov	r0, r5
3401982e:	47b8      	blx	r7
34019830:	3001      	adds	r0, #1
34019832:	f43f ae71 	beq.w	34019518 <_printf_float+0x98>
34019836:	f109 39ff 	add.w	r9, r9, #4294967295
3401983a:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
3401983e:	eeb5 7b40 	vcmp.f64	d7, #0.0
34019842:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019846:	d018      	beq.n	3401987a <_printf_float+0x3fa>
34019848:	464b      	mov	r3, r9
3401984a:	f108 0201 	add.w	r2, r8, #1
3401984e:	4631      	mov	r1, r6
34019850:	4628      	mov	r0, r5
34019852:	47b8      	blx	r7
34019854:	3001      	adds	r0, #1
34019856:	d10c      	bne.n	34019872 <_printf_float+0x3f2>
34019858:	e65e      	b.n	34019518 <_printf_float+0x98>
3401985a:	2301      	movs	r3, #1
3401985c:	465a      	mov	r2, fp
3401985e:	4631      	mov	r1, r6
34019860:	4628      	mov	r0, r5
34019862:	47b8      	blx	r7
34019864:	3001      	adds	r0, #1
34019866:	f43f ae57 	beq.w	34019518 <_printf_float+0x98>
3401986a:	f108 0801 	add.w	r8, r8, #1
3401986e:	45c8      	cmp	r8, r9
34019870:	dbf3      	blt.n	3401985a <_printf_float+0x3da>
34019872:	4653      	mov	r3, sl
34019874:	f104 0250 	add.w	r2, r4, #80	@ 0x50
34019878:	e6dc      	b.n	34019634 <_printf_float+0x1b4>
3401987a:	f04f 0800 	mov.w	r8, #0
3401987e:	f104 0b1a 	add.w	fp, r4, #26
34019882:	e7f4      	b.n	3401986e <_printf_float+0x3ee>
34019884:	2301      	movs	r3, #1
34019886:	4642      	mov	r2, r8
34019888:	e7e1      	b.n	3401984e <_printf_float+0x3ce>
3401988a:	2301      	movs	r3, #1
3401988c:	464a      	mov	r2, r9
3401988e:	4631      	mov	r1, r6
34019890:	4628      	mov	r0, r5
34019892:	47b8      	blx	r7
34019894:	3001      	adds	r0, #1
34019896:	f43f ae3f 	beq.w	34019518 <_printf_float+0x98>
3401989a:	f108 0801 	add.w	r8, r8, #1
3401989e:	68e3      	ldr	r3, [r4, #12]
340198a0:	990b      	ldr	r1, [sp, #44]	@ 0x2c
340198a2:	1a5b      	subs	r3, r3, r1
340198a4:	4543      	cmp	r3, r8
340198a6:	dcf0      	bgt.n	3401988a <_printf_float+0x40a>
340198a8:	e6f8      	b.n	3401969c <_printf_float+0x21c>
340198aa:	f04f 0800 	mov.w	r8, #0
340198ae:	f104 0919 	add.w	r9, r4, #25
340198b2:	e7f4      	b.n	3401989e <_printf_float+0x41e>

340198b4 <_printf_common>:
340198b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
340198b8:	4616      	mov	r6, r2
340198ba:	4698      	mov	r8, r3
340198bc:	688a      	ldr	r2, [r1, #8]
340198be:	4607      	mov	r7, r0
340198c0:	690b      	ldr	r3, [r1, #16]
340198c2:	460c      	mov	r4, r1
340198c4:	f8dd 9020 	ldr.w	r9, [sp, #32]
340198c8:	4293      	cmp	r3, r2
340198ca:	bfb8      	it	lt
340198cc:	4613      	movlt	r3, r2
340198ce:	6033      	str	r3, [r6, #0]
340198d0:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
340198d4:	b10a      	cbz	r2, 340198da <_printf_common+0x26>
340198d6:	3301      	adds	r3, #1
340198d8:	6033      	str	r3, [r6, #0]
340198da:	6823      	ldr	r3, [r4, #0]
340198dc:	0699      	lsls	r1, r3, #26
340198de:	bf42      	ittt	mi
340198e0:	6833      	ldrmi	r3, [r6, #0]
340198e2:	3302      	addmi	r3, #2
340198e4:	6033      	strmi	r3, [r6, #0]
340198e6:	6825      	ldr	r5, [r4, #0]
340198e8:	f015 0506 	ands.w	r5, r5, #6
340198ec:	d106      	bne.n	340198fc <_printf_common+0x48>
340198ee:	f104 0a19 	add.w	sl, r4, #25
340198f2:	68e3      	ldr	r3, [r4, #12]
340198f4:	6832      	ldr	r2, [r6, #0]
340198f6:	1a9b      	subs	r3, r3, r2
340198f8:	42ab      	cmp	r3, r5
340198fa:	dc2b      	bgt.n	34019954 <_printf_common+0xa0>
340198fc:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
34019900:	6822      	ldr	r2, [r4, #0]
34019902:	3b00      	subs	r3, #0
34019904:	bf18      	it	ne
34019906:	2301      	movne	r3, #1
34019908:	0692      	lsls	r2, r2, #26
3401990a:	d430      	bmi.n	3401996e <_printf_common+0xba>
3401990c:	f104 0243 	add.w	r2, r4, #67	@ 0x43
34019910:	4641      	mov	r1, r8
34019912:	4638      	mov	r0, r7
34019914:	47c8      	blx	r9
34019916:	3001      	adds	r0, #1
34019918:	d023      	beq.n	34019962 <_printf_common+0xae>
3401991a:	6823      	ldr	r3, [r4, #0]
3401991c:	341a      	adds	r4, #26
3401991e:	f854 2c0a 	ldr.w	r2, [r4, #-10]
34019922:	f003 0306 	and.w	r3, r3, #6
34019926:	2b04      	cmp	r3, #4
34019928:	bf0a      	itet	eq
3401992a:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
3401992e:	2500      	movne	r5, #0
34019930:	6833      	ldreq	r3, [r6, #0]
34019932:	f04f 0600 	mov.w	r6, #0
34019936:	bf08      	it	eq
34019938:	1aed      	subeq	r5, r5, r3
3401993a:	f854 3c12 	ldr.w	r3, [r4, #-18]
3401993e:	bf08      	it	eq
34019940:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
34019944:	4293      	cmp	r3, r2
34019946:	bfc4      	itt	gt
34019948:	1a9b      	subgt	r3, r3, r2
3401994a:	18ed      	addgt	r5, r5, r3
3401994c:	42b5      	cmp	r5, r6
3401994e:	d11a      	bne.n	34019986 <_printf_common+0xd2>
34019950:	2000      	movs	r0, #0
34019952:	e008      	b.n	34019966 <_printf_common+0xb2>
34019954:	2301      	movs	r3, #1
34019956:	4652      	mov	r2, sl
34019958:	4641      	mov	r1, r8
3401995a:	4638      	mov	r0, r7
3401995c:	47c8      	blx	r9
3401995e:	3001      	adds	r0, #1
34019960:	d103      	bne.n	3401996a <_printf_common+0xb6>
34019962:	f04f 30ff 	mov.w	r0, #4294967295
34019966:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3401996a:	3501      	adds	r5, #1
3401996c:	e7c1      	b.n	340198f2 <_printf_common+0x3e>
3401996e:	18e1      	adds	r1, r4, r3
34019970:	1c5a      	adds	r2, r3, #1
34019972:	2030      	movs	r0, #48	@ 0x30
34019974:	3302      	adds	r3, #2
34019976:	4422      	add	r2, r4
34019978:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
3401997c:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
34019980:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
34019984:	e7c2      	b.n	3401990c <_printf_common+0x58>
34019986:	2301      	movs	r3, #1
34019988:	4622      	mov	r2, r4
3401998a:	4641      	mov	r1, r8
3401998c:	4638      	mov	r0, r7
3401998e:	47c8      	blx	r9
34019990:	3001      	adds	r0, #1
34019992:	d0e6      	beq.n	34019962 <_printf_common+0xae>
34019994:	3601      	adds	r6, #1
34019996:	e7d9      	b.n	3401994c <_printf_common+0x98>

34019998 <_printf_i>:
34019998:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
3401999c:	7e0f      	ldrb	r7, [r1, #24]
3401999e:	4691      	mov	r9, r2
340199a0:	4680      	mov	r8, r0
340199a2:	460c      	mov	r4, r1
340199a4:	2f78      	cmp	r7, #120	@ 0x78
340199a6:	469a      	mov	sl, r3
340199a8:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
340199aa:	f101 0243 	add.w	r2, r1, #67	@ 0x43
340199ae:	d807      	bhi.n	340199c0 <_printf_i+0x28>
340199b0:	2f62      	cmp	r7, #98	@ 0x62
340199b2:	d80a      	bhi.n	340199ca <_printf_i+0x32>
340199b4:	2f00      	cmp	r7, #0
340199b6:	f000 80d1 	beq.w	34019b5c <_printf_i+0x1c4>
340199ba:	2f58      	cmp	r7, #88	@ 0x58
340199bc:	f000 80b8 	beq.w	34019b30 <_printf_i+0x198>
340199c0:	f104 0642 	add.w	r6, r4, #66	@ 0x42
340199c4:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
340199c8:	e03a      	b.n	34019a40 <_printf_i+0xa8>
340199ca:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
340199ce:	2b15      	cmp	r3, #21
340199d0:	d8f6      	bhi.n	340199c0 <_printf_i+0x28>
340199d2:	a101      	add	r1, pc, #4	@ (adr r1, 340199d8 <_printf_i+0x40>)
340199d4:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
340199d8:	34019a31 	.word	0x34019a31
340199dc:	34019a45 	.word	0x34019a45
340199e0:	340199c1 	.word	0x340199c1
340199e4:	340199c1 	.word	0x340199c1
340199e8:	340199c1 	.word	0x340199c1
340199ec:	340199c1 	.word	0x340199c1
340199f0:	34019a45 	.word	0x34019a45
340199f4:	340199c1 	.word	0x340199c1
340199f8:	340199c1 	.word	0x340199c1
340199fc:	340199c1 	.word	0x340199c1
34019a00:	340199c1 	.word	0x340199c1
34019a04:	34019b43 	.word	0x34019b43
34019a08:	34019a6f 	.word	0x34019a6f
34019a0c:	34019afd 	.word	0x34019afd
34019a10:	340199c1 	.word	0x340199c1
34019a14:	340199c1 	.word	0x340199c1
34019a18:	34019b65 	.word	0x34019b65
34019a1c:	340199c1 	.word	0x340199c1
34019a20:	34019a6f 	.word	0x34019a6f
34019a24:	340199c1 	.word	0x340199c1
34019a28:	340199c1 	.word	0x340199c1
34019a2c:	34019b05 	.word	0x34019b05
34019a30:	6833      	ldr	r3, [r6, #0]
34019a32:	1d1a      	adds	r2, r3, #4
34019a34:	681b      	ldr	r3, [r3, #0]
34019a36:	6032      	str	r2, [r6, #0]
34019a38:	f104 0642 	add.w	r6, r4, #66	@ 0x42
34019a3c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
34019a40:	2301      	movs	r3, #1
34019a42:	e09c      	b.n	34019b7e <_printf_i+0x1e6>
34019a44:	6833      	ldr	r3, [r6, #0]
34019a46:	6820      	ldr	r0, [r4, #0]
34019a48:	1d19      	adds	r1, r3, #4
34019a4a:	6031      	str	r1, [r6, #0]
34019a4c:	0606      	lsls	r6, r0, #24
34019a4e:	d501      	bpl.n	34019a54 <_printf_i+0xbc>
34019a50:	681d      	ldr	r5, [r3, #0]
34019a52:	e003      	b.n	34019a5c <_printf_i+0xc4>
34019a54:	0645      	lsls	r5, r0, #25
34019a56:	d5fb      	bpl.n	34019a50 <_printf_i+0xb8>
34019a58:	f9b3 5000 	ldrsh.w	r5, [r3]
34019a5c:	2d00      	cmp	r5, #0
34019a5e:	da03      	bge.n	34019a68 <_printf_i+0xd0>
34019a60:	232d      	movs	r3, #45	@ 0x2d
34019a62:	426d      	negs	r5, r5
34019a64:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
34019a68:	4858      	ldr	r0, [pc, #352]	@ (34019bcc <_printf_i+0x234>)
34019a6a:	230a      	movs	r3, #10
34019a6c:	e011      	b.n	34019a92 <_printf_i+0xfa>
34019a6e:	6821      	ldr	r1, [r4, #0]
34019a70:	6833      	ldr	r3, [r6, #0]
34019a72:	0608      	lsls	r0, r1, #24
34019a74:	f853 5b04 	ldr.w	r5, [r3], #4
34019a78:	d402      	bmi.n	34019a80 <_printf_i+0xe8>
34019a7a:	0649      	lsls	r1, r1, #25
34019a7c:	bf48      	it	mi
34019a7e:	b2ad      	uxthmi	r5, r5
34019a80:	2f6f      	cmp	r7, #111	@ 0x6f
34019a82:	6033      	str	r3, [r6, #0]
34019a84:	4851      	ldr	r0, [pc, #324]	@ (34019bcc <_printf_i+0x234>)
34019a86:	bf14      	ite	ne
34019a88:	230a      	movne	r3, #10
34019a8a:	2308      	moveq	r3, #8
34019a8c:	2100      	movs	r1, #0
34019a8e:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
34019a92:	6866      	ldr	r6, [r4, #4]
34019a94:	2e00      	cmp	r6, #0
34019a96:	60a6      	str	r6, [r4, #8]
34019a98:	db05      	blt.n	34019aa6 <_printf_i+0x10e>
34019a9a:	6821      	ldr	r1, [r4, #0]
34019a9c:	432e      	orrs	r6, r5
34019a9e:	f021 0104 	bic.w	r1, r1, #4
34019aa2:	6021      	str	r1, [r4, #0]
34019aa4:	d04b      	beq.n	34019b3e <_printf_i+0x1a6>
34019aa6:	4616      	mov	r6, r2
34019aa8:	fbb5 f1f3 	udiv	r1, r5, r3
34019aac:	fb03 5711 	mls	r7, r3, r1, r5
34019ab0:	5dc7      	ldrb	r7, [r0, r7]
34019ab2:	f806 7d01 	strb.w	r7, [r6, #-1]!
34019ab6:	462f      	mov	r7, r5
34019ab8:	460d      	mov	r5, r1
34019aba:	42bb      	cmp	r3, r7
34019abc:	d9f4      	bls.n	34019aa8 <_printf_i+0x110>
34019abe:	2b08      	cmp	r3, #8
34019ac0:	d10b      	bne.n	34019ada <_printf_i+0x142>
34019ac2:	6823      	ldr	r3, [r4, #0]
34019ac4:	07df      	lsls	r7, r3, #31
34019ac6:	d508      	bpl.n	34019ada <_printf_i+0x142>
34019ac8:	6923      	ldr	r3, [r4, #16]
34019aca:	6861      	ldr	r1, [r4, #4]
34019acc:	4299      	cmp	r1, r3
34019ace:	bfde      	ittt	le
34019ad0:	2330      	movle	r3, #48	@ 0x30
34019ad2:	f806 3c01 	strble.w	r3, [r6, #-1]
34019ad6:	f106 36ff 	addle.w	r6, r6, #4294967295
34019ada:	1b92      	subs	r2, r2, r6
34019adc:	6122      	str	r2, [r4, #16]
34019ade:	464b      	mov	r3, r9
34019ae0:	aa03      	add	r2, sp, #12
34019ae2:	4621      	mov	r1, r4
34019ae4:	4640      	mov	r0, r8
34019ae6:	f8cd a000 	str.w	sl, [sp]
34019aea:	f7ff fee3 	bl	340198b4 <_printf_common>
34019aee:	3001      	adds	r0, #1
34019af0:	d14a      	bne.n	34019b88 <_printf_i+0x1f0>
34019af2:	f04f 30ff 	mov.w	r0, #4294967295
34019af6:	b004      	add	sp, #16
34019af8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
34019afc:	6823      	ldr	r3, [r4, #0]
34019afe:	f043 0320 	orr.w	r3, r3, #32
34019b02:	6023      	str	r3, [r4, #0]
34019b04:	2778      	movs	r7, #120	@ 0x78
34019b06:	4832      	ldr	r0, [pc, #200]	@ (34019bd0 <_printf_i+0x238>)
34019b08:	6823      	ldr	r3, [r4, #0]
34019b0a:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
34019b0e:	061f      	lsls	r7, r3, #24
34019b10:	6831      	ldr	r1, [r6, #0]
34019b12:	f851 5b04 	ldr.w	r5, [r1], #4
34019b16:	d402      	bmi.n	34019b1e <_printf_i+0x186>
34019b18:	065f      	lsls	r7, r3, #25
34019b1a:	bf48      	it	mi
34019b1c:	b2ad      	uxthmi	r5, r5
34019b1e:	6031      	str	r1, [r6, #0]
34019b20:	07d9      	lsls	r1, r3, #31
34019b22:	bf44      	itt	mi
34019b24:	f043 0320 	orrmi.w	r3, r3, #32
34019b28:	6023      	strmi	r3, [r4, #0]
34019b2a:	b11d      	cbz	r5, 34019b34 <_printf_i+0x19c>
34019b2c:	2310      	movs	r3, #16
34019b2e:	e7ad      	b.n	34019a8c <_printf_i+0xf4>
34019b30:	4826      	ldr	r0, [pc, #152]	@ (34019bcc <_printf_i+0x234>)
34019b32:	e7e9      	b.n	34019b08 <_printf_i+0x170>
34019b34:	6823      	ldr	r3, [r4, #0]
34019b36:	f023 0320 	bic.w	r3, r3, #32
34019b3a:	6023      	str	r3, [r4, #0]
34019b3c:	e7f6      	b.n	34019b2c <_printf_i+0x194>
34019b3e:	4616      	mov	r6, r2
34019b40:	e7bd      	b.n	34019abe <_printf_i+0x126>
34019b42:	6833      	ldr	r3, [r6, #0]
34019b44:	6825      	ldr	r5, [r4, #0]
34019b46:	1d18      	adds	r0, r3, #4
34019b48:	6961      	ldr	r1, [r4, #20]
34019b4a:	6030      	str	r0, [r6, #0]
34019b4c:	062e      	lsls	r6, r5, #24
34019b4e:	681b      	ldr	r3, [r3, #0]
34019b50:	d501      	bpl.n	34019b56 <_printf_i+0x1be>
34019b52:	6019      	str	r1, [r3, #0]
34019b54:	e002      	b.n	34019b5c <_printf_i+0x1c4>
34019b56:	0668      	lsls	r0, r5, #25
34019b58:	d5fb      	bpl.n	34019b52 <_printf_i+0x1ba>
34019b5a:	8019      	strh	r1, [r3, #0]
34019b5c:	2300      	movs	r3, #0
34019b5e:	4616      	mov	r6, r2
34019b60:	6123      	str	r3, [r4, #16]
34019b62:	e7bc      	b.n	34019ade <_printf_i+0x146>
34019b64:	6833      	ldr	r3, [r6, #0]
34019b66:	2100      	movs	r1, #0
34019b68:	1d1a      	adds	r2, r3, #4
34019b6a:	6032      	str	r2, [r6, #0]
34019b6c:	681e      	ldr	r6, [r3, #0]
34019b6e:	6862      	ldr	r2, [r4, #4]
34019b70:	4630      	mov	r0, r6
34019b72:	f000 fd60 	bl	3401a636 <memchr>
34019b76:	b108      	cbz	r0, 34019b7c <_printf_i+0x1e4>
34019b78:	1b80      	subs	r0, r0, r6
34019b7a:	6060      	str	r0, [r4, #4]
34019b7c:	6863      	ldr	r3, [r4, #4]
34019b7e:	6123      	str	r3, [r4, #16]
34019b80:	2300      	movs	r3, #0
34019b82:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
34019b86:	e7aa      	b.n	34019ade <_printf_i+0x146>
34019b88:	6923      	ldr	r3, [r4, #16]
34019b8a:	4632      	mov	r2, r6
34019b8c:	4649      	mov	r1, r9
34019b8e:	4640      	mov	r0, r8
34019b90:	47d0      	blx	sl
34019b92:	3001      	adds	r0, #1
34019b94:	d0ad      	beq.n	34019af2 <_printf_i+0x15a>
34019b96:	6823      	ldr	r3, [r4, #0]
34019b98:	079b      	lsls	r3, r3, #30
34019b9a:	d413      	bmi.n	34019bc4 <_printf_i+0x22c>
34019b9c:	68e0      	ldr	r0, [r4, #12]
34019b9e:	9b03      	ldr	r3, [sp, #12]
34019ba0:	4298      	cmp	r0, r3
34019ba2:	bfb8      	it	lt
34019ba4:	4618      	movlt	r0, r3
34019ba6:	e7a6      	b.n	34019af6 <_printf_i+0x15e>
34019ba8:	2301      	movs	r3, #1
34019baa:	4632      	mov	r2, r6
34019bac:	4649      	mov	r1, r9
34019bae:	4640      	mov	r0, r8
34019bb0:	47d0      	blx	sl
34019bb2:	3001      	adds	r0, #1
34019bb4:	d09d      	beq.n	34019af2 <_printf_i+0x15a>
34019bb6:	3501      	adds	r5, #1
34019bb8:	68e3      	ldr	r3, [r4, #12]
34019bba:	9903      	ldr	r1, [sp, #12]
34019bbc:	1a5b      	subs	r3, r3, r1
34019bbe:	42ab      	cmp	r3, r5
34019bc0:	dcf2      	bgt.n	34019ba8 <_printf_i+0x210>
34019bc2:	e7eb      	b.n	34019b9c <_printf_i+0x204>
34019bc4:	2500      	movs	r5, #0
34019bc6:	f104 0619 	add.w	r6, r4, #25
34019bca:	e7f5      	b.n	34019bb8 <_printf_i+0x220>
34019bcc:	34022636 	.word	0x34022636
34019bd0:	34022647 	.word	0x34022647

34019bd4 <std>:
34019bd4:	2300      	movs	r3, #0
34019bd6:	b510      	push	{r4, lr}
34019bd8:	4604      	mov	r4, r0
34019bda:	6083      	str	r3, [r0, #8]
34019bdc:	8181      	strh	r1, [r0, #12]
34019bde:	4619      	mov	r1, r3
34019be0:	6643      	str	r3, [r0, #100]	@ 0x64
34019be2:	81c2      	strh	r2, [r0, #14]
34019be4:	2208      	movs	r2, #8
34019be6:	6183      	str	r3, [r0, #24]
34019be8:	e9c0 3300 	strd	r3, r3, [r0]
34019bec:	e9c0 3304 	strd	r3, r3, [r0, #16]
34019bf0:	305c      	adds	r0, #92	@ 0x5c
34019bf2:	f000 fa97 	bl	3401a124 <memset>
34019bf6:	4b0d      	ldr	r3, [pc, #52]	@ (34019c2c <std+0x58>)
34019bf8:	6224      	str	r4, [r4, #32]
34019bfa:	6263      	str	r3, [r4, #36]	@ 0x24
34019bfc:	4b0c      	ldr	r3, [pc, #48]	@ (34019c30 <std+0x5c>)
34019bfe:	62a3      	str	r3, [r4, #40]	@ 0x28
34019c00:	4b0c      	ldr	r3, [pc, #48]	@ (34019c34 <std+0x60>)
34019c02:	62e3      	str	r3, [r4, #44]	@ 0x2c
34019c04:	4b0c      	ldr	r3, [pc, #48]	@ (34019c38 <std+0x64>)
34019c06:	6323      	str	r3, [r4, #48]	@ 0x30
34019c08:	4b0c      	ldr	r3, [pc, #48]	@ (34019c3c <std+0x68>)
34019c0a:	429c      	cmp	r4, r3
34019c0c:	d006      	beq.n	34019c1c <std+0x48>
34019c0e:	f103 0268 	add.w	r2, r3, #104	@ 0x68
34019c12:	4294      	cmp	r4, r2
34019c14:	d002      	beq.n	34019c1c <std+0x48>
34019c16:	33d0      	adds	r3, #208	@ 0xd0
34019c18:	429c      	cmp	r4, r3
34019c1a:	d105      	bne.n	34019c28 <std+0x54>
34019c1c:	f104 0058 	add.w	r0, r4, #88	@ 0x58
34019c20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34019c24:	f000 bcfc 	b.w	3401a620 <__retarget_lock_init_recursive>
34019c28:	bd10      	pop	{r4, pc}
34019c2a:	bf00      	nop
34019c2c:	34019ec9 	.word	0x34019ec9
34019c30:	34019eeb 	.word	0x34019eeb
34019c34:	34019f23 	.word	0x34019f23
34019c38:	34019f47 	.word	0x34019f47
34019c3c:	340ceef4 	.word	0x340ceef4

34019c40 <stdio_exit_handler>:
34019c40:	4a02      	ldr	r2, [pc, #8]	@ (34019c4c <stdio_exit_handler+0xc>)
34019c42:	4903      	ldr	r1, [pc, #12]	@ (34019c50 <stdio_exit_handler+0x10>)
34019c44:	4803      	ldr	r0, [pc, #12]	@ (34019c54 <stdio_exit_handler+0x14>)
34019c46:	f000 b87b 	b.w	34019d40 <_fwalk_sglue>
34019c4a:	bf00      	nop
34019c4c:	340b1104 	.word	0x340b1104
34019c50:	3401c039 	.word	0x3401c039
34019c54:	340b1114 	.word	0x340b1114

34019c58 <cleanup_stdio>:
34019c58:	6841      	ldr	r1, [r0, #4]
34019c5a:	4b0c      	ldr	r3, [pc, #48]	@ (34019c8c <cleanup_stdio+0x34>)
34019c5c:	4299      	cmp	r1, r3
34019c5e:	b510      	push	{r4, lr}
34019c60:	4604      	mov	r4, r0
34019c62:	d001      	beq.n	34019c68 <cleanup_stdio+0x10>
34019c64:	f002 f9e8 	bl	3401c038 <_fflush_r>
34019c68:	68a1      	ldr	r1, [r4, #8]
34019c6a:	4b09      	ldr	r3, [pc, #36]	@ (34019c90 <cleanup_stdio+0x38>)
34019c6c:	4299      	cmp	r1, r3
34019c6e:	d002      	beq.n	34019c76 <cleanup_stdio+0x1e>
34019c70:	4620      	mov	r0, r4
34019c72:	f002 f9e1 	bl	3401c038 <_fflush_r>
34019c76:	68e1      	ldr	r1, [r4, #12]
34019c78:	4b06      	ldr	r3, [pc, #24]	@ (34019c94 <cleanup_stdio+0x3c>)
34019c7a:	4299      	cmp	r1, r3
34019c7c:	d004      	beq.n	34019c88 <cleanup_stdio+0x30>
34019c7e:	4620      	mov	r0, r4
34019c80:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34019c84:	f002 b9d8 	b.w	3401c038 <_fflush_r>
34019c88:	bd10      	pop	{r4, pc}
34019c8a:	bf00      	nop
34019c8c:	340ceef4 	.word	0x340ceef4
34019c90:	340cef5c 	.word	0x340cef5c
34019c94:	340cefc4 	.word	0x340cefc4

34019c98 <global_stdio_init.part.0>:
34019c98:	b510      	push	{r4, lr}
34019c9a:	4b0b      	ldr	r3, [pc, #44]	@ (34019cc8 <global_stdio_init.part.0+0x30>)
34019c9c:	2104      	movs	r1, #4
34019c9e:	4c0b      	ldr	r4, [pc, #44]	@ (34019ccc <global_stdio_init.part.0+0x34>)
34019ca0:	4a0b      	ldr	r2, [pc, #44]	@ (34019cd0 <global_stdio_init.part.0+0x38>)
34019ca2:	4620      	mov	r0, r4
34019ca4:	601a      	str	r2, [r3, #0]
34019ca6:	2200      	movs	r2, #0
34019ca8:	f7ff ff94 	bl	34019bd4 <std>
34019cac:	f104 0068 	add.w	r0, r4, #104	@ 0x68
34019cb0:	2201      	movs	r2, #1
34019cb2:	2109      	movs	r1, #9
34019cb4:	f7ff ff8e 	bl	34019bd4 <std>
34019cb8:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
34019cbc:	2202      	movs	r2, #2
34019cbe:	2112      	movs	r1, #18
34019cc0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34019cc4:	f7ff bf86 	b.w	34019bd4 <std>
34019cc8:	340cf02c 	.word	0x340cf02c
34019ccc:	340ceef4 	.word	0x340ceef4
34019cd0:	34019c41 	.word	0x34019c41

34019cd4 <__sfp_lock_acquire>:
34019cd4:	4801      	ldr	r0, [pc, #4]	@ (34019cdc <__sfp_lock_acquire+0x8>)
34019cd6:	f000 bca4 	b.w	3401a622 <__retarget_lock_acquire_recursive>
34019cda:	bf00      	nop
34019cdc:	340cf035 	.word	0x340cf035

34019ce0 <__sfp_lock_release>:
34019ce0:	4801      	ldr	r0, [pc, #4]	@ (34019ce8 <__sfp_lock_release+0x8>)
34019ce2:	f000 bc9f 	b.w	3401a624 <__retarget_lock_release_recursive>
34019ce6:	bf00      	nop
34019ce8:	340cf035 	.word	0x340cf035

34019cec <__sinit>:
34019cec:	b510      	push	{r4, lr}
34019cee:	4604      	mov	r4, r0
34019cf0:	f7ff fff0 	bl	34019cd4 <__sfp_lock_acquire>
34019cf4:	6a23      	ldr	r3, [r4, #32]
34019cf6:	b11b      	cbz	r3, 34019d00 <__sinit+0x14>
34019cf8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34019cfc:	f7ff bff0 	b.w	34019ce0 <__sfp_lock_release>
34019d00:	4b04      	ldr	r3, [pc, #16]	@ (34019d14 <__sinit+0x28>)
34019d02:	6223      	str	r3, [r4, #32]
34019d04:	4b04      	ldr	r3, [pc, #16]	@ (34019d18 <__sinit+0x2c>)
34019d06:	681b      	ldr	r3, [r3, #0]
34019d08:	2b00      	cmp	r3, #0
34019d0a:	d1f5      	bne.n	34019cf8 <__sinit+0xc>
34019d0c:	f7ff ffc4 	bl	34019c98 <global_stdio_init.part.0>
34019d10:	e7f2      	b.n	34019cf8 <__sinit+0xc>
34019d12:	bf00      	nop
34019d14:	34019c59 	.word	0x34019c59
34019d18:	340cf02c 	.word	0x340cf02c

34019d1c <fiprintf>:
34019d1c:	b40e      	push	{r1, r2, r3}
34019d1e:	b503      	push	{r0, r1, lr}
34019d20:	ab03      	add	r3, sp, #12
34019d22:	4601      	mov	r1, r0
34019d24:	4805      	ldr	r0, [pc, #20]	@ (34019d3c <fiprintf+0x20>)
34019d26:	f853 2b04 	ldr.w	r2, [r3], #4
34019d2a:	6800      	ldr	r0, [r0, #0]
34019d2c:	9301      	str	r3, [sp, #4]
34019d2e:	f001 ffe7 	bl	3401bd00 <_vfiprintf_r>
34019d32:	b002      	add	sp, #8
34019d34:	f85d eb04 	ldr.w	lr, [sp], #4
34019d38:	b003      	add	sp, #12
34019d3a:	4770      	bx	lr
34019d3c:	340b1110 	.word	0x340b1110

34019d40 <_fwalk_sglue>:
34019d40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34019d44:	4607      	mov	r7, r0
34019d46:	4688      	mov	r8, r1
34019d48:	4614      	mov	r4, r2
34019d4a:	2600      	movs	r6, #0
34019d4c:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
34019d50:	f1b9 0901 	subs.w	r9, r9, #1
34019d54:	d505      	bpl.n	34019d62 <_fwalk_sglue+0x22>
34019d56:	6824      	ldr	r4, [r4, #0]
34019d58:	2c00      	cmp	r4, #0
34019d5a:	d1f7      	bne.n	34019d4c <_fwalk_sglue+0xc>
34019d5c:	4630      	mov	r0, r6
34019d5e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
34019d62:	89ab      	ldrh	r3, [r5, #12]
34019d64:	2b01      	cmp	r3, #1
34019d66:	d907      	bls.n	34019d78 <_fwalk_sglue+0x38>
34019d68:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
34019d6c:	3301      	adds	r3, #1
34019d6e:	d003      	beq.n	34019d78 <_fwalk_sglue+0x38>
34019d70:	4629      	mov	r1, r5
34019d72:	4638      	mov	r0, r7
34019d74:	47c0      	blx	r8
34019d76:	4306      	orrs	r6, r0
34019d78:	3568      	adds	r5, #104	@ 0x68
34019d7a:	e7e9      	b.n	34019d50 <_fwalk_sglue+0x10>

34019d7c <iprintf>:
34019d7c:	b40f      	push	{r0, r1, r2, r3}
34019d7e:	b507      	push	{r0, r1, r2, lr}
34019d80:	4906      	ldr	r1, [pc, #24]	@ (34019d9c <iprintf+0x20>)
34019d82:	ab04      	add	r3, sp, #16
34019d84:	6808      	ldr	r0, [r1, #0]
34019d86:	f853 2b04 	ldr.w	r2, [r3], #4
34019d8a:	6881      	ldr	r1, [r0, #8]
34019d8c:	9301      	str	r3, [sp, #4]
34019d8e:	f001 ffb7 	bl	3401bd00 <_vfiprintf_r>
34019d92:	b003      	add	sp, #12
34019d94:	f85d eb04 	ldr.w	lr, [sp], #4
34019d98:	b004      	add	sp, #16
34019d9a:	4770      	bx	lr
34019d9c:	340b1110 	.word	0x340b1110

34019da0 <_puts_r>:
34019da0:	6a03      	ldr	r3, [r0, #32]
34019da2:	b570      	push	{r4, r5, r6, lr}
34019da4:	4605      	mov	r5, r0
34019da6:	460e      	mov	r6, r1
34019da8:	6884      	ldr	r4, [r0, #8]
34019daa:	b90b      	cbnz	r3, 34019db0 <_puts_r+0x10>
34019dac:	f7ff ff9e 	bl	34019cec <__sinit>
34019db0:	6e63      	ldr	r3, [r4, #100]	@ 0x64
34019db2:	07db      	lsls	r3, r3, #31
34019db4:	d405      	bmi.n	34019dc2 <_puts_r+0x22>
34019db6:	89a3      	ldrh	r3, [r4, #12]
34019db8:	0598      	lsls	r0, r3, #22
34019dba:	d402      	bmi.n	34019dc2 <_puts_r+0x22>
34019dbc:	6da0      	ldr	r0, [r4, #88]	@ 0x58
34019dbe:	f000 fc30 	bl	3401a622 <__retarget_lock_acquire_recursive>
34019dc2:	89a3      	ldrh	r3, [r4, #12]
34019dc4:	0719      	lsls	r1, r3, #28
34019dc6:	d502      	bpl.n	34019dce <_puts_r+0x2e>
34019dc8:	6923      	ldr	r3, [r4, #16]
34019dca:	2b00      	cmp	r3, #0
34019dcc:	d135      	bne.n	34019e3a <_puts_r+0x9a>
34019dce:	4621      	mov	r1, r4
34019dd0:	4628      	mov	r0, r5
34019dd2:	f000 f937 	bl	3401a044 <__swsetup_r>
34019dd6:	b380      	cbz	r0, 34019e3a <_puts_r+0x9a>
34019dd8:	f04f 35ff 	mov.w	r5, #4294967295
34019ddc:	6e63      	ldr	r3, [r4, #100]	@ 0x64
34019dde:	07da      	lsls	r2, r3, #31
34019de0:	d405      	bmi.n	34019dee <_puts_r+0x4e>
34019de2:	89a3      	ldrh	r3, [r4, #12]
34019de4:	059b      	lsls	r3, r3, #22
34019de6:	d402      	bmi.n	34019dee <_puts_r+0x4e>
34019de8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
34019dea:	f000 fc1b 	bl	3401a624 <__retarget_lock_release_recursive>
34019dee:	4628      	mov	r0, r5
34019df0:	bd70      	pop	{r4, r5, r6, pc}
34019df2:	2b00      	cmp	r3, #0
34019df4:	da04      	bge.n	34019e00 <_puts_r+0x60>
34019df6:	69a2      	ldr	r2, [r4, #24]
34019df8:	429a      	cmp	r2, r3
34019dfa:	dc17      	bgt.n	34019e2c <_puts_r+0x8c>
34019dfc:	290a      	cmp	r1, #10
34019dfe:	d015      	beq.n	34019e2c <_puts_r+0x8c>
34019e00:	6823      	ldr	r3, [r4, #0]
34019e02:	1c5a      	adds	r2, r3, #1
34019e04:	6022      	str	r2, [r4, #0]
34019e06:	7019      	strb	r1, [r3, #0]
34019e08:	68a3      	ldr	r3, [r4, #8]
34019e0a:	f816 1f01 	ldrb.w	r1, [r6, #1]!
34019e0e:	3b01      	subs	r3, #1
34019e10:	60a3      	str	r3, [r4, #8]
34019e12:	2900      	cmp	r1, #0
34019e14:	d1ed      	bne.n	34019df2 <_puts_r+0x52>
34019e16:	2b00      	cmp	r3, #0
34019e18:	da11      	bge.n	34019e3e <_puts_r+0x9e>
34019e1a:	4622      	mov	r2, r4
34019e1c:	210a      	movs	r1, #10
34019e1e:	4628      	mov	r0, r5
34019e20:	f000 f8d2 	bl	34019fc8 <__swbuf_r>
34019e24:	3001      	adds	r0, #1
34019e26:	d0d7      	beq.n	34019dd8 <_puts_r+0x38>
34019e28:	250a      	movs	r5, #10
34019e2a:	e7d7      	b.n	34019ddc <_puts_r+0x3c>
34019e2c:	4622      	mov	r2, r4
34019e2e:	4628      	mov	r0, r5
34019e30:	f000 f8ca 	bl	34019fc8 <__swbuf_r>
34019e34:	3001      	adds	r0, #1
34019e36:	d1e7      	bne.n	34019e08 <_puts_r+0x68>
34019e38:	e7ce      	b.n	34019dd8 <_puts_r+0x38>
34019e3a:	3e01      	subs	r6, #1
34019e3c:	e7e4      	b.n	34019e08 <_puts_r+0x68>
34019e3e:	6823      	ldr	r3, [r4, #0]
34019e40:	1c5a      	adds	r2, r3, #1
34019e42:	6022      	str	r2, [r4, #0]
34019e44:	220a      	movs	r2, #10
34019e46:	701a      	strb	r2, [r3, #0]
34019e48:	e7ee      	b.n	34019e28 <_puts_r+0x88>
	...

34019e4c <puts>:
34019e4c:	4b02      	ldr	r3, [pc, #8]	@ (34019e58 <puts+0xc>)
34019e4e:	4601      	mov	r1, r0
34019e50:	6818      	ldr	r0, [r3, #0]
34019e52:	f7ff bfa5 	b.w	34019da0 <_puts_r>
34019e56:	bf00      	nop
34019e58:	340b1110 	.word	0x340b1110

34019e5c <sniprintf>:
34019e5c:	b40c      	push	{r2, r3}
34019e5e:	4b19      	ldr	r3, [pc, #100]	@ (34019ec4 <sniprintf+0x68>)
34019e60:	b530      	push	{r4, r5, lr}
34019e62:	1e0c      	subs	r4, r1, #0
34019e64:	b09d      	sub	sp, #116	@ 0x74
34019e66:	681d      	ldr	r5, [r3, #0]
34019e68:	da08      	bge.n	34019e7c <sniprintf+0x20>
34019e6a:	238b      	movs	r3, #139	@ 0x8b
34019e6c:	f04f 30ff 	mov.w	r0, #4294967295
34019e70:	602b      	str	r3, [r5, #0]
34019e72:	b01d      	add	sp, #116	@ 0x74
34019e74:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34019e78:	b002      	add	sp, #8
34019e7a:	4770      	bx	lr
34019e7c:	f44f 7302 	mov.w	r3, #520	@ 0x208
34019e80:	9002      	str	r0, [sp, #8]
34019e82:	9006      	str	r0, [sp, #24]
34019e84:	a902      	add	r1, sp, #8
34019e86:	f8ad 3014 	strh.w	r3, [sp, #20]
34019e8a:	f04f 0300 	mov.w	r3, #0
34019e8e:	9a20      	ldr	r2, [sp, #128]	@ 0x80
34019e90:	4628      	mov	r0, r5
34019e92:	931b      	str	r3, [sp, #108]	@ 0x6c
34019e94:	bf14      	ite	ne
34019e96:	f104 33ff 	addne.w	r3, r4, #4294967295
34019e9a:	4623      	moveq	r3, r4
34019e9c:	9304      	str	r3, [sp, #16]
34019e9e:	9307      	str	r3, [sp, #28]
34019ea0:	f64f 73ff 	movw	r3, #65535	@ 0xffff
34019ea4:	f8ad 3016 	strh.w	r3, [sp, #22]
34019ea8:	ab21      	add	r3, sp, #132	@ 0x84
34019eaa:	9301      	str	r3, [sp, #4]
34019eac:	f001 fe02 	bl	3401bab4 <_svfiprintf_r>
34019eb0:	1c43      	adds	r3, r0, #1
34019eb2:	bfbc      	itt	lt
34019eb4:	238b      	movlt	r3, #139	@ 0x8b
34019eb6:	602b      	strlt	r3, [r5, #0]
34019eb8:	2c00      	cmp	r4, #0
34019eba:	d0da      	beq.n	34019e72 <sniprintf+0x16>
34019ebc:	9b02      	ldr	r3, [sp, #8]
34019ebe:	2200      	movs	r2, #0
34019ec0:	701a      	strb	r2, [r3, #0]
34019ec2:	e7d6      	b.n	34019e72 <sniprintf+0x16>
34019ec4:	340b1110 	.word	0x340b1110

34019ec8 <__sread>:
34019ec8:	b510      	push	{r4, lr}
34019eca:	460c      	mov	r4, r1
34019ecc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34019ed0:	f000 fb48 	bl	3401a564 <_read_r>
34019ed4:	2800      	cmp	r0, #0
34019ed6:	bfab      	itete	ge
34019ed8:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
34019eda:	89a3      	ldrhlt	r3, [r4, #12]
34019edc:	181b      	addge	r3, r3, r0
34019ede:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
34019ee2:	bfac      	ite	ge
34019ee4:	6563      	strge	r3, [r4, #84]	@ 0x54
34019ee6:	81a3      	strhlt	r3, [r4, #12]
34019ee8:	bd10      	pop	{r4, pc}

34019eea <__swrite>:
34019eea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34019eee:	461f      	mov	r7, r3
34019ef0:	898b      	ldrh	r3, [r1, #12]
34019ef2:	4605      	mov	r5, r0
34019ef4:	460c      	mov	r4, r1
34019ef6:	05db      	lsls	r3, r3, #23
34019ef8:	4616      	mov	r6, r2
34019efa:	d505      	bpl.n	34019f08 <__swrite+0x1e>
34019efc:	2302      	movs	r3, #2
34019efe:	2200      	movs	r2, #0
34019f00:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34019f04:	f000 fb1c 	bl	3401a540 <_lseek_r>
34019f08:	89a3      	ldrh	r3, [r4, #12]
34019f0a:	4632      	mov	r2, r6
34019f0c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
34019f10:	4628      	mov	r0, r5
34019f12:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
34019f16:	81a3      	strh	r3, [r4, #12]
34019f18:	463b      	mov	r3, r7
34019f1a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
34019f1e:	f000 bb43 	b.w	3401a5a8 <_write_r>

34019f22 <__sseek>:
34019f22:	b510      	push	{r4, lr}
34019f24:	460c      	mov	r4, r1
34019f26:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34019f2a:	f000 fb09 	bl	3401a540 <_lseek_r>
34019f2e:	1c43      	adds	r3, r0, #1
34019f30:	89a3      	ldrh	r3, [r4, #12]
34019f32:	bf15      	itete	ne
34019f34:	6560      	strne	r0, [r4, #84]	@ 0x54
34019f36:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
34019f3a:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
34019f3e:	81a3      	strheq	r3, [r4, #12]
34019f40:	bf18      	it	ne
34019f42:	81a3      	strhne	r3, [r4, #12]
34019f44:	bd10      	pop	{r4, pc}

34019f46 <__sclose>:
34019f46:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34019f4a:	f000 bae9 	b.w	3401a520 <_close_r>

34019f4e <_vsniprintf_r>:
34019f4e:	b530      	push	{r4, r5, lr}
34019f50:	4614      	mov	r4, r2
34019f52:	b09b      	sub	sp, #108	@ 0x6c
34019f54:	4605      	mov	r5, r0
34019f56:	461a      	mov	r2, r3
34019f58:	2c00      	cmp	r4, #0
34019f5a:	da05      	bge.n	34019f68 <_vsniprintf_r+0x1a>
34019f5c:	238b      	movs	r3, #139	@ 0x8b
34019f5e:	6003      	str	r3, [r0, #0]
34019f60:	f04f 30ff 	mov.w	r0, #4294967295
34019f64:	b01b      	add	sp, #108	@ 0x6c
34019f66:	bd30      	pop	{r4, r5, pc}
34019f68:	f44f 7302 	mov.w	r3, #520	@ 0x208
34019f6c:	9100      	str	r1, [sp, #0]
34019f6e:	9104      	str	r1, [sp, #16]
34019f70:	4669      	mov	r1, sp
34019f72:	f8ad 300c 	strh.w	r3, [sp, #12]
34019f76:	f04f 0300 	mov.w	r3, #0
34019f7a:	9319      	str	r3, [sp, #100]	@ 0x64
34019f7c:	bf14      	ite	ne
34019f7e:	f104 33ff 	addne.w	r3, r4, #4294967295
34019f82:	4623      	moveq	r3, r4
34019f84:	9302      	str	r3, [sp, #8]
34019f86:	9305      	str	r3, [sp, #20]
34019f88:	f64f 73ff 	movw	r3, #65535	@ 0xffff
34019f8c:	f8ad 300e 	strh.w	r3, [sp, #14]
34019f90:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
34019f92:	f001 fd8f 	bl	3401bab4 <_svfiprintf_r>
34019f96:	1c43      	adds	r3, r0, #1
34019f98:	bfbc      	itt	lt
34019f9a:	238b      	movlt	r3, #139	@ 0x8b
34019f9c:	602b      	strlt	r3, [r5, #0]
34019f9e:	2c00      	cmp	r4, #0
34019fa0:	d0e0      	beq.n	34019f64 <_vsniprintf_r+0x16>
34019fa2:	9b00      	ldr	r3, [sp, #0]
34019fa4:	2200      	movs	r2, #0
34019fa6:	701a      	strb	r2, [r3, #0]
34019fa8:	e7dc      	b.n	34019f64 <_vsniprintf_r+0x16>
	...

34019fac <vsniprintf>:
34019fac:	b507      	push	{r0, r1, r2, lr}
34019fae:	9300      	str	r3, [sp, #0]
34019fb0:	4613      	mov	r3, r2
34019fb2:	460a      	mov	r2, r1
34019fb4:	4601      	mov	r1, r0
34019fb6:	4803      	ldr	r0, [pc, #12]	@ (34019fc4 <vsniprintf+0x18>)
34019fb8:	6800      	ldr	r0, [r0, #0]
34019fba:	f7ff ffc8 	bl	34019f4e <_vsniprintf_r>
34019fbe:	b003      	add	sp, #12
34019fc0:	f85d fb04 	ldr.w	pc, [sp], #4
34019fc4:	340b1110 	.word	0x340b1110

34019fc8 <__swbuf_r>:
34019fc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34019fca:	460e      	mov	r6, r1
34019fcc:	4614      	mov	r4, r2
34019fce:	4605      	mov	r5, r0
34019fd0:	b118      	cbz	r0, 34019fda <__swbuf_r+0x12>
34019fd2:	6a03      	ldr	r3, [r0, #32]
34019fd4:	b90b      	cbnz	r3, 34019fda <__swbuf_r+0x12>
34019fd6:	f7ff fe89 	bl	34019cec <__sinit>
34019fda:	69a3      	ldr	r3, [r4, #24]
34019fdc:	60a3      	str	r3, [r4, #8]
34019fde:	89a3      	ldrh	r3, [r4, #12]
34019fe0:	071a      	lsls	r2, r3, #28
34019fe2:	d501      	bpl.n	34019fe8 <__swbuf_r+0x20>
34019fe4:	6923      	ldr	r3, [r4, #16]
34019fe6:	b943      	cbnz	r3, 34019ffa <__swbuf_r+0x32>
34019fe8:	4621      	mov	r1, r4
34019fea:	4628      	mov	r0, r5
34019fec:	f000 f82a 	bl	3401a044 <__swsetup_r>
34019ff0:	b118      	cbz	r0, 34019ffa <__swbuf_r+0x32>
34019ff2:	f04f 37ff 	mov.w	r7, #4294967295
34019ff6:	4638      	mov	r0, r7
34019ff8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
34019ffa:	6823      	ldr	r3, [r4, #0]
34019ffc:	b2f6      	uxtb	r6, r6
34019ffe:	6922      	ldr	r2, [r4, #16]
3401a000:	4637      	mov	r7, r6
3401a002:	1a98      	subs	r0, r3, r2
3401a004:	6963      	ldr	r3, [r4, #20]
3401a006:	4283      	cmp	r3, r0
3401a008:	dc05      	bgt.n	3401a016 <__swbuf_r+0x4e>
3401a00a:	4621      	mov	r1, r4
3401a00c:	4628      	mov	r0, r5
3401a00e:	f002 f813 	bl	3401c038 <_fflush_r>
3401a012:	2800      	cmp	r0, #0
3401a014:	d1ed      	bne.n	34019ff2 <__swbuf_r+0x2a>
3401a016:	68a3      	ldr	r3, [r4, #8]
3401a018:	3b01      	subs	r3, #1
3401a01a:	60a3      	str	r3, [r4, #8]
3401a01c:	6823      	ldr	r3, [r4, #0]
3401a01e:	1c5a      	adds	r2, r3, #1
3401a020:	6022      	str	r2, [r4, #0]
3401a022:	701e      	strb	r6, [r3, #0]
3401a024:	1c43      	adds	r3, r0, #1
3401a026:	6962      	ldr	r2, [r4, #20]
3401a028:	429a      	cmp	r2, r3
3401a02a:	d004      	beq.n	3401a036 <__swbuf_r+0x6e>
3401a02c:	89a3      	ldrh	r3, [r4, #12]
3401a02e:	07db      	lsls	r3, r3, #31
3401a030:	d5e1      	bpl.n	34019ff6 <__swbuf_r+0x2e>
3401a032:	2e0a      	cmp	r6, #10
3401a034:	d1df      	bne.n	34019ff6 <__swbuf_r+0x2e>
3401a036:	4621      	mov	r1, r4
3401a038:	4628      	mov	r0, r5
3401a03a:	f001 fffd 	bl	3401c038 <_fflush_r>
3401a03e:	2800      	cmp	r0, #0
3401a040:	d0d9      	beq.n	34019ff6 <__swbuf_r+0x2e>
3401a042:	e7d6      	b.n	34019ff2 <__swbuf_r+0x2a>

3401a044 <__swsetup_r>:
3401a044:	b538      	push	{r3, r4, r5, lr}
3401a046:	4b29      	ldr	r3, [pc, #164]	@ (3401a0ec <__swsetup_r+0xa8>)
3401a048:	4605      	mov	r5, r0
3401a04a:	460c      	mov	r4, r1
3401a04c:	6818      	ldr	r0, [r3, #0]
3401a04e:	b118      	cbz	r0, 3401a058 <__swsetup_r+0x14>
3401a050:	6a03      	ldr	r3, [r0, #32]
3401a052:	b90b      	cbnz	r3, 3401a058 <__swsetup_r+0x14>
3401a054:	f7ff fe4a 	bl	34019cec <__sinit>
3401a058:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401a05c:	0719      	lsls	r1, r3, #28
3401a05e:	d422      	bmi.n	3401a0a6 <__swsetup_r+0x62>
3401a060:	06da      	lsls	r2, r3, #27
3401a062:	d407      	bmi.n	3401a074 <__swsetup_r+0x30>
3401a064:	2209      	movs	r2, #9
3401a066:	602a      	str	r2, [r5, #0]
3401a068:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401a06c:	f04f 30ff 	mov.w	r0, #4294967295
3401a070:	81a3      	strh	r3, [r4, #12]
3401a072:	e033      	b.n	3401a0dc <__swsetup_r+0x98>
3401a074:	0758      	lsls	r0, r3, #29
3401a076:	d512      	bpl.n	3401a09e <__swsetup_r+0x5a>
3401a078:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3401a07a:	b141      	cbz	r1, 3401a08e <__swsetup_r+0x4a>
3401a07c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
3401a080:	4299      	cmp	r1, r3
3401a082:	d002      	beq.n	3401a08a <__swsetup_r+0x46>
3401a084:	4628      	mov	r0, r5
3401a086:	f001 f8e5 	bl	3401b254 <_free_r>
3401a08a:	2300      	movs	r3, #0
3401a08c:	6363      	str	r3, [r4, #52]	@ 0x34
3401a08e:	89a3      	ldrh	r3, [r4, #12]
3401a090:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
3401a094:	81a3      	strh	r3, [r4, #12]
3401a096:	2300      	movs	r3, #0
3401a098:	6063      	str	r3, [r4, #4]
3401a09a:	6923      	ldr	r3, [r4, #16]
3401a09c:	6023      	str	r3, [r4, #0]
3401a09e:	89a3      	ldrh	r3, [r4, #12]
3401a0a0:	f043 0308 	orr.w	r3, r3, #8
3401a0a4:	81a3      	strh	r3, [r4, #12]
3401a0a6:	6923      	ldr	r3, [r4, #16]
3401a0a8:	b94b      	cbnz	r3, 3401a0be <__swsetup_r+0x7a>
3401a0aa:	89a3      	ldrh	r3, [r4, #12]
3401a0ac:	f403 7320 	and.w	r3, r3, #640	@ 0x280
3401a0b0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401a0b4:	d003      	beq.n	3401a0be <__swsetup_r+0x7a>
3401a0b6:	4621      	mov	r1, r4
3401a0b8:	4628      	mov	r0, r5
3401a0ba:	f002 f80a 	bl	3401c0d2 <__smakebuf_r>
3401a0be:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401a0c2:	f013 0201 	ands.w	r2, r3, #1
3401a0c6:	d00a      	beq.n	3401a0de <__swsetup_r+0x9a>
3401a0c8:	2200      	movs	r2, #0
3401a0ca:	60a2      	str	r2, [r4, #8]
3401a0cc:	6962      	ldr	r2, [r4, #20]
3401a0ce:	4252      	negs	r2, r2
3401a0d0:	61a2      	str	r2, [r4, #24]
3401a0d2:	6922      	ldr	r2, [r4, #16]
3401a0d4:	b942      	cbnz	r2, 3401a0e8 <__swsetup_r+0xa4>
3401a0d6:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
3401a0da:	d1c5      	bne.n	3401a068 <__swsetup_r+0x24>
3401a0dc:	bd38      	pop	{r3, r4, r5, pc}
3401a0de:	0799      	lsls	r1, r3, #30
3401a0e0:	bf58      	it	pl
3401a0e2:	6962      	ldrpl	r2, [r4, #20]
3401a0e4:	60a2      	str	r2, [r4, #8]
3401a0e6:	e7f4      	b.n	3401a0d2 <__swsetup_r+0x8e>
3401a0e8:	2000      	movs	r0, #0
3401a0ea:	e7f7      	b.n	3401a0dc <__swsetup_r+0x98>
3401a0ec:	340b1110 	.word	0x340b1110

3401a0f0 <memmove>:
3401a0f0:	4288      	cmp	r0, r1
3401a0f2:	b510      	push	{r4, lr}
3401a0f4:	eb01 0402 	add.w	r4, r1, r2
3401a0f8:	d902      	bls.n	3401a100 <memmove+0x10>
3401a0fa:	4284      	cmp	r4, r0
3401a0fc:	4623      	mov	r3, r4
3401a0fe:	d807      	bhi.n	3401a110 <memmove+0x20>
3401a100:	1e43      	subs	r3, r0, #1
3401a102:	42a1      	cmp	r1, r4
3401a104:	d008      	beq.n	3401a118 <memmove+0x28>
3401a106:	f811 2b01 	ldrb.w	r2, [r1], #1
3401a10a:	f803 2f01 	strb.w	r2, [r3, #1]!
3401a10e:	e7f8      	b.n	3401a102 <memmove+0x12>
3401a110:	4402      	add	r2, r0
3401a112:	4601      	mov	r1, r0
3401a114:	428a      	cmp	r2, r1
3401a116:	d100      	bne.n	3401a11a <memmove+0x2a>
3401a118:	bd10      	pop	{r4, pc}
3401a11a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
3401a11e:	f802 4d01 	strb.w	r4, [r2, #-1]!
3401a122:	e7f7      	b.n	3401a114 <memmove+0x24>

3401a124 <memset>:
3401a124:	4402      	add	r2, r0
3401a126:	4603      	mov	r3, r0
3401a128:	4293      	cmp	r3, r2
3401a12a:	d100      	bne.n	3401a12e <memset+0xa>
3401a12c:	4770      	bx	lr
3401a12e:	f803 1b01 	strb.w	r1, [r3], #1
3401a132:	e7f9      	b.n	3401a128 <memset+0x4>

3401a134 <_strerror_r>:
3401a134:	b510      	push	{r4, lr}
3401a136:	4604      	mov	r4, r0
3401a138:	4608      	mov	r0, r1
3401a13a:	4611      	mov	r1, r2
3401a13c:	461a      	mov	r2, r3
3401a13e:	288e      	cmp	r0, #142	@ 0x8e
3401a140:	f200 8130 	bhi.w	3401a3a4 <_strerror_r+0x270>
3401a144:	e8df f010 	tbh	[pc, r0, lsl #1]
3401a148:	0138008f 	.word	0x0138008f
3401a14c:	00940092 	.word	0x00940092
3401a150:	00980096 	.word	0x00980096
3401a154:	009c009a 	.word	0x009c009a
3401a158:	00a2009e 	.word	0x00a2009e
3401a15c:	00a800a4 	.word	0x00a800a4
3401a160:	00ac00aa 	.word	0x00ac00aa
3401a164:	012e00ae 	.word	0x012e00ae
3401a168:	00b200b0 	.word	0x00b200b0
3401a16c:	00b600b4 	.word	0x00b600b4
3401a170:	00be00b8 	.word	0x00be00b8
3401a174:	00c600c0 	.word	0x00c600c0
3401a178:	00ca00c8 	.word	0x00ca00c8
3401a17c:	00ce00cc 	.word	0x00ce00cc
3401a180:	00d600d2 	.word	0x00d600d2
3401a184:	00da00d8 	.word	0x00da00d8
3401a188:	00de00dc 	.word	0x00de00dc
3401a18c:	00e200e0 	.word	0x00e200e0
3401a190:	012e00e4 	.word	0x012e00e4
3401a194:	012e012e 	.word	0x012e012e
3401a198:	012e012e 	.word	0x012e012e
3401a19c:	012e012e 	.word	0x012e012e
3401a1a0:	00e8012e 	.word	0x00e8012e
3401a1a4:	012e00ec 	.word	0x012e00ec
3401a1a8:	012e012e 	.word	0x012e012e
3401a1ac:	012e012e 	.word	0x012e012e
3401a1b0:	012e012e 	.word	0x012e012e
3401a1b4:	012e012e 	.word	0x012e012e
3401a1b8:	012e012e 	.word	0x012e012e
3401a1bc:	012e012e 	.word	0x012e012e
3401a1c0:	010800ee 	.word	0x010800ee
3401a1c4:	00f200f0 	.word	0x00f200f0
3401a1c8:	012e012e 	.word	0x012e012e
3401a1cc:	00f4012e 	.word	0x00f4012e
3401a1d0:	012e012e 	.word	0x012e012e
3401a1d4:	00f6012e 	.word	0x00f6012e
3401a1d8:	012e012e 	.word	0x012e012e
3401a1dc:	012e00fa 	.word	0x012e00fa
3401a1e0:	00fc012e 	.word	0x00fc012e
3401a1e4:	012e012e 	.word	0x012e012e
3401a1e8:	012e012e 	.word	0x012e012e
3401a1ec:	012e012e 	.word	0x012e012e
3401a1f0:	012e012e 	.word	0x012e012e
3401a1f4:	012e012e 	.word	0x012e012e
3401a1f8:	012e00fe 	.word	0x012e00fe
3401a1fc:	01020100 	.word	0x01020100
3401a200:	012e0104 	.word	0x012e0104
3401a204:	0126012e 	.word	0x0126012e
3401a208:	012e012e 	.word	0x012e012e
3401a20c:	012e012e 	.word	0x012e012e
3401a210:	012e012e 	.word	0x012e012e
3401a214:	012e012e 	.word	0x012e012e
3401a218:	01060114 	.word	0x01060114
3401a21c:	010c010a 	.word	0x010c010a
3401a220:	0110010e 	.word	0x0110010e
3401a224:	0112012e 	.word	0x0112012e
3401a228:	011a0116 	.word	0x011a0116
3401a22c:	00c200ea 	.word	0x00c200ea
3401a230:	00ba012c 	.word	0x00ba012c
3401a234:	00bc00d0 	.word	0x00bc00d0
3401a238:	00a600a0 	.word	0x00a600a0
3401a23c:	00f8012a 	.word	0x00f8012a
3401a240:	0118012e 	.word	0x0118012e
3401a244:	011e00c4 	.word	0x011e00c4
3401a248:	012e011c 	.word	0x012e011c
3401a24c:	012e012e 	.word	0x012e012e
3401a250:	012e012e 	.word	0x012e012e
3401a254:	012e00d4 	.word	0x012e00d4
3401a258:	012e012e 	.word	0x012e012e
3401a25c:	012800e6 	.word	0x012800e6
3401a260:	01220120 	.word	0x01220120
3401a264:	0124      	.short	0x0124
3401a266:	4b55      	ldr	r3, [pc, #340]	@ (3401a3bc <_strerror_r+0x288>)
3401a268:	4618      	mov	r0, r3
3401a26a:	bd10      	pop	{r4, pc}
3401a26c:	4b54      	ldr	r3, [pc, #336]	@ (3401a3c0 <_strerror_r+0x28c>)
3401a26e:	e7fb      	b.n	3401a268 <_strerror_r+0x134>
3401a270:	4b54      	ldr	r3, [pc, #336]	@ (3401a3c4 <_strerror_r+0x290>)
3401a272:	e7f9      	b.n	3401a268 <_strerror_r+0x134>
3401a274:	4b54      	ldr	r3, [pc, #336]	@ (3401a3c8 <_strerror_r+0x294>)
3401a276:	e7f7      	b.n	3401a268 <_strerror_r+0x134>
3401a278:	4b54      	ldr	r3, [pc, #336]	@ (3401a3cc <_strerror_r+0x298>)
3401a27a:	e7f5      	b.n	3401a268 <_strerror_r+0x134>
3401a27c:	4b54      	ldr	r3, [pc, #336]	@ (3401a3d0 <_strerror_r+0x29c>)
3401a27e:	e7f3      	b.n	3401a268 <_strerror_r+0x134>
3401a280:	4b54      	ldr	r3, [pc, #336]	@ (3401a3d4 <_strerror_r+0x2a0>)
3401a282:	e7f1      	b.n	3401a268 <_strerror_r+0x134>
3401a284:	4b54      	ldr	r3, [pc, #336]	@ (3401a3d8 <_strerror_r+0x2a4>)
3401a286:	e7ef      	b.n	3401a268 <_strerror_r+0x134>
3401a288:	4b54      	ldr	r3, [pc, #336]	@ (3401a3dc <_strerror_r+0x2a8>)
3401a28a:	e7ed      	b.n	3401a268 <_strerror_r+0x134>
3401a28c:	4b54      	ldr	r3, [pc, #336]	@ (3401a3e0 <_strerror_r+0x2ac>)
3401a28e:	e7eb      	b.n	3401a268 <_strerror_r+0x134>
3401a290:	4b54      	ldr	r3, [pc, #336]	@ (3401a3e4 <_strerror_r+0x2b0>)
3401a292:	e7e9      	b.n	3401a268 <_strerror_r+0x134>
3401a294:	4b54      	ldr	r3, [pc, #336]	@ (3401a3e8 <_strerror_r+0x2b4>)
3401a296:	e7e7      	b.n	3401a268 <_strerror_r+0x134>
3401a298:	4b54      	ldr	r3, [pc, #336]	@ (3401a3ec <_strerror_r+0x2b8>)
3401a29a:	e7e5      	b.n	3401a268 <_strerror_r+0x134>
3401a29c:	4b54      	ldr	r3, [pc, #336]	@ (3401a3f0 <_strerror_r+0x2bc>)
3401a29e:	e7e3      	b.n	3401a268 <_strerror_r+0x134>
3401a2a0:	4b54      	ldr	r3, [pc, #336]	@ (3401a3f4 <_strerror_r+0x2c0>)
3401a2a2:	e7e1      	b.n	3401a268 <_strerror_r+0x134>
3401a2a4:	4b54      	ldr	r3, [pc, #336]	@ (3401a3f8 <_strerror_r+0x2c4>)
3401a2a6:	e7df      	b.n	3401a268 <_strerror_r+0x134>
3401a2a8:	4b54      	ldr	r3, [pc, #336]	@ (3401a3fc <_strerror_r+0x2c8>)
3401a2aa:	e7dd      	b.n	3401a268 <_strerror_r+0x134>
3401a2ac:	4b54      	ldr	r3, [pc, #336]	@ (3401a400 <_strerror_r+0x2cc>)
3401a2ae:	e7db      	b.n	3401a268 <_strerror_r+0x134>
3401a2b0:	4b54      	ldr	r3, [pc, #336]	@ (3401a404 <_strerror_r+0x2d0>)
3401a2b2:	e7d9      	b.n	3401a268 <_strerror_r+0x134>
3401a2b4:	4b54      	ldr	r3, [pc, #336]	@ (3401a408 <_strerror_r+0x2d4>)
3401a2b6:	e7d7      	b.n	3401a268 <_strerror_r+0x134>
3401a2b8:	4b54      	ldr	r3, [pc, #336]	@ (3401a40c <_strerror_r+0x2d8>)
3401a2ba:	e7d5      	b.n	3401a268 <_strerror_r+0x134>
3401a2bc:	4b54      	ldr	r3, [pc, #336]	@ (3401a410 <_strerror_r+0x2dc>)
3401a2be:	e7d3      	b.n	3401a268 <_strerror_r+0x134>
3401a2c0:	4b54      	ldr	r3, [pc, #336]	@ (3401a414 <_strerror_r+0x2e0>)
3401a2c2:	e7d1      	b.n	3401a268 <_strerror_r+0x134>
3401a2c4:	4b54      	ldr	r3, [pc, #336]	@ (3401a418 <_strerror_r+0x2e4>)
3401a2c6:	e7cf      	b.n	3401a268 <_strerror_r+0x134>
3401a2c8:	4b54      	ldr	r3, [pc, #336]	@ (3401a41c <_strerror_r+0x2e8>)
3401a2ca:	e7cd      	b.n	3401a268 <_strerror_r+0x134>
3401a2cc:	4b54      	ldr	r3, [pc, #336]	@ (3401a420 <_strerror_r+0x2ec>)
3401a2ce:	e7cb      	b.n	3401a268 <_strerror_r+0x134>
3401a2d0:	4b54      	ldr	r3, [pc, #336]	@ (3401a424 <_strerror_r+0x2f0>)
3401a2d2:	e7c9      	b.n	3401a268 <_strerror_r+0x134>
3401a2d4:	4b54      	ldr	r3, [pc, #336]	@ (3401a428 <_strerror_r+0x2f4>)
3401a2d6:	e7c7      	b.n	3401a268 <_strerror_r+0x134>
3401a2d8:	4b54      	ldr	r3, [pc, #336]	@ (3401a42c <_strerror_r+0x2f8>)
3401a2da:	e7c5      	b.n	3401a268 <_strerror_r+0x134>
3401a2dc:	4b54      	ldr	r3, [pc, #336]	@ (3401a430 <_strerror_r+0x2fc>)
3401a2de:	e7c3      	b.n	3401a268 <_strerror_r+0x134>
3401a2e0:	4b54      	ldr	r3, [pc, #336]	@ (3401a434 <_strerror_r+0x300>)
3401a2e2:	e7c1      	b.n	3401a268 <_strerror_r+0x134>
3401a2e4:	4b54      	ldr	r3, [pc, #336]	@ (3401a438 <_strerror_r+0x304>)
3401a2e6:	e7bf      	b.n	3401a268 <_strerror_r+0x134>
3401a2e8:	4b54      	ldr	r3, [pc, #336]	@ (3401a43c <_strerror_r+0x308>)
3401a2ea:	e7bd      	b.n	3401a268 <_strerror_r+0x134>
3401a2ec:	4b54      	ldr	r3, [pc, #336]	@ (3401a440 <_strerror_r+0x30c>)
3401a2ee:	e7bb      	b.n	3401a268 <_strerror_r+0x134>
3401a2f0:	4b54      	ldr	r3, [pc, #336]	@ (3401a444 <_strerror_r+0x310>)
3401a2f2:	e7b9      	b.n	3401a268 <_strerror_r+0x134>
3401a2f4:	4b54      	ldr	r3, [pc, #336]	@ (3401a448 <_strerror_r+0x314>)
3401a2f6:	e7b7      	b.n	3401a268 <_strerror_r+0x134>
3401a2f8:	4b54      	ldr	r3, [pc, #336]	@ (3401a44c <_strerror_r+0x318>)
3401a2fa:	e7b5      	b.n	3401a268 <_strerror_r+0x134>
3401a2fc:	4b54      	ldr	r3, [pc, #336]	@ (3401a450 <_strerror_r+0x31c>)
3401a2fe:	e7b3      	b.n	3401a268 <_strerror_r+0x134>
3401a300:	4b54      	ldr	r3, [pc, #336]	@ (3401a454 <_strerror_r+0x320>)
3401a302:	e7b1      	b.n	3401a268 <_strerror_r+0x134>
3401a304:	4b54      	ldr	r3, [pc, #336]	@ (3401a458 <_strerror_r+0x324>)
3401a306:	e7af      	b.n	3401a268 <_strerror_r+0x134>
3401a308:	4b54      	ldr	r3, [pc, #336]	@ (3401a45c <_strerror_r+0x328>)
3401a30a:	e7ad      	b.n	3401a268 <_strerror_r+0x134>
3401a30c:	4b54      	ldr	r3, [pc, #336]	@ (3401a460 <_strerror_r+0x32c>)
3401a30e:	e7ab      	b.n	3401a268 <_strerror_r+0x134>
3401a310:	4b54      	ldr	r3, [pc, #336]	@ (3401a464 <_strerror_r+0x330>)
3401a312:	e7a9      	b.n	3401a268 <_strerror_r+0x134>
3401a314:	4b54      	ldr	r3, [pc, #336]	@ (3401a468 <_strerror_r+0x334>)
3401a316:	e7a7      	b.n	3401a268 <_strerror_r+0x134>
3401a318:	4b54      	ldr	r3, [pc, #336]	@ (3401a46c <_strerror_r+0x338>)
3401a31a:	e7a5      	b.n	3401a268 <_strerror_r+0x134>
3401a31c:	4b54      	ldr	r3, [pc, #336]	@ (3401a470 <_strerror_r+0x33c>)
3401a31e:	e7a3      	b.n	3401a268 <_strerror_r+0x134>
3401a320:	4b54      	ldr	r3, [pc, #336]	@ (3401a474 <_strerror_r+0x340>)
3401a322:	e7a1      	b.n	3401a268 <_strerror_r+0x134>
3401a324:	4b54      	ldr	r3, [pc, #336]	@ (3401a478 <_strerror_r+0x344>)
3401a326:	e79f      	b.n	3401a268 <_strerror_r+0x134>
3401a328:	4b54      	ldr	r3, [pc, #336]	@ (3401a47c <_strerror_r+0x348>)
3401a32a:	e79d      	b.n	3401a268 <_strerror_r+0x134>
3401a32c:	4b54      	ldr	r3, [pc, #336]	@ (3401a480 <_strerror_r+0x34c>)
3401a32e:	e79b      	b.n	3401a268 <_strerror_r+0x134>
3401a330:	4b54      	ldr	r3, [pc, #336]	@ (3401a484 <_strerror_r+0x350>)
3401a332:	e799      	b.n	3401a268 <_strerror_r+0x134>
3401a334:	4b54      	ldr	r3, [pc, #336]	@ (3401a488 <_strerror_r+0x354>)
3401a336:	e797      	b.n	3401a268 <_strerror_r+0x134>
3401a338:	4b54      	ldr	r3, [pc, #336]	@ (3401a48c <_strerror_r+0x358>)
3401a33a:	e795      	b.n	3401a268 <_strerror_r+0x134>
3401a33c:	4b54      	ldr	r3, [pc, #336]	@ (3401a490 <_strerror_r+0x35c>)
3401a33e:	e793      	b.n	3401a268 <_strerror_r+0x134>
3401a340:	4b54      	ldr	r3, [pc, #336]	@ (3401a494 <_strerror_r+0x360>)
3401a342:	e791      	b.n	3401a268 <_strerror_r+0x134>
3401a344:	4b54      	ldr	r3, [pc, #336]	@ (3401a498 <_strerror_r+0x364>)
3401a346:	e78f      	b.n	3401a268 <_strerror_r+0x134>
3401a348:	4b54      	ldr	r3, [pc, #336]	@ (3401a49c <_strerror_r+0x368>)
3401a34a:	e78d      	b.n	3401a268 <_strerror_r+0x134>
3401a34c:	4b54      	ldr	r3, [pc, #336]	@ (3401a4a0 <_strerror_r+0x36c>)
3401a34e:	e78b      	b.n	3401a268 <_strerror_r+0x134>
3401a350:	4b54      	ldr	r3, [pc, #336]	@ (3401a4a4 <_strerror_r+0x370>)
3401a352:	e789      	b.n	3401a268 <_strerror_r+0x134>
3401a354:	4b54      	ldr	r3, [pc, #336]	@ (3401a4a8 <_strerror_r+0x374>)
3401a356:	e787      	b.n	3401a268 <_strerror_r+0x134>
3401a358:	4b54      	ldr	r3, [pc, #336]	@ (3401a4ac <_strerror_r+0x378>)
3401a35a:	e785      	b.n	3401a268 <_strerror_r+0x134>
3401a35c:	4b54      	ldr	r3, [pc, #336]	@ (3401a4b0 <_strerror_r+0x37c>)
3401a35e:	e783      	b.n	3401a268 <_strerror_r+0x134>
3401a360:	4b54      	ldr	r3, [pc, #336]	@ (3401a4b4 <_strerror_r+0x380>)
3401a362:	e781      	b.n	3401a268 <_strerror_r+0x134>
3401a364:	4b54      	ldr	r3, [pc, #336]	@ (3401a4b8 <_strerror_r+0x384>)
3401a366:	e77f      	b.n	3401a268 <_strerror_r+0x134>
3401a368:	4b54      	ldr	r3, [pc, #336]	@ (3401a4bc <_strerror_r+0x388>)
3401a36a:	e77d      	b.n	3401a268 <_strerror_r+0x134>
3401a36c:	4b54      	ldr	r3, [pc, #336]	@ (3401a4c0 <_strerror_r+0x38c>)
3401a36e:	e77b      	b.n	3401a268 <_strerror_r+0x134>
3401a370:	4b54      	ldr	r3, [pc, #336]	@ (3401a4c4 <_strerror_r+0x390>)
3401a372:	e779      	b.n	3401a268 <_strerror_r+0x134>
3401a374:	4b54      	ldr	r3, [pc, #336]	@ (3401a4c8 <_strerror_r+0x394>)
3401a376:	e777      	b.n	3401a268 <_strerror_r+0x134>
3401a378:	4b54      	ldr	r3, [pc, #336]	@ (3401a4cc <_strerror_r+0x398>)
3401a37a:	e775      	b.n	3401a268 <_strerror_r+0x134>
3401a37c:	4b54      	ldr	r3, [pc, #336]	@ (3401a4d0 <_strerror_r+0x39c>)
3401a37e:	e773      	b.n	3401a268 <_strerror_r+0x134>
3401a380:	4b54      	ldr	r3, [pc, #336]	@ (3401a4d4 <_strerror_r+0x3a0>)
3401a382:	e771      	b.n	3401a268 <_strerror_r+0x134>
3401a384:	4b54      	ldr	r3, [pc, #336]	@ (3401a4d8 <_strerror_r+0x3a4>)
3401a386:	e76f      	b.n	3401a268 <_strerror_r+0x134>
3401a388:	4b54      	ldr	r3, [pc, #336]	@ (3401a4dc <_strerror_r+0x3a8>)
3401a38a:	e76d      	b.n	3401a268 <_strerror_r+0x134>
3401a38c:	4b54      	ldr	r3, [pc, #336]	@ (3401a4e0 <_strerror_r+0x3ac>)
3401a38e:	e76b      	b.n	3401a268 <_strerror_r+0x134>
3401a390:	4b54      	ldr	r3, [pc, #336]	@ (3401a4e4 <_strerror_r+0x3b0>)
3401a392:	e769      	b.n	3401a268 <_strerror_r+0x134>
3401a394:	4b54      	ldr	r3, [pc, #336]	@ (3401a4e8 <_strerror_r+0x3b4>)
3401a396:	e767      	b.n	3401a268 <_strerror_r+0x134>
3401a398:	4b54      	ldr	r3, [pc, #336]	@ (3401a4ec <_strerror_r+0x3b8>)
3401a39a:	e765      	b.n	3401a268 <_strerror_r+0x134>
3401a39c:	4b54      	ldr	r3, [pc, #336]	@ (3401a4f0 <_strerror_r+0x3bc>)
3401a39e:	e763      	b.n	3401a268 <_strerror_r+0x134>
3401a3a0:	4b54      	ldr	r3, [pc, #336]	@ (3401a4f4 <_strerror_r+0x3c0>)
3401a3a2:	e761      	b.n	3401a268 <_strerror_r+0x134>
3401a3a4:	2a00      	cmp	r2, #0
3401a3a6:	bf08      	it	eq
3401a3a8:	4622      	moveq	r2, r4
3401a3aa:	f000 f8b3 	bl	3401a514 <_user_strerror>
3401a3ae:	4b52      	ldr	r3, [pc, #328]	@ (3401a4f8 <_strerror_r+0x3c4>)
3401a3b0:	2800      	cmp	r0, #0
3401a3b2:	bf18      	it	ne
3401a3b4:	4603      	movne	r3, r0
3401a3b6:	e757      	b.n	3401a268 <_strerror_r+0x134>
3401a3b8:	4b50      	ldr	r3, [pc, #320]	@ (3401a4fc <_strerror_r+0x3c8>)
3401a3ba:	e755      	b.n	3401a268 <_strerror_r+0x134>
3401a3bc:	34022658 	.word	0x34022658
3401a3c0:	3402266a 	.word	0x3402266a
3401a3c4:	34022684 	.word	0x34022684
3401a3c8:	34022694 	.word	0x34022694
3401a3cc:	340226ac 	.word	0x340226ac
3401a3d0:	340226b6 	.word	0x340226b6
3401a3d4:	340226d0 	.word	0x340226d0
3401a3d8:	340226e2 	.word	0x340226e2
3401a3dc:	340226f4 	.word	0x340226f4
3401a3e0:	3402270d 	.word	0x3402270d
3401a3e4:	3402271d 	.word	0x3402271d
3401a3e8:	34022729 	.word	0x34022729
3401a3ec:	34022746 	.word	0x34022746
3401a3f0:	34022758 	.word	0x34022758
3401a3f4:	34022769 	.word	0x34022769
3401a3f8:	3402277b 	.word	0x3402277b
3401a3fc:	34022787 	.word	0x34022787
3401a400:	3402279f 	.word	0x3402279f
3401a404:	340227ab 	.word	0x340227ab
3401a408:	340227bd 	.word	0x340227bd
3401a40c:	340227cc 	.word	0x340227cc
3401a410:	340227dc 	.word	0x340227dc
3401a414:	340227e9 	.word	0x340227e9
3401a418:	34022808 	.word	0x34022808
3401a41c:	34022817 	.word	0x34022817
3401a420:	34022828 	.word	0x34022828
3401a424:	3402284c 	.word	0x3402284c
3401a428:	3402286a 	.word	0x3402286a
3401a42c:	34022888 	.word	0x34022888
3401a430:	340228a8 	.word	0x340228a8
3401a434:	340228bf 	.word	0x340228bf
3401a438:	340228ce 	.word	0x340228ce
3401a43c:	340228dd 	.word	0x340228dd
3401a440:	340228f1 	.word	0x340228f1
3401a444:	34022909 	.word	0x34022909
3401a448:	34022917 	.word	0x34022917
3401a44c:	34022924 	.word	0x34022924
3401a450:	3402293a 	.word	0x3402293a
3401a454:	34022949 	.word	0x34022949
3401a458:	34022955 	.word	0x34022955
3401a45c:	34022984 	.word	0x34022984
3401a460:	34022995 	.word	0x34022995
3401a464:	340229b0 	.word	0x340229b0
3401a468:	340229c3 	.word	0x340229c3
3401a46c:	340229d9 	.word	0x340229d9
3401a470:	340229e2 	.word	0x340229e2
3401a474:	340229f9 	.word	0x340229f9
3401a478:	34022a01 	.word	0x34022a01
3401a47c:	34022a0e 	.word	0x34022a0e
3401a480:	34022a23 	.word	0x34022a23
3401a484:	34022a37 	.word	0x34022a37
3401a488:	34022a4f 	.word	0x34022a4f
3401a48c:	34022a5e 	.word	0x34022a5e
3401a490:	34022a6f 	.word	0x34022a6f
3401a494:	34022a82 	.word	0x34022a82
3401a498:	34022a8e 	.word	0x34022a8e
3401a49c:	34022aa7 	.word	0x34022aa7
3401a4a0:	34022abb 	.word	0x34022abb
3401a4a4:	34022ad6 	.word	0x34022ad6
3401a4a8:	34022aee 	.word	0x34022aee
3401a4ac:	34022b08 	.word	0x34022b08
3401a4b0:	34022b10 	.word	0x34022b10
3401a4b4:	34022b40 	.word	0x34022b40
3401a4b8:	34022b5f 	.word	0x34022b5f
3401a4bc:	34022b7e 	.word	0x34022b7e
3401a4c0:	34022b95 	.word	0x34022b95
3401a4c4:	34022ba8 	.word	0x34022ba8
3401a4c8:	34022bc1 	.word	0x34022bc1
3401a4cc:	34022bd8 	.word	0x34022bd8
3401a4d0:	34022bee 	.word	0x34022bee
3401a4d4:	34022c0f 	.word	0x34022c0f
3401a4d8:	34022c27 	.word	0x34022c27
3401a4dc:	34022c43 	.word	0x34022c43
3401a4e0:	34022c56 	.word	0x34022c56
3401a4e4:	34022c6c 	.word	0x34022c6c
3401a4e8:	34022c80 	.word	0x34022c80
3401a4ec:	34022ca2 	.word	0x34022ca2
3401a4f0:	34022cc8 	.word	0x34022cc8
3401a4f4:	34022cd9 	.word	0x34022cd9
3401a4f8:	3402118e 	.word	0x3402118e
3401a4fc:	34022660 	.word	0x34022660

3401a500 <strerror>:
3401a500:	4601      	mov	r1, r0
3401a502:	2300      	movs	r3, #0
3401a504:	4802      	ldr	r0, [pc, #8]	@ (3401a510 <strerror+0x10>)
3401a506:	461a      	mov	r2, r3
3401a508:	6800      	ldr	r0, [r0, #0]
3401a50a:	f7ff be13 	b.w	3401a134 <_strerror_r>
3401a50e:	bf00      	nop
3401a510:	340b1110 	.word	0x340b1110

3401a514 <_user_strerror>:
3401a514:	2000      	movs	r0, #0
3401a516:	4770      	bx	lr

3401a518 <_localeconv_r>:
3401a518:	4800      	ldr	r0, [pc, #0]	@ (3401a51c <_localeconv_r+0x4>)
3401a51a:	4770      	bx	lr
3401a51c:	340b1250 	.word	0x340b1250

3401a520 <_close_r>:
3401a520:	b538      	push	{r3, r4, r5, lr}
3401a522:	2300      	movs	r3, #0
3401a524:	4d05      	ldr	r5, [pc, #20]	@ (3401a53c <_close_r+0x1c>)
3401a526:	4604      	mov	r4, r0
3401a528:	4608      	mov	r0, r1
3401a52a:	602b      	str	r3, [r5, #0]
3401a52c:	f7e8 fd75 	bl	3400301a <_close>
3401a530:	1c43      	adds	r3, r0, #1
3401a532:	d102      	bne.n	3401a53a <_close_r+0x1a>
3401a534:	682b      	ldr	r3, [r5, #0]
3401a536:	b103      	cbz	r3, 3401a53a <_close_r+0x1a>
3401a538:	6023      	str	r3, [r4, #0]
3401a53a:	bd38      	pop	{r3, r4, r5, pc}
3401a53c:	340cf030 	.word	0x340cf030

3401a540 <_lseek_r>:
3401a540:	b538      	push	{r3, r4, r5, lr}
3401a542:	4604      	mov	r4, r0
3401a544:	4d06      	ldr	r5, [pc, #24]	@ (3401a560 <_lseek_r+0x20>)
3401a546:	4608      	mov	r0, r1
3401a548:	4611      	mov	r1, r2
3401a54a:	2200      	movs	r2, #0
3401a54c:	602a      	str	r2, [r5, #0]
3401a54e:	461a      	mov	r2, r3
3401a550:	f7e8 fd6d 	bl	3400302e <_lseek>
3401a554:	1c43      	adds	r3, r0, #1
3401a556:	d102      	bne.n	3401a55e <_lseek_r+0x1e>
3401a558:	682b      	ldr	r3, [r5, #0]
3401a55a:	b103      	cbz	r3, 3401a55e <_lseek_r+0x1e>
3401a55c:	6023      	str	r3, [r4, #0]
3401a55e:	bd38      	pop	{r3, r4, r5, pc}
3401a560:	340cf030 	.word	0x340cf030

3401a564 <_read_r>:
3401a564:	b538      	push	{r3, r4, r5, lr}
3401a566:	4604      	mov	r4, r0
3401a568:	4d06      	ldr	r5, [pc, #24]	@ (3401a584 <_read_r+0x20>)
3401a56a:	4608      	mov	r0, r1
3401a56c:	4611      	mov	r1, r2
3401a56e:	2200      	movs	r2, #0
3401a570:	602a      	str	r2, [r5, #0]
3401a572:	461a      	mov	r2, r3
3401a574:	f7e8 fd35 	bl	34002fe2 <_read>
3401a578:	1c43      	adds	r3, r0, #1
3401a57a:	d102      	bne.n	3401a582 <_read_r+0x1e>
3401a57c:	682b      	ldr	r3, [r5, #0]
3401a57e:	b103      	cbz	r3, 3401a582 <_read_r+0x1e>
3401a580:	6023      	str	r3, [r4, #0]
3401a582:	bd38      	pop	{r3, r4, r5, pc}
3401a584:	340cf030 	.word	0x340cf030

3401a588 <_sbrk_r>:
3401a588:	b538      	push	{r3, r4, r5, lr}
3401a58a:	2300      	movs	r3, #0
3401a58c:	4d05      	ldr	r5, [pc, #20]	@ (3401a5a4 <_sbrk_r+0x1c>)
3401a58e:	4604      	mov	r4, r0
3401a590:	4608      	mov	r0, r1
3401a592:	602b      	str	r3, [r5, #0]
3401a594:	f002 fdd8 	bl	3401d148 <_sbrk>
3401a598:	1c43      	adds	r3, r0, #1
3401a59a:	d102      	bne.n	3401a5a2 <_sbrk_r+0x1a>
3401a59c:	682b      	ldr	r3, [r5, #0]
3401a59e:	b103      	cbz	r3, 3401a5a2 <_sbrk_r+0x1a>
3401a5a0:	6023      	str	r3, [r4, #0]
3401a5a2:	bd38      	pop	{r3, r4, r5, pc}
3401a5a4:	340cf030 	.word	0x340cf030

3401a5a8 <_write_r>:
3401a5a8:	b538      	push	{r3, r4, r5, lr}
3401a5aa:	4604      	mov	r4, r0
3401a5ac:	4d06      	ldr	r5, [pc, #24]	@ (3401a5c8 <_write_r+0x20>)
3401a5ae:	4608      	mov	r0, r1
3401a5b0:	4611      	mov	r1, r2
3401a5b2:	2200      	movs	r2, #0
3401a5b4:	602a      	str	r2, [r5, #0]
3401a5b6:	461a      	mov	r2, r3
3401a5b8:	f7e8 fd21 	bl	34002ffe <_write>
3401a5bc:	1c43      	adds	r3, r0, #1
3401a5be:	d102      	bne.n	3401a5c6 <_write_r+0x1e>
3401a5c0:	682b      	ldr	r3, [r5, #0]
3401a5c2:	b103      	cbz	r3, 3401a5c6 <_write_r+0x1e>
3401a5c4:	6023      	str	r3, [r4, #0]
3401a5c6:	bd38      	pop	{r3, r4, r5, pc}
3401a5c8:	340cf030 	.word	0x340cf030

3401a5cc <__errno>:
3401a5cc:	4b01      	ldr	r3, [pc, #4]	@ (3401a5d4 <__errno+0x8>)
3401a5ce:	6818      	ldr	r0, [r3, #0]
3401a5d0:	4770      	bx	lr
3401a5d2:	bf00      	nop
3401a5d4:	340b1110 	.word	0x340b1110

3401a5d8 <__libc_init_array>:
3401a5d8:	b570      	push	{r4, r5, r6, lr}
3401a5da:	4d0d      	ldr	r5, [pc, #52]	@ (3401a610 <__libc_init_array+0x38>)
3401a5dc:	2600      	movs	r6, #0
3401a5de:	4c0d      	ldr	r4, [pc, #52]	@ (3401a614 <__libc_init_array+0x3c>)
3401a5e0:	1b64      	subs	r4, r4, r5
3401a5e2:	10a4      	asrs	r4, r4, #2
3401a5e4:	42a6      	cmp	r6, r4
3401a5e6:	d109      	bne.n	3401a5fc <__libc_init_array+0x24>
3401a5e8:	4d0b      	ldr	r5, [pc, #44]	@ (3401a618 <__libc_init_array+0x40>)
3401a5ea:	2600      	movs	r6, #0
3401a5ec:	4c0b      	ldr	r4, [pc, #44]	@ (3401a61c <__libc_init_array+0x44>)
3401a5ee:	f002 fdb9 	bl	3401d164 <_init>
3401a5f2:	1b64      	subs	r4, r4, r5
3401a5f4:	10a4      	asrs	r4, r4, #2
3401a5f6:	42a6      	cmp	r6, r4
3401a5f8:	d105      	bne.n	3401a606 <__libc_init_array+0x2e>
3401a5fa:	bd70      	pop	{r4, r5, r6, pc}
3401a5fc:	f855 3b04 	ldr.w	r3, [r5], #4
3401a600:	3601      	adds	r6, #1
3401a602:	4798      	blx	r3
3401a604:	e7ee      	b.n	3401a5e4 <__libc_init_array+0xc>
3401a606:	f855 3b04 	ldr.w	r3, [r5], #4
3401a60a:	3601      	adds	r6, #1
3401a60c:	4798      	blx	r3
3401a60e:	e7f2      	b.n	3401a5f6 <__libc_init_array+0x1e>
3401a610:	340b0edc 	.word	0x340b0edc
3401a614:	340b0edc 	.word	0x340b0edc
3401a618:	340b0edc 	.word	0x340b0edc
3401a61c:	340b0ee0 	.word	0x340b0ee0

3401a620 <__retarget_lock_init_recursive>:
3401a620:	4770      	bx	lr

3401a622 <__retarget_lock_acquire_recursive>:
3401a622:	4770      	bx	lr

3401a624 <__retarget_lock_release_recursive>:
3401a624:	4770      	bx	lr

3401a626 <strcpy>:
3401a626:	4603      	mov	r3, r0
3401a628:	f811 2b01 	ldrb.w	r2, [r1], #1
3401a62c:	f803 2b01 	strb.w	r2, [r3], #1
3401a630:	2a00      	cmp	r2, #0
3401a632:	d1f9      	bne.n	3401a628 <strcpy+0x2>
3401a634:	4770      	bx	lr

3401a636 <memchr>:
3401a636:	b2c9      	uxtb	r1, r1
3401a638:	4603      	mov	r3, r0
3401a63a:	4402      	add	r2, r0
3401a63c:	b510      	push	{r4, lr}
3401a63e:	4293      	cmp	r3, r2
3401a640:	4618      	mov	r0, r3
3401a642:	d101      	bne.n	3401a648 <memchr+0x12>
3401a644:	2000      	movs	r0, #0
3401a646:	e003      	b.n	3401a650 <memchr+0x1a>
3401a648:	7804      	ldrb	r4, [r0, #0]
3401a64a:	3301      	adds	r3, #1
3401a64c:	428c      	cmp	r4, r1
3401a64e:	d1f6      	bne.n	3401a63e <memchr+0x8>
3401a650:	bd10      	pop	{r4, pc}

3401a652 <memcpy>:
3401a652:	440a      	add	r2, r1
3401a654:	1e43      	subs	r3, r0, #1
3401a656:	4291      	cmp	r1, r2
3401a658:	d100      	bne.n	3401a65c <memcpy+0xa>
3401a65a:	4770      	bx	lr
3401a65c:	b510      	push	{r4, lr}
3401a65e:	f811 4b01 	ldrb.w	r4, [r1], #1
3401a662:	4291      	cmp	r1, r2
3401a664:	f803 4f01 	strb.w	r4, [r3, #1]!
3401a668:	d1f9      	bne.n	3401a65e <memcpy+0xc>
3401a66a:	bd10      	pop	{r4, pc}

3401a66c <abort>:
3401a66c:	2006      	movs	r0, #6
3401a66e:	b508      	push	{r3, lr}
3401a670:	f001 fd94 	bl	3401c19c <raise>
3401a674:	2001      	movs	r0, #1
3401a676:	f7e8 fcae 	bl	34002fd6 <_exit>

3401a67a <quorem>:
3401a67a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401a67e:	6903      	ldr	r3, [r0, #16]
3401a680:	4607      	mov	r7, r0
3401a682:	690c      	ldr	r4, [r1, #16]
3401a684:	42a3      	cmp	r3, r4
3401a686:	f2c0 8083 	blt.w	3401a790 <quorem+0x116>
3401a68a:	3c01      	subs	r4, #1
3401a68c:	f100 0514 	add.w	r5, r0, #20
3401a690:	f101 0814 	add.w	r8, r1, #20
3401a694:	00a3      	lsls	r3, r4, #2
3401a696:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
3401a69a:	eb08 0984 	add.w	r9, r8, r4, lsl #2
3401a69e:	9300      	str	r3, [sp, #0]
3401a6a0:	eb05 0384 	add.w	r3, r5, r4, lsl #2
3401a6a4:	9301      	str	r3, [sp, #4]
3401a6a6:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
3401a6aa:	3301      	adds	r3, #1
3401a6ac:	429a      	cmp	r2, r3
3401a6ae:	fbb2 f6f3 	udiv	r6, r2, r3
3401a6b2:	d331      	bcc.n	3401a718 <quorem+0x9e>
3401a6b4:	f04f 0a00 	mov.w	sl, #0
3401a6b8:	46c4      	mov	ip, r8
3401a6ba:	46ae      	mov	lr, r5
3401a6bc:	46d3      	mov	fp, sl
3401a6be:	f85c 3b04 	ldr.w	r3, [ip], #4
3401a6c2:	b298      	uxth	r0, r3
3401a6c4:	45e1      	cmp	r9, ip
3401a6c6:	ea4f 4313 	mov.w	r3, r3, lsr #16
3401a6ca:	fb06 a000 	mla	r0, r6, r0, sl
3401a6ce:	ea4f 4210 	mov.w	r2, r0, lsr #16
3401a6d2:	b280      	uxth	r0, r0
3401a6d4:	fb06 2303 	mla	r3, r6, r3, r2
3401a6d8:	f8de 2000 	ldr.w	r2, [lr]
3401a6dc:	b292      	uxth	r2, r2
3401a6de:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3401a6e2:	eba2 0200 	sub.w	r2, r2, r0
3401a6e6:	b29b      	uxth	r3, r3
3401a6e8:	f8de 0000 	ldr.w	r0, [lr]
3401a6ec:	445a      	add	r2, fp
3401a6ee:	ebc3 4322 	rsb	r3, r3, r2, asr #16
3401a6f2:	b292      	uxth	r2, r2
3401a6f4:	eb03 4310 	add.w	r3, r3, r0, lsr #16
3401a6f8:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
3401a6fc:	ea4f 4b23 	mov.w	fp, r3, asr #16
3401a700:	f84e 2b04 	str.w	r2, [lr], #4
3401a704:	d2db      	bcs.n	3401a6be <quorem+0x44>
3401a706:	9b00      	ldr	r3, [sp, #0]
3401a708:	58eb      	ldr	r3, [r5, r3]
3401a70a:	b92b      	cbnz	r3, 3401a718 <quorem+0x9e>
3401a70c:	9b01      	ldr	r3, [sp, #4]
3401a70e:	3b04      	subs	r3, #4
3401a710:	429d      	cmp	r5, r3
3401a712:	461a      	mov	r2, r3
3401a714:	d330      	bcc.n	3401a778 <quorem+0xfe>
3401a716:	613c      	str	r4, [r7, #16]
3401a718:	4638      	mov	r0, r7
3401a71a:	f001 f85b 	bl	3401b7d4 <__mcmp>
3401a71e:	2800      	cmp	r0, #0
3401a720:	db26      	blt.n	3401a770 <quorem+0xf6>
3401a722:	4629      	mov	r1, r5
3401a724:	2000      	movs	r0, #0
3401a726:	f858 2b04 	ldr.w	r2, [r8], #4
3401a72a:	f8d1 c000 	ldr.w	ip, [r1]
3401a72e:	fa1f fe82 	uxth.w	lr, r2
3401a732:	45c1      	cmp	r9, r8
3401a734:	fa1f f38c 	uxth.w	r3, ip
3401a738:	ea4f 4212 	mov.w	r2, r2, lsr #16
3401a73c:	eba3 030e 	sub.w	r3, r3, lr
3401a740:	4403      	add	r3, r0
3401a742:	ebc2 4223 	rsb	r2, r2, r3, asr #16
3401a746:	b29b      	uxth	r3, r3
3401a748:	eb02 421c 	add.w	r2, r2, ip, lsr #16
3401a74c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3401a750:	ea4f 4022 	mov.w	r0, r2, asr #16
3401a754:	f841 3b04 	str.w	r3, [r1], #4
3401a758:	d2e5      	bcs.n	3401a726 <quorem+0xac>
3401a75a:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
3401a75e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
3401a762:	b922      	cbnz	r2, 3401a76e <quorem+0xf4>
3401a764:	3b04      	subs	r3, #4
3401a766:	429d      	cmp	r5, r3
3401a768:	461a      	mov	r2, r3
3401a76a:	d30b      	bcc.n	3401a784 <quorem+0x10a>
3401a76c:	613c      	str	r4, [r7, #16]
3401a76e:	3601      	adds	r6, #1
3401a770:	4630      	mov	r0, r6
3401a772:	b003      	add	sp, #12
3401a774:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401a778:	6812      	ldr	r2, [r2, #0]
3401a77a:	3b04      	subs	r3, #4
3401a77c:	2a00      	cmp	r2, #0
3401a77e:	d1ca      	bne.n	3401a716 <quorem+0x9c>
3401a780:	3c01      	subs	r4, #1
3401a782:	e7c5      	b.n	3401a710 <quorem+0x96>
3401a784:	6812      	ldr	r2, [r2, #0]
3401a786:	3b04      	subs	r3, #4
3401a788:	2a00      	cmp	r2, #0
3401a78a:	d1ef      	bne.n	3401a76c <quorem+0xf2>
3401a78c:	3c01      	subs	r4, #1
3401a78e:	e7ea      	b.n	3401a766 <quorem+0xec>
3401a790:	2000      	movs	r0, #0
3401a792:	e7ee      	b.n	3401a772 <quorem+0xf8>
3401a794:	0000      	movs	r0, r0
	...

3401a798 <_dtoa_r>:
3401a798:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401a79c:	69c7      	ldr	r7, [r0, #28]
3401a79e:	4681      	mov	r9, r0
3401a7a0:	ed2d 8b02 	vpush	{d8}
3401a7a4:	b091      	sub	sp, #68	@ 0x44
3401a7a6:	ec55 4b10 	vmov	r4, r5, d0
3401a7aa:	9e1c      	ldr	r6, [sp, #112]	@ 0x70
3401a7ac:	9107      	str	r1, [sp, #28]
3401a7ae:	9209      	str	r2, [sp, #36]	@ 0x24
3401a7b0:	930d      	str	r3, [sp, #52]	@ 0x34
3401a7b2:	ed8d 0b02 	vstr	d0, [sp, #8]
3401a7b6:	b97f      	cbnz	r7, 3401a7d8 <_dtoa_r+0x40>
3401a7b8:	2010      	movs	r0, #16
3401a7ba:	f7fe fb6d 	bl	34018e98 <malloc>
3401a7be:	4602      	mov	r2, r0
3401a7c0:	f8c9 001c 	str.w	r0, [r9, #28]
3401a7c4:	b920      	cbnz	r0, 3401a7d0 <_dtoa_r+0x38>
3401a7c6:	4ba0      	ldr	r3, [pc, #640]	@ (3401aa48 <_dtoa_r+0x2b0>)
3401a7c8:	21ef      	movs	r1, #239	@ 0xef
3401a7ca:	48a0      	ldr	r0, [pc, #640]	@ (3401aa4c <_dtoa_r+0x2b4>)
3401a7cc:	f7fe fb46 	bl	34018e5c <__assert_func>
3401a7d0:	e9c0 7701 	strd	r7, r7, [r0, #4]
3401a7d4:	6007      	str	r7, [r0, #0]
3401a7d6:	60c7      	str	r7, [r0, #12]
3401a7d8:	f8d9 301c 	ldr.w	r3, [r9, #28]
3401a7dc:	6819      	ldr	r1, [r3, #0]
3401a7de:	b159      	cbz	r1, 3401a7f8 <_dtoa_r+0x60>
3401a7e0:	685a      	ldr	r2, [r3, #4]
3401a7e2:	2301      	movs	r3, #1
3401a7e4:	4648      	mov	r0, r9
3401a7e6:	4093      	lsls	r3, r2
3401a7e8:	604a      	str	r2, [r1, #4]
3401a7ea:	608b      	str	r3, [r1, #8]
3401a7ec:	f000 fdbc 	bl	3401b368 <_Bfree>
3401a7f0:	f8d9 301c 	ldr.w	r3, [r9, #28]
3401a7f4:	2200      	movs	r2, #0
3401a7f6:	601a      	str	r2, [r3, #0]
3401a7f8:	1e2b      	subs	r3, r5, #0
3401a7fa:	bfb7      	itett	lt
3401a7fc:	f023 4300 	biclt.w	r3, r3, #2147483648	@ 0x80000000
3401a800:	2300      	movge	r3, #0
3401a802:	2201      	movlt	r2, #1
3401a804:	9303      	strlt	r3, [sp, #12]
3401a806:	bfac      	ite	ge
3401a808:	6033      	strge	r3, [r6, #0]
3401a80a:	6032      	strlt	r2, [r6, #0]
3401a80c:	4b90      	ldr	r3, [pc, #576]	@ (3401aa50 <_dtoa_r+0x2b8>)
3401a80e:	9e03      	ldr	r6, [sp, #12]
3401a810:	43b3      	bics	r3, r6
3401a812:	d110      	bne.n	3401a836 <_dtoa_r+0x9e>
3401a814:	f242 730f 	movw	r3, #9999	@ 0x270f
3401a818:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
3401a81a:	6013      	str	r3, [r2, #0]
3401a81c:	f3c6 0313 	ubfx	r3, r6, #0, #20
3401a820:	4323      	orrs	r3, r4
3401a822:	f000 84e6 	beq.w	3401b1f2 <_dtoa_r+0xa5a>
3401a826:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
3401a828:	4f8a      	ldr	r7, [pc, #552]	@ (3401aa54 <_dtoa_r+0x2bc>)
3401a82a:	2b00      	cmp	r3, #0
3401a82c:	f000 84e8 	beq.w	3401b200 <_dtoa_r+0xa68>
3401a830:	1cfb      	adds	r3, r7, #3
3401a832:	f000 bce3 	b.w	3401b1fc <_dtoa_r+0xa64>
3401a836:	ed9d 8b02 	vldr	d8, [sp, #8]
3401a83a:	eeb5 8b40 	vcmp.f64	d8, #0.0
3401a83e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401a842:	d10a      	bne.n	3401a85a <_dtoa_r+0xc2>
3401a844:	2301      	movs	r3, #1
3401a846:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
3401a848:	6013      	str	r3, [r2, #0]
3401a84a:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
3401a84c:	b113      	cbz	r3, 3401a854 <_dtoa_r+0xbc>
3401a84e:	4b82      	ldr	r3, [pc, #520]	@ (3401aa58 <_dtoa_r+0x2c0>)
3401a850:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
3401a852:	6013      	str	r3, [r2, #0]
3401a854:	4f81      	ldr	r7, [pc, #516]	@ (3401aa5c <_dtoa_r+0x2c4>)
3401a856:	f000 bcd3 	b.w	3401b200 <_dtoa_r+0xa68>
3401a85a:	aa0e      	add	r2, sp, #56	@ 0x38
3401a85c:	eeb0 0b48 	vmov.f64	d0, d8
3401a860:	a90f      	add	r1, sp, #60	@ 0x3c
3401a862:	4648      	mov	r0, r9
3401a864:	f001 f86a 	bl	3401b93c <__d2b>
3401a868:	f3c6 530a 	ubfx	r3, r6, #20, #11
3401a86c:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
3401a86e:	9001      	str	r0, [sp, #4]
3401a870:	2b00      	cmp	r3, #0
3401a872:	d045      	beq.n	3401a900 <_dtoa_r+0x168>
3401a874:	ee18 1a90 	vmov	r1, s17
3401a878:	eeb0 7b48 	vmov.f64	d7, d8
3401a87c:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
3401a880:	2500      	movs	r5, #0
3401a882:	f3c1 0113 	ubfx	r1, r1, #0, #20
3401a886:	f041 517f 	orr.w	r1, r1, #1069547520	@ 0x3fc00000
3401a88a:	f441 1140 	orr.w	r1, r1, #3145728	@ 0x300000
3401a88e:	eeb7 6b08 	vmov.f64	d6, #120	@ 0x3fc00000  1.5
3401a892:	ee07 1a90 	vmov	s15, r1
3401a896:	ed9f 5b66 	vldr	d5, [pc, #408]	@ 3401aa30 <_dtoa_r+0x298>
3401a89a:	ee37 7b46 	vsub.f64	d7, d7, d6
3401a89e:	ed9f 6b66 	vldr	d6, [pc, #408]	@ 3401aa38 <_dtoa_r+0x2a0>
3401a8a2:	eea7 6b05 	vfma.f64	d6, d7, d5
3401a8a6:	ee07 3a90 	vmov	s15, r3
3401a8aa:	eeb8 4be7 	vcvt.f64.s32	d4, s15
3401a8ae:	ed9f 5b64 	vldr	d5, [pc, #400]	@ 3401aa40 <_dtoa_r+0x2a8>
3401a8b2:	eeb0 7b46 	vmov.f64	d7, d6
3401a8b6:	eea4 7b05 	vfma.f64	d7, d4, d5
3401a8ba:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
3401a8be:	eefd 6bc7 	vcvt.s32.f64	s13, d7
3401a8c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401a8c6:	ee16 8a90 	vmov	r8, s13
3401a8ca:	d508      	bpl.n	3401a8de <_dtoa_r+0x146>
3401a8cc:	eeb8 6be6 	vcvt.f64.s32	d6, s13
3401a8d0:	eeb4 6b47 	vcmp.f64	d6, d7
3401a8d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401a8d8:	bf18      	it	ne
3401a8da:	f108 38ff 	addne.w	r8, r8, #4294967295
3401a8de:	f1b8 0f16 	cmp.w	r8, #22
3401a8e2:	d82d      	bhi.n	3401a940 <_dtoa_r+0x1a8>
3401a8e4:	495e      	ldr	r1, [pc, #376]	@ (3401aa60 <_dtoa_r+0x2c8>)
3401a8e6:	eb01 01c8 	add.w	r1, r1, r8, lsl #3
3401a8ea:	ed91 7b00 	vldr	d7, [r1]
3401a8ee:	eeb4 8bc7 	vcmpe.f64	d8, d7
3401a8f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401a8f6:	d501      	bpl.n	3401a8fc <_dtoa_r+0x164>
3401a8f8:	f108 38ff 	add.w	r8, r8, #4294967295
3401a8fc:	2100      	movs	r1, #0
3401a8fe:	e020      	b.n	3401a942 <_dtoa_r+0x1aa>
3401a900:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
3401a902:	2501      	movs	r5, #1
3401a904:	4413      	add	r3, r2
3401a906:	f203 4132 	addw	r1, r3, #1074	@ 0x432
3401a90a:	2920      	cmp	r1, #32
3401a90c:	bfc9      	itett	gt
3401a90e:	f1c1 0140 	rsbgt	r1, r1, #64	@ 0x40
3401a912:	f1c1 0120 	rsble	r1, r1, #32
3401a916:	408e      	lslgt	r6, r1
3401a918:	f203 4112 	addwgt	r1, r3, #1042	@ 0x412
3401a91c:	bfd8      	it	le
3401a91e:	fa04 f101 	lslle.w	r1, r4, r1
3401a922:	f103 33ff 	add.w	r3, r3, #4294967295
3401a926:	bfc4      	itt	gt
3401a928:	fa24 f101 	lsrgt.w	r1, r4, r1
3401a92c:	4331      	orrgt	r1, r6
3401a92e:	ee07 1a90 	vmov	s15, r1
3401a932:	eeb8 7b67 	vcvt.f64.u32	d7, s15
3401a936:	ee17 1a90 	vmov	r1, s15
3401a93a:	f1a1 71f8 	sub.w	r1, r1, #32505856	@ 0x1f00000
3401a93e:	e7a6      	b.n	3401a88e <_dtoa_r+0xf6>
3401a940:	2101      	movs	r1, #1
3401a942:	1ad2      	subs	r2, r2, r3
3401a944:	910c      	str	r1, [sp, #48]	@ 0x30
3401a946:	1e53      	subs	r3, r2, #1
3401a948:	9306      	str	r3, [sp, #24]
3401a94a:	bf49      	itett	mi
3401a94c:	f1c2 0301 	rsbmi	r3, r2, #1
3401a950:	2300      	movpl	r3, #0
3401a952:	9304      	strmi	r3, [sp, #16]
3401a954:	2300      	movmi	r3, #0
3401a956:	bf54      	ite	pl
3401a958:	9304      	strpl	r3, [sp, #16]
3401a95a:	9306      	strmi	r3, [sp, #24]
3401a95c:	f1b8 0f00 	cmp.w	r8, #0
3401a960:	db16      	blt.n	3401a990 <_dtoa_r+0x1f8>
3401a962:	9b06      	ldr	r3, [sp, #24]
3401a964:	f8cd 8028 	str.w	r8, [sp, #40]	@ 0x28
3401a968:	4443      	add	r3, r8
3401a96a:	9306      	str	r3, [sp, #24]
3401a96c:	2300      	movs	r3, #0
3401a96e:	9a07      	ldr	r2, [sp, #28]
3401a970:	2a09      	cmp	r2, #9
3401a972:	d843      	bhi.n	3401a9fc <_dtoa_r+0x264>
3401a974:	2a05      	cmp	r2, #5
3401a976:	bfc5      	ittet	gt
3401a978:	3a04      	subgt	r2, #4
3401a97a:	2400      	movgt	r4, #0
3401a97c:	2401      	movle	r4, #1
3401a97e:	9207      	strgt	r2, [sp, #28]
3401a980:	9a07      	ldr	r2, [sp, #28]
3401a982:	3a02      	subs	r2, #2
3401a984:	2a03      	cmp	r2, #3
3401a986:	d844      	bhi.n	3401aa12 <_dtoa_r+0x27a>
3401a988:	e8df f002 	tbb	[pc, r2]
3401a98c:	0b173634 	.word	0x0b173634
3401a990:	9b04      	ldr	r3, [sp, #16]
3401a992:	2200      	movs	r2, #0
3401a994:	eba3 0308 	sub.w	r3, r3, r8
3401a998:	920a      	str	r2, [sp, #40]	@ 0x28
3401a99a:	9304      	str	r3, [sp, #16]
3401a99c:	f1c8 0300 	rsb	r3, r8, #0
3401a9a0:	e7e5      	b.n	3401a96e <_dtoa_r+0x1d6>
3401a9a2:	2201      	movs	r2, #1
3401a9a4:	9208      	str	r2, [sp, #32]
3401a9a6:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401a9a8:	eb08 0b02 	add.w	fp, r8, r2
3401a9ac:	f10b 0a01 	add.w	sl, fp, #1
3401a9b0:	4652      	mov	r2, sl
3401a9b2:	2a01      	cmp	r2, #1
3401a9b4:	bfb8      	it	lt
3401a9b6:	2201      	movlt	r2, #1
3401a9b8:	e006      	b.n	3401a9c8 <_dtoa_r+0x230>
3401a9ba:	2201      	movs	r2, #1
3401a9bc:	9208      	str	r2, [sp, #32]
3401a9be:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401a9c0:	2a00      	cmp	r2, #0
3401a9c2:	dd29      	ble.n	3401aa18 <_dtoa_r+0x280>
3401a9c4:	4693      	mov	fp, r2
3401a9c6:	4692      	mov	sl, r2
3401a9c8:	f8d9 701c 	ldr.w	r7, [r9, #28]
3401a9cc:	2100      	movs	r1, #0
3401a9ce:	2004      	movs	r0, #4
3401a9d0:	f100 0614 	add.w	r6, r0, #20
3401a9d4:	4296      	cmp	r6, r2
3401a9d6:	d926      	bls.n	3401aa26 <_dtoa_r+0x28e>
3401a9d8:	6079      	str	r1, [r7, #4]
3401a9da:	4648      	mov	r0, r9
3401a9dc:	9305      	str	r3, [sp, #20]
3401a9de:	f000 fc83 	bl	3401b2e8 <_Balloc>
3401a9e2:	9b05      	ldr	r3, [sp, #20]
3401a9e4:	4607      	mov	r7, r0
3401a9e6:	2800      	cmp	r0, #0
3401a9e8:	d13e      	bne.n	3401aa68 <_dtoa_r+0x2d0>
3401a9ea:	4b1e      	ldr	r3, [pc, #120]	@ (3401aa64 <_dtoa_r+0x2cc>)
3401a9ec:	4602      	mov	r2, r0
3401a9ee:	f240 11af 	movw	r1, #431	@ 0x1af
3401a9f2:	e6ea      	b.n	3401a7ca <_dtoa_r+0x32>
3401a9f4:	2200      	movs	r2, #0
3401a9f6:	e7e1      	b.n	3401a9bc <_dtoa_r+0x224>
3401a9f8:	2200      	movs	r2, #0
3401a9fa:	e7d3      	b.n	3401a9a4 <_dtoa_r+0x20c>
3401a9fc:	2401      	movs	r4, #1
3401a9fe:	2200      	movs	r2, #0
3401aa00:	e9cd 2407 	strd	r2, r4, [sp, #28]
3401aa04:	f04f 3bff 	mov.w	fp, #4294967295
3401aa08:	2100      	movs	r1, #0
3401aa0a:	2212      	movs	r2, #18
3401aa0c:	46da      	mov	sl, fp
3401aa0e:	9109      	str	r1, [sp, #36]	@ 0x24
3401aa10:	e7da      	b.n	3401a9c8 <_dtoa_r+0x230>
3401aa12:	2201      	movs	r2, #1
3401aa14:	9208      	str	r2, [sp, #32]
3401aa16:	e7f5      	b.n	3401aa04 <_dtoa_r+0x26c>
3401aa18:	f04f 0b01 	mov.w	fp, #1
3401aa1c:	46da      	mov	sl, fp
3401aa1e:	465a      	mov	r2, fp
3401aa20:	f8cd b024 	str.w	fp, [sp, #36]	@ 0x24
3401aa24:	e7d0      	b.n	3401a9c8 <_dtoa_r+0x230>
3401aa26:	3101      	adds	r1, #1
3401aa28:	0040      	lsls	r0, r0, #1
3401aa2a:	e7d1      	b.n	3401a9d0 <_dtoa_r+0x238>
3401aa2c:	f3af 8000 	nop.w
3401aa30:	636f4361 	.word	0x636f4361
3401aa34:	3fd287a7 	.word	0x3fd287a7
3401aa38:	8b60c8b3 	.word	0x8b60c8b3
3401aa3c:	3fc68a28 	.word	0x3fc68a28
3401aa40:	509f79fb 	.word	0x509f79fb
3401aa44:	3fd34413 	.word	0x3fd34413
3401aa48:	34022cfb 	.word	0x34022cfb
3401aa4c:	34022d12 	.word	0x34022d12
3401aa50:	7ff00000 	.word	0x7ff00000
3401aa54:	34022cf7 	.word	0x34022cf7
3401aa58:	340217f9 	.word	0x340217f9
3401aa5c:	340217f8 	.word	0x340217f8
3401aa60:	340ae820 	.word	0x340ae820
3401aa64:	34022d6a 	.word	0x34022d6a
3401aa68:	f8d9 201c 	ldr.w	r2, [r9, #28]
3401aa6c:	f1ba 0f0e 	cmp.w	sl, #14
3401aa70:	6010      	str	r0, [r2, #0]
3401aa72:	d86e      	bhi.n	3401ab52 <_dtoa_r+0x3ba>
3401aa74:	2c00      	cmp	r4, #0
3401aa76:	d06c      	beq.n	3401ab52 <_dtoa_r+0x3ba>
3401aa78:	f1b8 0f00 	cmp.w	r8, #0
3401aa7c:	f340 80b4 	ble.w	3401abe8 <_dtoa_r+0x450>
3401aa80:	f008 010f 	and.w	r1, r8, #15
3401aa84:	4ac7      	ldr	r2, [pc, #796]	@ (3401ada4 <_dtoa_r+0x60c>)
3401aa86:	f418 7f80 	tst.w	r8, #256	@ 0x100
3401aa8a:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
3401aa8e:	ea4f 1128 	mov.w	r1, r8, asr #4
3401aa92:	ed92 7b00 	vldr	d7, [r2]
3401aa96:	f000 809b 	beq.w	3401abd0 <_dtoa_r+0x438>
3401aa9a:	4ac3      	ldr	r2, [pc, #780]	@ (3401ada8 <_dtoa_r+0x610>)
3401aa9c:	f001 010f 	and.w	r1, r1, #15
3401aaa0:	ed92 6b08 	vldr	d6, [r2, #32]
3401aaa4:	2203      	movs	r2, #3
3401aaa6:	ee88 6b06 	vdiv.f64	d6, d8, d6
3401aaaa:	ed8d 6b02 	vstr	d6, [sp, #8]
3401aaae:	48be      	ldr	r0, [pc, #760]	@ (3401ada8 <_dtoa_r+0x610>)
3401aab0:	2900      	cmp	r1, #0
3401aab2:	f040 808f 	bne.w	3401abd4 <_dtoa_r+0x43c>
3401aab6:	ed9d 6b02 	vldr	d6, [sp, #8]
3401aaba:	ee86 7b07 	vdiv.f64	d7, d6, d7
3401aabe:	ed8d 7b02 	vstr	d7, [sp, #8]
3401aac2:	990c      	ldr	r1, [sp, #48]	@ 0x30
3401aac4:	ed9d 7b02 	vldr	d7, [sp, #8]
3401aac8:	2900      	cmp	r1, #0
3401aaca:	f000 80b3 	beq.w	3401ac34 <_dtoa_r+0x49c>
3401aace:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
3401aad2:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401aad6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401aada:	f140 80ab 	bpl.w	3401ac34 <_dtoa_r+0x49c>
3401aade:	f1ba 0f00 	cmp.w	sl, #0
3401aae2:	f000 80a7 	beq.w	3401ac34 <_dtoa_r+0x49c>
3401aae6:	f1bb 0f00 	cmp.w	fp, #0
3401aaea:	dd30      	ble.n	3401ab4e <_dtoa_r+0x3b6>
3401aaec:	eeb2 6b04 	vmov.f64	d6, #36	@ 0x41200000  10.0
3401aaf0:	f108 31ff 	add.w	r1, r8, #4294967295
3401aaf4:	3201      	adds	r2, #1
3401aaf6:	465c      	mov	r4, fp
3401aaf8:	9105      	str	r1, [sp, #20]
3401aafa:	ee27 7b06 	vmul.f64	d7, d7, d6
3401aafe:	ed8d 7b02 	vstr	d7, [sp, #8]
3401ab02:	ee07 2a90 	vmov	s15, r2
3401ab06:	eeb1 5b0c 	vmov.f64	d5, #28	@ 0x40e00000  7.0
3401ab0a:	ed9d 6b02 	vldr	d6, [sp, #8]
3401ab0e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3401ab12:	eea7 5b06 	vfma.f64	d5, d7, d6
3401ab16:	ee15 2a90 	vmov	r2, s11
3401ab1a:	ec51 0b15 	vmov	r0, r1, d5
3401ab1e:	f1a2 7150 	sub.w	r1, r2, #54525952	@ 0x3400000
3401ab22:	2c00      	cmp	r4, #0
3401ab24:	f040 808a 	bne.w	3401ac3c <_dtoa_r+0x4a4>
3401ab28:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
3401ab2c:	ee36 6b47 	vsub.f64	d6, d6, d7
3401ab30:	ec41 0b17 	vmov	d7, r0, r1
3401ab34:	eeb4 6bc7 	vcmpe.f64	d6, d7
3401ab38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ab3c:	f300 826a 	bgt.w	3401b014 <_dtoa_r+0x87c>
3401ab40:	eeb1 7b47 	vneg.f64	d7, d7
3401ab44:	eeb4 6bc7 	vcmpe.f64	d6, d7
3401ab48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ab4c:	d423      	bmi.n	3401ab96 <_dtoa_r+0x3fe>
3401ab4e:	ed8d 8b02 	vstr	d8, [sp, #8]
3401ab52:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
3401ab54:	2a00      	cmp	r2, #0
3401ab56:	f2c0 8129 	blt.w	3401adac <_dtoa_r+0x614>
3401ab5a:	f1b8 0f0e 	cmp.w	r8, #14
3401ab5e:	f300 8125 	bgt.w	3401adac <_dtoa_r+0x614>
3401ab62:	4b90      	ldr	r3, [pc, #576]	@ (3401ada4 <_dtoa_r+0x60c>)
3401ab64:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
3401ab68:	ed93 6b00 	vldr	d6, [r3]
3401ab6c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401ab6e:	2b00      	cmp	r3, #0
3401ab70:	f280 80c8 	bge.w	3401ad04 <_dtoa_r+0x56c>
3401ab74:	f1ba 0f00 	cmp.w	sl, #0
3401ab78:	f300 80c4 	bgt.w	3401ad04 <_dtoa_r+0x56c>
3401ab7c:	d10b      	bne.n	3401ab96 <_dtoa_r+0x3fe>
3401ab7e:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
3401ab82:	ee26 6b07 	vmul.f64	d6, d6, d7
3401ab86:	ed9d 7b02 	vldr	d7, [sp, #8]
3401ab8a:	eeb4 6bc7 	vcmpe.f64	d6, d7
3401ab8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ab92:	f2c0 823c 	blt.w	3401b00e <_dtoa_r+0x876>
3401ab96:	2400      	movs	r4, #0
3401ab98:	4625      	mov	r5, r4
3401ab9a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401ab9c:	463e      	mov	r6, r7
3401ab9e:	43db      	mvns	r3, r3
3401aba0:	9305      	str	r3, [sp, #20]
3401aba2:	f04f 0800 	mov.w	r8, #0
3401aba6:	4621      	mov	r1, r4
3401aba8:	4648      	mov	r0, r9
3401abaa:	f000 fbdd 	bl	3401b368 <_Bfree>
3401abae:	2d00      	cmp	r5, #0
3401abb0:	f000 80a2 	beq.w	3401acf8 <_dtoa_r+0x560>
3401abb4:	f1b8 0f00 	cmp.w	r8, #0
3401abb8:	d005      	beq.n	3401abc6 <_dtoa_r+0x42e>
3401abba:	45a8      	cmp	r8, r5
3401abbc:	d003      	beq.n	3401abc6 <_dtoa_r+0x42e>
3401abbe:	4641      	mov	r1, r8
3401abc0:	4648      	mov	r0, r9
3401abc2:	f000 fbd1 	bl	3401b368 <_Bfree>
3401abc6:	4629      	mov	r1, r5
3401abc8:	4648      	mov	r0, r9
3401abca:	f000 fbcd 	bl	3401b368 <_Bfree>
3401abce:	e093      	b.n	3401acf8 <_dtoa_r+0x560>
3401abd0:	2202      	movs	r2, #2
3401abd2:	e76c      	b.n	3401aaae <_dtoa_r+0x316>
3401abd4:	07cc      	lsls	r4, r1, #31
3401abd6:	d504      	bpl.n	3401abe2 <_dtoa_r+0x44a>
3401abd8:	3201      	adds	r2, #1
3401abda:	ed90 6b00 	vldr	d6, [r0]
3401abde:	ee27 7b06 	vmul.f64	d7, d7, d6
3401abe2:	1049      	asrs	r1, r1, #1
3401abe4:	3008      	adds	r0, #8
3401abe6:	e763      	b.n	3401aab0 <_dtoa_r+0x318>
3401abe8:	d022      	beq.n	3401ac30 <_dtoa_r+0x498>
3401abea:	f1c8 0100 	rsb	r1, r8, #0
3401abee:	4a6d      	ldr	r2, [pc, #436]	@ (3401ada4 <_dtoa_r+0x60c>)
3401abf0:	2400      	movs	r4, #0
3401abf2:	f001 000f 	and.w	r0, r1, #15
3401abf6:	1109      	asrs	r1, r1, #4
3401abf8:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
3401abfc:	486a      	ldr	r0, [pc, #424]	@ (3401ada8 <_dtoa_r+0x610>)
3401abfe:	ed92 7b00 	vldr	d7, [r2]
3401ac02:	2202      	movs	r2, #2
3401ac04:	ee28 7b07 	vmul.f64	d7, d8, d7
3401ac08:	ed8d 7b02 	vstr	d7, [sp, #8]
3401ac0c:	b929      	cbnz	r1, 3401ac1a <_dtoa_r+0x482>
3401ac0e:	2c00      	cmp	r4, #0
3401ac10:	f43f af57 	beq.w	3401aac2 <_dtoa_r+0x32a>
3401ac14:	ed8d 7b02 	vstr	d7, [sp, #8]
3401ac18:	e753      	b.n	3401aac2 <_dtoa_r+0x32a>
3401ac1a:	07ce      	lsls	r6, r1, #31
3401ac1c:	d505      	bpl.n	3401ac2a <_dtoa_r+0x492>
3401ac1e:	3201      	adds	r2, #1
3401ac20:	2401      	movs	r4, #1
3401ac22:	ed90 6b00 	vldr	d6, [r0]
3401ac26:	ee27 7b06 	vmul.f64	d7, d7, d6
3401ac2a:	1049      	asrs	r1, r1, #1
3401ac2c:	3008      	adds	r0, #8
3401ac2e:	e7ed      	b.n	3401ac0c <_dtoa_r+0x474>
3401ac30:	2202      	movs	r2, #2
3401ac32:	e746      	b.n	3401aac2 <_dtoa_r+0x32a>
3401ac34:	4654      	mov	r4, sl
3401ac36:	f8cd 8014 	str.w	r8, [sp, #20]
3401ac3a:	e762      	b.n	3401ab02 <_dtoa_r+0x36a>
3401ac3c:	4a59      	ldr	r2, [pc, #356]	@ (3401ada4 <_dtoa_r+0x60c>)
3401ac3e:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
3401ac42:	443c      	add	r4, r7
3401ac44:	ed12 4b02 	vldr	d4, [r2, #-8]
3401ac48:	9a08      	ldr	r2, [sp, #32]
3401ac4a:	ec41 0b17 	vmov	d7, r0, r1
3401ac4e:	b34a      	cbz	r2, 3401aca4 <_dtoa_r+0x50c>
3401ac50:	eeb6 3b00 	vmov.f64	d3, #96	@ 0x3f000000  0.5
3401ac54:	463e      	mov	r6, r7
3401ac56:	eeb7 2b00 	vmov.f64	d2, #112	@ 0x3f800000  1.0
3401ac5a:	ee83 5b04 	vdiv.f64	d5, d3, d4
3401ac5e:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
3401ac62:	ee35 7b47 	vsub.f64	d7, d5, d7
3401ac66:	eefd 4bc6 	vcvt.s32.f64	s9, d6
3401ac6a:	eeb8 5be4 	vcvt.f64.s32	d5, s9
3401ac6e:	ee14 2a90 	vmov	r2, s9
3401ac72:	3230      	adds	r2, #48	@ 0x30
3401ac74:	ee36 6b45 	vsub.f64	d6, d6, d5
3401ac78:	f806 2b01 	strb.w	r2, [r6], #1
3401ac7c:	eeb4 6bc7 	vcmpe.f64	d6, d7
3401ac80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ac84:	d438      	bmi.n	3401acf8 <_dtoa_r+0x560>
3401ac86:	ee32 5b46 	vsub.f64	d5, d2, d6
3401ac8a:	eeb4 5bc7 	vcmpe.f64	d5, d7
3401ac8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ac92:	d46e      	bmi.n	3401ad72 <_dtoa_r+0x5da>
3401ac94:	42a6      	cmp	r6, r4
3401ac96:	f43f af5a 	beq.w	3401ab4e <_dtoa_r+0x3b6>
3401ac9a:	ee27 7b03 	vmul.f64	d7, d7, d3
3401ac9e:	ee26 6b03 	vmul.f64	d6, d6, d3
3401aca2:	e7e0      	b.n	3401ac66 <_dtoa_r+0x4ce>
3401aca4:	ee27 7b04 	vmul.f64	d7, d7, d4
3401aca8:	4621      	mov	r1, r4
3401acaa:	463e      	mov	r6, r7
3401acac:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
3401acb0:	eefd 4bc6 	vcvt.s32.f64	s9, d6
3401acb4:	ee14 2a90 	vmov	r2, s9
3401acb8:	eeb8 5be4 	vcvt.f64.s32	d5, s9
3401acbc:	3230      	adds	r2, #48	@ 0x30
3401acbe:	ee36 6b45 	vsub.f64	d6, d6, d5
3401acc2:	f806 2b01 	strb.w	r2, [r6], #1
3401acc6:	42a6      	cmp	r6, r4
3401acc8:	d119      	bne.n	3401acfe <_dtoa_r+0x566>
3401acca:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
3401acce:	ee37 4b05 	vadd.f64	d4, d7, d5
3401acd2:	eeb4 6bc4 	vcmpe.f64	d6, d4
3401acd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401acda:	dc4a      	bgt.n	3401ad72 <_dtoa_r+0x5da>
3401acdc:	ee35 5b47 	vsub.f64	d5, d5, d7
3401ace0:	eeb4 6bc5 	vcmpe.f64	d6, d5
3401ace4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ace8:	f57f af31 	bpl.w	3401ab4e <_dtoa_r+0x3b6>
3401acec:	460e      	mov	r6, r1
3401acee:	3901      	subs	r1, #1
3401acf0:	f816 3c01 	ldrb.w	r3, [r6, #-1]
3401acf4:	2b30      	cmp	r3, #48	@ 0x30
3401acf6:	d0f9      	beq.n	3401acec <_dtoa_r+0x554>
3401acf8:	f8dd 8014 	ldr.w	r8, [sp, #20]
3401acfc:	e027      	b.n	3401ad4e <_dtoa_r+0x5b6>
3401acfe:	ee26 6b03 	vmul.f64	d6, d6, d3
3401ad02:	e7d5      	b.n	3401acb0 <_dtoa_r+0x518>
3401ad04:	ed9d 7b02 	vldr	d7, [sp, #8]
3401ad08:	eeb2 4b04 	vmov.f64	d4, #36	@ 0x41200000  10.0
3401ad0c:	463e      	mov	r6, r7
3401ad0e:	ee87 5b06 	vdiv.f64	d5, d7, d6
3401ad12:	eebd 5bc5 	vcvt.s32.f64	s10, d5
3401ad16:	ee15 3a10 	vmov	r3, s10
3401ad1a:	eeb8 3bc5 	vcvt.f64.s32	d3, s10
3401ad1e:	3330      	adds	r3, #48	@ 0x30
3401ad20:	eea3 7b46 	vfms.f64	d7, d3, d6
3401ad24:	f806 3b01 	strb.w	r3, [r6], #1
3401ad28:	1bf3      	subs	r3, r6, r7
3401ad2a:	459a      	cmp	sl, r3
3401ad2c:	d132      	bne.n	3401ad94 <_dtoa_r+0x5fc>
3401ad2e:	ee37 7b07 	vadd.f64	d7, d7, d7
3401ad32:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401ad36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ad3a:	dc18      	bgt.n	3401ad6e <_dtoa_r+0x5d6>
3401ad3c:	eeb4 7b46 	vcmp.f64	d7, d6
3401ad40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ad44:	d103      	bne.n	3401ad4e <_dtoa_r+0x5b6>
3401ad46:	ee15 3a10 	vmov	r3, s10
3401ad4a:	07db      	lsls	r3, r3, #31
3401ad4c:	d40f      	bmi.n	3401ad6e <_dtoa_r+0x5d6>
3401ad4e:	9901      	ldr	r1, [sp, #4]
3401ad50:	4648      	mov	r0, r9
3401ad52:	f000 fb09 	bl	3401b368 <_Bfree>
3401ad56:	2300      	movs	r3, #0
3401ad58:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
3401ad5a:	7033      	strb	r3, [r6, #0]
3401ad5c:	f108 0301 	add.w	r3, r8, #1
3401ad60:	6013      	str	r3, [r2, #0]
3401ad62:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
3401ad64:	2b00      	cmp	r3, #0
3401ad66:	f000 824b 	beq.w	3401b200 <_dtoa_r+0xa68>
3401ad6a:	601e      	str	r6, [r3, #0]
3401ad6c:	e248      	b.n	3401b200 <_dtoa_r+0xa68>
3401ad6e:	f8cd 8014 	str.w	r8, [sp, #20]
3401ad72:	4633      	mov	r3, r6
3401ad74:	461e      	mov	r6, r3
3401ad76:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
3401ad7a:	2a39      	cmp	r2, #57	@ 0x39
3401ad7c:	d106      	bne.n	3401ad8c <_dtoa_r+0x5f4>
3401ad7e:	429f      	cmp	r7, r3
3401ad80:	d1f8      	bne.n	3401ad74 <_dtoa_r+0x5dc>
3401ad82:	9a05      	ldr	r2, [sp, #20]
3401ad84:	3201      	adds	r2, #1
3401ad86:	9205      	str	r2, [sp, #20]
3401ad88:	2230      	movs	r2, #48	@ 0x30
3401ad8a:	703a      	strb	r2, [r7, #0]
3401ad8c:	781a      	ldrb	r2, [r3, #0]
3401ad8e:	3201      	adds	r2, #1
3401ad90:	701a      	strb	r2, [r3, #0]
3401ad92:	e7b1      	b.n	3401acf8 <_dtoa_r+0x560>
3401ad94:	ee27 7b04 	vmul.f64	d7, d7, d4
3401ad98:	eeb5 7b40 	vcmp.f64	d7, #0.0
3401ad9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ada0:	d1b5      	bne.n	3401ad0e <_dtoa_r+0x576>
3401ada2:	e7d4      	b.n	3401ad4e <_dtoa_r+0x5b6>
3401ada4:	340ae820 	.word	0x340ae820
3401ada8:	340ae7f8 	.word	0x340ae7f8
3401adac:	9908      	ldr	r1, [sp, #32]
3401adae:	2900      	cmp	r1, #0
3401adb0:	f000 80e9 	beq.w	3401af86 <_dtoa_r+0x7ee>
3401adb4:	9907      	ldr	r1, [sp, #28]
3401adb6:	2901      	cmp	r1, #1
3401adb8:	f300 80cb 	bgt.w	3401af52 <_dtoa_r+0x7ba>
3401adbc:	2d00      	cmp	r5, #0
3401adbe:	f000 80c4 	beq.w	3401af4a <_dtoa_r+0x7b2>
3401adc2:	f202 4233 	addw	r2, r2, #1075	@ 0x433
3401adc6:	461c      	mov	r4, r3
3401adc8:	9e04      	ldr	r6, [sp, #16]
3401adca:	9305      	str	r3, [sp, #20]
3401adcc:	2101      	movs	r1, #1
3401adce:	9b04      	ldr	r3, [sp, #16]
3401add0:	4648      	mov	r0, r9
3401add2:	4413      	add	r3, r2
3401add4:	9304      	str	r3, [sp, #16]
3401add6:	9b06      	ldr	r3, [sp, #24]
3401add8:	4413      	add	r3, r2
3401adda:	9306      	str	r3, [sp, #24]
3401addc:	f000 fb7a 	bl	3401b4d4 <__i2b>
3401ade0:	9b05      	ldr	r3, [sp, #20]
3401ade2:	4605      	mov	r5, r0
3401ade4:	b166      	cbz	r6, 3401ae00 <_dtoa_r+0x668>
3401ade6:	9a06      	ldr	r2, [sp, #24]
3401ade8:	2a00      	cmp	r2, #0
3401adea:	dd09      	ble.n	3401ae00 <_dtoa_r+0x668>
3401adec:	42b2      	cmp	r2, r6
3401adee:	9904      	ldr	r1, [sp, #16]
3401adf0:	bfa8      	it	ge
3401adf2:	4632      	movge	r2, r6
3401adf4:	1a89      	subs	r1, r1, r2
3401adf6:	1ab6      	subs	r6, r6, r2
3401adf8:	9104      	str	r1, [sp, #16]
3401adfa:	9906      	ldr	r1, [sp, #24]
3401adfc:	1a8a      	subs	r2, r1, r2
3401adfe:	9206      	str	r2, [sp, #24]
3401ae00:	b30b      	cbz	r3, 3401ae46 <_dtoa_r+0x6ae>
3401ae02:	9a08      	ldr	r2, [sp, #32]
3401ae04:	2a00      	cmp	r2, #0
3401ae06:	f000 80c5 	beq.w	3401af94 <_dtoa_r+0x7fc>
3401ae0a:	2c00      	cmp	r4, #0
3401ae0c:	f000 80bf 	beq.w	3401af8e <_dtoa_r+0x7f6>
3401ae10:	4629      	mov	r1, r5
3401ae12:	4622      	mov	r2, r4
3401ae14:	4648      	mov	r0, r9
3401ae16:	930b      	str	r3, [sp, #44]	@ 0x2c
3401ae18:	f000 fc16 	bl	3401b648 <__pow5mult>
3401ae1c:	9a01      	ldr	r2, [sp, #4]
3401ae1e:	4601      	mov	r1, r0
3401ae20:	4605      	mov	r5, r0
3401ae22:	4648      	mov	r0, r9
3401ae24:	f000 fb6c 	bl	3401b500 <__multiply>
3401ae28:	9901      	ldr	r1, [sp, #4]
3401ae2a:	9005      	str	r0, [sp, #20]
3401ae2c:	4648      	mov	r0, r9
3401ae2e:	f000 fa9b 	bl	3401b368 <_Bfree>
3401ae32:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
3401ae34:	1b1b      	subs	r3, r3, r4
3401ae36:	f000 80b0 	beq.w	3401af9a <_dtoa_r+0x802>
3401ae3a:	461a      	mov	r2, r3
3401ae3c:	9905      	ldr	r1, [sp, #20]
3401ae3e:	4648      	mov	r0, r9
3401ae40:	f000 fc02 	bl	3401b648 <__pow5mult>
3401ae44:	9001      	str	r0, [sp, #4]
3401ae46:	2101      	movs	r1, #1
3401ae48:	4648      	mov	r0, r9
3401ae4a:	f000 fb43 	bl	3401b4d4 <__i2b>
3401ae4e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3401ae50:	4604      	mov	r4, r0
3401ae52:	2b00      	cmp	r3, #0
3401ae54:	f000 81da 	beq.w	3401b20c <_dtoa_r+0xa74>
3401ae58:	461a      	mov	r2, r3
3401ae5a:	4601      	mov	r1, r0
3401ae5c:	4648      	mov	r0, r9
3401ae5e:	f000 fbf3 	bl	3401b648 <__pow5mult>
3401ae62:	9b07      	ldr	r3, [sp, #28]
3401ae64:	4604      	mov	r4, r0
3401ae66:	2b01      	cmp	r3, #1
3401ae68:	f300 80a0 	bgt.w	3401afac <_dtoa_r+0x814>
3401ae6c:	9b02      	ldr	r3, [sp, #8]
3401ae6e:	2b00      	cmp	r3, #0
3401ae70:	f040 8096 	bne.w	3401afa0 <_dtoa_r+0x808>
3401ae74:	9b03      	ldr	r3, [sp, #12]
3401ae76:	f3c3 0213 	ubfx	r2, r3, #0, #20
3401ae7a:	2a00      	cmp	r2, #0
3401ae7c:	f040 8092 	bne.w	3401afa4 <_dtoa_r+0x80c>
3401ae80:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
3401ae84:	0d12      	lsrs	r2, r2, #20
3401ae86:	0512      	lsls	r2, r2, #20
3401ae88:	2a00      	cmp	r2, #0
3401ae8a:	f000 808d 	beq.w	3401afa8 <_dtoa_r+0x810>
3401ae8e:	9b04      	ldr	r3, [sp, #16]
3401ae90:	3301      	adds	r3, #1
3401ae92:	9304      	str	r3, [sp, #16]
3401ae94:	9b06      	ldr	r3, [sp, #24]
3401ae96:	3301      	adds	r3, #1
3401ae98:	9306      	str	r3, [sp, #24]
3401ae9a:	2301      	movs	r3, #1
3401ae9c:	930b      	str	r3, [sp, #44]	@ 0x2c
3401ae9e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3401aea0:	2b00      	cmp	r3, #0
3401aea2:	f000 81b9 	beq.w	3401b218 <_dtoa_r+0xa80>
3401aea6:	6922      	ldr	r2, [r4, #16]
3401aea8:	eb04 0282 	add.w	r2, r4, r2, lsl #2
3401aeac:	6910      	ldr	r0, [r2, #16]
3401aeae:	f000 fac5 	bl	3401b43c <__hi0bits>
3401aeb2:	f1c0 0020 	rsb	r0, r0, #32
3401aeb6:	9b06      	ldr	r3, [sp, #24]
3401aeb8:	4418      	add	r0, r3
3401aeba:	f010 001f 	ands.w	r0, r0, #31
3401aebe:	f000 8081 	beq.w	3401afc4 <_dtoa_r+0x82c>
3401aec2:	f1c0 0220 	rsb	r2, r0, #32
3401aec6:	2a04      	cmp	r2, #4
3401aec8:	dd73      	ble.n	3401afb2 <_dtoa_r+0x81a>
3401aeca:	f1c0 001c 	rsb	r0, r0, #28
3401aece:	9b04      	ldr	r3, [sp, #16]
3401aed0:	4403      	add	r3, r0
3401aed2:	4406      	add	r6, r0
3401aed4:	9304      	str	r3, [sp, #16]
3401aed6:	9b06      	ldr	r3, [sp, #24]
3401aed8:	4403      	add	r3, r0
3401aeda:	9306      	str	r3, [sp, #24]
3401aedc:	9b04      	ldr	r3, [sp, #16]
3401aede:	2b00      	cmp	r3, #0
3401aee0:	dd05      	ble.n	3401aeee <_dtoa_r+0x756>
3401aee2:	461a      	mov	r2, r3
3401aee4:	9901      	ldr	r1, [sp, #4]
3401aee6:	4648      	mov	r0, r9
3401aee8:	f000 fc08 	bl	3401b6fc <__lshift>
3401aeec:	9001      	str	r0, [sp, #4]
3401aeee:	9b06      	ldr	r3, [sp, #24]
3401aef0:	2b00      	cmp	r3, #0
3401aef2:	dd05      	ble.n	3401af00 <_dtoa_r+0x768>
3401aef4:	4621      	mov	r1, r4
3401aef6:	461a      	mov	r2, r3
3401aef8:	4648      	mov	r0, r9
3401aefa:	f000 fbff 	bl	3401b6fc <__lshift>
3401aefe:	4604      	mov	r4, r0
3401af00:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
3401af02:	2b00      	cmp	r3, #0
3401af04:	d060      	beq.n	3401afc8 <_dtoa_r+0x830>
3401af06:	4621      	mov	r1, r4
3401af08:	9801      	ldr	r0, [sp, #4]
3401af0a:	f000 fc63 	bl	3401b7d4 <__mcmp>
3401af0e:	2800      	cmp	r0, #0
3401af10:	da5a      	bge.n	3401afc8 <_dtoa_r+0x830>
3401af12:	f108 33ff 	add.w	r3, r8, #4294967295
3401af16:	220a      	movs	r2, #10
3401af18:	9901      	ldr	r1, [sp, #4]
3401af1a:	4648      	mov	r0, r9
3401af1c:	9305      	str	r3, [sp, #20]
3401af1e:	2300      	movs	r3, #0
3401af20:	f000 fa44 	bl	3401b3ac <__multadd>
3401af24:	9b08      	ldr	r3, [sp, #32]
3401af26:	9001      	str	r0, [sp, #4]
3401af28:	2b00      	cmp	r3, #0
3401af2a:	f000 8177 	beq.w	3401b21c <_dtoa_r+0xa84>
3401af2e:	4629      	mov	r1, r5
3401af30:	2300      	movs	r3, #0
3401af32:	220a      	movs	r2, #10
3401af34:	4648      	mov	r0, r9
3401af36:	f000 fa39 	bl	3401b3ac <__multadd>
3401af3a:	f1bb 0f00 	cmp.w	fp, #0
3401af3e:	4605      	mov	r5, r0
3401af40:	dc6e      	bgt.n	3401b020 <_dtoa_r+0x888>
3401af42:	9b07      	ldr	r3, [sp, #28]
3401af44:	2b02      	cmp	r3, #2
3401af46:	dc48      	bgt.n	3401afda <_dtoa_r+0x842>
3401af48:	e06a      	b.n	3401b020 <_dtoa_r+0x888>
3401af4a:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
3401af4c:	f1c2 0236 	rsb	r2, r2, #54	@ 0x36
3401af50:	e739      	b.n	3401adc6 <_dtoa_r+0x62e>
3401af52:	f10a 34ff 	add.w	r4, sl, #4294967295
3401af56:	42a3      	cmp	r3, r4
3401af58:	db07      	blt.n	3401af6a <_dtoa_r+0x7d2>
3401af5a:	f1ba 0f00 	cmp.w	sl, #0
3401af5e:	eba3 0404 	sub.w	r4, r3, r4
3401af62:	db0b      	blt.n	3401af7c <_dtoa_r+0x7e4>
3401af64:	9e04      	ldr	r6, [sp, #16]
3401af66:	4652      	mov	r2, sl
3401af68:	e72f      	b.n	3401adca <_dtoa_r+0x632>
3401af6a:	1ae2      	subs	r2, r4, r3
3401af6c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3401af6e:	9e04      	ldr	r6, [sp, #16]
3401af70:	4413      	add	r3, r2
3401af72:	4652      	mov	r2, sl
3401af74:	930a      	str	r3, [sp, #40]	@ 0x28
3401af76:	4623      	mov	r3, r4
3401af78:	2400      	movs	r4, #0
3401af7a:	e726      	b.n	3401adca <_dtoa_r+0x632>
3401af7c:	9a04      	ldr	r2, [sp, #16]
3401af7e:	eba2 060a 	sub.w	r6, r2, sl
3401af82:	2200      	movs	r2, #0
3401af84:	e721      	b.n	3401adca <_dtoa_r+0x632>
3401af86:	461c      	mov	r4, r3
3401af88:	9e04      	ldr	r6, [sp, #16]
3401af8a:	9d08      	ldr	r5, [sp, #32]
3401af8c:	e72a      	b.n	3401ade4 <_dtoa_r+0x64c>
3401af8e:	9a01      	ldr	r2, [sp, #4]
3401af90:	9205      	str	r2, [sp, #20]
3401af92:	e752      	b.n	3401ae3a <_dtoa_r+0x6a2>
3401af94:	461a      	mov	r2, r3
3401af96:	9901      	ldr	r1, [sp, #4]
3401af98:	e751      	b.n	3401ae3e <_dtoa_r+0x6a6>
3401af9a:	9b05      	ldr	r3, [sp, #20]
3401af9c:	9301      	str	r3, [sp, #4]
3401af9e:	e752      	b.n	3401ae46 <_dtoa_r+0x6ae>
3401afa0:	2300      	movs	r3, #0
3401afa2:	e77b      	b.n	3401ae9c <_dtoa_r+0x704>
3401afa4:	9b02      	ldr	r3, [sp, #8]
3401afa6:	e779      	b.n	3401ae9c <_dtoa_r+0x704>
3401afa8:	920b      	str	r2, [sp, #44]	@ 0x2c
3401afaa:	e778      	b.n	3401ae9e <_dtoa_r+0x706>
3401afac:	2300      	movs	r3, #0
3401afae:	930b      	str	r3, [sp, #44]	@ 0x2c
3401afb0:	e779      	b.n	3401aea6 <_dtoa_r+0x70e>
3401afb2:	d093      	beq.n	3401aedc <_dtoa_r+0x744>
3401afb4:	321c      	adds	r2, #28
3401afb6:	9b04      	ldr	r3, [sp, #16]
3401afb8:	4413      	add	r3, r2
3401afba:	4416      	add	r6, r2
3401afbc:	9304      	str	r3, [sp, #16]
3401afbe:	9b06      	ldr	r3, [sp, #24]
3401afc0:	4413      	add	r3, r2
3401afc2:	e78a      	b.n	3401aeda <_dtoa_r+0x742>
3401afc4:	4602      	mov	r2, r0
3401afc6:	e7f5      	b.n	3401afb4 <_dtoa_r+0x81c>
3401afc8:	f1ba 0f00 	cmp.w	sl, #0
3401afcc:	46d3      	mov	fp, sl
3401afce:	f8cd 8014 	str.w	r8, [sp, #20]
3401afd2:	dc21      	bgt.n	3401b018 <_dtoa_r+0x880>
3401afd4:	9b07      	ldr	r3, [sp, #28]
3401afd6:	2b02      	cmp	r3, #2
3401afd8:	dd1e      	ble.n	3401b018 <_dtoa_r+0x880>
3401afda:	f1bb 0f00 	cmp.w	fp, #0
3401afde:	f47f addc 	bne.w	3401ab9a <_dtoa_r+0x402>
3401afe2:	4621      	mov	r1, r4
3401afe4:	465b      	mov	r3, fp
3401afe6:	2205      	movs	r2, #5
3401afe8:	4648      	mov	r0, r9
3401afea:	f000 f9df 	bl	3401b3ac <__multadd>
3401afee:	4601      	mov	r1, r0
3401aff0:	4604      	mov	r4, r0
3401aff2:	9801      	ldr	r0, [sp, #4]
3401aff4:	f000 fbee 	bl	3401b7d4 <__mcmp>
3401aff8:	2800      	cmp	r0, #0
3401affa:	f77f adce 	ble.w	3401ab9a <_dtoa_r+0x402>
3401affe:	2331      	movs	r3, #49	@ 0x31
3401b000:	463e      	mov	r6, r7
3401b002:	f806 3b01 	strb.w	r3, [r6], #1
3401b006:	9b05      	ldr	r3, [sp, #20]
3401b008:	3301      	adds	r3, #1
3401b00a:	9305      	str	r3, [sp, #20]
3401b00c:	e5c9      	b.n	3401aba2 <_dtoa_r+0x40a>
3401b00e:	4654      	mov	r4, sl
3401b010:	f8cd 8014 	str.w	r8, [sp, #20]
3401b014:	4625      	mov	r5, r4
3401b016:	e7f2      	b.n	3401affe <_dtoa_r+0x866>
3401b018:	9b08      	ldr	r3, [sp, #32]
3401b01a:	2b00      	cmp	r3, #0
3401b01c:	f000 8102 	beq.w	3401b224 <_dtoa_r+0xa8c>
3401b020:	2e00      	cmp	r6, #0
3401b022:	dd05      	ble.n	3401b030 <_dtoa_r+0x898>
3401b024:	4629      	mov	r1, r5
3401b026:	4632      	mov	r2, r6
3401b028:	4648      	mov	r0, r9
3401b02a:	f000 fb67 	bl	3401b6fc <__lshift>
3401b02e:	4605      	mov	r5, r0
3401b030:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
3401b032:	2b00      	cmp	r3, #0
3401b034:	d058      	beq.n	3401b0e8 <_dtoa_r+0x950>
3401b036:	6869      	ldr	r1, [r5, #4]
3401b038:	4648      	mov	r0, r9
3401b03a:	f000 f955 	bl	3401b2e8 <_Balloc>
3401b03e:	4606      	mov	r6, r0
3401b040:	b928      	cbnz	r0, 3401b04e <_dtoa_r+0x8b6>
3401b042:	4b82      	ldr	r3, [pc, #520]	@ (3401b24c <_dtoa_r+0xab4>)
3401b044:	4602      	mov	r2, r0
3401b046:	f240 21ef 	movw	r1, #751	@ 0x2ef
3401b04a:	f7ff bbbe 	b.w	3401a7ca <_dtoa_r+0x32>
3401b04e:	692a      	ldr	r2, [r5, #16]
3401b050:	f105 010c 	add.w	r1, r5, #12
3401b054:	300c      	adds	r0, #12
3401b056:	3202      	adds	r2, #2
3401b058:	0092      	lsls	r2, r2, #2
3401b05a:	f7ff fafa 	bl	3401a652 <memcpy>
3401b05e:	2201      	movs	r2, #1
3401b060:	4631      	mov	r1, r6
3401b062:	4648      	mov	r0, r9
3401b064:	f000 fb4a 	bl	3401b6fc <__lshift>
3401b068:	1c7b      	adds	r3, r7, #1
3401b06a:	46a8      	mov	r8, r5
3401b06c:	4605      	mov	r5, r0
3401b06e:	9304      	str	r3, [sp, #16]
3401b070:	eb07 030b 	add.w	r3, r7, fp
3401b074:	9309      	str	r3, [sp, #36]	@ 0x24
3401b076:	9b02      	ldr	r3, [sp, #8]
3401b078:	f003 0301 	and.w	r3, r3, #1
3401b07c:	9308      	str	r3, [sp, #32]
3401b07e:	9b04      	ldr	r3, [sp, #16]
3401b080:	4621      	mov	r1, r4
3401b082:	9801      	ldr	r0, [sp, #4]
3401b084:	f103 3bff 	add.w	fp, r3, #4294967295
3401b088:	f7ff faf7 	bl	3401a67a <quorem>
3401b08c:	4641      	mov	r1, r8
3401b08e:	9002      	str	r0, [sp, #8]
3401b090:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
3401b094:	9801      	ldr	r0, [sp, #4]
3401b096:	f000 fb9d 	bl	3401b7d4 <__mcmp>
3401b09a:	462a      	mov	r2, r5
3401b09c:	9006      	str	r0, [sp, #24]
3401b09e:	4621      	mov	r1, r4
3401b0a0:	4648      	mov	r0, r9
3401b0a2:	f000 fbb3 	bl	3401b80c <__mdiff>
3401b0a6:	68c2      	ldr	r2, [r0, #12]
3401b0a8:	4606      	mov	r6, r0
3401b0aa:	b9fa      	cbnz	r2, 3401b0ec <_dtoa_r+0x954>
3401b0ac:	4601      	mov	r1, r0
3401b0ae:	9801      	ldr	r0, [sp, #4]
3401b0b0:	f000 fb90 	bl	3401b7d4 <__mcmp>
3401b0b4:	4602      	mov	r2, r0
3401b0b6:	4631      	mov	r1, r6
3401b0b8:	4648      	mov	r0, r9
3401b0ba:	920a      	str	r2, [sp, #40]	@ 0x28
3401b0bc:	f000 f954 	bl	3401b368 <_Bfree>
3401b0c0:	9b07      	ldr	r3, [sp, #28]
3401b0c2:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
3401b0c4:	9e04      	ldr	r6, [sp, #16]
3401b0c6:	ea42 0103 	orr.w	r1, r2, r3
3401b0ca:	9b08      	ldr	r3, [sp, #32]
3401b0cc:	4319      	orrs	r1, r3
3401b0ce:	d10f      	bne.n	3401b0f0 <_dtoa_r+0x958>
3401b0d0:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
3401b0d4:	d028      	beq.n	3401b128 <_dtoa_r+0x990>
3401b0d6:	9b06      	ldr	r3, [sp, #24]
3401b0d8:	2b00      	cmp	r3, #0
3401b0da:	dd02      	ble.n	3401b0e2 <_dtoa_r+0x94a>
3401b0dc:	9b02      	ldr	r3, [sp, #8]
3401b0de:	f103 0a31 	add.w	sl, r3, #49	@ 0x31
3401b0e2:	f88b a000 	strb.w	sl, [fp]
3401b0e6:	e55e      	b.n	3401aba6 <_dtoa_r+0x40e>
3401b0e8:	4628      	mov	r0, r5
3401b0ea:	e7bd      	b.n	3401b068 <_dtoa_r+0x8d0>
3401b0ec:	2201      	movs	r2, #1
3401b0ee:	e7e2      	b.n	3401b0b6 <_dtoa_r+0x91e>
3401b0f0:	9b06      	ldr	r3, [sp, #24]
3401b0f2:	2b00      	cmp	r3, #0
3401b0f4:	db04      	blt.n	3401b100 <_dtoa_r+0x968>
3401b0f6:	9907      	ldr	r1, [sp, #28]
3401b0f8:	430b      	orrs	r3, r1
3401b0fa:	9908      	ldr	r1, [sp, #32]
3401b0fc:	430b      	orrs	r3, r1
3401b0fe:	d120      	bne.n	3401b142 <_dtoa_r+0x9aa>
3401b100:	2a00      	cmp	r2, #0
3401b102:	ddee      	ble.n	3401b0e2 <_dtoa_r+0x94a>
3401b104:	2201      	movs	r2, #1
3401b106:	9901      	ldr	r1, [sp, #4]
3401b108:	4648      	mov	r0, r9
3401b10a:	f000 faf7 	bl	3401b6fc <__lshift>
3401b10e:	4621      	mov	r1, r4
3401b110:	9001      	str	r0, [sp, #4]
3401b112:	f000 fb5f 	bl	3401b7d4 <__mcmp>
3401b116:	2800      	cmp	r0, #0
3401b118:	dc03      	bgt.n	3401b122 <_dtoa_r+0x98a>
3401b11a:	d1e2      	bne.n	3401b0e2 <_dtoa_r+0x94a>
3401b11c:	f01a 0f01 	tst.w	sl, #1
3401b120:	d0df      	beq.n	3401b0e2 <_dtoa_r+0x94a>
3401b122:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
3401b126:	d1d9      	bne.n	3401b0dc <_dtoa_r+0x944>
3401b128:	2339      	movs	r3, #57	@ 0x39
3401b12a:	f88b 3000 	strb.w	r3, [fp]
3401b12e:	4633      	mov	r3, r6
3401b130:	461e      	mov	r6, r3
3401b132:	3b01      	subs	r3, #1
3401b134:	f816 2c01 	ldrb.w	r2, [r6, #-1]
3401b138:	2a39      	cmp	r2, #57	@ 0x39
3401b13a:	d052      	beq.n	3401b1e2 <_dtoa_r+0xa4a>
3401b13c:	3201      	adds	r2, #1
3401b13e:	701a      	strb	r2, [r3, #0]
3401b140:	e531      	b.n	3401aba6 <_dtoa_r+0x40e>
3401b142:	2a00      	cmp	r2, #0
3401b144:	dd07      	ble.n	3401b156 <_dtoa_r+0x9be>
3401b146:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
3401b14a:	d0ed      	beq.n	3401b128 <_dtoa_r+0x990>
3401b14c:	f10a 0301 	add.w	r3, sl, #1
3401b150:	f88b 3000 	strb.w	r3, [fp]
3401b154:	e527      	b.n	3401aba6 <_dtoa_r+0x40e>
3401b156:	9b04      	ldr	r3, [sp, #16]
3401b158:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401b15a:	f803 ac01 	strb.w	sl, [r3, #-1]
3401b15e:	4293      	cmp	r3, r2
3401b160:	d029      	beq.n	3401b1b6 <_dtoa_r+0xa1e>
3401b162:	2300      	movs	r3, #0
3401b164:	220a      	movs	r2, #10
3401b166:	9901      	ldr	r1, [sp, #4]
3401b168:	4648      	mov	r0, r9
3401b16a:	f000 f91f 	bl	3401b3ac <__multadd>
3401b16e:	45a8      	cmp	r8, r5
3401b170:	9001      	str	r0, [sp, #4]
3401b172:	f04f 0300 	mov.w	r3, #0
3401b176:	f04f 020a 	mov.w	r2, #10
3401b17a:	4641      	mov	r1, r8
3401b17c:	4648      	mov	r0, r9
3401b17e:	d107      	bne.n	3401b190 <_dtoa_r+0x9f8>
3401b180:	f000 f914 	bl	3401b3ac <__multadd>
3401b184:	4680      	mov	r8, r0
3401b186:	4605      	mov	r5, r0
3401b188:	9b04      	ldr	r3, [sp, #16]
3401b18a:	3301      	adds	r3, #1
3401b18c:	9304      	str	r3, [sp, #16]
3401b18e:	e776      	b.n	3401b07e <_dtoa_r+0x8e6>
3401b190:	f000 f90c 	bl	3401b3ac <__multadd>
3401b194:	4629      	mov	r1, r5
3401b196:	4680      	mov	r8, r0
3401b198:	2300      	movs	r3, #0
3401b19a:	220a      	movs	r2, #10
3401b19c:	4648      	mov	r0, r9
3401b19e:	f000 f905 	bl	3401b3ac <__multadd>
3401b1a2:	4605      	mov	r5, r0
3401b1a4:	e7f0      	b.n	3401b188 <_dtoa_r+0x9f0>
3401b1a6:	f1bb 0f00 	cmp.w	fp, #0
3401b1aa:	f04f 0800 	mov.w	r8, #0
3401b1ae:	bfcc      	ite	gt
3401b1b0:	465e      	movgt	r6, fp
3401b1b2:	2601      	movle	r6, #1
3401b1b4:	443e      	add	r6, r7
3401b1b6:	2201      	movs	r2, #1
3401b1b8:	9901      	ldr	r1, [sp, #4]
3401b1ba:	4648      	mov	r0, r9
3401b1bc:	f000 fa9e 	bl	3401b6fc <__lshift>
3401b1c0:	4621      	mov	r1, r4
3401b1c2:	9001      	str	r0, [sp, #4]
3401b1c4:	f000 fb06 	bl	3401b7d4 <__mcmp>
3401b1c8:	2800      	cmp	r0, #0
3401b1ca:	dcb0      	bgt.n	3401b12e <_dtoa_r+0x996>
3401b1cc:	d102      	bne.n	3401b1d4 <_dtoa_r+0xa3c>
3401b1ce:	f01a 0f01 	tst.w	sl, #1
3401b1d2:	d1ac      	bne.n	3401b12e <_dtoa_r+0x996>
3401b1d4:	4633      	mov	r3, r6
3401b1d6:	461e      	mov	r6, r3
3401b1d8:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
3401b1dc:	2a30      	cmp	r2, #48	@ 0x30
3401b1de:	d0fa      	beq.n	3401b1d6 <_dtoa_r+0xa3e>
3401b1e0:	e4e1      	b.n	3401aba6 <_dtoa_r+0x40e>
3401b1e2:	429f      	cmp	r7, r3
3401b1e4:	d1a4      	bne.n	3401b130 <_dtoa_r+0x998>
3401b1e6:	9b05      	ldr	r3, [sp, #20]
3401b1e8:	3301      	adds	r3, #1
3401b1ea:	9305      	str	r3, [sp, #20]
3401b1ec:	2331      	movs	r3, #49	@ 0x31
3401b1ee:	703b      	strb	r3, [r7, #0]
3401b1f0:	e4d9      	b.n	3401aba6 <_dtoa_r+0x40e>
3401b1f2:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
3401b1f4:	4f16      	ldr	r7, [pc, #88]	@ (3401b250 <_dtoa_r+0xab8>)
3401b1f6:	b11b      	cbz	r3, 3401b200 <_dtoa_r+0xa68>
3401b1f8:	f107 0308 	add.w	r3, r7, #8
3401b1fc:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
3401b1fe:	6013      	str	r3, [r2, #0]
3401b200:	4638      	mov	r0, r7
3401b202:	b011      	add	sp, #68	@ 0x44
3401b204:	ecbd 8b02 	vpop	{d8}
3401b208:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401b20c:	9b07      	ldr	r3, [sp, #28]
3401b20e:	2b01      	cmp	r3, #1
3401b210:	f77f ae2c 	ble.w	3401ae6c <_dtoa_r+0x6d4>
3401b214:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3401b216:	930b      	str	r3, [sp, #44]	@ 0x2c
3401b218:	2001      	movs	r0, #1
3401b21a:	e64c      	b.n	3401aeb6 <_dtoa_r+0x71e>
3401b21c:	f1bb 0f00 	cmp.w	fp, #0
3401b220:	f77f aed8 	ble.w	3401afd4 <_dtoa_r+0x83c>
3401b224:	463e      	mov	r6, r7
3401b226:	4621      	mov	r1, r4
3401b228:	9801      	ldr	r0, [sp, #4]
3401b22a:	f7ff fa26 	bl	3401a67a <quorem>
3401b22e:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
3401b232:	f806 ab01 	strb.w	sl, [r6], #1
3401b236:	1bf2      	subs	r2, r6, r7
3401b238:	4593      	cmp	fp, r2
3401b23a:	ddb4      	ble.n	3401b1a6 <_dtoa_r+0xa0e>
3401b23c:	2300      	movs	r3, #0
3401b23e:	220a      	movs	r2, #10
3401b240:	9901      	ldr	r1, [sp, #4]
3401b242:	4648      	mov	r0, r9
3401b244:	f000 f8b2 	bl	3401b3ac <__multadd>
3401b248:	9001      	str	r0, [sp, #4]
3401b24a:	e7ec      	b.n	3401b226 <_dtoa_r+0xa8e>
3401b24c:	34022d6a 	.word	0x34022d6a
3401b250:	34022cee 	.word	0x34022cee

3401b254 <_free_r>:
3401b254:	b538      	push	{r3, r4, r5, lr}
3401b256:	4605      	mov	r5, r0
3401b258:	2900      	cmp	r1, #0
3401b25a:	d041      	beq.n	3401b2e0 <_free_r+0x8c>
3401b25c:	f851 3c04 	ldr.w	r3, [r1, #-4]
3401b260:	1f0c      	subs	r4, r1, #4
3401b262:	2b00      	cmp	r3, #0
3401b264:	bfb8      	it	lt
3401b266:	18e4      	addlt	r4, r4, r3
3401b268:	f7fd fec0 	bl	34018fec <__malloc_lock>
3401b26c:	4a1d      	ldr	r2, [pc, #116]	@ (3401b2e4 <_free_r+0x90>)
3401b26e:	6813      	ldr	r3, [r2, #0]
3401b270:	b933      	cbnz	r3, 3401b280 <_free_r+0x2c>
3401b272:	6063      	str	r3, [r4, #4]
3401b274:	6014      	str	r4, [r2, #0]
3401b276:	4628      	mov	r0, r5
3401b278:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
3401b27c:	f7fd bebc 	b.w	34018ff8 <__malloc_unlock>
3401b280:	42a3      	cmp	r3, r4
3401b282:	d908      	bls.n	3401b296 <_free_r+0x42>
3401b284:	6820      	ldr	r0, [r4, #0]
3401b286:	1821      	adds	r1, r4, r0
3401b288:	428b      	cmp	r3, r1
3401b28a:	bf01      	itttt	eq
3401b28c:	6819      	ldreq	r1, [r3, #0]
3401b28e:	685b      	ldreq	r3, [r3, #4]
3401b290:	1809      	addeq	r1, r1, r0
3401b292:	6021      	streq	r1, [r4, #0]
3401b294:	e7ed      	b.n	3401b272 <_free_r+0x1e>
3401b296:	461a      	mov	r2, r3
3401b298:	685b      	ldr	r3, [r3, #4]
3401b29a:	b10b      	cbz	r3, 3401b2a0 <_free_r+0x4c>
3401b29c:	42a3      	cmp	r3, r4
3401b29e:	d9fa      	bls.n	3401b296 <_free_r+0x42>
3401b2a0:	6811      	ldr	r1, [r2, #0]
3401b2a2:	1850      	adds	r0, r2, r1
3401b2a4:	42a0      	cmp	r0, r4
3401b2a6:	d10b      	bne.n	3401b2c0 <_free_r+0x6c>
3401b2a8:	6820      	ldr	r0, [r4, #0]
3401b2aa:	4401      	add	r1, r0
3401b2ac:	1850      	adds	r0, r2, r1
3401b2ae:	6011      	str	r1, [r2, #0]
3401b2b0:	4283      	cmp	r3, r0
3401b2b2:	d1e0      	bne.n	3401b276 <_free_r+0x22>
3401b2b4:	6818      	ldr	r0, [r3, #0]
3401b2b6:	685b      	ldr	r3, [r3, #4]
3401b2b8:	4408      	add	r0, r1
3401b2ba:	6053      	str	r3, [r2, #4]
3401b2bc:	6010      	str	r0, [r2, #0]
3401b2be:	e7da      	b.n	3401b276 <_free_r+0x22>
3401b2c0:	d902      	bls.n	3401b2c8 <_free_r+0x74>
3401b2c2:	230c      	movs	r3, #12
3401b2c4:	602b      	str	r3, [r5, #0]
3401b2c6:	e7d6      	b.n	3401b276 <_free_r+0x22>
3401b2c8:	6820      	ldr	r0, [r4, #0]
3401b2ca:	1821      	adds	r1, r4, r0
3401b2cc:	428b      	cmp	r3, r1
3401b2ce:	bf02      	ittt	eq
3401b2d0:	6819      	ldreq	r1, [r3, #0]
3401b2d2:	685b      	ldreq	r3, [r3, #4]
3401b2d4:	1809      	addeq	r1, r1, r0
3401b2d6:	6063      	str	r3, [r4, #4]
3401b2d8:	bf08      	it	eq
3401b2da:	6021      	streq	r1, [r4, #0]
3401b2dc:	6054      	str	r4, [r2, #4]
3401b2de:	e7ca      	b.n	3401b276 <_free_r+0x22>
3401b2e0:	bd38      	pop	{r3, r4, r5, pc}
3401b2e2:	bf00      	nop
3401b2e4:	340ceef0 	.word	0x340ceef0

3401b2e8 <_Balloc>:
3401b2e8:	b570      	push	{r4, r5, r6, lr}
3401b2ea:	69c6      	ldr	r6, [r0, #28]
3401b2ec:	4604      	mov	r4, r0
3401b2ee:	460d      	mov	r5, r1
3401b2f0:	b976      	cbnz	r6, 3401b310 <_Balloc+0x28>
3401b2f2:	2010      	movs	r0, #16
3401b2f4:	f7fd fdd0 	bl	34018e98 <malloc>
3401b2f8:	4602      	mov	r2, r0
3401b2fa:	61e0      	str	r0, [r4, #28]
3401b2fc:	b920      	cbnz	r0, 3401b308 <_Balloc+0x20>
3401b2fe:	4b18      	ldr	r3, [pc, #96]	@ (3401b360 <_Balloc+0x78>)
3401b300:	216b      	movs	r1, #107	@ 0x6b
3401b302:	4818      	ldr	r0, [pc, #96]	@ (3401b364 <_Balloc+0x7c>)
3401b304:	f7fd fdaa 	bl	34018e5c <__assert_func>
3401b308:	e9c0 6601 	strd	r6, r6, [r0, #4]
3401b30c:	6006      	str	r6, [r0, #0]
3401b30e:	60c6      	str	r6, [r0, #12]
3401b310:	69e6      	ldr	r6, [r4, #28]
3401b312:	68f3      	ldr	r3, [r6, #12]
3401b314:	b183      	cbz	r3, 3401b338 <_Balloc+0x50>
3401b316:	69e3      	ldr	r3, [r4, #28]
3401b318:	68db      	ldr	r3, [r3, #12]
3401b31a:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
3401b31e:	b9b8      	cbnz	r0, 3401b350 <_Balloc+0x68>
3401b320:	2101      	movs	r1, #1
3401b322:	4620      	mov	r0, r4
3401b324:	fa01 f605 	lsl.w	r6, r1, r5
3401b328:	1d72      	adds	r2, r6, #5
3401b32a:	0092      	lsls	r2, r2, #2
3401b32c:	f000 ff74 	bl	3401c218 <_calloc_r>
3401b330:	b160      	cbz	r0, 3401b34c <_Balloc+0x64>
3401b332:	e9c0 5601 	strd	r5, r6, [r0, #4]
3401b336:	e00e      	b.n	3401b356 <_Balloc+0x6e>
3401b338:	2221      	movs	r2, #33	@ 0x21
3401b33a:	2104      	movs	r1, #4
3401b33c:	4620      	mov	r0, r4
3401b33e:	f000 ff6b 	bl	3401c218 <_calloc_r>
3401b342:	69e3      	ldr	r3, [r4, #28]
3401b344:	60f0      	str	r0, [r6, #12]
3401b346:	68db      	ldr	r3, [r3, #12]
3401b348:	2b00      	cmp	r3, #0
3401b34a:	d1e4      	bne.n	3401b316 <_Balloc+0x2e>
3401b34c:	2000      	movs	r0, #0
3401b34e:	bd70      	pop	{r4, r5, r6, pc}
3401b350:	6802      	ldr	r2, [r0, #0]
3401b352:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
3401b356:	2300      	movs	r3, #0
3401b358:	e9c0 3303 	strd	r3, r3, [r0, #12]
3401b35c:	e7f7      	b.n	3401b34e <_Balloc+0x66>
3401b35e:	bf00      	nop
3401b360:	34022cfb 	.word	0x34022cfb
3401b364:	34022d7b 	.word	0x34022d7b

3401b368 <_Bfree>:
3401b368:	b570      	push	{r4, r5, r6, lr}
3401b36a:	69c6      	ldr	r6, [r0, #28]
3401b36c:	4605      	mov	r5, r0
3401b36e:	460c      	mov	r4, r1
3401b370:	b976      	cbnz	r6, 3401b390 <_Bfree+0x28>
3401b372:	2010      	movs	r0, #16
3401b374:	f7fd fd90 	bl	34018e98 <malloc>
3401b378:	4602      	mov	r2, r0
3401b37a:	61e8      	str	r0, [r5, #28]
3401b37c:	b920      	cbnz	r0, 3401b388 <_Bfree+0x20>
3401b37e:	4b09      	ldr	r3, [pc, #36]	@ (3401b3a4 <_Bfree+0x3c>)
3401b380:	218f      	movs	r1, #143	@ 0x8f
3401b382:	4809      	ldr	r0, [pc, #36]	@ (3401b3a8 <_Bfree+0x40>)
3401b384:	f7fd fd6a 	bl	34018e5c <__assert_func>
3401b388:	e9c0 6601 	strd	r6, r6, [r0, #4]
3401b38c:	6006      	str	r6, [r0, #0]
3401b38e:	60c6      	str	r6, [r0, #12]
3401b390:	b13c      	cbz	r4, 3401b3a2 <_Bfree+0x3a>
3401b392:	69eb      	ldr	r3, [r5, #28]
3401b394:	6862      	ldr	r2, [r4, #4]
3401b396:	68db      	ldr	r3, [r3, #12]
3401b398:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
3401b39c:	6021      	str	r1, [r4, #0]
3401b39e:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
3401b3a2:	bd70      	pop	{r4, r5, r6, pc}
3401b3a4:	34022cfb 	.word	0x34022cfb
3401b3a8:	34022d7b 	.word	0x34022d7b

3401b3ac <__multadd>:
3401b3ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3401b3b0:	f101 0c14 	add.w	ip, r1, #20
3401b3b4:	4607      	mov	r7, r0
3401b3b6:	460c      	mov	r4, r1
3401b3b8:	461e      	mov	r6, r3
3401b3ba:	690d      	ldr	r5, [r1, #16]
3401b3bc:	2000      	movs	r0, #0
3401b3be:	f8dc 3000 	ldr.w	r3, [ip]
3401b3c2:	3001      	adds	r0, #1
3401b3c4:	b299      	uxth	r1, r3
3401b3c6:	4285      	cmp	r5, r0
3401b3c8:	fb02 6101 	mla	r1, r2, r1, r6
3401b3cc:	ea4f 4613 	mov.w	r6, r3, lsr #16
3401b3d0:	ea4f 4311 	mov.w	r3, r1, lsr #16
3401b3d4:	b289      	uxth	r1, r1
3401b3d6:	fb02 3306 	mla	r3, r2, r6, r3
3401b3da:	eb01 4103 	add.w	r1, r1, r3, lsl #16
3401b3de:	ea4f 4613 	mov.w	r6, r3, lsr #16
3401b3e2:	f84c 1b04 	str.w	r1, [ip], #4
3401b3e6:	dcea      	bgt.n	3401b3be <__multadd+0x12>
3401b3e8:	b30e      	cbz	r6, 3401b42e <__multadd+0x82>
3401b3ea:	68a3      	ldr	r3, [r4, #8]
3401b3ec:	42ab      	cmp	r3, r5
3401b3ee:	dc19      	bgt.n	3401b424 <__multadd+0x78>
3401b3f0:	6861      	ldr	r1, [r4, #4]
3401b3f2:	4638      	mov	r0, r7
3401b3f4:	3101      	adds	r1, #1
3401b3f6:	f7ff ff77 	bl	3401b2e8 <_Balloc>
3401b3fa:	4680      	mov	r8, r0
3401b3fc:	b928      	cbnz	r0, 3401b40a <__multadd+0x5e>
3401b3fe:	4602      	mov	r2, r0
3401b400:	4b0c      	ldr	r3, [pc, #48]	@ (3401b434 <__multadd+0x88>)
3401b402:	21ba      	movs	r1, #186	@ 0xba
3401b404:	480c      	ldr	r0, [pc, #48]	@ (3401b438 <__multadd+0x8c>)
3401b406:	f7fd fd29 	bl	34018e5c <__assert_func>
3401b40a:	6922      	ldr	r2, [r4, #16]
3401b40c:	f104 010c 	add.w	r1, r4, #12
3401b410:	300c      	adds	r0, #12
3401b412:	3202      	adds	r2, #2
3401b414:	0092      	lsls	r2, r2, #2
3401b416:	f7ff f91c 	bl	3401a652 <memcpy>
3401b41a:	4621      	mov	r1, r4
3401b41c:	4644      	mov	r4, r8
3401b41e:	4638      	mov	r0, r7
3401b420:	f7ff ffa2 	bl	3401b368 <_Bfree>
3401b424:	eb04 0385 	add.w	r3, r4, r5, lsl #2
3401b428:	3501      	adds	r5, #1
3401b42a:	615e      	str	r6, [r3, #20]
3401b42c:	6125      	str	r5, [r4, #16]
3401b42e:	4620      	mov	r0, r4
3401b430:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3401b434:	34022d6a 	.word	0x34022d6a
3401b438:	34022d7b 	.word	0x34022d7b

3401b43c <__hi0bits>:
3401b43c:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
3401b440:	4603      	mov	r3, r0
3401b442:	bf36      	itet	cc
3401b444:	0403      	lslcc	r3, r0, #16
3401b446:	2000      	movcs	r0, #0
3401b448:	2010      	movcc	r0, #16
3401b44a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3401b44e:	bf3c      	itt	cc
3401b450:	021b      	lslcc	r3, r3, #8
3401b452:	3008      	addcc	r0, #8
3401b454:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401b458:	bf3c      	itt	cc
3401b45a:	011b      	lslcc	r3, r3, #4
3401b45c:	3004      	addcc	r0, #4
3401b45e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3401b462:	bf3c      	itt	cc
3401b464:	009b      	lslcc	r3, r3, #2
3401b466:	3002      	addcc	r0, #2
3401b468:	2b00      	cmp	r3, #0
3401b46a:	db05      	blt.n	3401b478 <__hi0bits+0x3c>
3401b46c:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
3401b470:	f100 0001 	add.w	r0, r0, #1
3401b474:	bf08      	it	eq
3401b476:	2020      	moveq	r0, #32
3401b478:	4770      	bx	lr

3401b47a <__lo0bits>:
3401b47a:	6803      	ldr	r3, [r0, #0]
3401b47c:	4602      	mov	r2, r0
3401b47e:	f013 0007 	ands.w	r0, r3, #7
3401b482:	d00b      	beq.n	3401b49c <__lo0bits+0x22>
3401b484:	07d9      	lsls	r1, r3, #31
3401b486:	d421      	bmi.n	3401b4cc <__lo0bits+0x52>
3401b488:	0798      	lsls	r0, r3, #30
3401b48a:	bf47      	ittee	mi
3401b48c:	085b      	lsrmi	r3, r3, #1
3401b48e:	2001      	movmi	r0, #1
3401b490:	089b      	lsrpl	r3, r3, #2
3401b492:	2002      	movpl	r0, #2
3401b494:	bf4c      	ite	mi
3401b496:	6013      	strmi	r3, [r2, #0]
3401b498:	6013      	strpl	r3, [r2, #0]
3401b49a:	4770      	bx	lr
3401b49c:	b299      	uxth	r1, r3
3401b49e:	b909      	cbnz	r1, 3401b4a4 <__lo0bits+0x2a>
3401b4a0:	0c1b      	lsrs	r3, r3, #16
3401b4a2:	2010      	movs	r0, #16
3401b4a4:	b2d9      	uxtb	r1, r3
3401b4a6:	b909      	cbnz	r1, 3401b4ac <__lo0bits+0x32>
3401b4a8:	3008      	adds	r0, #8
3401b4aa:	0a1b      	lsrs	r3, r3, #8
3401b4ac:	0719      	lsls	r1, r3, #28
3401b4ae:	bf04      	itt	eq
3401b4b0:	091b      	lsreq	r3, r3, #4
3401b4b2:	3004      	addeq	r0, #4
3401b4b4:	0799      	lsls	r1, r3, #30
3401b4b6:	bf04      	itt	eq
3401b4b8:	089b      	lsreq	r3, r3, #2
3401b4ba:	3002      	addeq	r0, #2
3401b4bc:	07d9      	lsls	r1, r3, #31
3401b4be:	d403      	bmi.n	3401b4c8 <__lo0bits+0x4e>
3401b4c0:	085b      	lsrs	r3, r3, #1
3401b4c2:	f100 0001 	add.w	r0, r0, #1
3401b4c6:	d003      	beq.n	3401b4d0 <__lo0bits+0x56>
3401b4c8:	6013      	str	r3, [r2, #0]
3401b4ca:	4770      	bx	lr
3401b4cc:	2000      	movs	r0, #0
3401b4ce:	4770      	bx	lr
3401b4d0:	2020      	movs	r0, #32
3401b4d2:	4770      	bx	lr

3401b4d4 <__i2b>:
3401b4d4:	b510      	push	{r4, lr}
3401b4d6:	460c      	mov	r4, r1
3401b4d8:	2101      	movs	r1, #1
3401b4da:	f7ff ff05 	bl	3401b2e8 <_Balloc>
3401b4de:	4602      	mov	r2, r0
3401b4e0:	b928      	cbnz	r0, 3401b4ee <__i2b+0x1a>
3401b4e2:	4b05      	ldr	r3, [pc, #20]	@ (3401b4f8 <__i2b+0x24>)
3401b4e4:	f240 1145 	movw	r1, #325	@ 0x145
3401b4e8:	4804      	ldr	r0, [pc, #16]	@ (3401b4fc <__i2b+0x28>)
3401b4ea:	f7fd fcb7 	bl	34018e5c <__assert_func>
3401b4ee:	2301      	movs	r3, #1
3401b4f0:	6144      	str	r4, [r0, #20]
3401b4f2:	6103      	str	r3, [r0, #16]
3401b4f4:	bd10      	pop	{r4, pc}
3401b4f6:	bf00      	nop
3401b4f8:	34022d6a 	.word	0x34022d6a
3401b4fc:	34022d7b 	.word	0x34022d7b

3401b500 <__multiply>:
3401b500:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b504:	4617      	mov	r7, r2
3401b506:	690a      	ldr	r2, [r1, #16]
3401b508:	4689      	mov	r9, r1
3401b50a:	b085      	sub	sp, #20
3401b50c:	693b      	ldr	r3, [r7, #16]
3401b50e:	429a      	cmp	r2, r3
3401b510:	bfa2      	ittt	ge
3401b512:	463b      	movge	r3, r7
3401b514:	460f      	movge	r7, r1
3401b516:	4699      	movge	r9, r3
3401b518:	693d      	ldr	r5, [r7, #16]
3401b51a:	68bb      	ldr	r3, [r7, #8]
3401b51c:	f8d9 a010 	ldr.w	sl, [r9, #16]
3401b520:	6879      	ldr	r1, [r7, #4]
3401b522:	eb05 060a 	add.w	r6, r5, sl
3401b526:	42b3      	cmp	r3, r6
3401b528:	bfb8      	it	lt
3401b52a:	3101      	addlt	r1, #1
3401b52c:	f7ff fedc 	bl	3401b2e8 <_Balloc>
3401b530:	b930      	cbnz	r0, 3401b540 <__multiply+0x40>
3401b532:	4602      	mov	r2, r0
3401b534:	4b42      	ldr	r3, [pc, #264]	@ (3401b640 <__multiply+0x140>)
3401b536:	f44f 71b1 	mov.w	r1, #354	@ 0x162
3401b53a:	4842      	ldr	r0, [pc, #264]	@ (3401b644 <__multiply+0x144>)
3401b53c:	f7fd fc8e 	bl	34018e5c <__assert_func>
3401b540:	f100 0414 	add.w	r4, r0, #20
3401b544:	2200      	movs	r2, #0
3401b546:	eb04 0e86 	add.w	lr, r4, r6, lsl #2
3401b54a:	4623      	mov	r3, r4
3401b54c:	4573      	cmp	r3, lr
3401b54e:	d320      	bcc.n	3401b592 <__multiply+0x92>
3401b550:	f107 0814 	add.w	r8, r7, #20
3401b554:	f109 0114 	add.w	r1, r9, #20
3401b558:	eb08 0585 	add.w	r5, r8, r5, lsl #2
3401b55c:	eb01 038a 	add.w	r3, r1, sl, lsl #2
3401b560:	9302      	str	r3, [sp, #8]
3401b562:	1beb      	subs	r3, r5, r7
3401b564:	3715      	adds	r7, #21
3401b566:	3b15      	subs	r3, #21
3401b568:	f023 0303 	bic.w	r3, r3, #3
3401b56c:	3304      	adds	r3, #4
3401b56e:	42bd      	cmp	r5, r7
3401b570:	bf38      	it	cc
3401b572:	2304      	movcc	r3, #4
3401b574:	9301      	str	r3, [sp, #4]
3401b576:	9b02      	ldr	r3, [sp, #8]
3401b578:	9103      	str	r1, [sp, #12]
3401b57a:	428b      	cmp	r3, r1
3401b57c:	d80c      	bhi.n	3401b598 <__multiply+0x98>
3401b57e:	2e00      	cmp	r6, #0
3401b580:	dd03      	ble.n	3401b58a <__multiply+0x8a>
3401b582:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
3401b586:	2b00      	cmp	r3, #0
3401b588:	d057      	beq.n	3401b63a <__multiply+0x13a>
3401b58a:	6106      	str	r6, [r0, #16]
3401b58c:	b005      	add	sp, #20
3401b58e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401b592:	f843 2b04 	str.w	r2, [r3], #4
3401b596:	e7d9      	b.n	3401b54c <__multiply+0x4c>
3401b598:	f8b1 a000 	ldrh.w	sl, [r1]
3401b59c:	f1ba 0f00 	cmp.w	sl, #0
3401b5a0:	d021      	beq.n	3401b5e6 <__multiply+0xe6>
3401b5a2:	46c4      	mov	ip, r8
3401b5a4:	46a1      	mov	r9, r4
3401b5a6:	2700      	movs	r7, #0
3401b5a8:	f85c 2b04 	ldr.w	r2, [ip], #4
3401b5ac:	f8d9 3000 	ldr.w	r3, [r9]
3401b5b0:	fa1f fb82 	uxth.w	fp, r2
3401b5b4:	4565      	cmp	r5, ip
3401b5b6:	b29b      	uxth	r3, r3
3401b5b8:	ea4f 4212 	mov.w	r2, r2, lsr #16
3401b5bc:	fb0a 330b 	mla	r3, sl, fp, r3
3401b5c0:	443b      	add	r3, r7
3401b5c2:	f8d9 7000 	ldr.w	r7, [r9]
3401b5c6:	ea4f 4717 	mov.w	r7, r7, lsr #16
3401b5ca:	fb0a 7202 	mla	r2, sl, r2, r7
3401b5ce:	eb02 4213 	add.w	r2, r2, r3, lsr #16
3401b5d2:	b29b      	uxth	r3, r3
3401b5d4:	ea4f 4712 	mov.w	r7, r2, lsr #16
3401b5d8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3401b5dc:	f849 3b04 	str.w	r3, [r9], #4
3401b5e0:	d8e2      	bhi.n	3401b5a8 <__multiply+0xa8>
3401b5e2:	9b01      	ldr	r3, [sp, #4]
3401b5e4:	50e7      	str	r7, [r4, r3]
3401b5e6:	9b03      	ldr	r3, [sp, #12]
3401b5e8:	3104      	adds	r1, #4
3401b5ea:	f8b3 9002 	ldrh.w	r9, [r3, #2]
3401b5ee:	f1b9 0f00 	cmp.w	r9, #0
3401b5f2:	d020      	beq.n	3401b636 <__multiply+0x136>
3401b5f4:	6823      	ldr	r3, [r4, #0]
3401b5f6:	4647      	mov	r7, r8
3401b5f8:	46a4      	mov	ip, r4
3401b5fa:	f04f 0a00 	mov.w	sl, #0
3401b5fe:	f8b7 b000 	ldrh.w	fp, [r7]
3401b602:	b29b      	uxth	r3, r3
3401b604:	f8bc 2002 	ldrh.w	r2, [ip, #2]
3401b608:	fb09 220b 	mla	r2, r9, fp, r2
3401b60c:	4452      	add	r2, sl
3401b60e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3401b612:	f84c 3b04 	str.w	r3, [ip], #4
3401b616:	f857 3b04 	ldr.w	r3, [r7], #4
3401b61a:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3401b61e:	f8bc 3000 	ldrh.w	r3, [ip]
3401b622:	42bd      	cmp	r5, r7
3401b624:	fb09 330a 	mla	r3, r9, sl, r3
3401b628:	eb03 4312 	add.w	r3, r3, r2, lsr #16
3401b62c:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3401b630:	d8e5      	bhi.n	3401b5fe <__multiply+0xfe>
3401b632:	9a01      	ldr	r2, [sp, #4]
3401b634:	50a3      	str	r3, [r4, r2]
3401b636:	3404      	adds	r4, #4
3401b638:	e79d      	b.n	3401b576 <__multiply+0x76>
3401b63a:	3e01      	subs	r6, #1
3401b63c:	e79f      	b.n	3401b57e <__multiply+0x7e>
3401b63e:	bf00      	nop
3401b640:	34022d6a 	.word	0x34022d6a
3401b644:	34022d7b 	.word	0x34022d7b

3401b648 <__pow5mult>:
3401b648:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3401b64c:	4615      	mov	r5, r2
3401b64e:	f012 0203 	ands.w	r2, r2, #3
3401b652:	4607      	mov	r7, r0
3401b654:	460e      	mov	r6, r1
3401b656:	d007      	beq.n	3401b668 <__pow5mult+0x20>
3401b658:	3a01      	subs	r2, #1
3401b65a:	4c25      	ldr	r4, [pc, #148]	@ (3401b6f0 <__pow5mult+0xa8>)
3401b65c:	2300      	movs	r3, #0
3401b65e:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
3401b662:	f7ff fea3 	bl	3401b3ac <__multadd>
3401b666:	4606      	mov	r6, r0
3401b668:	10ad      	asrs	r5, r5, #2
3401b66a:	d03d      	beq.n	3401b6e8 <__pow5mult+0xa0>
3401b66c:	69fc      	ldr	r4, [r7, #28]
3401b66e:	b97c      	cbnz	r4, 3401b690 <__pow5mult+0x48>
3401b670:	2010      	movs	r0, #16
3401b672:	f7fd fc11 	bl	34018e98 <malloc>
3401b676:	4602      	mov	r2, r0
3401b678:	61f8      	str	r0, [r7, #28]
3401b67a:	b928      	cbnz	r0, 3401b688 <__pow5mult+0x40>
3401b67c:	4b1d      	ldr	r3, [pc, #116]	@ (3401b6f4 <__pow5mult+0xac>)
3401b67e:	f240 11b3 	movw	r1, #435	@ 0x1b3
3401b682:	481d      	ldr	r0, [pc, #116]	@ (3401b6f8 <__pow5mult+0xb0>)
3401b684:	f7fd fbea 	bl	34018e5c <__assert_func>
3401b688:	e9c0 4401 	strd	r4, r4, [r0, #4]
3401b68c:	6004      	str	r4, [r0, #0]
3401b68e:	60c4      	str	r4, [r0, #12]
3401b690:	f8d7 801c 	ldr.w	r8, [r7, #28]
3401b694:	f8d8 4008 	ldr.w	r4, [r8, #8]
3401b698:	b94c      	cbnz	r4, 3401b6ae <__pow5mult+0x66>
3401b69a:	f240 2171 	movw	r1, #625	@ 0x271
3401b69e:	4638      	mov	r0, r7
3401b6a0:	f7ff ff18 	bl	3401b4d4 <__i2b>
3401b6a4:	2300      	movs	r3, #0
3401b6a6:	4604      	mov	r4, r0
3401b6a8:	f8c8 0008 	str.w	r0, [r8, #8]
3401b6ac:	6003      	str	r3, [r0, #0]
3401b6ae:	f04f 0900 	mov.w	r9, #0
3401b6b2:	07eb      	lsls	r3, r5, #31
3401b6b4:	d50a      	bpl.n	3401b6cc <__pow5mult+0x84>
3401b6b6:	4631      	mov	r1, r6
3401b6b8:	4622      	mov	r2, r4
3401b6ba:	4638      	mov	r0, r7
3401b6bc:	f7ff ff20 	bl	3401b500 <__multiply>
3401b6c0:	4680      	mov	r8, r0
3401b6c2:	4631      	mov	r1, r6
3401b6c4:	4638      	mov	r0, r7
3401b6c6:	4646      	mov	r6, r8
3401b6c8:	f7ff fe4e 	bl	3401b368 <_Bfree>
3401b6cc:	106d      	asrs	r5, r5, #1
3401b6ce:	d00b      	beq.n	3401b6e8 <__pow5mult+0xa0>
3401b6d0:	6820      	ldr	r0, [r4, #0]
3401b6d2:	b938      	cbnz	r0, 3401b6e4 <__pow5mult+0x9c>
3401b6d4:	4622      	mov	r2, r4
3401b6d6:	4621      	mov	r1, r4
3401b6d8:	4638      	mov	r0, r7
3401b6da:	f7ff ff11 	bl	3401b500 <__multiply>
3401b6de:	6020      	str	r0, [r4, #0]
3401b6e0:	f8c0 9000 	str.w	r9, [r0]
3401b6e4:	4604      	mov	r4, r0
3401b6e6:	e7e4      	b.n	3401b6b2 <__pow5mult+0x6a>
3401b6e8:	4630      	mov	r0, r6
3401b6ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3401b6ee:	bf00      	nop
3401b6f0:	340ae7e8 	.word	0x340ae7e8
3401b6f4:	34022cfb 	.word	0x34022cfb
3401b6f8:	34022d7b 	.word	0x34022d7b

3401b6fc <__lshift>:
3401b6fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
3401b700:	460c      	mov	r4, r1
3401b702:	4607      	mov	r7, r0
3401b704:	4691      	mov	r9, r2
3401b706:	ea4f 1a62 	mov.w	sl, r2, asr #5
3401b70a:	6923      	ldr	r3, [r4, #16]
3401b70c:	6849      	ldr	r1, [r1, #4]
3401b70e:	eb03 1862 	add.w	r8, r3, r2, asr #5
3401b712:	68a3      	ldr	r3, [r4, #8]
3401b714:	f108 0601 	add.w	r6, r8, #1
3401b718:	42b3      	cmp	r3, r6
3401b71a:	db0b      	blt.n	3401b734 <__lshift+0x38>
3401b71c:	4638      	mov	r0, r7
3401b71e:	f7ff fde3 	bl	3401b2e8 <_Balloc>
3401b722:	4605      	mov	r5, r0
3401b724:	b948      	cbnz	r0, 3401b73a <__lshift+0x3e>
3401b726:	4602      	mov	r2, r0
3401b728:	4b28      	ldr	r3, [pc, #160]	@ (3401b7cc <__lshift+0xd0>)
3401b72a:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
3401b72e:	4828      	ldr	r0, [pc, #160]	@ (3401b7d0 <__lshift+0xd4>)
3401b730:	f7fd fb94 	bl	34018e5c <__assert_func>
3401b734:	3101      	adds	r1, #1
3401b736:	005b      	lsls	r3, r3, #1
3401b738:	e7ee      	b.n	3401b718 <__lshift+0x1c>
3401b73a:	2300      	movs	r3, #0
3401b73c:	f100 0114 	add.w	r1, r0, #20
3401b740:	f100 0210 	add.w	r2, r0, #16
3401b744:	4618      	mov	r0, r3
3401b746:	4553      	cmp	r3, sl
3401b748:	db33      	blt.n	3401b7b2 <__lshift+0xb6>
3401b74a:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
3401b74e:	f104 0314 	add.w	r3, r4, #20
3401b752:	6920      	ldr	r0, [r4, #16]
3401b754:	f019 091f 	ands.w	r9, r9, #31
3401b758:	eb01 018a 	add.w	r1, r1, sl, lsl #2
3401b75c:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
3401b760:	d02b      	beq.n	3401b7ba <__lshift+0xbe>
3401b762:	f1c9 0e20 	rsb	lr, r9, #32
3401b766:	468a      	mov	sl, r1
3401b768:	2200      	movs	r2, #0
3401b76a:	6818      	ldr	r0, [r3, #0]
3401b76c:	fa00 f009 	lsl.w	r0, r0, r9
3401b770:	4310      	orrs	r0, r2
3401b772:	f84a 0b04 	str.w	r0, [sl], #4
3401b776:	f853 2b04 	ldr.w	r2, [r3], #4
3401b77a:	459c      	cmp	ip, r3
3401b77c:	fa22 f20e 	lsr.w	r2, r2, lr
3401b780:	d8f3      	bhi.n	3401b76a <__lshift+0x6e>
3401b782:	ebac 0304 	sub.w	r3, ip, r4
3401b786:	f104 0015 	add.w	r0, r4, #21
3401b78a:	3b15      	subs	r3, #21
3401b78c:	f023 0303 	bic.w	r3, r3, #3
3401b790:	3304      	adds	r3, #4
3401b792:	4560      	cmp	r0, ip
3401b794:	bf88      	it	hi
3401b796:	2304      	movhi	r3, #4
3401b798:	50ca      	str	r2, [r1, r3]
3401b79a:	b10a      	cbz	r2, 3401b7a0 <__lshift+0xa4>
3401b79c:	f108 0602 	add.w	r6, r8, #2
3401b7a0:	3e01      	subs	r6, #1
3401b7a2:	4638      	mov	r0, r7
3401b7a4:	4621      	mov	r1, r4
3401b7a6:	612e      	str	r6, [r5, #16]
3401b7a8:	f7ff fdde 	bl	3401b368 <_Bfree>
3401b7ac:	4628      	mov	r0, r5
3401b7ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3401b7b2:	3301      	adds	r3, #1
3401b7b4:	f842 0f04 	str.w	r0, [r2, #4]!
3401b7b8:	e7c5      	b.n	3401b746 <__lshift+0x4a>
3401b7ba:	3904      	subs	r1, #4
3401b7bc:	f853 2b04 	ldr.w	r2, [r3], #4
3401b7c0:	459c      	cmp	ip, r3
3401b7c2:	f841 2f04 	str.w	r2, [r1, #4]!
3401b7c6:	d8f9      	bhi.n	3401b7bc <__lshift+0xc0>
3401b7c8:	e7ea      	b.n	3401b7a0 <__lshift+0xa4>
3401b7ca:	bf00      	nop
3401b7cc:	34022d6a 	.word	0x34022d6a
3401b7d0:	34022d7b 	.word	0x34022d7b

3401b7d4 <__mcmp>:
3401b7d4:	4603      	mov	r3, r0
3401b7d6:	690a      	ldr	r2, [r1, #16]
3401b7d8:	6900      	ldr	r0, [r0, #16]
3401b7da:	1a80      	subs	r0, r0, r2
3401b7dc:	b530      	push	{r4, r5, lr}
3401b7de:	d10e      	bne.n	3401b7fe <__mcmp+0x2a>
3401b7e0:	3314      	adds	r3, #20
3401b7e2:	3114      	adds	r1, #20
3401b7e4:	eb03 0482 	add.w	r4, r3, r2, lsl #2
3401b7e8:	eb01 0182 	add.w	r1, r1, r2, lsl #2
3401b7ec:	f854 5d04 	ldr.w	r5, [r4, #-4]!
3401b7f0:	f851 2d04 	ldr.w	r2, [r1, #-4]!
3401b7f4:	4295      	cmp	r5, r2
3401b7f6:	d003      	beq.n	3401b800 <__mcmp+0x2c>
3401b7f8:	d205      	bcs.n	3401b806 <__mcmp+0x32>
3401b7fa:	f04f 30ff 	mov.w	r0, #4294967295
3401b7fe:	bd30      	pop	{r4, r5, pc}
3401b800:	42a3      	cmp	r3, r4
3401b802:	d3f3      	bcc.n	3401b7ec <__mcmp+0x18>
3401b804:	e7fb      	b.n	3401b7fe <__mcmp+0x2a>
3401b806:	2001      	movs	r0, #1
3401b808:	e7f9      	b.n	3401b7fe <__mcmp+0x2a>
	...

3401b80c <__mdiff>:
3401b80c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b810:	4689      	mov	r9, r1
3401b812:	4606      	mov	r6, r0
3401b814:	4611      	mov	r1, r2
3401b816:	4614      	mov	r4, r2
3401b818:	4648      	mov	r0, r9
3401b81a:	f7ff ffdb 	bl	3401b7d4 <__mcmp>
3401b81e:	1e05      	subs	r5, r0, #0
3401b820:	d112      	bne.n	3401b848 <__mdiff+0x3c>
3401b822:	4629      	mov	r1, r5
3401b824:	4630      	mov	r0, r6
3401b826:	f7ff fd5f 	bl	3401b2e8 <_Balloc>
3401b82a:	4602      	mov	r2, r0
3401b82c:	b928      	cbnz	r0, 3401b83a <__mdiff+0x2e>
3401b82e:	4b41      	ldr	r3, [pc, #260]	@ (3401b934 <__mdiff+0x128>)
3401b830:	f240 2137 	movw	r1, #567	@ 0x237
3401b834:	4840      	ldr	r0, [pc, #256]	@ (3401b938 <__mdiff+0x12c>)
3401b836:	f7fd fb11 	bl	34018e5c <__assert_func>
3401b83a:	2301      	movs	r3, #1
3401b83c:	e9c0 3504 	strd	r3, r5, [r0, #16]
3401b840:	4610      	mov	r0, r2
3401b842:	b003      	add	sp, #12
3401b844:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401b848:	bfbc      	itt	lt
3401b84a:	464b      	movlt	r3, r9
3401b84c:	46a1      	movlt	r9, r4
3401b84e:	4630      	mov	r0, r6
3401b850:	bfb8      	it	lt
3401b852:	2501      	movlt	r5, #1
3401b854:	f8d9 1004 	ldr.w	r1, [r9, #4]
3401b858:	bfb4      	ite	lt
3401b85a:	461c      	movlt	r4, r3
3401b85c:	2500      	movge	r5, #0
3401b85e:	f7ff fd43 	bl	3401b2e8 <_Balloc>
3401b862:	4602      	mov	r2, r0
3401b864:	b918      	cbnz	r0, 3401b86e <__mdiff+0x62>
3401b866:	4b33      	ldr	r3, [pc, #204]	@ (3401b934 <__mdiff+0x128>)
3401b868:	f240 2145 	movw	r1, #581	@ 0x245
3401b86c:	e7e2      	b.n	3401b834 <__mdiff+0x28>
3401b86e:	f8d9 7010 	ldr.w	r7, [r9, #16]
3401b872:	f104 0e14 	add.w	lr, r4, #20
3401b876:	6926      	ldr	r6, [r4, #16]
3401b878:	f100 0b14 	add.w	fp, r0, #20
3401b87c:	60c5      	str	r5, [r0, #12]
3401b87e:	f109 0514 	add.w	r5, r9, #20
3401b882:	f109 0310 	add.w	r3, r9, #16
3401b886:	eb0e 0686 	add.w	r6, lr, r6, lsl #2
3401b88a:	eb05 0887 	add.w	r8, r5, r7, lsl #2
3401b88e:	46d9      	mov	r9, fp
3401b890:	f04f 0c00 	mov.w	ip, #0
3401b894:	9301      	str	r3, [sp, #4]
3401b896:	9b01      	ldr	r3, [sp, #4]
3401b898:	f85e 0b04 	ldr.w	r0, [lr], #4
3401b89c:	f853 af04 	ldr.w	sl, [r3, #4]!
3401b8a0:	4576      	cmp	r6, lr
3401b8a2:	9301      	str	r3, [sp, #4]
3401b8a4:	fa1f f38a 	uxth.w	r3, sl
3401b8a8:	4619      	mov	r1, r3
3401b8aa:	b283      	uxth	r3, r0
3401b8ac:	ea4f 4010 	mov.w	r0, r0, lsr #16
3401b8b0:	eba1 0303 	sub.w	r3, r1, r3
3401b8b4:	ebc0 401a 	rsb	r0, r0, sl, lsr #16
3401b8b8:	4463      	add	r3, ip
3401b8ba:	eb00 4023 	add.w	r0, r0, r3, asr #16
3401b8be:	b29b      	uxth	r3, r3
3401b8c0:	ea4f 4c20 	mov.w	ip, r0, asr #16
3401b8c4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3401b8c8:	f849 3b04 	str.w	r3, [r9], #4
3401b8cc:	d8e3      	bhi.n	3401b896 <__mdiff+0x8a>
3401b8ce:	1b33      	subs	r3, r6, r4
3401b8d0:	3415      	adds	r4, #21
3401b8d2:	3b15      	subs	r3, #21
3401b8d4:	f023 0303 	bic.w	r3, r3, #3
3401b8d8:	3304      	adds	r3, #4
3401b8da:	42a6      	cmp	r6, r4
3401b8dc:	bf38      	it	cc
3401b8de:	2304      	movcc	r3, #4
3401b8e0:	441d      	add	r5, r3
3401b8e2:	445b      	add	r3, fp
3401b8e4:	462c      	mov	r4, r5
3401b8e6:	461e      	mov	r6, r3
3401b8e8:	4544      	cmp	r4, r8
3401b8ea:	d30e      	bcc.n	3401b90a <__mdiff+0xfe>
3401b8ec:	f108 0103 	add.w	r1, r8, #3
3401b8f0:	1b49      	subs	r1, r1, r5
3401b8f2:	3d03      	subs	r5, #3
3401b8f4:	f021 0103 	bic.w	r1, r1, #3
3401b8f8:	45a8      	cmp	r8, r5
3401b8fa:	bf38      	it	cc
3401b8fc:	2100      	movcc	r1, #0
3401b8fe:	440b      	add	r3, r1
3401b900:	f853 1d04 	ldr.w	r1, [r3, #-4]!
3401b904:	b199      	cbz	r1, 3401b92e <__mdiff+0x122>
3401b906:	6117      	str	r7, [r2, #16]
3401b908:	e79a      	b.n	3401b840 <__mdiff+0x34>
3401b90a:	f854 1b04 	ldr.w	r1, [r4], #4
3401b90e:	46e6      	mov	lr, ip
3401b910:	fa1f fc81 	uxth.w	ip, r1
3401b914:	0c08      	lsrs	r0, r1, #16
3401b916:	4471      	add	r1, lr
3401b918:	44f4      	add	ip, lr
3401b91a:	b289      	uxth	r1, r1
3401b91c:	eb00 402c 	add.w	r0, r0, ip, asr #16
3401b920:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
3401b924:	ea4f 4c20 	mov.w	ip, r0, asr #16
3401b928:	f846 1b04 	str.w	r1, [r6], #4
3401b92c:	e7dc      	b.n	3401b8e8 <__mdiff+0xdc>
3401b92e:	3f01      	subs	r7, #1
3401b930:	e7e6      	b.n	3401b900 <__mdiff+0xf4>
3401b932:	bf00      	nop
3401b934:	34022d6a 	.word	0x34022d6a
3401b938:	34022d7b 	.word	0x34022d7b

3401b93c <__d2b>:
3401b93c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
3401b940:	460f      	mov	r7, r1
3401b942:	2101      	movs	r1, #1
3401b944:	4616      	mov	r6, r2
3401b946:	ec59 8b10 	vmov	r8, r9, d0
3401b94a:	f7ff fccd 	bl	3401b2e8 <_Balloc>
3401b94e:	4604      	mov	r4, r0
3401b950:	b930      	cbnz	r0, 3401b960 <__d2b+0x24>
3401b952:	4602      	mov	r2, r0
3401b954:	4b23      	ldr	r3, [pc, #140]	@ (3401b9e4 <__d2b+0xa8>)
3401b956:	f240 310f 	movw	r1, #783	@ 0x30f
3401b95a:	4823      	ldr	r0, [pc, #140]	@ (3401b9e8 <__d2b+0xac>)
3401b95c:	f7fd fa7e 	bl	34018e5c <__assert_func>
3401b960:	f3c9 550a 	ubfx	r5, r9, #20, #11
3401b964:	f3c9 0313 	ubfx	r3, r9, #0, #20
3401b968:	b10d      	cbz	r5, 3401b96e <__d2b+0x32>
3401b96a:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
3401b96e:	9301      	str	r3, [sp, #4]
3401b970:	f1b8 0300 	subs.w	r3, r8, #0
3401b974:	d023      	beq.n	3401b9be <__d2b+0x82>
3401b976:	4668      	mov	r0, sp
3401b978:	9300      	str	r3, [sp, #0]
3401b97a:	f7ff fd7e 	bl	3401b47a <__lo0bits>
3401b97e:	e9dd 1200 	ldrd	r1, r2, [sp]
3401b982:	b1d0      	cbz	r0, 3401b9ba <__d2b+0x7e>
3401b984:	f1c0 0320 	rsb	r3, r0, #32
3401b988:	fa02 f303 	lsl.w	r3, r2, r3
3401b98c:	40c2      	lsrs	r2, r0
3401b98e:	430b      	orrs	r3, r1
3401b990:	9201      	str	r2, [sp, #4]
3401b992:	6163      	str	r3, [r4, #20]
3401b994:	9b01      	ldr	r3, [sp, #4]
3401b996:	2b00      	cmp	r3, #0
3401b998:	61a3      	str	r3, [r4, #24]
3401b99a:	bf0c      	ite	eq
3401b99c:	2201      	moveq	r2, #1
3401b99e:	2202      	movne	r2, #2
3401b9a0:	6122      	str	r2, [r4, #16]
3401b9a2:	b1a5      	cbz	r5, 3401b9ce <__d2b+0x92>
3401b9a4:	f2a5 4533 	subw	r5, r5, #1075	@ 0x433
3401b9a8:	4405      	add	r5, r0
3401b9aa:	f1c0 0035 	rsb	r0, r0, #53	@ 0x35
3401b9ae:	603d      	str	r5, [r7, #0]
3401b9b0:	6030      	str	r0, [r6, #0]
3401b9b2:	4620      	mov	r0, r4
3401b9b4:	b003      	add	sp, #12
3401b9b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
3401b9ba:	6161      	str	r1, [r4, #20]
3401b9bc:	e7ea      	b.n	3401b994 <__d2b+0x58>
3401b9be:	a801      	add	r0, sp, #4
3401b9c0:	f7ff fd5b 	bl	3401b47a <__lo0bits>
3401b9c4:	9b01      	ldr	r3, [sp, #4]
3401b9c6:	3020      	adds	r0, #32
3401b9c8:	2201      	movs	r2, #1
3401b9ca:	6163      	str	r3, [r4, #20]
3401b9cc:	e7e8      	b.n	3401b9a0 <__d2b+0x64>
3401b9ce:	f2a0 4032 	subw	r0, r0, #1074	@ 0x432
3401b9d2:	eb04 0382 	add.w	r3, r4, r2, lsl #2
3401b9d6:	6038      	str	r0, [r7, #0]
3401b9d8:	6918      	ldr	r0, [r3, #16]
3401b9da:	f7ff fd2f 	bl	3401b43c <__hi0bits>
3401b9de:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
3401b9e2:	e7e5      	b.n	3401b9b0 <__d2b+0x74>
3401b9e4:	34022d6a 	.word	0x34022d6a
3401b9e8:	34022d7b 	.word	0x34022d7b

3401b9ec <_malloc_usable_size_r>:
3401b9ec:	f851 3c04 	ldr.w	r3, [r1, #-4]
3401b9f0:	1f18      	subs	r0, r3, #4
3401b9f2:	2b00      	cmp	r3, #0
3401b9f4:	bfbc      	itt	lt
3401b9f6:	580b      	ldrlt	r3, [r1, r0]
3401b9f8:	18c0      	addlt	r0, r0, r3
3401b9fa:	4770      	bx	lr

3401b9fc <__ssputs_r>:
3401b9fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
3401ba00:	461f      	mov	r7, r3
3401ba02:	688e      	ldr	r6, [r1, #8]
3401ba04:	4682      	mov	sl, r0
3401ba06:	460c      	mov	r4, r1
3401ba08:	42be      	cmp	r6, r7
3401ba0a:	4690      	mov	r8, r2
3401ba0c:	680b      	ldr	r3, [r1, #0]
3401ba0e:	d82d      	bhi.n	3401ba6c <__ssputs_r+0x70>
3401ba10:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
3401ba14:	f412 6f90 	tst.w	r2, #1152	@ 0x480
3401ba18:	d026      	beq.n	3401ba68 <__ssputs_r+0x6c>
3401ba1a:	6965      	ldr	r5, [r4, #20]
3401ba1c:	6909      	ldr	r1, [r1, #16]
3401ba1e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
3401ba22:	eba3 0901 	sub.w	r9, r3, r1
3401ba26:	1c7b      	adds	r3, r7, #1
3401ba28:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
3401ba2c:	444b      	add	r3, r9
3401ba2e:	106d      	asrs	r5, r5, #1
3401ba30:	429d      	cmp	r5, r3
3401ba32:	bf38      	it	cc
3401ba34:	461d      	movcc	r5, r3
3401ba36:	0553      	lsls	r3, r2, #21
3401ba38:	d527      	bpl.n	3401ba8a <__ssputs_r+0x8e>
3401ba3a:	4629      	mov	r1, r5
3401ba3c:	f7fd fa56 	bl	34018eec <_malloc_r>
3401ba40:	4606      	mov	r6, r0
3401ba42:	b360      	cbz	r0, 3401ba9e <__ssputs_r+0xa2>
3401ba44:	464a      	mov	r2, r9
3401ba46:	6921      	ldr	r1, [r4, #16]
3401ba48:	f7fe fe03 	bl	3401a652 <memcpy>
3401ba4c:	89a3      	ldrh	r3, [r4, #12]
3401ba4e:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
3401ba52:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
3401ba56:	81a3      	strh	r3, [r4, #12]
3401ba58:	6126      	str	r6, [r4, #16]
3401ba5a:	444e      	add	r6, r9
3401ba5c:	6165      	str	r5, [r4, #20]
3401ba5e:	eba5 0509 	sub.w	r5, r5, r9
3401ba62:	6026      	str	r6, [r4, #0]
3401ba64:	463e      	mov	r6, r7
3401ba66:	60a5      	str	r5, [r4, #8]
3401ba68:	42be      	cmp	r6, r7
3401ba6a:	d900      	bls.n	3401ba6e <__ssputs_r+0x72>
3401ba6c:	463e      	mov	r6, r7
3401ba6e:	4632      	mov	r2, r6
3401ba70:	4641      	mov	r1, r8
3401ba72:	6820      	ldr	r0, [r4, #0]
3401ba74:	f7fe fb3c 	bl	3401a0f0 <memmove>
3401ba78:	68a3      	ldr	r3, [r4, #8]
3401ba7a:	2000      	movs	r0, #0
3401ba7c:	1b9b      	subs	r3, r3, r6
3401ba7e:	60a3      	str	r3, [r4, #8]
3401ba80:	6823      	ldr	r3, [r4, #0]
3401ba82:	4433      	add	r3, r6
3401ba84:	6023      	str	r3, [r4, #0]
3401ba86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3401ba8a:	462a      	mov	r2, r5
3401ba8c:	f7fd faba 	bl	34019004 <_realloc_r>
3401ba90:	4606      	mov	r6, r0
3401ba92:	2800      	cmp	r0, #0
3401ba94:	d1e0      	bne.n	3401ba58 <__ssputs_r+0x5c>
3401ba96:	6921      	ldr	r1, [r4, #16]
3401ba98:	4650      	mov	r0, sl
3401ba9a:	f7ff fbdb 	bl	3401b254 <_free_r>
3401ba9e:	230c      	movs	r3, #12
3401baa0:	f04f 30ff 	mov.w	r0, #4294967295
3401baa4:	f8ca 3000 	str.w	r3, [sl]
3401baa8:	89a3      	ldrh	r3, [r4, #12]
3401baaa:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401baae:	81a3      	strh	r3, [r4, #12]
3401bab0:	e7e9      	b.n	3401ba86 <__ssputs_r+0x8a>
	...

3401bab4 <_svfiprintf_r>:
3401bab4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401bab8:	4698      	mov	r8, r3
3401baba:	898b      	ldrh	r3, [r1, #12]
3401babc:	b09d      	sub	sp, #116	@ 0x74
3401babe:	4607      	mov	r7, r0
3401bac0:	061b      	lsls	r3, r3, #24
3401bac2:	460d      	mov	r5, r1
3401bac4:	4614      	mov	r4, r2
3401bac6:	d510      	bpl.n	3401baea <_svfiprintf_r+0x36>
3401bac8:	690b      	ldr	r3, [r1, #16]
3401baca:	b973      	cbnz	r3, 3401baea <_svfiprintf_r+0x36>
3401bacc:	2140      	movs	r1, #64	@ 0x40
3401bace:	f7fd fa0d 	bl	34018eec <_malloc_r>
3401bad2:	6028      	str	r0, [r5, #0]
3401bad4:	6128      	str	r0, [r5, #16]
3401bad6:	b930      	cbnz	r0, 3401bae6 <_svfiprintf_r+0x32>
3401bad8:	230c      	movs	r3, #12
3401bada:	603b      	str	r3, [r7, #0]
3401badc:	f04f 30ff 	mov.w	r0, #4294967295
3401bae0:	b01d      	add	sp, #116	@ 0x74
3401bae2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401bae6:	2340      	movs	r3, #64	@ 0x40
3401bae8:	616b      	str	r3, [r5, #20]
3401baea:	2300      	movs	r3, #0
3401baec:	f8cd 800c 	str.w	r8, [sp, #12]
3401baf0:	f04f 0901 	mov.w	r9, #1
3401baf4:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 3401bc98 <_svfiprintf_r+0x1e4>
3401baf8:	9309      	str	r3, [sp, #36]	@ 0x24
3401bafa:	2320      	movs	r3, #32
3401bafc:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
3401bb00:	2330      	movs	r3, #48	@ 0x30
3401bb02:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
3401bb06:	4623      	mov	r3, r4
3401bb08:	469a      	mov	sl, r3
3401bb0a:	f813 2b01 	ldrb.w	r2, [r3], #1
3401bb0e:	b10a      	cbz	r2, 3401bb14 <_svfiprintf_r+0x60>
3401bb10:	2a25      	cmp	r2, #37	@ 0x25
3401bb12:	d1f9      	bne.n	3401bb08 <_svfiprintf_r+0x54>
3401bb14:	ebba 0b04 	subs.w	fp, sl, r4
3401bb18:	d00b      	beq.n	3401bb32 <_svfiprintf_r+0x7e>
3401bb1a:	465b      	mov	r3, fp
3401bb1c:	4622      	mov	r2, r4
3401bb1e:	4629      	mov	r1, r5
3401bb20:	4638      	mov	r0, r7
3401bb22:	f7ff ff6b 	bl	3401b9fc <__ssputs_r>
3401bb26:	3001      	adds	r0, #1
3401bb28:	f000 80a7 	beq.w	3401bc7a <_svfiprintf_r+0x1c6>
3401bb2c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401bb2e:	445a      	add	r2, fp
3401bb30:	9209      	str	r2, [sp, #36]	@ 0x24
3401bb32:	f89a 3000 	ldrb.w	r3, [sl]
3401bb36:	2b00      	cmp	r3, #0
3401bb38:	f000 809f 	beq.w	3401bc7a <_svfiprintf_r+0x1c6>
3401bb3c:	2300      	movs	r3, #0
3401bb3e:	f04f 32ff 	mov.w	r2, #4294967295
3401bb42:	f10a 0a01 	add.w	sl, sl, #1
3401bb46:	9304      	str	r3, [sp, #16]
3401bb48:	9307      	str	r3, [sp, #28]
3401bb4a:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
3401bb4e:	931a      	str	r3, [sp, #104]	@ 0x68
3401bb50:	e9cd 2305 	strd	r2, r3, [sp, #20]
3401bb54:	4654      	mov	r4, sl
3401bb56:	2205      	movs	r2, #5
3401bb58:	484f      	ldr	r0, [pc, #316]	@ (3401bc98 <_svfiprintf_r+0x1e4>)
3401bb5a:	f814 1b01 	ldrb.w	r1, [r4], #1
3401bb5e:	f7fe fd6a 	bl	3401a636 <memchr>
3401bb62:	9a04      	ldr	r2, [sp, #16]
3401bb64:	b9d8      	cbnz	r0, 3401bb9e <_svfiprintf_r+0xea>
3401bb66:	06d0      	lsls	r0, r2, #27
3401bb68:	bf44      	itt	mi
3401bb6a:	2320      	movmi	r3, #32
3401bb6c:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401bb70:	0711      	lsls	r1, r2, #28
3401bb72:	bf44      	itt	mi
3401bb74:	232b      	movmi	r3, #43	@ 0x2b
3401bb76:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401bb7a:	f89a 3000 	ldrb.w	r3, [sl]
3401bb7e:	2b2a      	cmp	r3, #42	@ 0x2a
3401bb80:	d015      	beq.n	3401bbae <_svfiprintf_r+0xfa>
3401bb82:	9a07      	ldr	r2, [sp, #28]
3401bb84:	4654      	mov	r4, sl
3401bb86:	2000      	movs	r0, #0
3401bb88:	f04f 0c0a 	mov.w	ip, #10
3401bb8c:	4621      	mov	r1, r4
3401bb8e:	f811 3b01 	ldrb.w	r3, [r1], #1
3401bb92:	3b30      	subs	r3, #48	@ 0x30
3401bb94:	2b09      	cmp	r3, #9
3401bb96:	d94b      	bls.n	3401bc30 <_svfiprintf_r+0x17c>
3401bb98:	b1b0      	cbz	r0, 3401bbc8 <_svfiprintf_r+0x114>
3401bb9a:	9207      	str	r2, [sp, #28]
3401bb9c:	e014      	b.n	3401bbc8 <_svfiprintf_r+0x114>
3401bb9e:	eba0 0308 	sub.w	r3, r0, r8
3401bba2:	46a2      	mov	sl, r4
3401bba4:	fa09 f303 	lsl.w	r3, r9, r3
3401bba8:	4313      	orrs	r3, r2
3401bbaa:	9304      	str	r3, [sp, #16]
3401bbac:	e7d2      	b.n	3401bb54 <_svfiprintf_r+0xa0>
3401bbae:	9b03      	ldr	r3, [sp, #12]
3401bbb0:	1d19      	adds	r1, r3, #4
3401bbb2:	681b      	ldr	r3, [r3, #0]
3401bbb4:	2b00      	cmp	r3, #0
3401bbb6:	9103      	str	r1, [sp, #12]
3401bbb8:	bfbb      	ittet	lt
3401bbba:	425b      	neglt	r3, r3
3401bbbc:	f042 0202 	orrlt.w	r2, r2, #2
3401bbc0:	9307      	strge	r3, [sp, #28]
3401bbc2:	9307      	strlt	r3, [sp, #28]
3401bbc4:	bfb8      	it	lt
3401bbc6:	9204      	strlt	r2, [sp, #16]
3401bbc8:	7823      	ldrb	r3, [r4, #0]
3401bbca:	2b2e      	cmp	r3, #46	@ 0x2e
3401bbcc:	d10a      	bne.n	3401bbe4 <_svfiprintf_r+0x130>
3401bbce:	7863      	ldrb	r3, [r4, #1]
3401bbd0:	2b2a      	cmp	r3, #42	@ 0x2a
3401bbd2:	d132      	bne.n	3401bc3a <_svfiprintf_r+0x186>
3401bbd4:	9b03      	ldr	r3, [sp, #12]
3401bbd6:	3402      	adds	r4, #2
3401bbd8:	1d1a      	adds	r2, r3, #4
3401bbda:	681b      	ldr	r3, [r3, #0]
3401bbdc:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
3401bbe0:	9203      	str	r2, [sp, #12]
3401bbe2:	9305      	str	r3, [sp, #20]
3401bbe4:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 3401bca8 <_svfiprintf_r+0x1f4>
3401bbe8:	2203      	movs	r2, #3
3401bbea:	7821      	ldrb	r1, [r4, #0]
3401bbec:	4650      	mov	r0, sl
3401bbee:	f7fe fd22 	bl	3401a636 <memchr>
3401bbf2:	b138      	cbz	r0, 3401bc04 <_svfiprintf_r+0x150>
3401bbf4:	eba0 000a 	sub.w	r0, r0, sl
3401bbf8:	2240      	movs	r2, #64	@ 0x40
3401bbfa:	9b04      	ldr	r3, [sp, #16]
3401bbfc:	3401      	adds	r4, #1
3401bbfe:	4082      	lsls	r2, r0
3401bc00:	4313      	orrs	r3, r2
3401bc02:	9304      	str	r3, [sp, #16]
3401bc04:	f814 1b01 	ldrb.w	r1, [r4], #1
3401bc08:	2206      	movs	r2, #6
3401bc0a:	4824      	ldr	r0, [pc, #144]	@ (3401bc9c <_svfiprintf_r+0x1e8>)
3401bc0c:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
3401bc10:	f7fe fd11 	bl	3401a636 <memchr>
3401bc14:	2800      	cmp	r0, #0
3401bc16:	d036      	beq.n	3401bc86 <_svfiprintf_r+0x1d2>
3401bc18:	4b21      	ldr	r3, [pc, #132]	@ (3401bca0 <_svfiprintf_r+0x1ec>)
3401bc1a:	bb1b      	cbnz	r3, 3401bc64 <_svfiprintf_r+0x1b0>
3401bc1c:	9b03      	ldr	r3, [sp, #12]
3401bc1e:	3307      	adds	r3, #7
3401bc20:	f023 0307 	bic.w	r3, r3, #7
3401bc24:	3308      	adds	r3, #8
3401bc26:	9303      	str	r3, [sp, #12]
3401bc28:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401bc2a:	4433      	add	r3, r6
3401bc2c:	9309      	str	r3, [sp, #36]	@ 0x24
3401bc2e:	e76a      	b.n	3401bb06 <_svfiprintf_r+0x52>
3401bc30:	fb0c 3202 	mla	r2, ip, r2, r3
3401bc34:	460c      	mov	r4, r1
3401bc36:	2001      	movs	r0, #1
3401bc38:	e7a8      	b.n	3401bb8c <_svfiprintf_r+0xd8>
3401bc3a:	2300      	movs	r3, #0
3401bc3c:	3401      	adds	r4, #1
3401bc3e:	f04f 0c0a 	mov.w	ip, #10
3401bc42:	4619      	mov	r1, r3
3401bc44:	9305      	str	r3, [sp, #20]
3401bc46:	4620      	mov	r0, r4
3401bc48:	f810 2b01 	ldrb.w	r2, [r0], #1
3401bc4c:	3a30      	subs	r2, #48	@ 0x30
3401bc4e:	2a09      	cmp	r2, #9
3401bc50:	d903      	bls.n	3401bc5a <_svfiprintf_r+0x1a6>
3401bc52:	2b00      	cmp	r3, #0
3401bc54:	d0c6      	beq.n	3401bbe4 <_svfiprintf_r+0x130>
3401bc56:	9105      	str	r1, [sp, #20]
3401bc58:	e7c4      	b.n	3401bbe4 <_svfiprintf_r+0x130>
3401bc5a:	fb0c 2101 	mla	r1, ip, r1, r2
3401bc5e:	4604      	mov	r4, r0
3401bc60:	2301      	movs	r3, #1
3401bc62:	e7f0      	b.n	3401bc46 <_svfiprintf_r+0x192>
3401bc64:	ab03      	add	r3, sp, #12
3401bc66:	462a      	mov	r2, r5
3401bc68:	a904      	add	r1, sp, #16
3401bc6a:	4638      	mov	r0, r7
3401bc6c:	9300      	str	r3, [sp, #0]
3401bc6e:	4b0d      	ldr	r3, [pc, #52]	@ (3401bca4 <_svfiprintf_r+0x1f0>)
3401bc70:	f7fd fc06 	bl	34019480 <_printf_float>
3401bc74:	1c42      	adds	r2, r0, #1
3401bc76:	4606      	mov	r6, r0
3401bc78:	d1d6      	bne.n	3401bc28 <_svfiprintf_r+0x174>
3401bc7a:	89ab      	ldrh	r3, [r5, #12]
3401bc7c:	065b      	lsls	r3, r3, #25
3401bc7e:	f53f af2d 	bmi.w	3401badc <_svfiprintf_r+0x28>
3401bc82:	9809      	ldr	r0, [sp, #36]	@ 0x24
3401bc84:	e72c      	b.n	3401bae0 <_svfiprintf_r+0x2c>
3401bc86:	ab03      	add	r3, sp, #12
3401bc88:	462a      	mov	r2, r5
3401bc8a:	a904      	add	r1, sp, #16
3401bc8c:	4638      	mov	r0, r7
3401bc8e:	9300      	str	r3, [sp, #0]
3401bc90:	4b04      	ldr	r3, [pc, #16]	@ (3401bca4 <_svfiprintf_r+0x1f0>)
3401bc92:	f7fd fe81 	bl	34019998 <_printf_i>
3401bc96:	e7ed      	b.n	3401bc74 <_svfiprintf_r+0x1c0>
3401bc98:	34022dd4 	.word	0x34022dd4
3401bc9c:	34022dde 	.word	0x34022dde
3401bca0:	34019481 	.word	0x34019481
3401bca4:	3401b9fd 	.word	0x3401b9fd
3401bca8:	34022dda 	.word	0x34022dda

3401bcac <__sfputc_r>:
3401bcac:	6893      	ldr	r3, [r2, #8]
3401bcae:	3b01      	subs	r3, #1
3401bcb0:	2b00      	cmp	r3, #0
3401bcb2:	b410      	push	{r4}
3401bcb4:	6093      	str	r3, [r2, #8]
3401bcb6:	da08      	bge.n	3401bcca <__sfputc_r+0x1e>
3401bcb8:	6994      	ldr	r4, [r2, #24]
3401bcba:	42a3      	cmp	r3, r4
3401bcbc:	db01      	blt.n	3401bcc2 <__sfputc_r+0x16>
3401bcbe:	290a      	cmp	r1, #10
3401bcc0:	d103      	bne.n	3401bcca <__sfputc_r+0x1e>
3401bcc2:	f85d 4b04 	ldr.w	r4, [sp], #4
3401bcc6:	f7fe b97f 	b.w	34019fc8 <__swbuf_r>
3401bcca:	6813      	ldr	r3, [r2, #0]
3401bccc:	1c58      	adds	r0, r3, #1
3401bcce:	6010      	str	r0, [r2, #0]
3401bcd0:	4608      	mov	r0, r1
3401bcd2:	7019      	strb	r1, [r3, #0]
3401bcd4:	f85d 4b04 	ldr.w	r4, [sp], #4
3401bcd8:	4770      	bx	lr

3401bcda <__sfputs_r>:
3401bcda:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401bcdc:	4606      	mov	r6, r0
3401bcde:	460f      	mov	r7, r1
3401bce0:	4614      	mov	r4, r2
3401bce2:	18d5      	adds	r5, r2, r3
3401bce4:	42ac      	cmp	r4, r5
3401bce6:	d101      	bne.n	3401bcec <__sfputs_r+0x12>
3401bce8:	2000      	movs	r0, #0
3401bcea:	e007      	b.n	3401bcfc <__sfputs_r+0x22>
3401bcec:	463a      	mov	r2, r7
3401bcee:	f814 1b01 	ldrb.w	r1, [r4], #1
3401bcf2:	4630      	mov	r0, r6
3401bcf4:	f7ff ffda 	bl	3401bcac <__sfputc_r>
3401bcf8:	1c43      	adds	r3, r0, #1
3401bcfa:	d1f3      	bne.n	3401bce4 <__sfputs_r+0xa>
3401bcfc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

3401bd00 <_vfiprintf_r>:
3401bd00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401bd04:	460d      	mov	r5, r1
3401bd06:	b09d      	sub	sp, #116	@ 0x74
3401bd08:	4614      	mov	r4, r2
3401bd0a:	4698      	mov	r8, r3
3401bd0c:	4606      	mov	r6, r0
3401bd0e:	b118      	cbz	r0, 3401bd18 <_vfiprintf_r+0x18>
3401bd10:	6a03      	ldr	r3, [r0, #32]
3401bd12:	b90b      	cbnz	r3, 3401bd18 <_vfiprintf_r+0x18>
3401bd14:	f7fd ffea 	bl	34019cec <__sinit>
3401bd18:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401bd1a:	07d9      	lsls	r1, r3, #31
3401bd1c:	d405      	bmi.n	3401bd2a <_vfiprintf_r+0x2a>
3401bd1e:	89ab      	ldrh	r3, [r5, #12]
3401bd20:	059a      	lsls	r2, r3, #22
3401bd22:	d402      	bmi.n	3401bd2a <_vfiprintf_r+0x2a>
3401bd24:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401bd26:	f7fe fc7c 	bl	3401a622 <__retarget_lock_acquire_recursive>
3401bd2a:	89ab      	ldrh	r3, [r5, #12]
3401bd2c:	071b      	lsls	r3, r3, #28
3401bd2e:	d501      	bpl.n	3401bd34 <_vfiprintf_r+0x34>
3401bd30:	692b      	ldr	r3, [r5, #16]
3401bd32:	b99b      	cbnz	r3, 3401bd5c <_vfiprintf_r+0x5c>
3401bd34:	4629      	mov	r1, r5
3401bd36:	4630      	mov	r0, r6
3401bd38:	f7fe f984 	bl	3401a044 <__swsetup_r>
3401bd3c:	b170      	cbz	r0, 3401bd5c <_vfiprintf_r+0x5c>
3401bd3e:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401bd40:	07dc      	lsls	r4, r3, #31
3401bd42:	d504      	bpl.n	3401bd4e <_vfiprintf_r+0x4e>
3401bd44:	f04f 30ff 	mov.w	r0, #4294967295
3401bd48:	b01d      	add	sp, #116	@ 0x74
3401bd4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401bd4e:	89ab      	ldrh	r3, [r5, #12]
3401bd50:	0598      	lsls	r0, r3, #22
3401bd52:	d4f7      	bmi.n	3401bd44 <_vfiprintf_r+0x44>
3401bd54:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401bd56:	f7fe fc65 	bl	3401a624 <__retarget_lock_release_recursive>
3401bd5a:	e7f3      	b.n	3401bd44 <_vfiprintf_r+0x44>
3401bd5c:	2300      	movs	r3, #0
3401bd5e:	f8cd 800c 	str.w	r8, [sp, #12]
3401bd62:	f04f 0901 	mov.w	r9, #1
3401bd66:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 3401bf1c <_vfiprintf_r+0x21c>
3401bd6a:	9309      	str	r3, [sp, #36]	@ 0x24
3401bd6c:	2320      	movs	r3, #32
3401bd6e:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
3401bd72:	2330      	movs	r3, #48	@ 0x30
3401bd74:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
3401bd78:	4623      	mov	r3, r4
3401bd7a:	469a      	mov	sl, r3
3401bd7c:	f813 2b01 	ldrb.w	r2, [r3], #1
3401bd80:	b10a      	cbz	r2, 3401bd86 <_vfiprintf_r+0x86>
3401bd82:	2a25      	cmp	r2, #37	@ 0x25
3401bd84:	d1f9      	bne.n	3401bd7a <_vfiprintf_r+0x7a>
3401bd86:	ebba 0b04 	subs.w	fp, sl, r4
3401bd8a:	d00b      	beq.n	3401bda4 <_vfiprintf_r+0xa4>
3401bd8c:	465b      	mov	r3, fp
3401bd8e:	4622      	mov	r2, r4
3401bd90:	4629      	mov	r1, r5
3401bd92:	4630      	mov	r0, r6
3401bd94:	f7ff ffa1 	bl	3401bcda <__sfputs_r>
3401bd98:	3001      	adds	r0, #1
3401bd9a:	f000 80a7 	beq.w	3401beec <_vfiprintf_r+0x1ec>
3401bd9e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401bda0:	445a      	add	r2, fp
3401bda2:	9209      	str	r2, [sp, #36]	@ 0x24
3401bda4:	f89a 3000 	ldrb.w	r3, [sl]
3401bda8:	2b00      	cmp	r3, #0
3401bdaa:	f000 809f 	beq.w	3401beec <_vfiprintf_r+0x1ec>
3401bdae:	2300      	movs	r3, #0
3401bdb0:	f04f 32ff 	mov.w	r2, #4294967295
3401bdb4:	f10a 0a01 	add.w	sl, sl, #1
3401bdb8:	9304      	str	r3, [sp, #16]
3401bdba:	9307      	str	r3, [sp, #28]
3401bdbc:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
3401bdc0:	931a      	str	r3, [sp, #104]	@ 0x68
3401bdc2:	e9cd 2305 	strd	r2, r3, [sp, #20]
3401bdc6:	4654      	mov	r4, sl
3401bdc8:	2205      	movs	r2, #5
3401bdca:	4854      	ldr	r0, [pc, #336]	@ (3401bf1c <_vfiprintf_r+0x21c>)
3401bdcc:	f814 1b01 	ldrb.w	r1, [r4], #1
3401bdd0:	f7fe fc31 	bl	3401a636 <memchr>
3401bdd4:	9a04      	ldr	r2, [sp, #16]
3401bdd6:	b9d8      	cbnz	r0, 3401be10 <_vfiprintf_r+0x110>
3401bdd8:	06d1      	lsls	r1, r2, #27
3401bdda:	bf44      	itt	mi
3401bddc:	2320      	movmi	r3, #32
3401bdde:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401bde2:	0713      	lsls	r3, r2, #28
3401bde4:	bf44      	itt	mi
3401bde6:	232b      	movmi	r3, #43	@ 0x2b
3401bde8:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401bdec:	f89a 3000 	ldrb.w	r3, [sl]
3401bdf0:	2b2a      	cmp	r3, #42	@ 0x2a
3401bdf2:	d015      	beq.n	3401be20 <_vfiprintf_r+0x120>
3401bdf4:	9a07      	ldr	r2, [sp, #28]
3401bdf6:	4654      	mov	r4, sl
3401bdf8:	2000      	movs	r0, #0
3401bdfa:	f04f 0c0a 	mov.w	ip, #10
3401bdfe:	4621      	mov	r1, r4
3401be00:	f811 3b01 	ldrb.w	r3, [r1], #1
3401be04:	3b30      	subs	r3, #48	@ 0x30
3401be06:	2b09      	cmp	r3, #9
3401be08:	d94b      	bls.n	3401bea2 <_vfiprintf_r+0x1a2>
3401be0a:	b1b0      	cbz	r0, 3401be3a <_vfiprintf_r+0x13a>
3401be0c:	9207      	str	r2, [sp, #28]
3401be0e:	e014      	b.n	3401be3a <_vfiprintf_r+0x13a>
3401be10:	eba0 0308 	sub.w	r3, r0, r8
3401be14:	46a2      	mov	sl, r4
3401be16:	fa09 f303 	lsl.w	r3, r9, r3
3401be1a:	4313      	orrs	r3, r2
3401be1c:	9304      	str	r3, [sp, #16]
3401be1e:	e7d2      	b.n	3401bdc6 <_vfiprintf_r+0xc6>
3401be20:	9b03      	ldr	r3, [sp, #12]
3401be22:	1d19      	adds	r1, r3, #4
3401be24:	681b      	ldr	r3, [r3, #0]
3401be26:	2b00      	cmp	r3, #0
3401be28:	9103      	str	r1, [sp, #12]
3401be2a:	bfbb      	ittet	lt
3401be2c:	425b      	neglt	r3, r3
3401be2e:	f042 0202 	orrlt.w	r2, r2, #2
3401be32:	9307      	strge	r3, [sp, #28]
3401be34:	9307      	strlt	r3, [sp, #28]
3401be36:	bfb8      	it	lt
3401be38:	9204      	strlt	r2, [sp, #16]
3401be3a:	7823      	ldrb	r3, [r4, #0]
3401be3c:	2b2e      	cmp	r3, #46	@ 0x2e
3401be3e:	d10a      	bne.n	3401be56 <_vfiprintf_r+0x156>
3401be40:	7863      	ldrb	r3, [r4, #1]
3401be42:	2b2a      	cmp	r3, #42	@ 0x2a
3401be44:	d132      	bne.n	3401beac <_vfiprintf_r+0x1ac>
3401be46:	9b03      	ldr	r3, [sp, #12]
3401be48:	3402      	adds	r4, #2
3401be4a:	1d1a      	adds	r2, r3, #4
3401be4c:	681b      	ldr	r3, [r3, #0]
3401be4e:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
3401be52:	9203      	str	r2, [sp, #12]
3401be54:	9305      	str	r3, [sp, #20]
3401be56:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 3401bf2c <_vfiprintf_r+0x22c>
3401be5a:	2203      	movs	r2, #3
3401be5c:	7821      	ldrb	r1, [r4, #0]
3401be5e:	4650      	mov	r0, sl
3401be60:	f7fe fbe9 	bl	3401a636 <memchr>
3401be64:	b138      	cbz	r0, 3401be76 <_vfiprintf_r+0x176>
3401be66:	eba0 000a 	sub.w	r0, r0, sl
3401be6a:	2240      	movs	r2, #64	@ 0x40
3401be6c:	9b04      	ldr	r3, [sp, #16]
3401be6e:	3401      	adds	r4, #1
3401be70:	4082      	lsls	r2, r0
3401be72:	4313      	orrs	r3, r2
3401be74:	9304      	str	r3, [sp, #16]
3401be76:	f814 1b01 	ldrb.w	r1, [r4], #1
3401be7a:	2206      	movs	r2, #6
3401be7c:	4828      	ldr	r0, [pc, #160]	@ (3401bf20 <_vfiprintf_r+0x220>)
3401be7e:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
3401be82:	f7fe fbd8 	bl	3401a636 <memchr>
3401be86:	2800      	cmp	r0, #0
3401be88:	d03f      	beq.n	3401bf0a <_vfiprintf_r+0x20a>
3401be8a:	4b26      	ldr	r3, [pc, #152]	@ (3401bf24 <_vfiprintf_r+0x224>)
3401be8c:	bb1b      	cbnz	r3, 3401bed6 <_vfiprintf_r+0x1d6>
3401be8e:	9b03      	ldr	r3, [sp, #12]
3401be90:	3307      	adds	r3, #7
3401be92:	f023 0307 	bic.w	r3, r3, #7
3401be96:	3308      	adds	r3, #8
3401be98:	9303      	str	r3, [sp, #12]
3401be9a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401be9c:	443b      	add	r3, r7
3401be9e:	9309      	str	r3, [sp, #36]	@ 0x24
3401bea0:	e76a      	b.n	3401bd78 <_vfiprintf_r+0x78>
3401bea2:	fb0c 3202 	mla	r2, ip, r2, r3
3401bea6:	460c      	mov	r4, r1
3401bea8:	2001      	movs	r0, #1
3401beaa:	e7a8      	b.n	3401bdfe <_vfiprintf_r+0xfe>
3401beac:	2300      	movs	r3, #0
3401beae:	3401      	adds	r4, #1
3401beb0:	f04f 0c0a 	mov.w	ip, #10
3401beb4:	4619      	mov	r1, r3
3401beb6:	9305      	str	r3, [sp, #20]
3401beb8:	4620      	mov	r0, r4
3401beba:	f810 2b01 	ldrb.w	r2, [r0], #1
3401bebe:	3a30      	subs	r2, #48	@ 0x30
3401bec0:	2a09      	cmp	r2, #9
3401bec2:	d903      	bls.n	3401becc <_vfiprintf_r+0x1cc>
3401bec4:	2b00      	cmp	r3, #0
3401bec6:	d0c6      	beq.n	3401be56 <_vfiprintf_r+0x156>
3401bec8:	9105      	str	r1, [sp, #20]
3401beca:	e7c4      	b.n	3401be56 <_vfiprintf_r+0x156>
3401becc:	fb0c 2101 	mla	r1, ip, r1, r2
3401bed0:	4604      	mov	r4, r0
3401bed2:	2301      	movs	r3, #1
3401bed4:	e7f0      	b.n	3401beb8 <_vfiprintf_r+0x1b8>
3401bed6:	ab03      	add	r3, sp, #12
3401bed8:	462a      	mov	r2, r5
3401beda:	a904      	add	r1, sp, #16
3401bedc:	4630      	mov	r0, r6
3401bede:	9300      	str	r3, [sp, #0]
3401bee0:	4b11      	ldr	r3, [pc, #68]	@ (3401bf28 <_vfiprintf_r+0x228>)
3401bee2:	f7fd facd 	bl	34019480 <_printf_float>
3401bee6:	4607      	mov	r7, r0
3401bee8:	1c78      	adds	r0, r7, #1
3401beea:	d1d6      	bne.n	3401be9a <_vfiprintf_r+0x19a>
3401beec:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401beee:	07d9      	lsls	r1, r3, #31
3401bef0:	d405      	bmi.n	3401befe <_vfiprintf_r+0x1fe>
3401bef2:	89ab      	ldrh	r3, [r5, #12]
3401bef4:	059a      	lsls	r2, r3, #22
3401bef6:	d402      	bmi.n	3401befe <_vfiprintf_r+0x1fe>
3401bef8:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401befa:	f7fe fb93 	bl	3401a624 <__retarget_lock_release_recursive>
3401befe:	89ab      	ldrh	r3, [r5, #12]
3401bf00:	065b      	lsls	r3, r3, #25
3401bf02:	f53f af1f 	bmi.w	3401bd44 <_vfiprintf_r+0x44>
3401bf06:	9809      	ldr	r0, [sp, #36]	@ 0x24
3401bf08:	e71e      	b.n	3401bd48 <_vfiprintf_r+0x48>
3401bf0a:	ab03      	add	r3, sp, #12
3401bf0c:	462a      	mov	r2, r5
3401bf0e:	a904      	add	r1, sp, #16
3401bf10:	4630      	mov	r0, r6
3401bf12:	9300      	str	r3, [sp, #0]
3401bf14:	4b04      	ldr	r3, [pc, #16]	@ (3401bf28 <_vfiprintf_r+0x228>)
3401bf16:	f7fd fd3f 	bl	34019998 <_printf_i>
3401bf1a:	e7e4      	b.n	3401bee6 <_vfiprintf_r+0x1e6>
3401bf1c:	34022dd4 	.word	0x34022dd4
3401bf20:	34022dde 	.word	0x34022dde
3401bf24:	34019481 	.word	0x34019481
3401bf28:	3401bcdb 	.word	0x3401bcdb
3401bf2c:	34022dda 	.word	0x34022dda

3401bf30 <__sflush_r>:
3401bf30:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
3401bf34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3401bf38:	0716      	lsls	r6, r2, #28
3401bf3a:	4605      	mov	r5, r0
3401bf3c:	460c      	mov	r4, r1
3401bf3e:	d454      	bmi.n	3401bfea <__sflush_r+0xba>
3401bf40:	684b      	ldr	r3, [r1, #4]
3401bf42:	2b00      	cmp	r3, #0
3401bf44:	dc02      	bgt.n	3401bf4c <__sflush_r+0x1c>
3401bf46:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
3401bf48:	2b00      	cmp	r3, #0
3401bf4a:	dd48      	ble.n	3401bfde <__sflush_r+0xae>
3401bf4c:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
3401bf4e:	2e00      	cmp	r6, #0
3401bf50:	d045      	beq.n	3401bfde <__sflush_r+0xae>
3401bf52:	2300      	movs	r3, #0
3401bf54:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
3401bf58:	682f      	ldr	r7, [r5, #0]
3401bf5a:	6a21      	ldr	r1, [r4, #32]
3401bf5c:	602b      	str	r3, [r5, #0]
3401bf5e:	d030      	beq.n	3401bfc2 <__sflush_r+0x92>
3401bf60:	6d62      	ldr	r2, [r4, #84]	@ 0x54
3401bf62:	89a3      	ldrh	r3, [r4, #12]
3401bf64:	0759      	lsls	r1, r3, #29
3401bf66:	d505      	bpl.n	3401bf74 <__sflush_r+0x44>
3401bf68:	6863      	ldr	r3, [r4, #4]
3401bf6a:	1ad2      	subs	r2, r2, r3
3401bf6c:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3401bf6e:	b10b      	cbz	r3, 3401bf74 <__sflush_r+0x44>
3401bf70:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3401bf72:	1ad2      	subs	r2, r2, r3
3401bf74:	2300      	movs	r3, #0
3401bf76:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
3401bf78:	6a21      	ldr	r1, [r4, #32]
3401bf7a:	4628      	mov	r0, r5
3401bf7c:	47b0      	blx	r6
3401bf7e:	1c43      	adds	r3, r0, #1
3401bf80:	89a3      	ldrh	r3, [r4, #12]
3401bf82:	d106      	bne.n	3401bf92 <__sflush_r+0x62>
3401bf84:	6829      	ldr	r1, [r5, #0]
3401bf86:	291d      	cmp	r1, #29
3401bf88:	d82b      	bhi.n	3401bfe2 <__sflush_r+0xb2>
3401bf8a:	4a2a      	ldr	r2, [pc, #168]	@ (3401c034 <__sflush_r+0x104>)
3401bf8c:	40ca      	lsrs	r2, r1
3401bf8e:	07d6      	lsls	r6, r2, #31
3401bf90:	d527      	bpl.n	3401bfe2 <__sflush_r+0xb2>
3401bf92:	2200      	movs	r2, #0
3401bf94:	04d9      	lsls	r1, r3, #19
3401bf96:	6062      	str	r2, [r4, #4]
3401bf98:	6922      	ldr	r2, [r4, #16]
3401bf9a:	6022      	str	r2, [r4, #0]
3401bf9c:	d504      	bpl.n	3401bfa8 <__sflush_r+0x78>
3401bf9e:	1c42      	adds	r2, r0, #1
3401bfa0:	d101      	bne.n	3401bfa6 <__sflush_r+0x76>
3401bfa2:	682b      	ldr	r3, [r5, #0]
3401bfa4:	b903      	cbnz	r3, 3401bfa8 <__sflush_r+0x78>
3401bfa6:	6560      	str	r0, [r4, #84]	@ 0x54
3401bfa8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3401bfaa:	602f      	str	r7, [r5, #0]
3401bfac:	b1b9      	cbz	r1, 3401bfde <__sflush_r+0xae>
3401bfae:	f104 0344 	add.w	r3, r4, #68	@ 0x44
3401bfb2:	4299      	cmp	r1, r3
3401bfb4:	d002      	beq.n	3401bfbc <__sflush_r+0x8c>
3401bfb6:	4628      	mov	r0, r5
3401bfb8:	f7ff f94c 	bl	3401b254 <_free_r>
3401bfbc:	2300      	movs	r3, #0
3401bfbe:	6363      	str	r3, [r4, #52]	@ 0x34
3401bfc0:	e00d      	b.n	3401bfde <__sflush_r+0xae>
3401bfc2:	2301      	movs	r3, #1
3401bfc4:	4628      	mov	r0, r5
3401bfc6:	47b0      	blx	r6
3401bfc8:	4602      	mov	r2, r0
3401bfca:	1c50      	adds	r0, r2, #1
3401bfcc:	d1c9      	bne.n	3401bf62 <__sflush_r+0x32>
3401bfce:	682b      	ldr	r3, [r5, #0]
3401bfd0:	2b00      	cmp	r3, #0
3401bfd2:	d0c6      	beq.n	3401bf62 <__sflush_r+0x32>
3401bfd4:	2b1d      	cmp	r3, #29
3401bfd6:	d001      	beq.n	3401bfdc <__sflush_r+0xac>
3401bfd8:	2b16      	cmp	r3, #22
3401bfda:	d11d      	bne.n	3401c018 <__sflush_r+0xe8>
3401bfdc:	602f      	str	r7, [r5, #0]
3401bfde:	2000      	movs	r0, #0
3401bfe0:	e021      	b.n	3401c026 <__sflush_r+0xf6>
3401bfe2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401bfe6:	b21b      	sxth	r3, r3
3401bfe8:	e01a      	b.n	3401c020 <__sflush_r+0xf0>
3401bfea:	690f      	ldr	r7, [r1, #16]
3401bfec:	2f00      	cmp	r7, #0
3401bfee:	d0f6      	beq.n	3401bfde <__sflush_r+0xae>
3401bff0:	0793      	lsls	r3, r2, #30
3401bff2:	680e      	ldr	r6, [r1, #0]
3401bff4:	600f      	str	r7, [r1, #0]
3401bff6:	bf0c      	ite	eq
3401bff8:	694b      	ldreq	r3, [r1, #20]
3401bffa:	2300      	movne	r3, #0
3401bffc:	eba6 0807 	sub.w	r8, r6, r7
3401c000:	608b      	str	r3, [r1, #8]
3401c002:	f1b8 0f00 	cmp.w	r8, #0
3401c006:	ddea      	ble.n	3401bfde <__sflush_r+0xae>
3401c008:	4643      	mov	r3, r8
3401c00a:	463a      	mov	r2, r7
3401c00c:	6a21      	ldr	r1, [r4, #32]
3401c00e:	4628      	mov	r0, r5
3401c010:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
3401c012:	47b0      	blx	r6
3401c014:	2800      	cmp	r0, #0
3401c016:	dc08      	bgt.n	3401c02a <__sflush_r+0xfa>
3401c018:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401c01c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401c020:	f04f 30ff 	mov.w	r0, #4294967295
3401c024:	81a3      	strh	r3, [r4, #12]
3401c026:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3401c02a:	4407      	add	r7, r0
3401c02c:	eba8 0800 	sub.w	r8, r8, r0
3401c030:	e7e7      	b.n	3401c002 <__sflush_r+0xd2>
3401c032:	bf00      	nop
3401c034:	20400001 	.word	0x20400001

3401c038 <_fflush_r>:
3401c038:	b538      	push	{r3, r4, r5, lr}
3401c03a:	690b      	ldr	r3, [r1, #16]
3401c03c:	4605      	mov	r5, r0
3401c03e:	460c      	mov	r4, r1
3401c040:	b913      	cbnz	r3, 3401c048 <_fflush_r+0x10>
3401c042:	2500      	movs	r5, #0
3401c044:	4628      	mov	r0, r5
3401c046:	bd38      	pop	{r3, r4, r5, pc}
3401c048:	b118      	cbz	r0, 3401c052 <_fflush_r+0x1a>
3401c04a:	6a03      	ldr	r3, [r0, #32]
3401c04c:	b90b      	cbnz	r3, 3401c052 <_fflush_r+0x1a>
3401c04e:	f7fd fe4d 	bl	34019cec <__sinit>
3401c052:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401c056:	2b00      	cmp	r3, #0
3401c058:	d0f3      	beq.n	3401c042 <_fflush_r+0xa>
3401c05a:	6e62      	ldr	r2, [r4, #100]	@ 0x64
3401c05c:	07d0      	lsls	r0, r2, #31
3401c05e:	d404      	bmi.n	3401c06a <_fflush_r+0x32>
3401c060:	0599      	lsls	r1, r3, #22
3401c062:	d402      	bmi.n	3401c06a <_fflush_r+0x32>
3401c064:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401c066:	f7fe fadc 	bl	3401a622 <__retarget_lock_acquire_recursive>
3401c06a:	4628      	mov	r0, r5
3401c06c:	4621      	mov	r1, r4
3401c06e:	f7ff ff5f 	bl	3401bf30 <__sflush_r>
3401c072:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3401c074:	4605      	mov	r5, r0
3401c076:	07da      	lsls	r2, r3, #31
3401c078:	d4e4      	bmi.n	3401c044 <_fflush_r+0xc>
3401c07a:	89a3      	ldrh	r3, [r4, #12]
3401c07c:	059b      	lsls	r3, r3, #22
3401c07e:	d4e1      	bmi.n	3401c044 <_fflush_r+0xc>
3401c080:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401c082:	f7fe facf 	bl	3401a624 <__retarget_lock_release_recursive>
3401c086:	e7dd      	b.n	3401c044 <_fflush_r+0xc>

3401c088 <__swhatbuf_r>:
3401c088:	b570      	push	{r4, r5, r6, lr}
3401c08a:	460c      	mov	r4, r1
3401c08c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3401c090:	b096      	sub	sp, #88	@ 0x58
3401c092:	4615      	mov	r5, r2
3401c094:	2900      	cmp	r1, #0
3401c096:	461e      	mov	r6, r3
3401c098:	da0c      	bge.n	3401c0b4 <__swhatbuf_r+0x2c>
3401c09a:	89a3      	ldrh	r3, [r4, #12]
3401c09c:	2100      	movs	r1, #0
3401c09e:	f013 0f80 	tst.w	r3, #128	@ 0x80
3401c0a2:	bf14      	ite	ne
3401c0a4:	2340      	movne	r3, #64	@ 0x40
3401c0a6:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
3401c0aa:	2000      	movs	r0, #0
3401c0ac:	6031      	str	r1, [r6, #0]
3401c0ae:	602b      	str	r3, [r5, #0]
3401c0b0:	b016      	add	sp, #88	@ 0x58
3401c0b2:	bd70      	pop	{r4, r5, r6, pc}
3401c0b4:	466a      	mov	r2, sp
3401c0b6:	f000 f879 	bl	3401c1ac <_fstat_r>
3401c0ba:	2800      	cmp	r0, #0
3401c0bc:	dbed      	blt.n	3401c09a <__swhatbuf_r+0x12>
3401c0be:	9901      	ldr	r1, [sp, #4]
3401c0c0:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
3401c0c4:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
3401c0c8:	4259      	negs	r1, r3
3401c0ca:	4159      	adcs	r1, r3
3401c0cc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3401c0d0:	e7eb      	b.n	3401c0aa <__swhatbuf_r+0x22>

3401c0d2 <__smakebuf_r>:
3401c0d2:	898b      	ldrh	r3, [r1, #12]
3401c0d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3401c0d6:	079d      	lsls	r5, r3, #30
3401c0d8:	4606      	mov	r6, r0
3401c0da:	460c      	mov	r4, r1
3401c0dc:	d507      	bpl.n	3401c0ee <__smakebuf_r+0x1c>
3401c0de:	f104 0347 	add.w	r3, r4, #71	@ 0x47
3401c0e2:	6023      	str	r3, [r4, #0]
3401c0e4:	6123      	str	r3, [r4, #16]
3401c0e6:	2301      	movs	r3, #1
3401c0e8:	6163      	str	r3, [r4, #20]
3401c0ea:	b003      	add	sp, #12
3401c0ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
3401c0ee:	ab01      	add	r3, sp, #4
3401c0f0:	466a      	mov	r2, sp
3401c0f2:	f7ff ffc9 	bl	3401c088 <__swhatbuf_r>
3401c0f6:	9f00      	ldr	r7, [sp, #0]
3401c0f8:	4605      	mov	r5, r0
3401c0fa:	4630      	mov	r0, r6
3401c0fc:	4639      	mov	r1, r7
3401c0fe:	f7fc fef5 	bl	34018eec <_malloc_r>
3401c102:	b948      	cbnz	r0, 3401c118 <__smakebuf_r+0x46>
3401c104:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401c108:	059a      	lsls	r2, r3, #22
3401c10a:	d4ee      	bmi.n	3401c0ea <__smakebuf_r+0x18>
3401c10c:	f023 0303 	bic.w	r3, r3, #3
3401c110:	f043 0302 	orr.w	r3, r3, #2
3401c114:	81a3      	strh	r3, [r4, #12]
3401c116:	e7e2      	b.n	3401c0de <__smakebuf_r+0xc>
3401c118:	89a3      	ldrh	r3, [r4, #12]
3401c11a:	6020      	str	r0, [r4, #0]
3401c11c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
3401c120:	81a3      	strh	r3, [r4, #12]
3401c122:	9b01      	ldr	r3, [sp, #4]
3401c124:	e9c4 0704 	strd	r0, r7, [r4, #16]
3401c128:	b15b      	cbz	r3, 3401c142 <__smakebuf_r+0x70>
3401c12a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
3401c12e:	4630      	mov	r0, r6
3401c130:	f000 f84e 	bl	3401c1d0 <_isatty_r>
3401c134:	b128      	cbz	r0, 3401c142 <__smakebuf_r+0x70>
3401c136:	89a3      	ldrh	r3, [r4, #12]
3401c138:	f023 0303 	bic.w	r3, r3, #3
3401c13c:	f043 0301 	orr.w	r3, r3, #1
3401c140:	81a3      	strh	r3, [r4, #12]
3401c142:	89a3      	ldrh	r3, [r4, #12]
3401c144:	431d      	orrs	r5, r3
3401c146:	81a5      	strh	r5, [r4, #12]
3401c148:	e7cf      	b.n	3401c0ea <__smakebuf_r+0x18>

3401c14a <_raise_r>:
3401c14a:	291f      	cmp	r1, #31
3401c14c:	b538      	push	{r3, r4, r5, lr}
3401c14e:	4605      	mov	r5, r0
3401c150:	460c      	mov	r4, r1
3401c152:	d904      	bls.n	3401c15e <_raise_r+0x14>
3401c154:	2316      	movs	r3, #22
3401c156:	6003      	str	r3, [r0, #0]
3401c158:	f04f 30ff 	mov.w	r0, #4294967295
3401c15c:	bd38      	pop	{r3, r4, r5, pc}
3401c15e:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
3401c160:	b112      	cbz	r2, 3401c168 <_raise_r+0x1e>
3401c162:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
3401c166:	b94b      	cbnz	r3, 3401c17c <_raise_r+0x32>
3401c168:	4628      	mov	r0, r5
3401c16a:	f000 f853 	bl	3401c214 <_getpid_r>
3401c16e:	4622      	mov	r2, r4
3401c170:	4601      	mov	r1, r0
3401c172:	4628      	mov	r0, r5
3401c174:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
3401c178:	f000 b83a 	b.w	3401c1f0 <_kill_r>
3401c17c:	2b01      	cmp	r3, #1
3401c17e:	d00a      	beq.n	3401c196 <_raise_r+0x4c>
3401c180:	1c59      	adds	r1, r3, #1
3401c182:	d103      	bne.n	3401c18c <_raise_r+0x42>
3401c184:	2316      	movs	r3, #22
3401c186:	6003      	str	r3, [r0, #0]
3401c188:	2001      	movs	r0, #1
3401c18a:	e7e7      	b.n	3401c15c <_raise_r+0x12>
3401c18c:	2100      	movs	r1, #0
3401c18e:	4620      	mov	r0, r4
3401c190:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
3401c194:	4798      	blx	r3
3401c196:	2000      	movs	r0, #0
3401c198:	e7e0      	b.n	3401c15c <_raise_r+0x12>
	...

3401c19c <raise>:
3401c19c:	4b02      	ldr	r3, [pc, #8]	@ (3401c1a8 <raise+0xc>)
3401c19e:	4601      	mov	r1, r0
3401c1a0:	6818      	ldr	r0, [r3, #0]
3401c1a2:	f7ff bfd2 	b.w	3401c14a <_raise_r>
3401c1a6:	bf00      	nop
3401c1a8:	340b1110 	.word	0x340b1110

3401c1ac <_fstat_r>:
3401c1ac:	b538      	push	{r3, r4, r5, lr}
3401c1ae:	2300      	movs	r3, #0
3401c1b0:	4d06      	ldr	r5, [pc, #24]	@ (3401c1cc <_fstat_r+0x20>)
3401c1b2:	4604      	mov	r4, r0
3401c1b4:	4608      	mov	r0, r1
3401c1b6:	4611      	mov	r1, r2
3401c1b8:	602b      	str	r3, [r5, #0]
3401c1ba:	f7e6 ff31 	bl	34003020 <_fstat>
3401c1be:	1c43      	adds	r3, r0, #1
3401c1c0:	d102      	bne.n	3401c1c8 <_fstat_r+0x1c>
3401c1c2:	682b      	ldr	r3, [r5, #0]
3401c1c4:	b103      	cbz	r3, 3401c1c8 <_fstat_r+0x1c>
3401c1c6:	6023      	str	r3, [r4, #0]
3401c1c8:	bd38      	pop	{r3, r4, r5, pc}
3401c1ca:	bf00      	nop
3401c1cc:	340cf030 	.word	0x340cf030

3401c1d0 <_isatty_r>:
3401c1d0:	b538      	push	{r3, r4, r5, lr}
3401c1d2:	2300      	movs	r3, #0
3401c1d4:	4d05      	ldr	r5, [pc, #20]	@ (3401c1ec <_isatty_r+0x1c>)
3401c1d6:	4604      	mov	r4, r0
3401c1d8:	4608      	mov	r0, r1
3401c1da:	602b      	str	r3, [r5, #0]
3401c1dc:	f7e6 ff25 	bl	3400302a <_isatty>
3401c1e0:	1c43      	adds	r3, r0, #1
3401c1e2:	d102      	bne.n	3401c1ea <_isatty_r+0x1a>
3401c1e4:	682b      	ldr	r3, [r5, #0]
3401c1e6:	b103      	cbz	r3, 3401c1ea <_isatty_r+0x1a>
3401c1e8:	6023      	str	r3, [r4, #0]
3401c1ea:	bd38      	pop	{r3, r4, r5, pc}
3401c1ec:	340cf030 	.word	0x340cf030

3401c1f0 <_kill_r>:
3401c1f0:	b538      	push	{r3, r4, r5, lr}
3401c1f2:	2300      	movs	r3, #0
3401c1f4:	4d06      	ldr	r5, [pc, #24]	@ (3401c210 <_kill_r+0x20>)
3401c1f6:	4604      	mov	r4, r0
3401c1f8:	4608      	mov	r0, r1
3401c1fa:	4611      	mov	r1, r2
3401c1fc:	602b      	str	r3, [r5, #0]
3401c1fe:	f7e6 fee2 	bl	34002fc6 <_kill>
3401c202:	1c43      	adds	r3, r0, #1
3401c204:	d102      	bne.n	3401c20c <_kill_r+0x1c>
3401c206:	682b      	ldr	r3, [r5, #0]
3401c208:	b103      	cbz	r3, 3401c20c <_kill_r+0x1c>
3401c20a:	6023      	str	r3, [r4, #0]
3401c20c:	bd38      	pop	{r3, r4, r5, pc}
3401c20e:	bf00      	nop
3401c210:	340cf030 	.word	0x340cf030

3401c214 <_getpid_r>:
3401c214:	f7e6 bed5 	b.w	34002fc2 <_getpid>

3401c218 <_calloc_r>:
3401c218:	b570      	push	{r4, r5, r6, lr}
3401c21a:	fba1 5402 	umull	r5, r4, r1, r2
3401c21e:	b934      	cbnz	r4, 3401c22e <_calloc_r+0x16>
3401c220:	4629      	mov	r1, r5
3401c222:	f7fc fe63 	bl	34018eec <_malloc_r>
3401c226:	4606      	mov	r6, r0
3401c228:	b928      	cbnz	r0, 3401c236 <_calloc_r+0x1e>
3401c22a:	4630      	mov	r0, r6
3401c22c:	bd70      	pop	{r4, r5, r6, pc}
3401c22e:	220c      	movs	r2, #12
3401c230:	2600      	movs	r6, #0
3401c232:	6002      	str	r2, [r0, #0]
3401c234:	e7f9      	b.n	3401c22a <_calloc_r+0x12>
3401c236:	462a      	mov	r2, r5
3401c238:	4621      	mov	r1, r4
3401c23a:	f7fd ff73 	bl	3401a124 <memset>
3401c23e:	e7f4      	b.n	3401c22a <_calloc_r+0x12>

3401c240 <__ascii_mbtowc>:
3401c240:	b082      	sub	sp, #8
3401c242:	b901      	cbnz	r1, 3401c246 <__ascii_mbtowc+0x6>
3401c244:	a901      	add	r1, sp, #4
3401c246:	b142      	cbz	r2, 3401c25a <__ascii_mbtowc+0x1a>
3401c248:	b14b      	cbz	r3, 3401c25e <__ascii_mbtowc+0x1e>
3401c24a:	7813      	ldrb	r3, [r2, #0]
3401c24c:	600b      	str	r3, [r1, #0]
3401c24e:	7812      	ldrb	r2, [r2, #0]
3401c250:	1e10      	subs	r0, r2, #0
3401c252:	bf18      	it	ne
3401c254:	2001      	movne	r0, #1
3401c256:	b002      	add	sp, #8
3401c258:	4770      	bx	lr
3401c25a:	4610      	mov	r0, r2
3401c25c:	e7fb      	b.n	3401c256 <__ascii_mbtowc+0x16>
3401c25e:	f06f 0001 	mvn.w	r0, #1
3401c262:	e7f8      	b.n	3401c256 <__ascii_mbtowc+0x16>

3401c264 <__ascii_wctomb>:
3401c264:	4603      	mov	r3, r0
3401c266:	4608      	mov	r0, r1
3401c268:	b141      	cbz	r1, 3401c27c <__ascii_wctomb+0x18>
3401c26a:	2aff      	cmp	r2, #255	@ 0xff
3401c26c:	d904      	bls.n	3401c278 <__ascii_wctomb+0x14>
3401c26e:	228a      	movs	r2, #138	@ 0x8a
3401c270:	f04f 30ff 	mov.w	r0, #4294967295
3401c274:	601a      	str	r2, [r3, #0]
3401c276:	4770      	bx	lr
3401c278:	2001      	movs	r0, #1
3401c27a:	700a      	strb	r2, [r1, #0]
3401c27c:	4770      	bx	lr
	...

3401c280 <log10>:
3401c280:	b508      	push	{r3, lr}
3401c282:	ed2d 8b02 	vpush	{d8}
3401c286:	eeb0 8b40 	vmov.f64	d8, d0
3401c28a:	f000 fdf5 	bl	3401ce78 <__ieee754_log10>
3401c28e:	eeb4 8b48 	vcmp.f64	d8, d8
3401c292:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c296:	d60f      	bvs.n	3401c2b8 <log10+0x38>
3401c298:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
3401c29c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c2a0:	d80a      	bhi.n	3401c2b8 <log10+0x38>
3401c2a2:	eeb5 8b40 	vcmp.f64	d8, #0.0
3401c2a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c2aa:	d108      	bne.n	3401c2be <log10+0x3e>
3401c2ac:	f7fe f98e 	bl	3401a5cc <__errno>
3401c2b0:	2322      	movs	r3, #34	@ 0x22
3401c2b2:	ed9f 0b09 	vldr	d0, [pc, #36]	@ 3401c2d8 <log10+0x58>
3401c2b6:	6003      	str	r3, [r0, #0]
3401c2b8:	ecbd 8b02 	vpop	{d8}
3401c2bc:	bd08      	pop	{r3, pc}
3401c2be:	f7fe f985 	bl	3401a5cc <__errno>
3401c2c2:	2321      	movs	r3, #33	@ 0x21
3401c2c4:	ecbd 8b02 	vpop	{d8}
3401c2c8:	6003      	str	r3, [r0, #0]
3401c2ca:	4805      	ldr	r0, [pc, #20]	@ (3401c2e0 <log10+0x60>)
3401c2cc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
3401c2d0:	f000 b82a 	b.w	3401c328 <nan>
3401c2d4:	f3af 8000 	nop.w
3401c2d8:	00000000 	.word	0x00000000
3401c2dc:	fff00000 	.word	0xfff00000
3401c2e0:	3402118e 	.word	0x3402118e
3401c2e4:	00000000 	.word	0x00000000

3401c2e8 <sqrt>:
3401c2e8:	b508      	push	{r3, lr}
3401c2ea:	ed2d 8b04 	vpush	{d8-d9}
3401c2ee:	eeb0 8b40 	vmov.f64	d8, d0
3401c2f2:	f000 fdbe 	bl	3401ce72 <__ieee754_sqrt>
3401c2f6:	eeb4 8b48 	vcmp.f64	d8, d8
3401c2fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c2fe:	d60c      	bvs.n	3401c31a <sqrt+0x32>
3401c300:	ed9f 9b07 	vldr	d9, [pc, #28]	@ 3401c320 <sqrt+0x38>
3401c304:	eeb4 8bc9 	vcmpe.f64	d8, d9
3401c308:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c30c:	d505      	bpl.n	3401c31a <sqrt+0x32>
3401c30e:	f7fe f95d 	bl	3401a5cc <__errno>
3401c312:	ee89 0b09 	vdiv.f64	d0, d9, d9
3401c316:	2321      	movs	r3, #33	@ 0x21
3401c318:	6003      	str	r3, [r0, #0]
3401c31a:	ecbd 8b04 	vpop	{d8-d9}
3401c31e:	bd08      	pop	{r3, pc}
	...

3401c328 <nan>:
3401c328:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3401c330 <nan+0x8>
3401c32c:	4770      	bx	lr
3401c32e:	bf00      	nop
3401c330:	00000000 	.word	0x00000000
3401c334:	7ff80000 	.word	0x7ff80000

3401c338 <with_errno>:
3401c338:	b510      	push	{r4, lr}
3401c33a:	ed2d 8b02 	vpush	{d8}
3401c33e:	eeb0 8b40 	vmov.f64	d8, d0
3401c342:	4604      	mov	r4, r0
3401c344:	f7fe f942 	bl	3401a5cc <__errno>
3401c348:	6004      	str	r4, [r0, #0]
3401c34a:	eeb0 0b48 	vmov.f64	d0, d8
3401c34e:	ecbd 8b02 	vpop	{d8}
3401c352:	bd10      	pop	{r4, pc}

3401c354 <xflow>:
3401c354:	b082      	sub	sp, #8
3401c356:	b158      	cbz	r0, 3401c370 <xflow+0x1c>
3401c358:	eeb1 7b40 	vneg.f64	d7, d0
3401c35c:	2022      	movs	r0, #34	@ 0x22
3401c35e:	ed8d 7b00 	vstr	d7, [sp]
3401c362:	ed9d 7b00 	vldr	d7, [sp]
3401c366:	ee20 0b07 	vmul.f64	d0, d0, d7
3401c36a:	b002      	add	sp, #8
3401c36c:	f7ff bfe4 	b.w	3401c338 <with_errno>
3401c370:	eeb0 7b40 	vmov.f64	d7, d0
3401c374:	e7f2      	b.n	3401c35c <xflow+0x8>
	...

3401c378 <__math_uflow>:
3401c378:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3401c380 <__math_uflow+0x8>
3401c37c:	f7ff bfea 	b.w	3401c354 <xflow>
3401c380:	00000000 	.word	0x00000000
3401c384:	10000000 	.word	0x10000000

3401c388 <__math_oflow>:
3401c388:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3401c390 <__math_oflow+0x8>
3401c38c:	f7ff bfe2 	b.w	3401c354 <xflow>
3401c390:	00000000 	.word	0x00000000
3401c394:	70000000 	.word	0x70000000

3401c398 <__math_divzero>:
3401c398:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
3401c39c:	b082      	sub	sp, #8
3401c39e:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
3401c3a2:	2800      	cmp	r0, #0
3401c3a4:	f04f 0022 	mov.w	r0, #34	@ 0x22
3401c3a8:	fe07 7b06 	vseleq.f64	d7, d7, d6
3401c3ac:	ed8d 7b00 	vstr	d7, [sp]
3401c3b0:	ed9d 0b00 	vldr	d0, [sp]
3401c3b4:	ed9f 7b04 	vldr	d7, [pc, #16]	@ 3401c3c8 <__math_divzero+0x30>
3401c3b8:	ee80 0b07 	vdiv.f64	d0, d0, d7
3401c3bc:	b002      	add	sp, #8
3401c3be:	f7ff bfbb 	b.w	3401c338 <with_errno>
3401c3c2:	bf00      	nop
3401c3c4:	f3af 8000 	nop.w
	...

3401c3d0 <__math_invalid>:
3401c3d0:	eeb0 7b40 	vmov.f64	d7, d0
3401c3d4:	ee30 6b40 	vsub.f64	d6, d0, d0
3401c3d8:	eeb4 7b47 	vcmp.f64	d7, d7
3401c3dc:	ee86 0b06 	vdiv.f64	d0, d6, d6
3401c3e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c3e4:	d602      	bvs.n	3401c3ec <__math_invalid+0x1c>
3401c3e6:	2021      	movs	r0, #33	@ 0x21
3401c3e8:	f7ff bfa6 	b.w	3401c338 <with_errno>
3401c3ec:	4770      	bx	lr

3401c3ee <__math_check_uflow>:
3401c3ee:	eeb5 0b40 	vcmp.f64	d0, #0.0
3401c3f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c3f6:	d102      	bne.n	3401c3fe <__math_check_uflow+0x10>
3401c3f8:	2022      	movs	r0, #34	@ 0x22
3401c3fa:	f7ff bf9d 	b.w	3401c338 <with_errno>
3401c3fe:	4770      	bx	lr

3401c400 <__math_check_oflow>:
3401c400:	eeb0 7bc0 	vabs.f64	d7, d0
3401c404:	ed9f 6b06 	vldr	d6, [pc, #24]	@ 3401c420 <__math_check_oflow+0x20>
3401c408:	eeb4 7b46 	vcmp.f64	d7, d6
3401c40c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c410:	dd02      	ble.n	3401c418 <__math_check_oflow+0x18>
3401c412:	2022      	movs	r0, #34	@ 0x22
3401c414:	f7ff bf90 	b.w	3401c338 <with_errno>
3401c418:	4770      	bx	lr
3401c41a:	bf00      	nop
3401c41c:	f3af 8000 	nop.w
3401c420:	ffffffff 	.word	0xffffffff
3401c424:	7fefffff 	.word	0x7fefffff

3401c428 <checkint>:
3401c428:	f3c1 520a 	ubfx	r2, r1, #20, #11
3401c42c:	f240 33fe 	movw	r3, #1022	@ 0x3fe
3401c430:	429a      	cmp	r2, r3
3401c432:	b570      	push	{r4, r5, r6, lr}
3401c434:	dd2a      	ble.n	3401c48c <checkint+0x64>
3401c436:	f240 4333 	movw	r3, #1075	@ 0x433
3401c43a:	429a      	cmp	r2, r3
3401c43c:	dc24      	bgt.n	3401c488 <checkint+0x60>
3401c43e:	1a9b      	subs	r3, r3, r2
3401c440:	f04f 32ff 	mov.w	r2, #4294967295
3401c444:	f1a3 0620 	sub.w	r6, r3, #32
3401c448:	fa02 f403 	lsl.w	r4, r2, r3
3401c44c:	f1c3 0520 	rsb	r5, r3, #32
3401c450:	fa02 f606 	lsl.w	r6, r2, r6
3401c454:	fa22 f505 	lsr.w	r5, r2, r5
3401c458:	409a      	lsls	r2, r3
3401c45a:	4334      	orrs	r4, r6
3401c45c:	ea20 0202 	bic.w	r2, r0, r2
3401c460:	432c      	orrs	r4, r5
3401c462:	ea21 0404 	bic.w	r4, r1, r4
3401c466:	4322      	orrs	r2, r4
3401c468:	f1a3 0420 	sub.w	r4, r3, #32
3401c46c:	f1c3 0220 	rsb	r2, r3, #32
3401c470:	d10c      	bne.n	3401c48c <checkint+0x64>
3401c472:	40d8      	lsrs	r0, r3
3401c474:	fa01 f302 	lsl.w	r3, r1, r2
3401c478:	40e1      	lsrs	r1, r4
3401c47a:	4318      	orrs	r0, r3
3401c47c:	4308      	orrs	r0, r1
3401c47e:	f000 0001 	and.w	r0, r0, #1
3401c482:	f1d0 0002 	rsbs	r0, r0, #2
3401c486:	bd70      	pop	{r4, r5, r6, pc}
3401c488:	2002      	movs	r0, #2
3401c48a:	e7fc      	b.n	3401c486 <checkint+0x5e>
3401c48c:	2000      	movs	r0, #0
3401c48e:	e7fa      	b.n	3401c486 <checkint+0x5e>

3401c490 <pow>:
3401c490:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401c494:	ee10 4a90 	vmov	r4, s1
3401c498:	f240 73fd 	movw	r3, #2045	@ 0x7fd
3401c49c:	ee11 aa90 	vmov	sl, s3
3401c4a0:	ee10 5a10 	vmov	r5, s0
3401c4a4:	ea4f 5814 	mov.w	r8, r4, lsr #20
3401c4a8:	ee11 0a10 	vmov	r0, s2
3401c4ac:	ea4f 561a 	mov.w	r6, sl, lsr #20
3401c4b0:	f108 32ff 	add.w	r2, r8, #4294967295
3401c4b4:	46c4      	mov	ip, r8
3401c4b6:	429a      	cmp	r2, r3
3401c4b8:	ed2d 8b0a 	vpush	{d8-d12}
3401c4bc:	b087      	sub	sp, #28
3401c4be:	d806      	bhi.n	3401c4ce <pow+0x3e>
3401c4c0:	f3c6 030a 	ubfx	r3, r6, #0, #11
3401c4c4:	f2a3 33be 	subw	r3, r3, #958	@ 0x3be
3401c4c8:	2b7f      	cmp	r3, #127	@ 0x7f
3401c4ca:	f240 8157 	bls.w	3401c77c <pow+0x2ec>
3401c4ce:	1802      	adds	r2, r0, r0
3401c4d0:	f06f 0b01 	mvn.w	fp, #1
3401c4d4:	f46f 1e00 	mvn.w	lr, #2097152	@ 0x200000
3401c4d8:	eb4a 010a 	adc.w	r1, sl, sl
3401c4dc:	1e57      	subs	r7, r2, #1
3401c4de:	f141 33ff 	adc.w	r3, r1, #4294967295
3401c4e2:	45bb      	cmp	fp, r7
3401c4e4:	eb7e 0303 	sbcs.w	r3, lr, r3
3401c4e8:	d242      	bcs.n	3401c570 <pow+0xe0>
3401c4ea:	ea52 0301 	orrs.w	r3, r2, r1
3401c4ee:	f04f 0300 	mov.w	r3, #0
3401c4f2:	d10c      	bne.n	3401c50e <pow+0x7e>
3401c4f4:	196d      	adds	r5, r5, r5
3401c4f6:	f484 2400 	eor.w	r4, r4, #524288	@ 0x80000
3401c4fa:	4164      	adcs	r4, r4
3401c4fc:	42ab      	cmp	r3, r5
3401c4fe:	f5a3 1380 	sub.w	r3, r3, #1048576	@ 0x100000
3401c502:	41a3      	sbcs	r3, r4
3401c504:	f0c0 808f 	bcc.w	3401c626 <pow+0x196>
3401c508:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401c50c:	e02b      	b.n	3401c566 <pow+0xd6>
3401c50e:	4ed4      	ldr	r6, [pc, #848]	@ (3401c860 <pow+0x3d0>)
3401c510:	42b4      	cmp	r4, r6
3401c512:	bf08      	it	eq
3401c514:	429d      	cmpeq	r5, r3
3401c516:	d109      	bne.n	3401c52c <pow+0x9c>
3401c518:	1800      	adds	r0, r0, r0
3401c51a:	f48a 2a00 	eor.w	sl, sl, #524288	@ 0x80000
3401c51e:	eb4a 0a0a 	adc.w	sl, sl, sl
3401c522:	4283      	cmp	r3, r0
3401c524:	4bcf      	ldr	r3, [pc, #828]	@ (3401c864 <pow+0x3d4>)
3401c526:	eb73 030a 	sbcs.w	r3, r3, sl
3401c52a:	e7eb      	b.n	3401c504 <pow+0x74>
3401c52c:	196d      	adds	r5, r5, r5
3401c52e:	48ce      	ldr	r0, [pc, #824]	@ (3401c868 <pow+0x3d8>)
3401c530:	4164      	adcs	r4, r4
3401c532:	42ab      	cmp	r3, r5
3401c534:	eb70 0604 	sbcs.w	r6, r0, r4
3401c538:	d375      	bcc.n	3401c626 <pow+0x196>
3401c53a:	4281      	cmp	r1, r0
3401c53c:	bf08      	it	eq
3401c53e:	429a      	cmpeq	r2, r3
3401c540:	d171      	bne.n	3401c626 <pow+0x196>
3401c542:	4aca      	ldr	r2, [pc, #808]	@ (3401c86c <pow+0x3dc>)
3401c544:	4294      	cmp	r4, r2
3401c546:	bf08      	it	eq
3401c548:	429d      	cmpeq	r5, r3
3401c54a:	d0dd      	beq.n	3401c508 <pow+0x78>
3401c54c:	4294      	cmp	r4, r2
3401c54e:	ea6f 0a0a 	mvn.w	sl, sl
3401c552:	bf34      	ite	cc
3401c554:	2400      	movcc	r4, #0
3401c556:	2401      	movcs	r4, #1
3401c558:	ea4f 7ada 	mov.w	sl, sl, lsr #31
3401c55c:	4554      	cmp	r4, sl
3401c55e:	f040 81dc 	bne.w	3401c91a <pow+0x48a>
3401c562:	ee21 0b01 	vmul.f64	d0, d1, d1
3401c566:	b007      	add	sp, #28
3401c568:	ecbd 8b0a 	vpop	{d8-d12}
3401c56c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401c570:	196f      	adds	r7, r5, r5
3401c572:	eb44 0904 	adc.w	r9, r4, r4
3401c576:	1e7a      	subs	r2, r7, #1
3401c578:	f169 0300 	sbc.w	r3, r9, #0
3401c57c:	4593      	cmp	fp, r2
3401c57e:	eb7e 0303 	sbcs.w	r3, lr, r3
3401c582:	d225      	bcs.n	3401c5d0 <pow+0x140>
3401c584:	2c00      	cmp	r4, #0
3401c586:	ee20 0b00 	vmul.f64	d0, d0, d0
3401c58a:	da13      	bge.n	3401c5b4 <pow+0x124>
3401c58c:	4651      	mov	r1, sl
3401c58e:	f7ff ff4b 	bl	3401c428 <checkint>
3401c592:	2801      	cmp	r0, #1
3401c594:	d10e      	bne.n	3401c5b4 <pow+0x124>
3401c596:	eeb1 0b40 	vneg.f64	d0, d0
3401c59a:	ea57 0909 	orrs.w	r9, r7, r9
3401c59e:	d10b      	bne.n	3401c5b8 <pow+0x128>
3401c5a0:	f1ba 0f00 	cmp.w	sl, #0
3401c5a4:	dadf      	bge.n	3401c566 <pow+0xd6>
3401c5a6:	b007      	add	sp, #28
3401c5a8:	ecbd 8b0a 	vpop	{d8-d12}
3401c5ac:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401c5b0:	f7ff bef2 	b.w	3401c398 <__math_divzero>
3401c5b4:	2000      	movs	r0, #0
3401c5b6:	e7f0      	b.n	3401c59a <pow+0x10a>
3401c5b8:	f1ba 0f00 	cmp.w	sl, #0
3401c5bc:	dad3      	bge.n	3401c566 <pow+0xd6>
3401c5be:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
3401c5c2:	ee86 7b00 	vdiv.f64	d7, d6, d0
3401c5c6:	ed8d 7b00 	vstr	d7, [sp]
3401c5ca:	ed9d 0b00 	vldr	d0, [sp]
3401c5ce:	e7ca      	b.n	3401c566 <pow+0xd6>
3401c5d0:	2c00      	cmp	r4, #0
3401c5d2:	da2b      	bge.n	3401c62c <pow+0x19c>
3401c5d4:	4651      	mov	r1, sl
3401c5d6:	f7ff ff27 	bl	3401c428 <checkint>
3401c5da:	b930      	cbnz	r0, 3401c5ea <pow+0x15a>
3401c5dc:	b007      	add	sp, #28
3401c5de:	ecbd 8b0a 	vpop	{d8-d12}
3401c5e2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401c5e6:	f7ff bef3 	b.w	3401c3d0 <__math_invalid>
3401c5ea:	1e41      	subs	r1, r0, #1
3401c5ec:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
3401c5f0:	f3c8 0c0a 	ubfx	ip, r8, #0, #11
3401c5f4:	4248      	negs	r0, r1
3401c5f6:	4148      	adcs	r0, r1
3401c5f8:	0480      	lsls	r0, r0, #18
3401c5fa:	f3c6 020a 	ubfx	r2, r6, #0, #11
3401c5fe:	f2a2 33be 	subw	r3, r2, #958	@ 0x3be
3401c602:	2b7f      	cmp	r3, #127	@ 0x7f
3401c604:	d92d      	bls.n	3401c662 <pow+0x1d2>
3401c606:	2000      	movs	r0, #0
3401c608:	4b95      	ldr	r3, [pc, #596]	@ (3401c860 <pow+0x3d0>)
3401c60a:	429c      	cmp	r4, r3
3401c60c:	bf08      	it	eq
3401c60e:	4285      	cmpeq	r5, r0
3401c610:	f43f af7a 	beq.w	3401c508 <pow+0x78>
3401c614:	f240 31bd 	movw	r1, #957	@ 0x3bd
3401c618:	428a      	cmp	r2, r1
3401c61a:	d80c      	bhi.n	3401c636 <pow+0x1a6>
3401c61c:	42a8      	cmp	r0, r5
3401c61e:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401c622:	41a3      	sbcs	r3, r4
3401c624:	d204      	bcs.n	3401c630 <pow+0x1a0>
3401c626:	ee31 0b00 	vadd.f64	d0, d1, d0
3401c62a:	e79c      	b.n	3401c566 <pow+0xd6>
3401c62c:	2000      	movs	r0, #0
3401c62e:	e7e4      	b.n	3401c5fa <pow+0x16a>
3401c630:	ee30 0b41 	vsub.f64	d0, d0, d1
3401c634:	e797      	b.n	3401c566 <pow+0xd6>
3401c636:	2d01      	cmp	r5, #1
3401c638:	f240 72ff 	movw	r2, #2047	@ 0x7ff
3401c63c:	eb74 0303 	sbcs.w	r3, r4, r3
3401c640:	bf34      	ite	cc
3401c642:	2301      	movcc	r3, #1
3401c644:	2300      	movcs	r3, #0
3401c646:	4296      	cmp	r6, r2
3401c648:	bf8c      	ite	hi
3401c64a:	2600      	movhi	r6, #0
3401c64c:	2601      	movls	r6, #1
3401c64e:	42b3      	cmp	r3, r6
3401c650:	f000 809c 	beq.w	3401c78c <pow+0x2fc>
3401c654:	b007      	add	sp, #28
3401c656:	ecbd 8b0a 	vpop	{d8-d12}
3401c65a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401c65e:	f7ff be93 	b.w	3401c388 <__math_oflow>
3401c662:	f1bc 0f00 	cmp.w	ip, #0
3401c666:	d10a      	bne.n	3401c67e <pow+0x1ee>
3401c668:	ed9f 7b79 	vldr	d7, [pc, #484]	@ 3401c850 <pow+0x3c0>
3401c66c:	ee20 7b07 	vmul.f64	d7, d0, d7
3401c670:	ec53 2b17 	vmov	r2, r3, d7
3401c674:	f023 4400 	bic.w	r4, r3, #2147483648	@ 0x80000000
3401c678:	4615      	mov	r5, r2
3401c67a:	f1a4 7450 	sub.w	r4, r4, #54525952	@ 0x3400000
3401c67e:	4a7c      	ldr	r2, [pc, #496]	@ (3401c870 <pow+0x3e0>)
3401c680:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
3401c684:	4422      	add	r2, r4
3401c686:	1513      	asrs	r3, r2, #20
3401c688:	f3c2 3146 	ubfx	r1, r2, #13, #7
3401c68c:	f36f 0213 	bfc	r2, #0, #20
3401c690:	ee03 3a10 	vmov	s6, r3
3401c694:	4b77      	ldr	r3, [pc, #476]	@ (3401c874 <pow+0x3e4>)
3401c696:	1aa7      	subs	r7, r4, r2
3401c698:	eb03 1641 	add.w	r6, r3, r1, lsl #5
3401c69c:	eeb8 3bc3 	vcvt.f64.s32	d3, s6
3401c6a0:	eb03 1241 	add.w	r2, r3, r1, lsl #5
3401c6a4:	ed96 7b18 	vldr	d7, [r6, #96]	@ 0x60
3401c6a8:	ed92 5b12 	vldr	d5, [r2, #72]	@ 0x48
3401c6ac:	1e2e      	subs	r6, r5, #0
3401c6ae:	ec47 6b14 	vmov	d4, r6, r7
3401c6b2:	eea4 6b05 	vfma.f64	d6, d4, d5
3401c6b6:	ed92 2b16 	vldr	d2, [r2, #88]	@ 0x58
3401c6ba:	ed93 5b00 	vldr	d5, [r3]
3401c6be:	ed93 cb10 	vldr	d12, [r3, #64]	@ 0x40
3401c6c2:	f46f 7272 	mvn.w	r2, #968	@ 0x3c8
3401c6c6:	eea3 2b05 	vfma.f64	d2, d3, d5
3401c6ca:	ed93 5b02 	vldr	d5, [r3, #8]
3401c6ce:	eea3 7b05 	vfma.f64	d7, d3, d5
3401c6d2:	ee36 4b02 	vadd.f64	d4, d6, d2
3401c6d6:	ed93 5b04 	vldr	d5, [r3, #16]
3401c6da:	ee32 2b44 	vsub.f64	d2, d2, d4
3401c6de:	ee26 5b05 	vmul.f64	d5, d6, d5
3401c6e2:	ee32 2b06 	vadd.f64	d2, d2, d6
3401c6e6:	ed93 3b0c 	vldr	d3, [r3, #48]	@ 0x30
3401c6ea:	ee26 0b05 	vmul.f64	d0, d6, d5
3401c6ee:	ee37 7b02 	vadd.f64	d7, d7, d2
3401c6f2:	ee34 8b00 	vadd.f64	d8, d4, d0
3401c6f6:	eeb0 9b40 	vmov.f64	d9, d0
3401c6fa:	ee26 bb00 	vmul.f64	d11, d6, d0
3401c6fe:	ee34 4b48 	vsub.f64	d4, d4, d8
3401c702:	ee96 9b05 	vfnms.f64	d9, d6, d5
3401c706:	ee34 ab00 	vadd.f64	d10, d4, d0
3401c70a:	ed93 5b06 	vldr	d5, [r3, #24]
3401c70e:	ed93 4b08 	vldr	d4, [r3, #32]
3401c712:	eea6 5b04 	vfma.f64	d5, d6, d4
3401c716:	ee37 7b09 	vadd.f64	d7, d7, d9
3401c71a:	ed93 4b0a 	vldr	d4, [r3, #40]	@ 0x28
3401c71e:	ee37 7b0a 	vadd.f64	d7, d7, d10
3401c722:	eea6 4b03 	vfma.f64	d4, d6, d3
3401c726:	ed93 3b0e 	vldr	d3, [r3, #56]	@ 0x38
3401c72a:	eea6 3b0c 	vfma.f64	d3, d6, d12
3401c72e:	eea0 4b03 	vfma.f64	d4, d0, d3
3401c732:	eea0 5b04 	vfma.f64	d5, d0, d4
3401c736:	eeab 7b05 	vfma.f64	d7, d11, d5
3401c73a:	ee38 4b07 	vadd.f64	d4, d8, d7
3401c73e:	ee21 6b04 	vmul.f64	d6, d1, d4
3401c742:	ee38 8b44 	vsub.f64	d8, d8, d4
3401c746:	eeb0 5b46 	vmov.f64	d5, d6
3401c74a:	ee16 3a90 	vmov	r3, s13
3401c74e:	ee38 8b07 	vadd.f64	d8, d8, d7
3401c752:	f3c3 560a 	ubfx	r6, r3, #20, #11
3401c756:	ee91 5b04 	vfnms.f64	d5, d1, d4
3401c75a:	18b2      	adds	r2, r6, r2
3401c75c:	2a3e      	cmp	r2, #62	@ 0x3e
3401c75e:	eea1 5b08 	vfma.f64	d5, d1, d8
3401c762:	d91b      	bls.n	3401c79c <pow+0x30c>
3401c764:	2a00      	cmp	r2, #0
3401c766:	da0b      	bge.n	3401c780 <pow+0x2f0>
3401c768:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401c76c:	ee36 0b00 	vadd.f64	d0, d6, d0
3401c770:	2800      	cmp	r0, #0
3401c772:	f43f aef8 	beq.w	3401c566 <pow+0xd6>
3401c776:	eeb1 0b40 	vneg.f64	d0, d0
3401c77a:	e6f4      	b.n	3401c566 <pow+0xd6>
3401c77c:	2000      	movs	r0, #0
3401c77e:	e77e      	b.n	3401c67e <pow+0x1ee>
3401c780:	f5b6 6f81 	cmp.w	r6, #1032	@ 0x408
3401c784:	d909      	bls.n	3401c79a <pow+0x30a>
3401c786:	2b00      	cmp	r3, #0
3401c788:	f6bf af64 	bge.w	3401c654 <pow+0x1c4>
3401c78c:	b007      	add	sp, #28
3401c78e:	ecbd 8b0a 	vpop	{d8-d12}
3401c792:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401c796:	f7ff bdef 	b.w	3401c378 <__math_uflow>
3401c79a:	2600      	movs	r6, #0
3401c79c:	4936      	ldr	r1, [pc, #216]	@ (3401c878 <pow+0x3e8>)
3401c79e:	2700      	movs	r7, #0
3401c7a0:	ed91 4b02 	vldr	d4, [r1, #8]
3401c7a4:	ed91 3b00 	vldr	d3, [r1]
3401c7a8:	eeb0 7b44 	vmov.f64	d7, d4
3401c7ac:	eea6 7b03 	vfma.f64	d7, d6, d3
3401c7b0:	ed91 3b0a 	vldr	d3, [r1, #40]	@ 0x28
3401c7b4:	ee17 5a10 	vmov	r5, s14
3401c7b8:	ee37 7b44 	vsub.f64	d7, d7, d4
3401c7bc:	ed91 4b04 	vldr	d4, [r1, #16]
3401c7c0:	f005 037f 	and.w	r3, r5, #127	@ 0x7f
3401c7c4:	eea7 6b04 	vfma.f64	d6, d7, d4
3401c7c8:	18dc      	adds	r4, r3, r3
3401c7ca:	1940      	adds	r0, r0, r5
3401c7cc:	f104 030f 	add.w	r3, r4, #15
3401c7d0:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
3401c7d4:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
3401c7d8:	f851 c033 	ldr.w	ip, [r1, r3, lsl #3]
3401c7dc:	ed91 4b06 	vldr	d4, [r1, #24]
3401c7e0:	f8d2 e004 	ldr.w	lr, [r2, #4]
3401c7e4:	eb17 020c 	adds.w	r2, r7, ip
3401c7e8:	eb0e 3340 	add.w	r3, lr, r0, lsl #13
3401c7ec:	eea7 6b04 	vfma.f64	d6, d7, d4
3401c7f0:	ed91 4b08 	vldr	d4, [r1, #32]
3401c7f4:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
3401c7f8:	ee35 5b06 	vadd.f64	d5, d5, d6
3401c7fc:	eea5 4b03 	vfma.f64	d4, d5, d3
3401c800:	ee25 6b05 	vmul.f64	d6, d5, d5
3401c804:	ee35 7b07 	vadd.f64	d7, d5, d7
3401c808:	ed91 3b0e 	vldr	d3, [r1, #56]	@ 0x38
3401c80c:	eea6 7b04 	vfma.f64	d7, d6, d4
3401c810:	ee26 6b06 	vmul.f64	d6, d6, d6
3401c814:	ed91 4b0c 	vldr	d4, [r1, #48]	@ 0x30
3401c818:	eea5 4b03 	vfma.f64	d4, d5, d3
3401c81c:	eea6 7b04 	vfma.f64	d7, d6, d4
3401c820:	2e00      	cmp	r6, #0
3401c822:	d175      	bne.n	3401c910 <pow+0x480>
3401c824:	42bd      	cmp	r5, r7
3401c826:	db29      	blt.n	3401c87c <pow+0x3ec>
3401c828:	f103 4140 	add.w	r1, r3, #32####MQTT_PASS####5472	@ 0xc0000000
3401c82c:	4610      	mov	r0, r2
3401c82e:	f501 0170 	add.w	r1, r1, #15728640	@ 0xf00000
3401c832:	ec41 0b10 	vmov	d0, r0, r1
3401c836:	eea7 0b00 	vfma.f64	d0, d7, d0
3401c83a:	ed9f 7b07 	vldr	d7, [pc, #28]	@ 3401c858 <pow+0x3c8>
3401c83e:	ee20 0b07 	vmul.f64	d0, d0, d7
3401c842:	b007      	add	sp, #28
3401c844:	ecbd 8b0a 	vpop	{d8-d12}
3401c848:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401c84c:	f7ff bdd8 	b.w	3401c400 <__math_check_oflow>
3401c850:	00000000 	.word	0x00000000
3401c854:	43300000 	.word	0x43300000
3401c858:	00000000 	.word	0x00000000
3401c85c:	7f000000 	.word	0x7f000000
3401c860:	3ff00000 	.word	0x3ff00000
3401c864:	fff00000 	.word	0xfff00000
3401c868:	ffe00000 	.word	0xffe00000
3401c86c:	7fe00000 	.word	0x7fe00000
3401c870:	c0196aab 	.word	0xc0196aab
3401c874:	340af260 	.word	0x340af260
3401c878:	340ae9f0 	.word	0x340ae9f0
3401c87c:	f103 517f 	add.w	r1, r3, #1069547520	@ 0x3fc00000
3401c880:	4610      	mov	r0, r2
3401c882:	eeb7 3b00 	vmov.f64	d3, #112	@ 0x3f800000  1.0
3401c886:	f501 1100 	add.w	r1, r1, #2097152	@ 0x200000
3401c88a:	ec41 0b15 	vmov	d5, r0, r1
3401c88e:	ee27 6b05 	vmul.f64	d6, d7, d5
3401c892:	ed9f 0b23 	vldr	d0, [pc, #140]	@ 3401c920 <pow+0x490>
3401c896:	ee35 7b06 	vadd.f64	d7, d5, d6
3401c89a:	eeb0 4bc7 	vabs.f64	d4, d7
3401c89e:	eeb4 4bc3 	vcmpe.f64	d4, d3
3401c8a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c8a6:	d52a      	bpl.n	3401c8fe <pow+0x46e>
3401c8a8:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
3401c8ac:	eebf 4b00 	vmov.f64	d4, #240	@ 0xbf800000 -1.0
3401c8b0:	ee35 5b47 	vsub.f64	d5, d5, d7
3401c8b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c8b8:	ee35 5b06 	vadd.f64	d5, d5, d6
3401c8bc:	bf58      	it	pl
3401c8be:	eeb0 4b43 	vmovpl.f64	d4, d3
3401c8c2:	ee37 3b04 	vadd.f64	d3, d7, d4
3401c8c6:	ee34 6b43 	vsub.f64	d6, d4, d3
3401c8ca:	ee36 6b07 	vadd.f64	d6, d6, d7
3401c8ce:	ee36 6b05 	vadd.f64	d6, d6, d5
3401c8d2:	ee36 6b03 	vadd.f64	d6, d6, d3
3401c8d6:	ee36 7b44 	vsub.f64	d7, d6, d4
3401c8da:	eeb5 7b40 	vcmp.f64	d7, #0.0
3401c8de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c8e2:	d104      	bne.n	3401c8ee <pow+0x45e>
3401c8e4:	4632      	mov	r2, r6
3401c8e6:	f001 4300 	and.w	r3, r1, #2147483648	@ 0x80000000
3401c8ea:	ec43 2b17 	vmov	d7, r2, r3
3401c8ee:	ed8d 0b02 	vstr	d0, [sp, #8]
3401c8f2:	ed9d 6b02 	vldr	d6, [sp, #8]
3401c8f6:	ee26 6b00 	vmul.f64	d6, d6, d0
3401c8fa:	ed8d 6b04 	vstr	d6, [sp, #16]
3401c8fe:	ee27 0b00 	vmul.f64	d0, d7, d0
3401c902:	b007      	add	sp, #28
3401c904:	ecbd 8b0a 	vpop	{d8-d12}
3401c908:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401c90c:	f7ff bd6f 	b.w	3401c3ee <__math_check_uflow>
3401c910:	ec43 2b10 	vmov	d0, r2, r3
3401c914:	eea7 0b00 	vfma.f64	d0, d7, d0
3401c918:	e625      	b.n	3401c566 <pow+0xd6>
3401c91a:	ed9f 0b03 	vldr	d0, [pc, #12]	@ 3401c928 <pow+0x498>
3401c91e:	e622      	b.n	3401c566 <pow+0xd6>
3401c920:	00000000 	.word	0x00000000
3401c924:	00100000 	.word	0x00100000
	...

3401c930 <expf>:
3401c930:	ee10 2a10 	vmov	r2, s0
3401c934:	f240 412a 	movw	r1, #1066	@ 0x42a
3401c938:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
3401c93c:	f3c2 530a 	ubfx	r3, r2, #20, #11
3401c940:	428b      	cmp	r3, r1
3401c942:	b430      	push	{r4, r5}
3401c944:	d92a      	bls.n	3401c99c <expf+0x6c>
3401c946:	f512 0f00 	cmn.w	r2, #8388608	@ 0x800000
3401c94a:	d058      	beq.n	3401c9fe <expf+0xce>
3401c94c:	f5b3 6fff 	cmp.w	r3, #2040	@ 0x7f8
3401c950:	d303      	bcc.n	3401c95a <expf+0x2a>
3401c952:	ee30 0a00 	vadd.f32	s0, s0, s0
3401c956:	bc30      	pop	{r4, r5}
3401c958:	4770      	bx	lr
3401c95a:	eddf 7a2a 	vldr	s15, [pc, #168]	@ 3401ca04 <expf+0xd4>
3401c95e:	eeb4 0ae7 	vcmpe.f32	s0, s15
3401c962:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c966:	dd03      	ble.n	3401c970 <expf+0x40>
3401c968:	2000      	movs	r0, #0
3401c96a:	bc30      	pop	{r4, r5}
3401c96c:	f000 ba5a 	b.w	3401ce24 <__math_oflowf>
3401c970:	eddf 7a25 	vldr	s15, [pc, #148]	@ 3401ca08 <expf+0xd8>
3401c974:	eeb4 0ae7 	vcmpe.f32	s0, s15
3401c978:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c97c:	d503      	bpl.n	3401c986 <expf+0x56>
3401c97e:	2000      	movs	r0, #0
3401c980:	bc30      	pop	{r4, r5}
3401c982:	f000 ba43 	b.w	3401ce0c <__math_uflowf>
3401c986:	eddf 7a21 	vldr	s15, [pc, #132]	@ 3401ca0c <expf+0xdc>
3401c98a:	eeb4 0ae7 	vcmpe.f32	s0, s15
3401c98e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c992:	d503      	bpl.n	3401c99c <expf+0x6c>
3401c994:	2000      	movs	r0, #0
3401c996:	bc30      	pop	{r4, r5}
3401c998:	f000 ba3e 	b.w	3401ce18 <__math_may_uflowf>
3401c99c:	4b1c      	ldr	r3, [pc, #112]	@ (3401ca10 <expf+0xe0>)
3401c99e:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401c9a2:	ed93 4b48 	vldr	d4, [r3, #288]	@ 0x120
3401c9a6:	ed93 5b4a 	vldr	d5, [r3, #296]	@ 0x128
3401c9aa:	eeb0 7b44 	vmov.f64	d7, d4
3401c9ae:	eea5 7b06 	vfma.f64	d7, d5, d6
3401c9b2:	ee17 0a10 	vmov	r0, s14
3401c9b6:	ee37 7b44 	vsub.f64	d7, d7, d4
3401c9ba:	f000 021f 	and.w	r2, r0, #31
3401c9be:	ee95 7b06 	vfnms.f64	d7, d5, d6
3401c9c2:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
3401c9c6:	f853 4032 	ldr.w	r4, [r3, r2, lsl #3]
3401c9ca:	684d      	ldr	r5, [r1, #4]
3401c9cc:	2100      	movs	r1, #0
3401c9ce:	ed93 5b4c 	vldr	d5, [r3, #304]	@ 0x130
3401c9d2:	ed93 6b4e 	vldr	d6, [r3, #312]	@ 0x138
3401c9d6:	190a      	adds	r2, r1, r4
3401c9d8:	eea5 6b07 	vfma.f64	d6, d5, d7
3401c9dc:	ee27 4b07 	vmul.f64	d4, d7, d7
3401c9e0:	ed93 5b50 	vldr	d5, [r3, #320]	@ 0x140
3401c9e4:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
3401c9e8:	eea5 0b07 	vfma.f64	d0, d5, d7
3401c9ec:	ec43 2b17 	vmov	d7, r2, r3
3401c9f0:	eea6 0b04 	vfma.f64	d0, d6, d4
3401c9f4:	ee20 0b07 	vmul.f64	d0, d0, d7
3401c9f8:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
3401c9fc:	e7ab      	b.n	3401c956 <expf+0x26>
3401c9fe:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 3401ca14 <expf+0xe4>
3401ca02:	e7a8      	b.n	3401c956 <expf+0x26>
3401ca04:	42b17217 	.word	0x42b17217
3401ca08:	c2cff1b4 	.word	0xc2cff1b4
3401ca0c:	c2ce8ecf 	.word	0xc2ce8ecf
3401ca10:	340b02a8 	.word	0x340b02a8
3401ca14:	00000000 	.word	0x00000000

3401ca18 <logf>:
3401ca18:	ee10 3a10 	vmov	r3, s0
3401ca1c:	f1b3 5f7e 	cmp.w	r3, #1065353216	@ 0x3f800000
3401ca20:	b410      	push	{r4}
3401ca22:	d055      	beq.n	3401cad0 <logf+0xb8>
3401ca24:	f5a3 0200 	sub.w	r2, r3, #8388608	@ 0x800000
3401ca28:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
3401ca2c:	d31a      	bcc.n	3401ca64 <logf+0x4c>
3401ca2e:	005a      	lsls	r2, r3, #1
3401ca30:	d104      	bne.n	3401ca3c <logf+0x24>
3401ca32:	2001      	movs	r0, #1
3401ca34:	f85d 4b04 	ldr.w	r4, [sp], #4
3401ca38:	f000 b9fa 	b.w	3401ce30 <__math_divzerof>
3401ca3c:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
3401ca40:	d043      	beq.n	3401caca <logf+0xb2>
3401ca42:	2b00      	cmp	r3, #0
3401ca44:	db02      	blt.n	3401ca4c <logf+0x34>
3401ca46:	f1b2 4f7f 	cmp.w	r2, #4278190080	@ 0xff000000
3401ca4a:	d303      	bcc.n	3401ca54 <logf+0x3c>
3401ca4c:	f85d 4b04 	ldr.w	r4, [sp], #4
3401ca50:	f000 ba00 	b.w	3401ce54 <__math_invalidf>
3401ca54:	eddf 7a20 	vldr	s15, [pc, #128]	@ 3401cad8 <logf+0xc0>
3401ca58:	ee20 0a27 	vmul.f32	s0, s0, s15
3401ca5c:	ee10 3a10 	vmov	r3, s0
3401ca60:	f1a3 6338 	sub.w	r3, r3, #192937984	@ 0xb800000
3401ca64:	f103 4240 	add.w	r2, r3, #32####MQTT_PASS####5472	@ 0xc0000000
3401ca68:	491c      	ldr	r1, [pc, #112]	@ (3401cadc <logf+0xc4>)
3401ca6a:	eebf 0b00 	vmov.f64	d0, #240	@ 0xbf800000 -1.0
3401ca6e:	f502 024d 	add.w	r2, r2, #13434880	@ 0xcd0000
3401ca72:	0dd4      	lsrs	r4, r2, #23
3401ca74:	f3c2 40c3 	ubfx	r0, r2, #19, #4
3401ca78:	15d2      	asrs	r2, r2, #23
3401ca7a:	05e4      	lsls	r4, r4, #23
3401ca7c:	eb01 1000 	add.w	r0, r1, r0, lsl #4
3401ca80:	1b1b      	subs	r3, r3, r4
3401ca82:	ee07 3a90 	vmov	s15, r3
3401ca86:	ed90 5b00 	vldr	d5, [r0]
3401ca8a:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3401ca8e:	ed90 6b02 	vldr	d6, [r0, #8]
3401ca92:	eea5 0b07 	vfma.f64	d0, d5, d7
3401ca96:	ee07 2a90 	vmov	s15, r2
3401ca9a:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3401ca9e:	ed91 5b40 	vldr	d5, [r1, #256]	@ 0x100
3401caa2:	eea7 6b05 	vfma.f64	d6, d7, d5
3401caa6:	ee20 4b00 	vmul.f64	d4, d0, d0
3401caaa:	ed91 5b44 	vldr	d5, [r1, #272]	@ 0x110
3401caae:	ed91 7b46 	vldr	d7, [r1, #280]	@ 0x118
3401cab2:	eea5 7b00 	vfma.f64	d7, d5, d0
3401cab6:	ee30 0b06 	vadd.f64	d0, d0, d6
3401caba:	ed91 5b42 	vldr	d5, [r1, #264]	@ 0x108
3401cabe:	eea5 7b04 	vfma.f64	d7, d5, d4
3401cac2:	eea4 0b07 	vfma.f64	d0, d4, d7
3401cac6:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
3401caca:	f85d 4b04 	ldr.w	r4, [sp], #4
3401cace:	4770      	bx	lr
3401cad0:	ed9f 0a03 	vldr	s0, [pc, #12]	@ 3401cae0 <logf+0xc8>
3401cad4:	e7f9      	b.n	3401caca <logf+0xb2>
3401cad6:	bf00      	nop
3401cad8:	4b000000 	.word	0x4b000000
3401cadc:	340b03f0 	.word	0x340b03f0
3401cae0:	00000000 	.word	0x00000000

3401cae4 <checkint>:
3401cae4:	f3c0 53c7 	ubfx	r3, r0, #23, #8
3401cae8:	2b7e      	cmp	r3, #126	@ 0x7e
3401caea:	d910      	bls.n	3401cb0e <checkint+0x2a>
3401caec:	2b96      	cmp	r3, #150	@ 0x96
3401caee:	d80c      	bhi.n	3401cb0a <checkint+0x26>
3401caf0:	2201      	movs	r2, #1
3401caf2:	f1c3 0396 	rsb	r3, r3, #150	@ 0x96
3401caf6:	fa02 f303 	lsl.w	r3, r2, r3
3401cafa:	1e5a      	subs	r2, r3, #1
3401cafc:	4202      	tst	r2, r0
3401cafe:	d106      	bne.n	3401cb0e <checkint+0x2a>
3401cb00:	4203      	tst	r3, r0
3401cb02:	bf14      	ite	ne
3401cb04:	2001      	movne	r0, #1
3401cb06:	2002      	moveq	r0, #2
3401cb08:	4770      	bx	lr
3401cb0a:	2002      	movs	r0, #2
3401cb0c:	4770      	bx	lr
3401cb0e:	2000      	movs	r0, #0
3401cb10:	4770      	bx	lr
3401cb12:	0000      	movs	r0, r0
3401cb14:	0000      	movs	r0, r0
	...

3401cb18 <powf>:
3401cb18:	b537      	push	{r0, r1, r2, r4, r5, lr}
3401cb1a:	ee10 1a10 	vmov	r1, s0
3401cb1e:	ee10 4a90 	vmov	r4, s1
3401cb22:	eef0 7a40 	vmov.f32	s15, s0
3401cb26:	f5a1 0200 	sub.w	r2, r1, #8388608	@ 0x800000
3401cb2a:	0063      	lsls	r3, r4, #1
3401cb2c:	eeb0 7a60 	vmov.f32	s14, s1
3401cb30:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
3401cb34:	f103 30ff 	add.w	r0, r3, #4294967295
3401cb38:	f06f 7280 	mvn.w	r2, #16777216	@ 0x1000000
3401cb3c:	d252      	bcs.n	3401cbe4 <powf+0xcc>
3401cb3e:	4290      	cmp	r0, r2
3401cb40:	d258      	bcs.n	3401cbf4 <powf+0xdc>
3401cb42:	2000      	movs	r0, #0
3401cb44:	f101 4340 	add.w	r3, r1, #32####MQTT_PASS####5472	@ 0xc0000000
3401cb48:	4a9f      	ldr	r2, [pc, #636]	@ (3401cdc8 <powf+0x2b0>)
3401cb4a:	eebf 2b00 	vmov.f64	d2, #240	@ 0xbf800000 -1.0
3401cb4e:	f503 034d 	add.w	r3, r3, #13434880	@ 0xcd0000
3401cb52:	f3c3 44c3 	ubfx	r4, r3, #19, #4
3401cb56:	f36f 0316 	bfc	r3, #0, #23
3401cb5a:	1ac9      	subs	r1, r1, r3
3401cb5c:	eb02 1404 	add.w	r4, r2, r4, lsl #4
3401cb60:	15db      	asrs	r3, r3, #23
3401cb62:	ee07 1a90 	vmov	s15, r1
3401cb66:	ed94 4b00 	vldr	d4, [r4]
3401cb6a:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
3401cb6e:	ee07 3a90 	vmov	s15, r3
3401cb72:	ed94 5b02 	vldr	d5, [r4, #8]
3401cb76:	eea4 2b06 	vfma.f64	d2, d4, d6
3401cb7a:	eeb8 6be7 	vcvt.f64.s32	d6, s15
3401cb7e:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3401cb82:	ee36 6b05 	vadd.f64	d6, d6, d5
3401cb86:	ed92 1b42 	vldr	d1, [r2, #264]	@ 0x108
3401cb8a:	ed92 5b40 	vldr	d5, [r2, #256]	@ 0x100
3401cb8e:	ed92 3b44 	vldr	d3, [r2, #272]	@ 0x110
3401cb92:	ee22 4b02 	vmul.f64	d4, d2, d2
3401cb96:	eea2 1b05 	vfma.f64	d1, d2, d5
3401cb9a:	ee24 0b04 	vmul.f64	d0, d4, d4
3401cb9e:	ed92 5b46 	vldr	d5, [r2, #280]	@ 0x118
3401cba2:	eea2 5b03 	vfma.f64	d5, d2, d3
3401cba6:	ed92 3b48 	vldr	d3, [r2, #288]	@ 0x120
3401cbaa:	eea2 6b03 	vfma.f64	d6, d2, d3
3401cbae:	eea4 6b05 	vfma.f64	d6, d4, d5
3401cbb2:	eea1 6b00 	vfma.f64	d6, d1, d0
3401cbb6:	ee27 7b06 	vmul.f64	d7, d7, d6
3401cbba:	ee17 3a90 	vmov	r3, s15
3401cbbe:	f3c3 32cf 	ubfx	r2, r3, #15, #16
3401cbc2:	f248 03bf 	movw	r3, #32959	@ 0x80bf
3401cbc6:	429a      	cmp	r2, r3
3401cbc8:	f0c0 8098 	bcc.w	3401ccfc <powf+0x1e4>
3401cbcc:	ed9f 6b76 	vldr	d6, [pc, #472]	@ 3401cda8 <powf+0x290>
3401cbd0:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401cbd4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401cbd8:	dd79      	ble.n	3401ccce <powf+0x1b6>
3401cbda:	b003      	add	sp, #12
3401cbdc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401cbe0:	f000 b920 	b.w	3401ce24 <__math_oflowf>
3401cbe4:	4290      	cmp	r0, r2
3401cbe6:	d330      	bcc.n	3401cc4a <powf+0x132>
3401cbe8:	b12b      	cbz	r3, 3401cbf6 <powf+0xde>
3401cbea:	0049      	lsls	r1, r1, #1
3401cbec:	f1b1 4f7f 	cmp.w	r1, #4278190080	@ 0xff000000
3401cbf0:	d808      	bhi.n	3401cc04 <powf+0xec>
3401cbf2:	e015      	b.n	3401cc20 <powf+0x108>
3401cbf4:	b953      	cbnz	r3, 3401cc0c <powf+0xf4>
3401cbf6:	f481 0180 	eor.w	r1, r1, #4194304	@ 0x400000
3401cbfa:	0049      	lsls	r1, r1, #1
3401cbfc:	f511 0f00 	cmn.w	r1, #8388608	@ 0x800000
3401cc00:	f240 80ca 	bls.w	3401cd98 <powf+0x280>
3401cc04:	ee37 0a87 	vadd.f32	s0, s15, s14
3401cc08:	b003      	add	sp, #12
3401cc0a:	bd30      	pop	{r4, r5, pc}
3401cc0c:	f1b1 5f7e 	cmp.w	r1, #1065353216	@ 0x3f800000
3401cc10:	d105      	bne.n	3401cc1e <powf+0x106>
3401cc12:	f484 0480 	eor.w	r4, r4, #4194304	@ 0x400000
3401cc16:	0064      	lsls	r4, r4, #1
3401cc18:	f514 0f00 	cmn.w	r4, #8388608	@ 0x800000
3401cc1c:	e7f0      	b.n	3401cc00 <powf+0xe8>
3401cc1e:	0049      	lsls	r1, r1, #1
3401cc20:	f1b3 4f7f 	cmp.w	r3, #4278190080	@ 0xff000000
3401cc24:	d1ee      	bne.n	3401cc04 <powf+0xec>
3401cc26:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
3401cc2a:	f000 80b5 	beq.w	3401cd98 <powf+0x280>
3401cc2e:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
3401cc32:	ea6f 0404 	mvn.w	r4, r4
3401cc36:	bf34      	ite	cc
3401cc38:	2100      	movcc	r1, #0
3401cc3a:	2101      	movcs	r1, #1
3401cc3c:	0fe4      	lsrs	r4, r4, #31
3401cc3e:	42a1      	cmp	r1, r4
3401cc40:	f040 80ad 	bne.w	3401cd9e <powf+0x286>
3401cc44:	ee27 0a07 	vmul.f32	s0, s14, s14
3401cc48:	e7de      	b.n	3401cc08 <powf+0xf0>
3401cc4a:	004d      	lsls	r5, r1, #1
3401cc4c:	1e6b      	subs	r3, r5, #1
3401cc4e:	4293      	cmp	r3, r2
3401cc50:	d31b      	bcc.n	3401cc8a <powf+0x172>
3401cc52:	2900      	cmp	r1, #0
3401cc54:	ee20 0a00 	vmul.f32	s0, s0, s0
3401cc58:	da0e      	bge.n	3401cc78 <powf+0x160>
3401cc5a:	4620      	mov	r0, r4
3401cc5c:	f7ff ff42 	bl	3401cae4 <checkint>
3401cc60:	2801      	cmp	r0, #1
3401cc62:	d109      	bne.n	3401cc78 <powf+0x160>
3401cc64:	eeb1 0a40 	vneg.f32	s0, s0
3401cc68:	b945      	cbnz	r5, 3401cc7c <powf+0x164>
3401cc6a:	2c00      	cmp	r4, #0
3401cc6c:	dacc      	bge.n	3401cc08 <powf+0xf0>
3401cc6e:	b003      	add	sp, #12
3401cc70:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401cc74:	f000 b8dc 	b.w	3401ce30 <__math_divzerof>
3401cc78:	2000      	movs	r0, #0
3401cc7a:	e7f5      	b.n	3401cc68 <powf+0x150>
3401cc7c:	2c00      	cmp	r4, #0
3401cc7e:	dac3      	bge.n	3401cc08 <powf+0xf0>
3401cc80:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3401cc84:	ee87 0a80 	vdiv.f32	s0, s15, s0
3401cc88:	e7be      	b.n	3401cc08 <powf+0xf0>
3401cc8a:	2900      	cmp	r1, #0
3401cc8c:	da1d      	bge.n	3401ccca <powf+0x1b2>
3401cc8e:	4620      	mov	r0, r4
3401cc90:	f7ff ff28 	bl	3401cae4 <checkint>
3401cc94:	b920      	cbnz	r0, 3401cca0 <powf+0x188>
3401cc96:	b003      	add	sp, #12
3401cc98:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401cc9c:	f000 b8da 	b.w	3401ce54 <__math_invalidf>
3401cca0:	1e43      	subs	r3, r0, #1
3401cca2:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
3401cca6:	4258      	negs	r0, r3
3401cca8:	4158      	adcs	r0, r3
3401ccaa:	0400      	lsls	r0, r0, #16
3401ccac:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
3401ccb0:	f4bf af48 	bcs.w	3401cb44 <powf+0x2c>
3401ccb4:	eddf 6a45 	vldr	s13, [pc, #276]	@ 3401cdcc <powf+0x2b4>
3401ccb8:	ee27 0aa6 	vmul.f32	s0, s15, s13
3401ccbc:	ee10 3a10 	vmov	r3, s0
3401ccc0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3401ccc4:	f1a3 6138 	sub.w	r1, r3, #192937984	@ 0xb800000
3401ccc8:	e73c      	b.n	3401cb44 <powf+0x2c>
3401ccca:	2000      	movs	r0, #0
3401cccc:	e7ee      	b.n	3401ccac <powf+0x194>
3401ccce:	ed9f 6b38 	vldr	d6, [pc, #224]	@ 3401cdb0 <powf+0x298>
3401ccd2:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401ccd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ccda:	dd45      	ble.n	3401cd68 <powf+0x250>
3401ccdc:	f04f 534c 	mov.w	r3, #855638016	@ 0x33000000
3401cce0:	b3d0      	cbz	r0, 3401cd58 <powf+0x240>
3401cce2:	eebf 6a00 	vmov.f32	s12, #240	@ 0xbf800000 -1.0
3401cce6:	9301      	str	r3, [sp, #4]
3401cce8:	eddd 6a01 	vldr	s13, [sp, #4]
3401ccec:	ee76 6a66 	vsub.f32	s13, s12, s13
3401ccf0:	eef4 6a46 	vcmp.f32	s13, s12
3401ccf4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ccf8:	f47f af6f 	bne.w	3401cbda <powf+0xc2>
3401ccfc:	4b34      	ldr	r3, [pc, #208]	@ (3401cdd0 <powf+0x2b8>)
3401ccfe:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401cd02:	ed93 5b40 	vldr	d5, [r3, #256]	@ 0x100
3401cd06:	ee37 6b05 	vadd.f64	d6, d7, d5
3401cd0a:	ee16 2a10 	vmov	r2, s12
3401cd0e:	ee36 6b45 	vsub.f64	d6, d6, d5
3401cd12:	ed93 5b42 	vldr	d5, [r3, #264]	@ 0x108
3401cd16:	ee37 7b46 	vsub.f64	d7, d7, d6
3401cd1a:	f002 011f 	and.w	r1, r2, #31
3401cd1e:	1880      	adds	r0, r0, r2
3401cd20:	eb03 05c1 	add.w	r5, r3, r1, lsl #3
3401cd24:	f853 4031 	ldr.w	r4, [r3, r1, lsl #3]
3401cd28:	ee27 4b07 	vmul.f64	d4, d7, d7
3401cd2c:	2100      	movs	r1, #0
3401cd2e:	686d      	ldr	r5, [r5, #4]
3401cd30:	190a      	adds	r2, r1, r4
3401cd32:	ed93 6b44 	vldr	d6, [r3, #272]	@ 0x110
3401cd36:	eea7 6b05 	vfma.f64	d6, d7, d5
3401cd3a:	ed93 5b46 	vldr	d5, [r3, #280]	@ 0x118
3401cd3e:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
3401cd42:	eea7 0b05 	vfma.f64	d0, d7, d5
3401cd46:	ec43 2b17 	vmov	d7, r2, r3
3401cd4a:	eea6 0b04 	vfma.f64	d0, d6, d4
3401cd4e:	ee20 0b07 	vmul.f64	d0, d0, d7
3401cd52:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
3401cd56:	e757      	b.n	3401cc08 <powf+0xf0>
3401cd58:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
3401cd5c:	9300      	str	r3, [sp, #0]
3401cd5e:	eddd 6a00 	vldr	s13, [sp]
3401cd62:	ee76 6a86 	vadd.f32	s13, s13, s12
3401cd66:	e7c3      	b.n	3401ccf0 <powf+0x1d8>
3401cd68:	ed9f 6b13 	vldr	d6, [pc, #76]	@ 3401cdb8 <powf+0x2a0>
3401cd6c:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401cd70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401cd74:	d804      	bhi.n	3401cd80 <powf+0x268>
3401cd76:	b003      	add	sp, #12
3401cd78:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401cd7c:	f000 b846 	b.w	3401ce0c <__math_uflowf>
3401cd80:	ed9f 6b0f 	vldr	d6, [pc, #60]	@ 3401cdc0 <powf+0x2a8>
3401cd84:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401cd88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401cd8c:	d5b6      	bpl.n	3401ccfc <powf+0x1e4>
3401cd8e:	b003      	add	sp, #12
3401cd90:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401cd94:	f000 b840 	b.w	3401ce18 <__math_may_uflowf>
3401cd98:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3401cd9c:	e734      	b.n	3401cc08 <powf+0xf0>
3401cd9e:	ed9f 0a0d 	vldr	s0, [pc, #52]	@ 3401cdd4 <powf+0x2bc>
3401cda2:	e731      	b.n	3401cc08 <powf+0xf0>
3401cda4:	f3af 8000 	nop.w
3401cda8:	ffd1d571 	.word	0xffd1d571
3401cdac:	405fffff 	.word	0x405fffff
3401cdb0:	ffa3aae2 	.word	0xffa3aae2
3401cdb4:	405fffff 	.word	0x405fffff
3401cdb8:	00000000 	.word	0x00000000
3401cdbc:	c062c000 	.word	0xc062c000
3401cdc0:	00000000 	.word	0x00000000
3401cdc4:	c062a000 	.word	0xc062a000
3401cdc8:	340b0da0 	.word	0x340b0da0
3401cdcc:	4b000000 	.word	0x4b000000
3401cdd0:	340b02a8 	.word	0x340b02a8
3401cdd4:	00000000 	.word	0x00000000

3401cdd8 <with_errnof>:
3401cdd8:	b510      	push	{r4, lr}
3401cdda:	ed2d 8b02 	vpush	{d8}
3401cdde:	eeb0 8a40 	vmov.f32	s16, s0
3401cde2:	4604      	mov	r4, r0
3401cde4:	f7fd fbf2 	bl	3401a5cc <__errno>
3401cde8:	6004      	str	r4, [r0, #0]
3401cdea:	eeb0 0a48 	vmov.f32	s0, s16
3401cdee:	ecbd 8b02 	vpop	{d8}
3401cdf2:	bd10      	pop	{r4, pc}

3401cdf4 <xflowf>:
3401cdf4:	b130      	cbz	r0, 3401ce04 <xflowf+0x10>
3401cdf6:	eef1 7a40 	vneg.f32	s15, s0
3401cdfa:	ee27 0a80 	vmul.f32	s0, s15, s0
3401cdfe:	2022      	movs	r0, #34	@ 0x22
3401ce00:	f7ff bfea 	b.w	3401cdd8 <with_errnof>
3401ce04:	eef0 7a40 	vmov.f32	s15, s0
3401ce08:	e7f7      	b.n	3401cdfa <xflowf+0x6>
	...

3401ce0c <__math_uflowf>:
3401ce0c:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3401ce14 <__math_uflowf+0x8>
3401ce10:	f7ff bff0 	b.w	3401cdf4 <xflowf>
3401ce14:	10000000 	.word	0x10000000

3401ce18 <__math_may_uflowf>:
3401ce18:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3401ce20 <__math_may_uflowf+0x8>
3401ce1c:	f7ff bfea 	b.w	3401cdf4 <xflowf>
3401ce20:	1a200000 	.word	0x1a200000

3401ce24 <__math_oflowf>:
3401ce24:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3401ce2c <__math_oflowf+0x8>
3401ce28:	f7ff bfe4 	b.w	3401cdf4 <xflowf>
3401ce2c:	70000000 	.word	0x70000000

3401ce30 <__math_divzerof>:
3401ce30:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3401ce34:	2800      	cmp	r0, #0
3401ce36:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
3401ce3a:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 3401ce50 <__math_divzerof+0x20>
3401ce3e:	f04f 0022 	mov.w	r0, #34	@ 0x22
3401ce42:	fe47 7a87 	vseleq.f32	s15, s15, s14
3401ce46:	ee87 0a80 	vdiv.f32	s0, s15, s0
3401ce4a:	f7ff bfc5 	b.w	3401cdd8 <with_errnof>
3401ce4e:	bf00      	nop
3401ce50:	00000000 	.word	0x00000000

3401ce54 <__math_invalidf>:
3401ce54:	eef0 7a40 	vmov.f32	s15, s0
3401ce58:	ee30 7a40 	vsub.f32	s14, s0, s0
3401ce5c:	eef4 7a67 	vcmp.f32	s15, s15
3401ce60:	ee87 0a07 	vdiv.f32	s0, s14, s14
3401ce64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ce68:	d602      	bvs.n	3401ce70 <__math_invalidf+0x1c>
3401ce6a:	2021      	movs	r0, #33	@ 0x21
3401ce6c:	f7ff bfb4 	b.w	3401cdd8 <with_errnof>
3401ce70:	4770      	bx	lr

3401ce72 <__ieee754_sqrt>:
3401ce72:	eeb1 0bc0 	vsqrt.f64	d0, d0
3401ce76:	4770      	bx	lr

3401ce78 <__ieee754_log10>:
3401ce78:	ee10 3a90 	vmov	r3, s1
3401ce7c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3401ce80:	b510      	push	{r4, lr}
3401ce82:	ed2d 8b02 	vpush	{d8}
3401ce86:	da21      	bge.n	3401cecc <__ieee754_log10+0x54>
3401ce88:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
3401ce8c:	ee10 1a10 	vmov	r1, s0
3401ce90:	430a      	orrs	r2, r1
3401ce92:	d108      	bne.n	3401cea6 <__ieee754_log10+0x2e>
3401ce94:	ed9f 6b22 	vldr	d6, [pc, #136]	@ 3401cf20 <__ieee754_log10+0xa8>
3401ce98:	ed9f 7b23 	vldr	d7, [pc, #140]	@ 3401cf28 <__ieee754_log10+0xb0>
3401ce9c:	ee86 0b07 	vdiv.f64	d0, d6, d7
3401cea0:	ecbd 8b02 	vpop	{d8}
3401cea4:	bd10      	pop	{r4, pc}
3401cea6:	2b00      	cmp	r3, #0
3401cea8:	da02      	bge.n	3401ceb0 <__ieee754_log10+0x38>
3401ceaa:	ee30 6b40 	vsub.f64	d6, d0, d0
3401ceae:	e7f3      	b.n	3401ce98 <__ieee754_log10+0x20>
3401ceb0:	ed9f 7b1f 	vldr	d7, [pc, #124]	@ 3401cf30 <__ieee754_log10+0xb8>
3401ceb4:	f06f 0235 	mvn.w	r2, #53	@ 0x35
3401ceb8:	ee20 0b07 	vmul.f64	d0, d0, d7
3401cebc:	ee10 3a90 	vmov	r3, s1
3401cec0:	4923      	ldr	r1, [pc, #140]	@ (3401cf50 <__ieee754_log10+0xd8>)
3401cec2:	428b      	cmp	r3, r1
3401cec4:	dd04      	ble.n	3401ced0 <__ieee754_log10+0x58>
3401cec6:	ee30 0b00 	vadd.f64	d0, d0, d0
3401ceca:	e7e9      	b.n	3401cea0 <__ieee754_log10+0x28>
3401cecc:	2200      	movs	r2, #0
3401cece:	e7f7      	b.n	3401cec0 <__ieee754_log10+0x48>
3401ced0:	1518      	asrs	r0, r3, #20
3401ced2:	f240 34ff 	movw	r4, #1023	@ 0x3ff
3401ced6:	f3c3 0113 	ubfx	r1, r3, #0, #20
3401ceda:	f2a0 30ff 	subw	r0, r0, #1023	@ 0x3ff
3401cede:	4410      	add	r0, r2
3401cee0:	eb00 73d0 	add.w	r3, r0, r0, lsr #31
3401cee4:	eba4 70d0 	sub.w	r0, r4, r0, lsr #31
3401cee8:	ee08 3a10 	vmov	s16, r3
3401ceec:	ec53 2b10 	vmov	r2, r3, d0
3401cef0:	ea41 5300 	orr.w	r3, r1, r0, lsl #20
3401cef4:	eeb8 8bc8 	vcvt.f64.s32	d8, s16
3401cef8:	ec43 2b10 	vmov	d0, r2, r3
3401cefc:	f000 f82c 	bl	3401cf58 <log>
3401cf00:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3401cf38 <__ieee754_log10+0xc0>
3401cf04:	ee20 0b07 	vmul.f64	d0, d0, d7
3401cf08:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3401cf40 <__ieee754_log10+0xc8>
3401cf0c:	eea8 0b07 	vfma.f64	d0, d8, d7
3401cf10:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3401cf48 <__ieee754_log10+0xd0>
3401cf14:	eea8 0b07 	vfma.f64	d0, d8, d7
3401cf18:	e7c2      	b.n	3401cea0 <__ieee754_log10+0x28>
3401cf1a:	bf00      	nop
3401cf1c:	f3af 8000 	nop.w
3401cf20:	00000000 	.word	0x00000000
3401cf24:	c3500000 	.word	0xc3500000
	...
3401cf34:	43500000 	.word	0x43500000
3401cf38:	1526e50e 	.word	0x1526e50e
3401cf3c:	3fdbcb7b 	.word	0x3fdbcb7b
3401cf40:	11f12b36 	.word	0x11f12b36
3401cf44:	3d59fef3 	.word	0x3d59fef3
3401cf48:	509f6000 	.word	0x509f6000
3401cf4c:	3fd34413 	.word	0x3fd34413
3401cf50:	7fefffff 	.word	0x7fefffff
3401cf54:	00000000 	.word	0x00000000

3401cf58 <log>:
3401cf58:	ee10 0a90 	vmov	r0, s1
3401cf5c:	ee10 3a10 	vmov	r3, s0
3401cf60:	b4f0      	push	{r4, r5, r6, r7}
3401cf62:	f100 4140 	add.w	r1, r0, #32####MQTT_PASS####5472	@ 0xc0000000
3401cf66:	f04f 34ff 	mov.w	r4, #4294967295
3401cf6a:	0c02      	lsrs	r2, r0, #16
3401cf6c:	429c      	cmp	r4, r3
3401cf6e:	f501 1190 	add.w	r1, r1, #1179648	@ 0x120000
3401cf72:	4c71      	ldr	r4, [pc, #452]	@ (3401d138 <log+0x1e0>)
3401cf74:	418c      	sbcs	r4, r1
3401cf76:	ed2d 8b02 	vpush	{d8}
3401cf7a:	d35a      	bcc.n	3401d032 <log+0xda>
3401cf7c:	4a6f      	ldr	r2, [pc, #444]	@ (3401d13c <log+0x1e4>)
3401cf7e:	4290      	cmp	r0, r2
3401cf80:	bf08      	it	eq
3401cf82:	2b00      	cmpeq	r3, #0
3401cf84:	f000 80c7 	beq.w	3401d116 <log+0x1be>
3401cf88:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
3401cf8c:	4b6c      	ldr	r3, [pc, #432]	@ (3401d140 <log+0x1e8>)
3401cf8e:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
3401cf92:	ee30 0b47 	vsub.f64	d0, d0, d7
3401cf96:	ed93 7b10 	vldr	d7, [r3, #64]	@ 0x40
3401cf9a:	ee20 2b00 	vmul.f64	d2, d0, d0
3401cf9e:	eea6 7b00 	vfma.f64	d7, d6, d0
3401cfa2:	ee20 4b02 	vmul.f64	d4, d0, d2
3401cfa6:	ed93 6b14 	vldr	d6, [r3, #80]	@ 0x50
3401cfaa:	ed93 5b18 	vldr	d5, [r3, #96]	@ 0x60
3401cfae:	ed93 3b1e 	vldr	d3, [r3, #120]	@ 0x78
3401cfb2:	eea6 7b02 	vfma.f64	d7, d6, d2
3401cfb6:	ed93 6b16 	vldr	d6, [r3, #88]	@ 0x58
3401cfba:	eea5 6b00 	vfma.f64	d6, d5, d0
3401cfbe:	ed93 5b1a 	vldr	d5, [r3, #104]	@ 0x68
3401cfc2:	eea5 6b02 	vfma.f64	d6, d5, d2
3401cfc6:	ed93 5b1c 	vldr	d5, [r3, #112]	@ 0x70
3401cfca:	eea3 5b00 	vfma.f64	d5, d3, d0
3401cfce:	ed93 3b20 	vldr	d3, [r3, #128]	@ 0x80
3401cfd2:	eea3 5b02 	vfma.f64	d5, d3, d2
3401cfd6:	ed93 3b22 	vldr	d3, [r3, #136]	@ 0x88
3401cfda:	eea3 5b04 	vfma.f64	d5, d3, d4
3401cfde:	eeb0 3b40 	vmov.f64	d3, d0
3401cfe2:	eea5 6b04 	vfma.f64	d6, d5, d4
3401cfe6:	ed93 5b0e 	vldr	d5, [r3, #56]	@ 0x38
3401cfea:	eea6 7b04 	vfma.f64	d7, d6, d4
3401cfee:	eeb0 6b40 	vmov.f64	d6, d0
3401cff2:	eeb0 2b47 	vmov.f64	d2, d7
3401cff6:	ed9f 7b4a 	vldr	d7, [pc, #296]	@ 3401d120 <log+0x1c8>
3401cffa:	eea0 6b07 	vfma.f64	d6, d0, d7
3401cffe:	eea0 6b47 	vfms.f64	d6, d0, d7
3401d002:	ee26 1b06 	vmul.f64	d1, d6, d6
3401d006:	ee30 8b46 	vsub.f64	d8, d0, d6
3401d00a:	eea1 3b05 	vfma.f64	d3, d1, d5
3401d00e:	ee30 7b43 	vsub.f64	d7, d0, d3
3401d012:	ee30 0b06 	vadd.f64	d0, d0, d6
3401d016:	eea1 7b05 	vfma.f64	d7, d1, d5
3401d01a:	ee25 5b08 	vmul.f64	d5, d5, d8
3401d01e:	eea5 7b00 	vfma.f64	d7, d5, d0
3401d022:	eea2 7b04 	vfma.f64	d7, d2, d4
3401d026:	ee33 0b07 	vadd.f64	d0, d3, d7
3401d02a:	ecbd 8b02 	vpop	{d8}
3401d02e:	bcf0      	pop	{r4, r5, r6, r7}
3401d030:	4770      	bx	lr
3401d032:	f1a2 0410 	sub.w	r4, r2, #16
3401d036:	f647 71df 	movw	r1, #32735	@ 0x7fdf
3401d03a:	428c      	cmp	r4, r1
3401d03c:	d923      	bls.n	3401d086 <log+0x12e>
3401d03e:	18d9      	adds	r1, r3, r3
3401d040:	eb40 0400 	adc.w	r4, r0, r0
3401d044:	4321      	orrs	r1, r4
3401d046:	d105      	bne.n	3401d054 <log+0xfc>
3401d048:	2001      	movs	r0, #1
3401d04a:	ecbd 8b02 	vpop	{d8}
3401d04e:	bcf0      	pop	{r4, r5, r6, r7}
3401d050:	f7ff b9a2 	b.w	3401c398 <__math_divzero>
3401d054:	493b      	ldr	r1, [pc, #236]	@ (3401d144 <log+0x1ec>)
3401d056:	4288      	cmp	r0, r1
3401d058:	bf08      	it	eq
3401d05a:	2b00      	cmpeq	r3, #0
3401d05c:	d0e5      	beq.n	3401d02a <log+0xd2>
3401d05e:	0413      	lsls	r3, r2, #16
3401d060:	d403      	bmi.n	3401d06a <log+0x112>
3401d062:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
3401d066:	4393      	bics	r3, r2
3401d068:	d104      	bne.n	3401d074 <log+0x11c>
3401d06a:	ecbd 8b02 	vpop	{d8}
3401d06e:	bcf0      	pop	{r4, r5, r6, r7}
3401d070:	f7ff b9ae 	b.w	3401c3d0 <__math_invalid>
3401d074:	ed9f 7b2c 	vldr	d7, [pc, #176]	@ 3401d128 <log+0x1d0>
3401d078:	ee20 7b07 	vmul.f64	d7, d0, d7
3401d07c:	ec53 2b17 	vmov	r2, r3, d7
3401d080:	f1a3 7050 	sub.w	r0, r3, #54525952	@ 0x3400000
3401d084:	4613      	mov	r3, r2
3401d086:	f100 4240 	add.w	r2, r0, #32####MQTT_PASS####5472	@ 0xc0000000
3401d08a:	492d      	ldr	r1, [pc, #180]	@ (3401d140 <log+0x1e8>)
3401d08c:	eebf 5b00 	vmov.f64	d5, #240	@ 0xbf800000 -1.0
3401d090:	1e1e      	subs	r6, r3, #0
3401d092:	f502 12d0 	add.w	r2, r2, #1703936	@ 0x1a0000
3401d096:	f3c2 3446 	ubfx	r4, r2, #13, #7
3401d09a:	ea4f 5c12 	mov.w	ip, r2, lsr #20
3401d09e:	1512      	asrs	r2, r2, #20
3401d0a0:	eb01 1504 	add.w	r5, r1, r4, lsl #4
3401d0a4:	ea4f 5c0c 	mov.w	ip, ip, lsl #20
3401d0a8:	ed95 7b24 	vldr	d7, [r5, #144]	@ 0x90
3401d0ac:	eba0 070c 	sub.w	r7, r0, ip
3401d0b0:	ec47 6b16 	vmov	d6, r6, r7
3401d0b4:	eea7 5b06 	vfma.f64	d5, d7, d6
3401d0b8:	ee07 2a90 	vmov	s15, r2
3401d0bc:	eeb8 6be7 	vcvt.f64.s32	d6, s15
3401d0c0:	ed91 4b00 	vldr	d4, [r1]
3401d0c4:	ed95 7b26 	vldr	d7, [r5, #152]	@ 0x98
3401d0c8:	ed91 3b0c 	vldr	d3, [r1, #48]	@ 0x30
3401d0cc:	eea4 7b06 	vfma.f64	d7, d4, d6
3401d0d0:	ee25 2b05 	vmul.f64	d2, d5, d5
3401d0d4:	ee35 4b07 	vadd.f64	d4, d5, d7
3401d0d8:	ee25 1b02 	vmul.f64	d1, d5, d2
3401d0dc:	ee37 0b44 	vsub.f64	d0, d7, d4
3401d0e0:	ed91 7b02 	vldr	d7, [r1, #8]
3401d0e4:	ee30 0b05 	vadd.f64	d0, d0, d5
3401d0e8:	eea7 0b06 	vfma.f64	d0, d7, d6
3401d0ec:	ed91 7b04 	vldr	d7, [r1, #16]
3401d0f0:	ed91 6b08 	vldr	d6, [r1, #32]
3401d0f4:	eea7 0b02 	vfma.f64	d0, d7, d2
3401d0f8:	ed91 7b06 	vldr	d7, [r1, #24]
3401d0fc:	eea6 7b05 	vfma.f64	d7, d6, d5
3401d100:	ed91 6b0a 	vldr	d6, [r1, #40]	@ 0x28
3401d104:	eea3 6b05 	vfma.f64	d6, d3, d5
3401d108:	eea6 7b02 	vfma.f64	d7, d6, d2
3401d10c:	eea1 0b07 	vfma.f64	d0, d1, d7
3401d110:	ee30 0b04 	vadd.f64	d0, d0, d4
3401d114:	e789      	b.n	3401d02a <log+0xd2>
3401d116:	ed9f 0b06 	vldr	d0, [pc, #24]	@ 3401d130 <log+0x1d8>
3401d11a:	e786      	b.n	3401d02a <log+0xd2>
3401d11c:	f3af 8000 	nop.w
3401d120:	00000000 	.word	0x00000000
3401d124:	41a00000 	.word	0x41a00000
3401d128:	00000000 	.word	0x00000000
3401d12c:	43300000 	.word	0x43300000
	...
3401d138:	000308ff 	.word	0x000308ff
3401d13c:	3ff00000 	.word	0x3ff00000
3401d140:	340b0510 	.word	0x340b0510
3401d144:	7ff00000 	.word	0x7ff00000

3401d148 <_sbrk>:
3401d148:	4a04      	ldr	r2, [pc, #16]	@ (3401d15c <_sbrk+0x14>)
3401d14a:	4603      	mov	r3, r0
3401d14c:	6811      	ldr	r1, [r2, #0]
3401d14e:	b909      	cbnz	r1, 3401d154 <_sbrk+0xc>
3401d150:	4903      	ldr	r1, [pc, #12]	@ (3401d160 <_sbrk+0x18>)
3401d152:	6011      	str	r1, [r2, #0]
3401d154:	6810      	ldr	r0, [r2, #0]
3401d156:	4403      	add	r3, r0
3401d158:	6013      	str	r3, [r2, #0]
3401d15a:	4770      	bx	lr
3401d15c:	340cf038 	.word	0x340cf038
3401d160:	340cf040 	.word	0x340cf040

3401d164 <_init>:
3401d164:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401d166:	bf00      	nop
3401d168:	bcf8      	pop	{r3, r4, r5, r6, r7}
3401d16a:	bc08      	pop	{r3}
3401d16c:	469e      	mov	lr, r3
3401d16e:	4770      	bx	lr

3401d170 <_fini>:
3401d170:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401d172:	bf00      	nop
3401d174:	bcf8      	pop	{r3, r4, r5, r6, r7}
3401d176:	bc08      	pop	{r3}
3401d178:	469e      	mov	lr, r3
3401d17a:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

3401d180 <SECURE_SystemCoreClockUpdate>:
3401d180:	e97f e97f 	sg
3401d184:	f7e7 be22 	b.w	34004dcc <__acle_se_SECURE_SystemCoreClockUpdate>
	...
